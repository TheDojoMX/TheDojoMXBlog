
[{"content":"","date":"16 octubre 2025","externalUrl":null,"permalink":"/","section":"The Dojo MX Blog","summary":"","title":"The Dojo MX Blog","type":"page"},{"content":"","date":"19 agosto 2025","externalUrl":null,"permalink":"/tags/c/","section":"Tags","summary":"","title":"C","type":"tags"},{"content":"","date":"19 agosto 2025","externalUrl":null,"permalink":"/tags/c-lang/","section":"Tags","summary":"","title":"C-Lang","type":"tags"},{"content":"","date":"19 agosto 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"19 agosto 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"19 agosto 2025","externalUrl":null,"permalink":"/tags/zig/","section":"Tags","summary":"","title":"Zig","type":"tags"},{"content":"","date":"19 agosto 2025","externalUrl":null,"permalink":"/tags/zig-lang/","section":"Tags","summary":"","title":"Zig-Lang","type":"tags"},{"content":"Recientemente hemos visto una ola de lenguajes listos para destronar a los lenguajes de programación que forman la base de casi toda nuestra computación actual: C y C++. Lenguajes como Rust y Go quieren reemplazarlos, pero tenemos a otro competidor que apunta directamente hacia C y parece que se está acercando aunque no tiene todavía una versión completamente estable.\nEn este artículo vamos a hablar de las características de Zig y cómo es que planea reemplazar a C.\nLas características de Zig # Zig es actualmente desarrollado por la Zig Software Foundation, una organización sin fines de lucro que básicamente fue creada para seguir desarrollando el lenguaje. Pero Andrew Kelley, lo empezó en 2015 con la idea de retar la forma en la que hacemos software.\nKelley es un programador con experiencia en C principalmente y mientras trabajaba en su proyecto \u0026ldquo;Genesis Digital Audio Workstation\u0026rdquo; se decidió para crear Zig. En sus propias palabras: \u0026ldquo;mi meta es crear un lenguaje más pragmático que C.\u0026rdquo;\nAlgunas de las características que presenta en el artículo en el que habla por primera vez de Zig son:\nPragmatismo. Ser pragmático es lo mismo que ser práctico. Zig es un lenguaje que se enfoca en resolver problemas reales y no en ser un lenguaje teórico, y quiere ayudarte a lograr lo que necesitas hacer mejor que otros lenguajes. Óptimo. Debe de ser iguale de rápido o más que C y más fácil de escribir. Seguridad en memoria. Es la segunda característica más importante del lenguaje, Kelley dice que va en el asiento del copiloto. Legible. zig debería evitar la sintaxis compleja y tener una forma canónica de hacer las cosas dando como resultado un código que sea fácil de leer, aunque te tengas que esforzar un poco para escribirlo. Algunas decisiones de diseño # Se dice que los lenguajes de programación están creados por los miedos de sus diseñadores. Por ejemplo, si alguien quiere hacer un nuevo lenguaje viniendo de lenguajes que tardan mucho en compilar, por ejemplo C++, va a intentar hacer un lenguaje que compile rápido, como fue le caso de Go.\nVeamos algunas decisiones de diseño de Zig.\nInteroperabilidad completa con C # C tiene una dominación histórica en el mundo de la programación de sistemas. Muchos de los sistemas importantes están escritos en C. Así es que Zig tiene como una decisón de diseño crear programas que puedan ser usados desde C o al revés. Así que Zig es compatible con la C ABI.\nLa C ABI (Application Binary Interface) es un conjunto de convenciones y reglas que define cómo los programas compilados en C interactúan a nivel de código máquina.\nUso de tipos opcionales # El manejo de valores vacíos o nulos es uno de los grandes problemas en todo el desarrollo de software. Así que Zig ha elegido usar tipos opcionales, es decir, valores que desde el sistemas de tipos declaras que pueden contener un valor o no. Así el compilador te puede ayudar a no dispararte en el pie dejando como nulo o aceptando un nulo en una variable donde siempre debería haber un valor. Además, te puede ayudar a verificar que estás considerando todos los casos posibles cuando tienes variables opcionales.\nManejo de errores # Zig utiliza tipos de datos primitivos para manejar errores. Estos son los Error Sets y Error Unions. Con estos dos tipos de datos puedes crear funciones que devuelvan un error y manejarlo de forma más elegante.\nOtras características # Zig tiene otras características muy interesantes nacidas directamente del uso que su principal creador, Andrew Kelley, hizo de C desde hace mucho tiempo. Por ejemplo tiene características para evitar el preprocesador de C, por ejemplo, sintaxis directa para compilación condicional.\nAlgunos proyectos importantes en Zig # Aunque todavía no tenemos una versión 100% estable de Zig, ya tenemos proyectos que están haciendo olas en el mundo de la programación programados en Zig. Hablemos de algunos de ellos:\nBun: Bun es un nuevo runtime de JavaScript que caracteriza por su gran velocidad de ejecución. Aunque no tiene todas las características de Node.js todavía, se lo lleva por mucho en rendimiento.\nTigerBeetle: TigerBeetle es una base de datos financiera distribuida. Como te imaginarás, todo aquello que se quiera usar en un entorno financiero serio debe ofrecer características fuertes de rendimiento y seguridad.\nGhostty: Ghostty es un emulador de terminal escrito por el mismo creador de Terraform, Mitchell Hashimoto, que está intentando hacer todas las cosas bien.\nConclusión # Si estás metido en el desarrollo de sistemas, sin duda Zig es un lenguaje que vale la pena voltear a ver, pero también si quieres aprender más sobre desarrollo de software a bajo nivel con ideas modernas.\n","date":"19 agosto 2025","externalUrl":null,"permalink":"/2025/08/19/zig-un-lenguaje-que-quiere-reemplazar-al-poderoso-c/","section":"Posts","summary":"\u003cp\u003eRecientemente hemos visto una ola de lenguajes listos para destronar\na los lenguajes de programación que forman la base de casi toda nuestra\ncomputación actual: C y C++. Lenguajes como Rust y Go quieren reemplazarlos,\npero tenemos a otro competidor que apunta directamente hacia C y parece\nque se está acercando aunque no tiene todavía una versión completamente estable.\u003c/p\u003e","title":"Zig: un lenguaje que quiere reemplazar al poderoso C","type":"posts"},{"content":"Con la llegada de los LLM\u0026rsquo;s, el término \u0026ldquo;agente\u0026rdquo; empezó a ganar más popularidad y lo oímos por todos lados. En este artículo vamos a hablar de qué son, para entenderlo lo mejor posible y no dejarnos llevar por el hype.\n¿Qué es un agente? # Este es un concepto que ha sido muy difícil de definir y por muchaos lados encuentras definiciones diferentes. En ester artículo vamos a dar una definicón sencilla y que nos parece práctica y que captura la idea principal de toda esta ola de crear programas que puedan comportarse como agentes.\nPrimeo vamos a la etimología de la palabra: viene del latín \u0026ldquo;agere\u0026rdquo; que significa \u0026ldquo;hacer\u0026rdquo;, \u0026ldquo;actuar\u0026rdquo;, \u0026ldquo;mover\u0026rdquo;, entre otros significados. En pocas palabras, un agente es cualquier entidad que puede tomar decisiones y actuar. Esta definición confiere bastante flexibilidad, pero conlleva en el fondo un idea que para mi es la característica principal: la autonomía.\nEn el caso de sistemas de software, vamos a definir a un agente como un programa que tiene un objetivo y para lograrlo puede tomar decisiones autónomas. Estas decisiones pueden ser tomadas basadas en su percepción del entorno, en su estado interno (incluida la memoria) o en una combinación de estas cosas. Finalmente un agente puede actuar para modificar su contexto y lograr su objetivo. Una característica que no siempre se cumple pero que a veces está implícita es que el agente está funcionando de manera constante, o sea que no es un programa que prendas y apagues, sino que está corriendo todo el tiempo.\nEn esta definición sencilla, encontramos varias partes clave que debe tener un programa para ser considerado un agente:\nObjetivo: El agente debe tener un objetivo claro que quiere lograr y por lo tanto una manera de medir su éxito. Autonomía: El agente debe ser capaz de tomar decisiones para los diferentes casos que se le presenten. Percepción: Aunque no es completamente necesario, muchos agentes tienen la capacidad de leer su entorno para tomar mejores decisiones. Actuación: Los agentes pueden ser capaces de modificar su entorno, de hecho, esta, junto con el objetivo es lo que le da sentido al concepto de agente. Estado interno: Debido a que las tareas que realizan los agentes pueden ser complejas, muchas veces es necesario mantener un estado interno que les permita ejecutar un plan de múltiples pasos, y para eso necesitan un registro interno. Este estado interno puede incluir diferentes tipos de memorias: a corto plazo, a largo plazo, cachés, etc. ¿En qué se diferencia un agente de un programa normal? Para mi la principal diferencia es la capacidad de tomar algún tipo de decisión autónoma y ejecutarla.\n¿Por qué tanto alboroto con los agentes? # Como podrás notar, lo que acabamos de describir se puede lograr con cualquier programa desde hace mucho tiempo, de hecho, tenemos ejemplos de programas que llamamos agentes desde hace década, justo porque cumplen con algunas de las características que describimos.\nPor ejemplo:\nLos programas que monitorean el estado de un servidor y mandan las estadísticas a un concentrador para tomar decisiones. Los agentes encargado de actualizar automáticamente tus sistemas operativos, como el Windows Update Agent. Programas encargados de negociar entre protocolos de comunicación, como en el caso de DHCP o DNS, o SMTP. Todos estos programas cumplen con la capacidad de tomar decisiones autónomas, cooperar con su entorno y ejecutar acciones para lograr su objetivo. Pero, ¿entonces por qué el boom actual?\nUna da las partes más difíciles de construir un programa que se pueda considerar un agentes es la de la toma de decisiones. Los algoritmos internos capaces de adaptarse a muchas situaciones y tomar decisiones sin que fueran explícitamente programados para eso son muy muy difíciles de construir. ¿Pero qué pasa si podemos usar las nuevas tecnologías como el corazón de un agente?\nJustamente, los LLM\u0026rsquo;s cons su capacidad limitada de razonamiento, toma de decisiones, adaptación, conocimiento general y capacidad de generar texto bien formado (para usarlo en protocolos de comunicación), son una tecnología perfecta para servir como los motores de decisión de un agente, todas las demás partes: la memoria, la observación del contexto o el entorno, el estado interno y la capacidad de actuar son temas que ya teníamos más o menos resueltos.\nEs por esto que los LLM\u0026rsquo;s y los nuevos sistemas capaces de adaptarse a una cantidad inimaginable de entradas de información y adaptar su respuesta y comportamiento a ellas, así como la capacidad de ser modificados para comportarse mejor para casos específicos, han creado una ola de software basado en la idea de los agentes.\nConclusión # Ahora ya sabes lo que es un agente de software, por qué decimos en esta última ola que los modernos son inteligentes y qué está impulsando toda la emoción que se ve por todos lados.Los agentes son herramientas poderosas para crear sistemas que hagan cosas complejas, normalmente con poca programación pero mucho control de nuestro lado. Viene una época en la que cada vez se usarán más, por lo que te conviene conocerlos y aprender a usar esta técnica de desarrollo. En un artículo futuro vamos a ver cómo crear diferentes tipos de agentes con capacidades cada vez más complejas.\n","date":"16 mayo 2025","externalUrl":null,"permalink":"/2025/05/16/qu%C3%A9-son-los-agentes-inteligentes/","section":"Posts","summary":"\u003cp\u003eCon la llegada de los LLM\u0026rsquo;s, el término \u0026ldquo;agente\u0026rdquo; empezó a ganar más popularidad y\nlo oímos por todos lados. En este artículo vamos a hablar de qué son, para entenderlo\nlo mejor posible y no dejarnos llevar por el hype.\u003c/p\u003e","title":"¿Qué son los agentes inteligentes?","type":"posts"},{"content":"","date":"16 mayo 2025","externalUrl":null,"permalink":"/tags/agente/","section":"Tags","summary":"","title":"Agente","type":"tags"},{"content":"","date":"16 mayo 2025","externalUrl":null,"permalink":"/tags/agents/","section":"Tags","summary":"","title":"Agents","type":"tags"},{"content":"","date":"16 mayo 2025","externalUrl":null,"permalink":"/tags/ia/","section":"Tags","summary":"","title":"IA","type":"tags"},{"content":"","date":"16 mayo 2025","externalUrl":null,"permalink":"/tags/inteligencia-artificial/","section":"Tags","summary":"","title":"Inteligencia-Artificial","type":"tags"},{"content":"","date":"15 mayo 2025","externalUrl":null,"permalink":"/tags/complejidad/","section":"Tags","summary":"","title":"Complejidad","type":"tags"},{"content":"El libro \u0026ldquo;Thinking in Systems\u0026rdquo; de Donella Hager Meadows es un libro muy importante para cualquier desarrollador de software. ¿Por qué? Los desarrolladores nos dedicamos a hacer sistemas, y este es justo el tema principal del libro, escrito por una experta en sistemas complejos.\nVeamos por qué puede ser una buena lectura para ti y por que te recomiendo leerlo lo antes posible.\nA cerca de Thinking in Systems # Thinking in systems es un libro un poco antiguo, publicado hace casi 17 años, en 2008, después del fallecimiento de su autora. Pero el primer borrador de libro ya estaba circulando en 1993. Esto te lo estoy diciendo como un recordatorio más de que muchas de las ideas que vale la pena leer tienen mucho tiempo de haber sido escritas, sobre todo en comparadas con las ideas a las que les hacemos caso en el mundo del software.\nDe qué trata Thinking in Systems # Pero, ¿de qué trata Thinking in Systems? Este libro te da una introducción a los conceptos básicos del modelado de sistemas, empezando por ejemplos muy sencillos y avanzando un poco en complejidad, sin presentarte nada realmente complejo. Te ayuda a comprender cómo empezar a modelar un sistema usando ejemplos y diagramas sencillos.\nPero antes, ¿qué es un sistema? El libro lo define como una conjunto de elementos que interactúan entre sí para lograr un objetivo. Lo más importante de un sistema es que su comportamiento no se puede explicar observando el comportamiento individual de sus elementos, por lo que se dice lo que distingue a un sistema de un montón de elementos que no lo son es que \u0026ldquo;un sistema es más que la suma de sus partes\u0026rdquo;.\nLos componentes principales de un sistema son:\nAlmacenes (stock): Es un lugar físico o virtual donde se almacenan o van acumulando cosas, en sistemas de software los puedes pensar como un buffer. Los stocks pueden tener límites o no. En el libro se usa el ejemplo de las existencias de una agencia automotriz, el stock es el inventario de autos que tienen para la venta. Flujos (flow): Son los movimientos, es decir, entrada y salidas de las cosas que se mueven entre almacenes o dentro y fuera del sistema. Y ya, con esto puedes empezar a modelar un sistema. Existen casos especiales sobre todo de flujos que son muy importantes y que son lo que les da su comportamiento interesante:\nFlujos de retroalimentación: Cuando los cambios en la condición de un almacén causan cambios en sus flujos de entrada y de salida, tenemos un flujo de retroalimentación. Piénsalo en el caso de un sistema de control de inventario, si se ve que no hay suficientes autos para la venta de la siguiente semana, se piden bastantes autos, pero si el almacén está casi lleno, se piden menos.\nTasas de cambio: Algo que considerar es que los cambios en el mundo real no son instantáneos, por lo que todo lo que hemos hablado hasta ahora está afectado por un ritmo de cambio.\nPero ya te estoy adelantando de más, para que comprendas esto mejor, te recomiendo leer el libro.\nTipos de sistemas # Lo más interesante de este libro es el análisis de los comportamientos de los sistemas, y cómo es que aunque un sistema esté compuesto de partes completamente entendidas, el comportamiento del sistema no es obvio o fácil de predecir, sin embargo, sí hay patrones que puedes identificar y entender.\nEl libro te presenta una clasificación de sistemas a la que le llama \u0026ldquo;un zoológico de sistemas\u0026rdquo;, clasificándolos como si fueran especies bien entendidas de animales. Aquí podemos ver varios tipos de sistemas y sus destinos finales:\nSistemas que se mantienen estables y funcionando. Sistemas resilientes que se adaptan a los cambios. Sistemas destinados a desaparecer: por su crecimiento desmedido o porque no producen resultados. En esta parte podrás aprender a identificar varios patrones más.\nCómo controlar y cambiar un sistema # Una de las lecciones más importantes de \u0026ldquo;Thinking in Systems\u0026rdquo; es que los sistemas son muy sensibles a los cambios y que no es fácil comprender su efectos. Por lo tanto, un sistema es difícil de controlar o cambiar y no nos queda más que hacer experimentos para entender cómo cambiarlo.\nEl libro da una lista de 12 cosas que podemos hacer para cambiar un sistema, pero deja claro que ninguna de esas cosas es infalible. Esto es importante porque los desarrolladores de software somos muy propensos a sentir que entendemos un sistema más de lo que realmente lo entendemos y segundo a pensar que lo podemos cambiar con facilidad haciendo intervenciones sencillas. Esto normalmente lleva al desastre.\nReglas para vivir en un mundo de sistemas complejos # Finalmente, Donella da una lista de 15 reglas o principios para comportarnos mejor en un mundo en el que los sistemas son engañosos, que se me hacen esenciales para cualquier persona que trabaje en el área del conocimiento, y son especialmente importantes para los desarrolladores de software. Cuando los leas verás que tienen mucho que ver con las \u0026ldquo;buenas prácticas\u0026rdquo; que se fomentan en diferentes metodologías de desarrollo de software.\nLa mayoría tienen que ver con la idea de manejar correctamente la información que tenemos, clarificarla, registrarla y compartirla.\nQué podemos aprender los desarrolladores de software # Ya hemos repetido hasta el cansancio que los desarrolladores de software debemos ser expertos en modelar sistemas. ¿Pero por qué? Recuerda que tu trabajo es representar el mundo real en un lenguaje de programación, conectar diferentes piezas de software para que la información fluya, y mantener esos sistemas funcionando, al mismo tiempo que cuidas de los recursos que consumen y te aseguras de que evolucionen para que sigan siendo precisos y útiles.\nTodo lo anterior implica primero entender el sistema del mundo real y después representarlo en nuestras computadoras. Así que creo que es obvio por qué este libro es tan buena lectura para cualquier desarrollador de software que quiera avanzar en su carrera: te ayudará a ser mejor en tu trabajo.\nPero el libro tiene una lección que me parece de suma importancia: los sistemas del mundo real son más complejos de lo que podemos representar en cualquier medio de representación humano, por lo que debemos ser explícitos sobre lo que estamos modelando y sus límite, siempre manteniendo una actitud de curiosidad, aprendizaje y humildad intelectual. Este punto específicamente es lo que los desarrolladores de software se beneficiarán de aprender a hacer, y es una de las razones por las que este libro es tan importante.\nConclusión # Si eres desarrollador de software y quieres mejorar tu habilidad para crear sistemas complejos que sirvan en el mundo real, mientras antes leas este libro, mejor. No solo lo leas, estudia Thinking in Systems, toma notas, y pon en práctica lo que aprendas en los nuevos sistemas que diseñes y construyas.\nEl mensaje de fondo de Meadows es que aquellos que nos dedicamos a entender y modelar el mundo podemos tener un gran impacto en la forma en la que funcionan las cosas, pero ese impacto no es fácil de lograr y mucho menos inmediato. A final de cuentas, ¿no quieres que tu trabajo sea importante? Si es así, seguir los consejos de este libro te ayudará a que eso suceda.\n","date":"15 mayo 2025","externalUrl":null,"permalink":"/2025/05/15/debes-leer-thinking-in-systems/","section":"Posts","summary":"\u003cp\u003eEl libro \u0026ldquo;Thinking in Systems\u0026rdquo; de \u003ca\n  href=\"https://en.wikipedia.org/wiki/Donella_H._Meadows\"\n    target=\"_blank\"\n  \u003eDonella Hager Meadows\u003c/a\u003e\nes un libro muy importante para cualquier desarrollador de software. ¿Por qué? Los desarrolladores nos dedicamos\na hacer \u003cem\u003esistemas\u003c/em\u003e, y este es justo el tema principal del libro, escrito por una experta en sistemas complejos.\u003c/p\u003e","title":"Debes leer 'Thinking in Systems'","type":"posts"},{"content":"","date":"15 mayo 2025","externalUrl":null,"permalink":"/tags/libros/","section":"Tags","summary":"","title":"Libros","type":"tags"},{"content":"","date":"15 mayo 2025","externalUrl":null,"permalink":"/tags/sistemas/","section":"Tags","summary":"","title":"Sistemas","type":"tags"},{"content":"Los LLM\u0026rsquo;s llegaron para cambiar la forma en la que usamos la computadora. Pero sus limitaciones y casos de uso que nos abren, requieren que los utilicemos en conjunto con otras tecnologías y nuevas arquitecturas, para hacer software confiable, útil y que cumpla con lo que el usuario necesita.\nUna parte importante es la fuente de información, ya que no podemos confiar en ellos como fuentes de información exactas. ¿En qué tipos de bases de datos podemos guardar información para crear programas en combinación con los modelos generativos que sirvan lo mejor posible?\nEn este artículo vamos a hablar de eso, pero empecemos entendiendo por qué se necesitan bases de datos con capacidades especiales.\n¿Por qué se necesitan bases de datos con capacidades especiales? # Pensemos en algunos de los casos que los LLMs pueden ser útiles para resolver:\nChatbots más sofisticados que los basados en reglas, con mayor capacidad de respuesta y flexibilidad en en el tipo de respuestas que puede dar. Sistemas de creación de contenido en general, que nos dan mejores ideas o resultados finales de alta calidad. Agentes autónomos más inteligentes que pueden tomar decisiones y realizar tareas más complejas. Asistentes personales que analizan el contexto, juntan información y la usan para poder darnos ayuda en diferentes áreas. Para que un LLM sea realmente útil en cualquiera de estos contextos necesitamos que tenga acceso a información actualizada y relevante. Para hacer un chatbot que pueda responder preguntas sobre cualquier tema no podemos confiar en lo que el modelo tiene codificado en sus parámetros, primero porque puede estar desactualizado y segundo porque es propenso a cometer errores, lo que se conoce como alucinaciones. Ni los modelos más avanzados se escapan de eso, y de hecho algunos investigadores piensan que mientras más \u0026ldquo;capaz\u0026rdquo; sea el modelo, más propenso a cometer alucinaciones. En mi experiencia, pasa exactamente eso, un LLM muy avanzado puede hacer invenciones cada vez más convincentes, pero que siguen sin estar apegadas a la realidad.\nLo que esperamos del software # Dependiendo del caso se requieren algunas características que se esperan del software en general pero que los LLM\u0026rsquo;s no son especialmente buenos para cumplir, por ejemplo:\nVelocidad: Casi todos los programas que encaran al usuario final requieren responder lo más rápido posible. Exactitud: En la mayoría de los casos necesitamos que la información que nos proporciona el LLM sea lo más exacta posible, muchas veces no necesitamos una precisión absoluta, pero por lo menos esperamos que no sea completamente errónea la respuesta. Frescura en la información: La información que usamos en el día a día cambia y si tenemos un sistema que la usa, debe tener acceso a lo más actualizado. Capacidad de atender a muchos usuarios: A veces el mismo sistema debe poder atender a muchos usuarios. Esto nos enfrenta con dos problemas principalmente: la capacidad de cómputo requerida para manejar todas las peticiones y el costo de correr los modelos. Es por eso que los proyectos basados en LLM\u0026rsquo;s utilizan técnicas para lograr dos cosas principalmente:\nDarle información correcta, actualizada y sucinta al LLM: Esto ataca los problemas de velocidad, exactitud y frescura de la información. Reducir la cantidad de tokens que consume el LLM: Esto también nos puede ayudar con casi todos los puntos de arriba, pero principalmente con el costo. La técnica principal se llama en inglés Retrieval Augmented Generation (RAG). Hablemos brevemente de ella.\n¿Qué es RAG? # La técnica o arquitectura RAG consiste básicamente en usar una base de datos para almacenar la información relevante que le vamos a inyectar al LLM dependiendo de la tarea que tenga que realizar. La parte difícil está compuesta por dos etapas, que podemos resumir en dos preguntas:\n¿Cómo preparo la información para que el LLM pueda usarla? ¿Cómo hago que cuando el LLM necesite información, pueda acceder a ella de manera rápida y eficiente? No vamos a profundizar mucho en la implementación de RAG, pero uno de los puntos más importantes para tener un sistema exitoso es la base de datos que usamos para almacenar la información, que tiene que ver más con la segunda pregunta.\nBases de datos para proyectos con LLM\u0026rsquo;s # Hablemos de dos tipos diferentes de bases de datos que pueden ayudar a tu sistema a cumplir con lo que se espera de un sistema de software, mientras aprovechamos las capacidades de los LLM\u0026rsquo;s.\nBases de datos vectoriales # Los modelos de lenguaje pueden generar texto, pero también pueden generar vectores. Estos vectores representan el significado de los textos en un espacio vectorial. En inglés se les conoce como embeddings y en español casi no se usa la traducción pero les podemos llamar incorporaciones.\nEl punto es que al transformar el texto en un vector que representa su significado podemos hacer operaciones con los vectores para encontrar textos que sean similares o relacionados. Y aunque esto lo podríamos programar manualmente, una programa especializado en eso nos sería de mucha ayuda. Además, los vectores que te dan los modelos de lenguaje tienen una dimensión muy grande, por lo que no es fácil de manejarlos con técnicas tradicionales.\nPara que tu LLM tenga acceso a información relevante, una técnica transformar toda la información que quieres que el LLM pueda usar en embeddings y guardarlos en una base de datos vectorial. Las bases de datos vectoriales pueden ayudarte a traer (Retrieval) la información más relevante cuando la necesites, de manera rápida y eficiente.\nAquí te presento algunos ejemplos de bases de datos vectoriales que puedes usar:\nFaiss: No es propiamente una base de datos, sino una biblioteca open-source creada por Facebook AI Research, muy eficiente en búsqueda y clustering de vectores densos. Se usa comúnmente embebida en aplicaciones Python/C++ para implementar búsquedas vectoriales locales. También puede ser usado para crear tu propia base de datos vectorial. Milvus: Es de código abierto, diseñada para escalabilidad horizontal y manejo de miles de millones de vectores. Ofrece un servicio completo (con clustering, replicación) ideal para APIs de búsqueda semántica. También tienen una versión gestionada llamada Zilliz Cloud. Pinecone: Plataforma SaaS especializada en vectores. Es una de las formas más sencillas de empezar y ofrecen una capa gratuita para pequeños proyectos. ChromaDB: Otro proyecto open-source, que ha evolucionado a no solamente ser una base de datos de vectores sino también de documentos, con funciones como búsqueda de texto completo, filtrado de metadatos y almacenamiento multi-modal. También es una de las formas más sencillas de empezar porque puedes embeberla en tu proyecto de forma sencilla. Weaviate: Es un proyecto open source hecho en Go. Su enfoque es completamente ser una base de datos pensada para servir a aplicaciones de inteligencia artificial, sobre todo a aquellas basadas en texto. Te puede ayudar desde convertir tus documentos en vectores y almacenarlos, hasta hacer búsquedas de diferentes tipos. Qdrant: Otro motor open-source con características a los anteriores, desarrollado en Rust, pero que ofrece características enterprise, tiene versiones gestionadas y parece que es usado en proyectos grandes. PostgreSQL tiene la extensión PGVector para almacenar y comparar embeddings en columnas de una tabla, por lo que si ya tienes una aplicación y no quieres agregar una nueva pieza de tecnología que mantener, el viejo confiable PostgreSQL puede ser una buena opción. Bases de datos de grafos # Las bases de datos de grafos sirven muy bien para representar relaciones entre entidades. Este tipo de representación es muy útil para modelar sistemas de información, y por lo tanto para crear búsquedas semánticas y recomendaciones por similitud o temas relacionados.\nAunque este tipo de bases de datos tienen menos relevancia en los proyectos para LLM\u0026rsquo;s, te pueden ayudar para crear mejores sistemas que contesten mejor a las peticiones de los usuarios y que abaraten el costo de las respuestas por el uso de tokens.\nA los sistemas que usan una base de datos de grafos para enriquecer las respuestas les llaman GraphRAG (Graph-based Retrieval Augmented Generation). Aquí puedes usar las clásicas bases de datos de grafos de toda la vida:\nNeo4j: Igual un desarrollo de código abierto, con versiones gestionadas y enterprise. Si quieres irte por el camino fácil, esta es una de las mejores opciones, por su confiabilidad y soporte. ArangoDB: Es una base datos híbrida, pensada tanto para grafos como para vectores, promete cubrir los dos lados de los que hablamos en este artículo: la flexibilidad de los vectores con la capacidad de grafos. No es open-source, pero tienen una versión de comunidad para que puedas probarla. Dgraph: Es una base de datos de grafos open-source, recientemente adquirida por una empresa llamada Hypermode, enfocada en desarrollo de software con LLM\u0026rsquo;s. Promete procesar terabytes de datos y responder en tiempo real. Conclusiones # Las bases de datos vectoriales y de grafos son herramientas poderosas que te pueden ayudar a cumplir con las expectativas y necesidades de los proyectos que son típicos de desarrollar con LLM\u0026rsquo;s. Para usarlas correctamente hay que comprender su funcionamiento lo suficiente, pero no es necesario que te vayas a cada detalle.\nCuando estamos desarrollando software siempre aplica el dicho de usar la herramienta correcta para el problema y este es un ejemplo claro de la aplicación de este principio. Pero siempre hay que equilibrarlo con la simplicidad y recordando que cada pieza de software o hardware que agreguemos al proyecto aumenta la complejidad y el costo de correr y mantener el proyecto.\n","date":"10 mayo 2025","externalUrl":null,"permalink":"/2025/05/10/bases-de-datos-para-llms/","section":"Posts","summary":"\u003cp\u003eLos LLM\u0026rsquo;s llegaron para cambiar la forma en la que usamos la computadora.\nPero sus limitaciones y casos de uso que nos abren, requieren que los\nutilicemos en conjunto con otras tecnologías y nuevas arquitecturas, para\nhacer software confiable, útil y que cumpla con lo que el usuario necesita.\u003c/p\u003e","title":"Bases de datos para LLM's","type":"posts"},{"content":"","date":"10 mayo 2025","externalUrl":null,"permalink":"/tags/bases-de-datos/","section":"Tags","summary":"","title":"Bases-De-Datos","type":"tags"},{"content":"","date":"10 mayo 2025","externalUrl":null,"permalink":"/tags/embeddings/","section":"Tags","summary":"","title":"Embeddings","type":"tags"},{"content":"","date":"10 mayo 2025","externalUrl":null,"permalink":"/tags/grafos/","section":"Tags","summary":"","title":"Grafos","type":"tags"},{"content":"","date":"10 mayo 2025","externalUrl":null,"permalink":"/tags/llms/","section":"Tags","summary":"","title":"Llms","type":"tags"},{"content":"","date":"10 mayo 2025","externalUrl":null,"permalink":"/tags/vectores/","section":"Tags","summary":"","title":"Vectores","type":"tags"},{"content":"","date":"17 abril 2025","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"Hablar de metaprogramación en C++ suele generar cierto rechazo, y no sin razón: dominar el lenguaje ya representa un reto considerable, y sumarle la complejidad de los teamplates puede parecer excesivo. A diferencia de otros lenguajes con mecanismos más flexibles o integrados, C++ exige un conocimiento profundo no solo del lenguaje, sino también del compilador y su comportamiento. Comprender cómo interactúan las plantillas, como se resuelven los tipos, como se gestionan las sobrecargas o se aplican las optimizaciones es esencial para escribir código genérico eficaz, lo que convierte esta práctica en un desafío tanto técnico como mental.\nPero el desafío que implica la Metaprogramación no es exclusivo de C++; otros lenguajes también han buscado formas de extender sus propias capacidades, enfrentándose a problemas similares desde enfoques muy distintos.\nA lo largo de la historia de la informática, diversos lenguajes han explorado la metaprogramación desde ángulos muy distintos. LISP fue pionero absoluto en este campo, abordando el código como si fuera datos y utilizando macros para modificar y extender el propio lenguaje desde dentro. Esa fusión entre programa y datos sentó las bases de lo que hoy conocemos como metaprogramación.\nPor otro lado, Ada introdujo desde etapas tempranas mecanismos más estructurados, como los generics, que ofrecían una forma de reutilización de código orientada a la seguridad y el tipado fuerte. Por ejemplo, al definir un paquete genérico para pilas:\ngeneric type Elemento is private; package Pilas is procedure Push (P : in out Pilas; E : in Elemento); function Pop (P : in out Pilas) return Elemento; private type Pilas is array (Natural range \u0026lt;\u0026gt;) of Elemento; end Pilas; package Pilas_Enteros is new Pilas (Elemento =\u0026gt; Integer); Mientras Ada se centra en la metaprogramación estática, otros lenguajes exploraron la reflexión y los meta‑objetos para ganar flexibilidad en tiempo de ejecución. Java, por ejemplo, utiliza Annotation Processors para generar código antes de compilar, C# aprovecha Roslyn para inspeccionar y modificar su árbol de sintaxis, D ofrece CTFE y mixins, y Rust incorpora procedural macros que derivan implementaciones de rasgos automáticamente.\nUno de los primeros antecedentes directos de la metaprogramación en C++ lo encontramos en C, particularmente en el uso creativo de su preprocesador. Más allá de las clásicas macros con funciones, surgieron técnicas como los X-macros, que permitían generar múltiples fragmentos de código reutilizando una lista común de componentes. Esta técnica consistía en definir un conjunto de macros en un archivo de cabecera que podía incluirse varias veces, redefiniendo la macro principal en cada inclusión para producir diferentes versiones del código.\n// xmacro.h #define COMPONENTS \\ X(int, age) \\ X(char*, name) \\ X(double, salary) #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;mac.h\u0026#34; // 1. Definir la estructura usando las X-macros #define X(type, name) type name; typedef struct { COMPONENTS } Employee; #undef X // 2. Declarar funciones específicas para imprimir cada campo void print_age(int age) { printf(\u0026#34;age: %d\\n\u0026#34;, age); } void print_name(char* name) { printf(\u0026#34;name: %s\\n\u0026#34;, name); } void print_salary(double salary) { printf(\u0026#34;salary: %.2f\\n\u0026#34;, salary); } // 3. Usar X-macros para llamar automáticamente a las funciones de impresión #define X(type, name) print_##name(e.name); void print_employee(Employee e) { COMPONENTS } #undef X int main() { Employee emp = {30, \u0026#34;John Doe\u0026#34;, 55000.5}; print_employee(emp); return 0; } Aunque limitada y propensa a errores, esta estrategia fue una solución creativa a la falta de mecanismos más robustos, y se ha usado en tareas como la serialización de estructuras o la generación repetitiva de código.\nLa evolución hacia C++ introdujo un enfoque más robusto y expresivo para la generación de código: en lugar de depender de las macros del preprocesador — propensas a errores y difíciles de depurar — , el lenguaje apostó por mecanismos estáticos como los templates. Esta decisión, formalizada en el estándar C++98, marcó un hito importante en la historia del lenguaje. Originalmente concebidos por Bjarne Stroustrup a principios de los años 90, los templates surgieron como una extensión natural de la idea de reutilización de código sin sacrificar eficiencia. Esta elección estaba alineada con la filosofía de C++: ofrecer un control fino sobre el rendimiento y el uso eficiente de los recursos.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; // Definición de la clase Persona struct Persona { std::string nombre; int edad; // Sobrecarga del operador \u0026gt; bool operator\u0026gt;(const Persona\u0026amp; otra) const { return edad \u0026gt; otra.edad; } }; // Plantilla max para comparar dos objetos de cualquier tipo template \u0026lt;typename T\u0026gt; T max(T a, T b) { return (a \u0026gt; b) ? a : b; } int main() { std::cout \u0026lt;\u0026lt; max(5, 10) \u0026lt;\u0026lt; std::endl; // Comparar enteros std::cout \u0026lt;\u0026lt; max(5.5, 2.3) \u0026lt;\u0026lt; std::endl; // Comparar flotantes std::cout \u0026lt;\u0026lt; max(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) \u0026lt;\u0026lt; std::endl; // Comparar caracteres std::cout \u0026lt;\u0026lt; max(\u0026#34;Hola\u0026#34;, \u0026#34;Mundo\u0026#34;) \u0026lt;\u0026lt; std::endl; // Comparar cadenas de caracteres // Crear objetos Persona Persona p1{\u0026#34;Ana\u0026#34;, 30}; Persona p2{\u0026#34;Luis\u0026#34;, 25}; // Usar la plantilla max con objetos Persona Persona mayor = max(p1, p2); std::cout \u0026lt;\u0026lt; \u0026#34;La persona mayor es: \u0026#34; \u0026lt;\u0026lt; mayor.nombre \u0026lt;\u0026lt; \u0026#34; con \u0026#34; \u0026lt;\u0026lt; mayor.edad \u0026lt;\u0026lt; \u0026#34; años.\u0026#34;; return 0; } Un ejemplo sobresaliente del poder de la metaprogramación en C++ es la Standard Template Library (STL). Diseñada hace más de dos décadas, esta biblioteca demostró que es posible construir algoritmos y estructuras de datos altamente reutilizables, seguros y eficientes sin sacrificar rendimiento. Su arquitectura, basada completamente en templates, permite que muchas decisiones se tomen en tiempo de compilación, lo que facilita optimizaciones que en otros lenguajes se delegan al tiempo de ejecución. Gracias a este enfoque, los programadores pueden trabajar con listas, vectores, mapas y muchos otros contenedores de forma abstracta, sin comprometer el control sobre el rendimiento.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; // Clase personalizada struct Persona { std::string nombre; int edad; // Sobrecarga del operador \u0026gt; (requisito para usar con maximo\u0026lt;T\u0026gt;) bool operator\u0026gt;(const Persona\u0026amp; otra) const { return edad \u0026gt; otra.edad; } // Para usar en búsquedas bool esMayorDeEdad() const { return edad \u0026gt;= 18; } }; // Template genérico como ejemplo de metaprogramación template \u0026lt;typename T\u0026gt; T maximo(const T\u0026amp; a, const T\u0026amp; b) { return (a \u0026gt; b) ? a : b; } // Función para imprimir un vector genérico (puede usarse con cualquier tipo imprimible) template \u0026lt;typename T\u0026gt; void imprimirVector(const std::vector\u0026lt;T\u0026gt;\u0026amp; vec, const std::string\u0026amp; titulo) { std::cout \u0026lt;\u0026lt; titulo \u0026lt;\u0026lt; \u0026#34;:\\n\u0026#34;; for (const auto\u0026amp; elem : vec) { std::cout \u0026lt;\u0026lt; \u0026#34;- \u0026#34; \u0026lt;\u0026lt; elem.nombre \u0026lt;\u0026lt; \u0026#34; (\u0026#34; \u0026lt;\u0026lt; elem.edad \u0026lt;\u0026lt; \u0026#34; años)\\n\u0026#34;; } } int main() { Persona p1{\u0026#34;Ana\u0026#34;, 30}; Persona p2{\u0026#34;Luis\u0026#34;, 25}; Persona p3{\u0026#34;Carlos\u0026#34;, 40}; Persona p4{\u0026#34;Elena\u0026#34;, 35}; // Uso del template maximo Persona mayor = maximo(p1, p2); std::cout \u0026lt;\u0026lt; \u0026#34;Entre \u0026#34; \u0026lt;\u0026lt; p1.nombre \u0026lt;\u0026lt; \u0026#34; y \u0026#34; \u0026lt;\u0026lt; p2.nombre \u0026lt;\u0026lt; \u0026#34;, el mayor es: \u0026#34; \u0026lt;\u0026lt; mayor.nombre \u0026lt;\u0026lt; \u0026#34; con \u0026#34; \u0026lt;\u0026lt; mayor.edad \u0026lt;\u0026lt; \u0026#34; años.\\n\\n\u0026#34;; // STL: vector y sort con lambda std::vector\u0026lt;Persona\u0026gt; personas = {p1, p2, p3, p4}; std::sort(personas.begin(), personas.end(), [](const Persona\u0026amp; a, const Persona\u0026amp; b) { return a.edad \u0026lt; b.edad; }); imprimirVector(personas, \u0026#34;Personas ordenadas por edad\u0026#34;); // Uso de std::find_if para buscar al primer mayor de edad auto it = std::find_if(personas.begin(), personas.end(), [](const Persona\u0026amp; p) { return p.esMayorDeEdad(); }); if (it != personas.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;\\nPrimera persona mayor de edad: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;nombre \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // Uso de std::map con string -\u0026gt; Persona std::map\u0026lt;std::string, Persona\u0026gt; directorio; for (const auto\u0026amp; persona : personas) { directorio[persona.nombre] = persona; } std::cout \u0026lt;\u0026lt; \u0026#34;\\nDirectorio (map de nombre -\u0026gt; edad):\\n\u0026#34;; for (const auto\u0026amp; [nombre, persona] : directorio) { std::cout \u0026lt;\u0026lt; nombre \u0026lt;\u0026lt; \u0026#34; tiene \u0026#34; \u0026lt;\u0026lt; persona.edad \u0026lt;\u0026lt; \u0026#34; años\\n\u0026#34;; } return 0; } La STL no solo consolidó el papel de la metaprogramación en el ecosistema de C++, sino que también mostró cómo podía usarse para diseñar software genérico, modular y de alto rendimiento.\nDurante mucho tiempo, trabajar con metaprogramación en C++ fue una tarea ardua: los mensajes de error crípticos, la dificultad de depuración y la complejidad sintáctica desalentaban incluso a programadores experimentados. A pesar de la gran utilidad de los templates, las actualizaciones significativas fueron pausadas durante un largo periodo, desde el estándar de 1998 hasta la llegada de C++11 en 2011.\nSin embargo, el lenguaje comenzó a evolucionar de manera más progresiva, incorporando características como auto, decltype, constexpr y variadic templates, que facilitaban la escritura de código genérico más expresivo. Posteriormente, C++14 y C++17 siguieron refinando estas ideas, mientras que C++20 marcó un punto de inflexión con la inclusión de concepts, que aportaron una forma formal y clara de expresar los requisitos de los tipos en las plantillas.\nLa introducción de concepts en C++20 representó un paso crucial en esta evolución. Inspirados en gran medida por las ideas de Alexander Stepanov, cocreador de la STL, los concepts permiten especificar de forma clara y expresiva qué requisitos debe cumplir un tipo para ser utilizado en una plantilla. Esta abstracción permite escribir código genérico más legible y seguro, con validaciones en tiempo de compilación que antes requerían técnicas mucho más complejas o indirectas. Gracias a herramientas como concepts, la metaprogramación en C++ ha dejado de ser un arte oscuro para convertirse en una práctica más accesible, robusta y expresiva.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;concepts\u0026gt; // Concepto que exige un método miembro `area()` que devuelva un número (real o entero) template \u0026lt;typename T\u0026gt; concept TieneArea = requires(T a) { { a.area() } -\u0026gt; std::convertible_to\u0026lt;double\u0026gt;; }; // Función que suma el área de todas las figuras que cumplen con el concepto TieneArea template \u0026lt;TieneArea T\u0026gt; double area_total(const std::vector\u0026lt;T\u0026gt;\u0026amp; figuras) { double total = 0; for (const auto\u0026amp; figura : figuras) { total += figura.area(); // Se garantiza que existe } return total; } // Clases que implementan el método `area()` struct Rectangulo { double ancho, alto; double area() const { return ancho * alto; } }; struct Circulo { double radio; double area() const { return 3.14159 * radio * radio; } }; // Clase que NO implementa `area()` y no cumple el concepto struct Punto { double x, y; }; int main() { std::vector\u0026lt;Rectangulo\u0026gt; rectangulos = { {4.0, 5.0}, {2.0, 3.0} }; std::vector\u0026lt;Circulo\u0026gt; circulos = { {1.0}, {2.5} }; std::cout \u0026lt;\u0026lt; \u0026#34;Área total de rectángulos: \u0026#34; \u0026lt;\u0026lt; area_total(rectangulos) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Área total de círculos: \u0026#34; \u0026lt;\u0026lt; area_total(circulos) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // std::vector\u0026lt;Punto\u0026gt; puntos = { {1.0, 2.0}, {3.0, 4.0} }; // area_total(puntos); // Error de compilación: Punto no tiene `area()` return 0; } Además, de cara a C++26, se contempla la incorporación de mecanismos de reflexión estática, una capacidad largamente esperada que permitiría inspeccionar y manipular tipos y estructuras del programa durante la compilación. Esta funcionalidad ampliaría aún más el poder de la metaprogramación en C++, facilitando tareas como la generación automática de código, la serialización de objetos o la validación estructural sin recurrir a macros o técnicas intrusivas.\nLa metaprogramación en C++ ha evolucionado de forma notable: desde los ingeniosos — aunque limitados — usos del preprocesador, hasta un presente donde los templates, concepts y la futura incorporación de reflexión estática conforman un ecosistema cada vez más potente, seguro y expresivo. Lejos de ser una técnica reservada a expertos, hoy se consolida como una herramienta estratégica para escribir código genérico, reutilizable y eficiente. Comprender esta evolución no solo permite valorar mejor el diseño del lenguaje, sino también adoptar una perspectiva más madura sobre cómo abstraemos y optimizamos nuestros programas. En última instancia, Metaprogramación en C++ es ampliar los límites de lo que podemos construir con precisión, elegancia y control.\n","date":"17 abril 2025","externalUrl":null,"permalink":"/2025/04/17/el-arte-gen%C3%A9rico-una-historia-de-la-metaprogramaci%C3%B3n-en-c-/","section":"Posts","summary":"\u003cp\u003eHablar de metaprogramación en C++ suele generar cierto rechazo, y no sin razón: dominar el lenguaje ya representa un reto considerable, y sumarle la complejidad de los teamplates puede parecer excesivo. A diferencia de otros lenguajes con mecanismos más flexibles o integrados, C++ exige un conocimiento profundo no solo del lenguaje, sino también del compilador y su comportamiento. Comprender cómo interactúan las plantillas, como se resuelven los tipos, como se gestionan las sobrecargas o se aplican las optimizaciones es esencial para escribir código genérico eficaz, lo que convierte esta práctica en un desafío tanto técnico como mental.\u003c/p\u003e","title":"El arte genérico: una historia de la metaprogramación en C++","type":"posts"},{"content":"","date":"17 abril 2025","externalUrl":null,"permalink":"/tags/metaprogramaci%C3%B3n/","section":"Tags","summary":"","title":"Metaprogramación","type":"tags"},{"content":"","date":"23 febrero 2025","externalUrl":null,"permalink":"/tags/deep-learning/","section":"Tags","summary":"","title":"Deep-Learning","type":"tags"},{"content":"","date":"23 febrero 2025","externalUrl":null,"permalink":"/tags/machine-learning/","section":"Tags","summary":"","title":"Machine-Learning","type":"tags"},{"content":"","date":"23 febrero 2025","externalUrl":null,"permalink":"/tags/matem%C3%A1ticas/","section":"Tags","summary":"","title":"Matemáticas","type":"tags"},{"content":"La serie The MIT Press Essential Knowledge Series es una serie de libros de introducción a diferentes temas interesantes y actuales, sobre todo de ciencia y tecnología.\nMe gustan mucho porque son lo suficientemente introductorios para que cualquiera sin conocimiento previo del tema específico pueda introducirse, pero lo suficientemente completos para salir con una buena visión general de ese tema específico.\nEl libro del que quiero hablar es de un tema que se ha vuelto cada vez más importante, el Deep Learning.\nReseña del Deep Learning de John D. Kelleher # {: .align-center}\nEn este libro empezarás desde la introducción a lo que llamamos inteligencia artificial, machine learning y finalmente deep learning, junto con los efectos que ha tenido en el mundo.\nMe gusta mucho que el libro te explica en términos simples la base matemática que sustenta todo lo que hacemos con los modelos y te aclara los términos que se escuchan por todos lados sin ser tan difícil de entender. Por ejemplo:\nTe aclara que un modelo es una función en el sentido matemático y te explica cuál es el trabajo del entrenamiento para llegar a ese modelo Explica lo que es el aprendizaje y la experiencia Aclara qué es un parámetro Deja muy claros los pasos de entrenamiento e inferencia Después de poner las cartas sobre la mesa respecto términos y definiciones, se pasa a hablar de la historia de la inteligencia artificial y cómo es que llegamos casi hasta donde estamos ahora, porque este libro se escribió antes del boom de los LLMs, pero viéndolo desde nuestra perspectiva te puedes dar cuenta de lo mucho que sabe el autor del tema porque ya menciona a los transformadores (la base de los LLMs modernos) como un tipo de modelo de Deep Learning importante.\nDespués de esto, pasa a explicar cómo se entrena a un perceptrón, o un modelo de una neurona, para que puedas entender el procedimiento básico y después pasar a los modelos que son el centro del libro: los modelos profundos.\nEn este libro aprenderás que el deep learning es simplemente una forma de entrenar modelos que están compuestos por varias capas de neuronas, y que es un campo en sí mismo porque estos modelos no son tan fáciles de entrenar e incluso requieren matemáticas específicas y técnicas que han ido surgiendo con la prueba y el error.\nEl libro te explica dos algoritmos esenciales en el deep learning:\nEl descenso de gradiente (gradient descent) El algoritmo de retropropagación (backpropagation) Esta es la parte más pesada del libro respecto a matemáticas, incluso dice que te la puedes leer por encima si te cuestan mucho trabajo, pero que también puedes comprobar por ti mismo las matemáticas que te explica. Aquí es justo donde digo que esta serie profundiza lo suficiente para no sentirse como un libro sin profundidad que es la pura introducción.\nEl libro finaliza con un análisis de lo que el autor considera lo que sigue para el deep learning y la inteligencia artificial en general, como la explicabilidad, la eficiencia, el cómputo especializado en imitar el cerebro, los transformadores (BERT), etc.\nEspero que este resumen te de una idea de lo que trata el libro.\nConclusión y opinión # Si te quieres entender de manera un poco más profunda cómo funcionan las redes neuronales en general y los detalles de las redes neuronales profundas, este libro es una excelente introducción, porque incluso te da un viaje por las matemáticas detrás del entrenamiento de los modelos que usamos diariamente.\nComo se escribió en 2019, no te habla de LLMs o cosas similares, pero sí de las bases que les permitieron nacer: el transformador. Incluso menciona cosas no tan famosas, como la computación neuromórfica, de la que no dudo que pueda tener relevancia en el futuro, o impactar en nuevas tecnologías y nuevas formas de crear inteligencia artificial.\nPor su extensión, además, es un libro que vale la pena. Es cierto que se podría mejorar un poco en la forma de escribirlo, pero no es algo que te vaya a impedir extraer la información relevante.\nSi tienes bases de matemáticas de nivel preparatoria, en la que entiendes el álgebra y un poco de cálculo, estás del otro lado para entender este libro. Si no, puedes saltarte los capítulos matemáticos y leer todo lo demás para para darte una idea superficial del tema de Deep Learning y cómo puedes empezar a aprender la parte más técnica e incluirlo en tus desarrollos.\nEso sí, este libro no tiene ni una línea de código, es un libro completamente conceptual para entender la bases antes de aventarnos de cabeza a la programación.\n","date":"23 febrero 2025","externalUrl":null,"permalink":"/2025/02/23/rese%C3%B1a-del-libro-deep-learning-de-mit-press-essential-knowledge-series/","section":"Posts","summary":"\u003cp\u003eLa serie \u003cstrong\u003eThe MIT Press Essential Knowledge Series\u003c/strong\u003e es una serie de libros de introducción\na diferentes temas interesantes y actuales, sobre todo de ciencia y tecnología.\u003c/p\u003e\n\u003cp\u003eMe gustan mucho porque son lo suficientemente introductorios para que cualquiera\nsin conocimiento previo del tema específico pueda introducirse, pero lo suficientemente\ncompletos para salir con una buena visión general de ese tema específico.\u003c/p\u003e","title":"Reseña del libro 'Deep Learning' de MIT Press Essential Knowledge Series","type":"posts"},{"content":"","date":"30 diciembre 2024","externalUrl":null,"permalink":"/tags/buffer/","section":"Tags","summary":"","title":"Buffer","type":"tags"},{"content":"","date":"30 diciembre 2024","externalUrl":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"30 diciembre 2024","externalUrl":null,"permalink":"/tags/software-development/","section":"Tags","summary":"","title":"Software-Development","type":"tags"},{"content":"","date":"30 diciembre 2024","externalUrl":null,"permalink":"/tags/t%C3%A9cnicas-de-programaci%C3%B3n/","section":"Tags","summary":"","title":"Técnicas-De-Programación","type":"tags"},{"content":"El concepto de buffer es usado por todos lados en el desarrollo de software, pero siento que es un concepto poco entendido. En este artículo vamos a hablar de qué son los buffers, para qué se usan y cómo pueden ayudarte a resolver problemas y diseñar mejor software.\n¿Qué es un buffer? # Primero hablemos de dónde viene la idea de los buffers. Un buffer es un concepto importante en teoría de sistemas. Los buffers se utilizan para almacenar temporalmente datos, asegurando que eventualmente lleguen a su destino final. Esto ocurre a una velocidad o ritmo diferente al que fueron generados originalmente.\nTraducir la palabra \u0026ldquo;buffer\u0026rdquo; es difícil, porque no hay un concepto en español que abarque todos los usos que se le dan en el desarrollo de software.Algunos ejemplos de uso de buffers en el desarrollo de software son:\nAmortiguador Almacén temporal Memoria intermedia Regulador Esta última palabra te puede empezar a sonar, ya que en el desarrollo de software usamos los buffers para regular el flujo de datos entre diferentes sistemas o componentes. Los buffers causan retrasos intencionales en el flujo de datos.\nEmpecemos a hablar de cómo se usan en el desarrollo de software.\nBuffers en acción # Estos son algunos ejemplos de este concepto que seguro conoces o has visto aplicados en software. Recuerda que lo que estamos buscando entender es el concepto, por lo que vamos a explicar cómo el ejemplo es un buffer, pero no vamos a entrar en detalles de la implementación.\nEscritura en archivos # Cuando escribimos en un archivo, los sistemas operativos usan buffers para guardar los datos en memoria antes de escribirlos en su destino final, ya que si escribiera directamente en el disco byte por byte, sería muy lento. Además, escribir directamente en el disco por cada byte que un programa mande a escribir causaría problemas de estabilidad y rendimiento. Aquí no tenemos que explicar mucho por qué un buffer, ya que es el ejemplo más común. Incluso en varios lenguajes de programación los objetos que se usan para escribir en los archivos tienen \u0026ldquo;Buffer\u0026rdquo; o \u0026ldquo;Buffered\u0026rdquo; en su nombre.\nUso de servicios remotos # Usar un servicio o una función a través de la red (un servicio remoto) es costoso en tiempo y recursos en comparación con cualquier cálculo local que se haga. Por eso es buena idea usar buffers para guardar información antes de hacer una llamada a un servicio remoto. Por ejemplo, en desarrollo web, cuando se hace un auto-completado o búsqueda mientras se sigue escribiendo, el programa espera a que el campo tenga un número de caracteres para hacer una llamada al servicio de búsqueda que pueda tener sentido.\nCaching # Este ejemplo no podía faltar. El caché es un tipo de buffer que guarda información temporalmente con varios objetivos:\nAhorrar cómputo Acelerar el acceso a la información Evitar la sobrecarga de los recursos Como sabemos, lo más difícil del cachee es decidir primero qué guardar y luego cómo refrescarlo para que se no sea obsoleto.\nBuffering de contenido multimedia # Debido a que el contenido multimedia es muy pesado, un buen reproductor o sistema de streaming casi siempre incluye un buffer que va descargando el contenido a mayo velocidad y un poco adelantado para tener un reproducción fluida. Si no lo incluimos, estamos a merced de la velocidad y las intermitencias de la red.\n¿Cómo pueden ayudarte a diseñar mejor software? # Escribir software usando buffers es más complejo que hacerlo sin ellos, ya que son una pieza más que puede causar problemas y que en algún momento vas a tener que depurar. Pero los buffers complican el código y las pruebas de software, son indispensables para el buen rendimiento y la estabilidad de los sistemas. Incluso algunos lenguajes de programación como Java, tienen buffers incorporados en su librería estándar.\nRecuerda, usar buffers te va a ayudar a escribir software:\nMás estable Con mejor rendimiento Más resiliente Más eficiente Así que te conviene buscar oportunidades para usarlos lo mejor posible.\nConclusión # Los buffers son interesantes. Son una herramienta poderosa que puedes usar para resolver problemas con mejor calidad y que te permiten crear características arquitectónicas deseables, a costa de hacer el código un poco más complejo. Sin embargo, si los ocultas correctamente detrás de interfaces efectivas, los documentas bien y los pruebas, te ayudarán mucho.\n","date":"30 diciembre 2024","externalUrl":null,"permalink":"/2024/12/30/un-concepto-importante-los-buffers/","section":"Posts","summary":"\u003cp\u003eEl concepto de buffer es usado por todos lados en el desarrollo de software, pero siento\nque es un concepto poco entendido. En este artículo vamos a hablar de qué son los buffers,\npara qué se usan y cómo pueden ayudarte a resolver problemas y diseñar mejor software.\u003c/p\u003e","title":"Un concepto importante: los buffers","type":"posts"},{"content":"\u0026ldquo;Requerimientos funcionales\u0026rdquo; es una expresión muy rebuscada para un concepto muy sencillo relacionado con el diseño de los sistemas de software: las cosas que tu sistema HACE.\nEn este artículo hablaremos de formas de encontrarlos, definirlos, documentarlos y tenerlos listos para la siguiente etapa del desarrollo de software.\nCómo definir las funciones de un sistemas # La primera tarea como arquitecto de software tiene que ver con la de entender completamente lo que el software tiene que HACER. El software normalmente tiene unas pocas funciones principales, pero muchas tareas secundarias o terciarias que las soportan, y es por eso que descubrirlas y describirlas todas no es una tarea sencilla.\nCómo encontrarlos # La forma más eficiente de encontrar los requerimientos funcionales o funciones que debe tener tu sistema es viviendo el proceso o problema que tu sistema va a resolver. Es por esto que algunos de los mejores sistemas son creados por gente que \u0026ldquo;se rasca su propia comezón\u0026rdquo; (\u0026ldquo;scratch their own itch\u0026rdquo;). Es decir, que resuelven un problema que ellos mismos viven o han vivido, y que por eso mismo entienden a fondo.\nUna de las ventajas de atender un problema que tú vives, es que tienes retroalimentación inmediata sobre si el sistema resuelve el problema o no.\nPero esto no siempre es posible, sobre todo cuando construyes software como profesión, porque no siempre puedes dedicar tiempo y recursos suficientes para tú realizar la operación de lo que quieres resolver, o simplemente no es práctico. Así que la segunda mejor opción que tenemos es platicar con los usuarios.\nAquí es donde entran un montón de habilidades \u0026ldquo;blandas\u0026rdquo;. Un mejor nombre para estas habilidades es \u0026ldquo;habilidades personales e interpersonales\u0026rdquo;. O habilidades básicas humanas. Así que, a menos que tengas a alguien en tu equipo que lo haga por ti, (y que siempre vaya a estar contigo), te conviene desarrollarlas.\nCómo documentarlos # No existe una forma aceptada por todos para documentar nada en el software, dependiendo de la cultura del equipo y de la empresa en general. Veamos algunas de las formas más comunes. Cabe mencionar que estas formas no son excluyentes, se pueden combinar para ver diferentes aspectos de una misma función.\nHistorias de Usuario # En este estilo de documentación, describes las funciones del sistema desde la perspectiva del usuario. Se lleva muy bien con procesos modernos de desarrollo de productos digitales, relacionados con el desarrollo ágil de software.\nTienen el siguiente formato:\nComo [rol de usuario] Quiero [acción/función] Para [beneficio/valor] Como puedes ver, antes de empezar a crear historias de usuario, debes por lo menos tener un idea de las personas que van a usar el sistema y lo roles que desempeñan. Después, describes la función que va a realizar, desde su punto de vista, pero también intentando mostrar cómo funcionará internamente el sistema para cumplir con esa función.\nY finalmente, la razón de existencia de esta función: cómo es que beneficia al usuario o la empresa que crea el software. Esta última parte es muy importante, ya que nos hace pensar en si realmente es necesario tener esta función o no.\nCasos de Uso # Este tipo de documentación viene de la época en la que se prefería el desarrollo en cascada, pero a mi me sigue pareciendo muy útil. Es más formal y detallada, incluye:\nActores (usuarios o sistemas externos) involucrados Flujo principal: el caso en el que todo sale bien Flujos alternativos: los casos en los que algo sale mal o se manejan de otra manera Precondiciones y postcondiciones: cómo está el sistema antes y después de la ejecución En muchos sistemas de documentación, los casos de uso requieren un identificador para referirse a ellos en etapas posteriores, como cuando se hacen pruebas o se crean tareas específicas para el equipo de desarrollo.\nLos recomiendo mucho en el caso de sistemas o funciones críticas, en donde es necesario pensar más a profundidad antes de empezar a desarrollar. Puedes encontrar un ejemplo y una plantilla aquí: Casos de uso.\nCómo mantenerlos actualizados # El software es dinámico, y no basta con definir o documentar cómo funciona una sola vez, tenemos que mantener actualizadas las funciones documentadas del sistema o agregar nuevas conforme vayan apareciendo.\nAquí tienes algunas sugerencias para mantener actualizados los requerimientos:\nRevisar y actualizar # Si tienes suficiente personal, siempre debería haber un owner de la documentación y esta persona debería revisar y asegurarse que los diferentes miembros del equipo mantengan actualizadas las funciones documentadas y documenten las nuevas.\nControl de versiones # Es buena idea mantener los documentos de requerimientos bajo control de versiones, igual que el código. De hecho, una de las mejores formas de hacer documentación es tratarla exactamente como código, como se sugiere en Docs as Code.\nCada cambio debería ir acompañado de:\nFecha del cambio Razón del cambio Persona responsable Impacto en el sistema Trazabilidad # Puedes mantener una matriz de trazabilidad que conecte los requerimientos con:\nEl código que los implementa Las pruebas que los verifican Otra documentación relacionada Para que esta matriz sea útil, se debe de incluir su actualización en el proceso de desarrollo y considerarse dentro de la definición de \u0026ldquo;terminado\u0026rdquo; de una tarea (definition of done). Esto es buena idea sólo si tienes un equipo grande y un proyecto complejo, ya que requiere bastante trabajo en sí mismo.\nComunicación efectiva # Esto es esencial para todos los procesos de desarrollo de software, pero debes asegurarte que mientras más avance tu proyecto y más gente se involucre, más se haga:\nQue todos los cambios en los requerimientos sean comunicados a equipo de desarrollo y puestos en un documento que los describa Que las personas involucradas en el proyecto sepan de los cambios y sientan que su voz es escuchada, también registrando sus comentarios y sugerencias Es importante dejar la registro de la comunicación y las decisiones tomadas para que el conocimiento del software sea accesible para todos.\nUna alternativa: Design Documents # Los Design Documents son documentos que se usan en algunas big techs para documentar cómo se va implementar una función. Como es natural, estos documentos son bastante técnicos y algo tardados, pero incluyen por lo menos una descripción de la función que se quiere implementar y cómo se va a implementar.\nEstán pensados para obtener consenso sobre la forma en la que se va a hacer algo y son una buena idea si tienes un equipo de desarrollo maduro que puede llegar rápido a compromisos para lograr implementar algo.\nUn conjunto histórico de estos documentos, puede ser una buena alternativa para documentar los requerimientos funcionales de un sistema.\nConclusión # Entender lo que necesitamos que haga nuestro software es el primer paso para crear software útil. Los requisitos funcionales o funciones y su documentación son una herramienta para mantener un registro histórico y asegurarnos de que entendemos lo que se requiere. Esto también puede servir para obtener aprobación de las personas interesadas en que el software se realice y evitar malentendidos en el futuro.\nTambién facilitan la estimación de recursos y tiempos, y permiten un desarrollo más eficiente y enfocado. Finalmente, mejoran la comunicación entre todas las partes involucradas.\nEs importante dedicar el tiempo y esfuerzo necesarios para documentarlos adecuadamente (en mi opinión más como una herramienta de entendimiento que como una obligación) y mantenerlos actualizados durante la vida del proyecto. Un sistema bien diseñado comienza con funciones bien definidas, entendidas y gestionadas.\n","date":"23 noviembre 2024","externalUrl":null,"permalink":"/2024/11/23/qu%C3%A9-son-los-requerimientos-funcionales/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e\u0026ldquo;Requerimientos funcionales\u0026rdquo;\u003c/strong\u003e es una expresión muy rebuscada para un concepto\nmuy sencillo relacionado con el diseño de los sistemas de software: \u003cstrong\u003elas\ncosas que tu sistema HACE\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eEn este artículo hablaremos de formas de encontrarlos, definirlos, documentarlos\ny tenerlos listos para la siguiente etapa del desarrollo de software.\u003c/p\u003e","title":"¿Qué son los requerimientos funcionales?","type":"posts"},{"content":"","date":"23 noviembre 2024","externalUrl":null,"permalink":"/tags/arquitectura/","section":"Tags","summary":"","title":"Arquitectura","type":"tags"},{"content":"La programación asíncrona es uno de los primeros temas avanzados que encontrarás al programar, especialmente si desarrollas aplicaciones web. Esto es aún más común si haces JavaScript, que es un lenguaje que se usa en entornos de ejecución asíncronos.\nEn este artículo la explicaremos para que puedas programar de manera asíncrona con seguridad.\n¿Por qué existe? - El caso de la programación asíncrona # Imagínate un proceso de la vida real en el que tengas una conjunto de recursos limitados, que sean completamente necesarios para terminar el trabajo. Por ejemplo, imagina que quieres hacer una comida especial, en la que necesitas usar un horno. En el horno puedes poner un platillo a la vez, ya que requiere un tiempo y temperatura específica. Pero este platillo especial tal vez va acompañado de una sopa que puedes hacer mientras el platillo principal está en el horno.\nEn términos computacionales, estas dos tareas están sucediendo de manera concurrente, aunque tú literalmente no estés haciendo ambas cosas al mismo tiempo. No vale la pena que te sientes a esperar a que el lomo del horno esté listo para empezar a hacer la sopa. Puedes hacer la sopa mientras esperas, ya que no ocupan los mismos recursos.\nExactamente pasa lo mismo en los programas de computadora, se tienen que ejecutar tareas que usan recursos compartidos o lentos, como por ejemplo el sistema de archivos o la red. En la programación web también se da que el programa está esperando la respuesta de el usuario y mientras tanto puede seguir haciendo otras cosas. Aquí es donde entra la programación asíncrona.\n¿Qué es la programación asíncrona? # Para entenderla primero tenemos que entender la programación tradicional o síncrona (creo que la palabra correcta en español es sincrónica).\nEn la programación tradicional, las cosas siempre suceden en un orden estricto: una instrucción empieza y hasta que no se termina, no se ejecuta la siguiente. Observa el siguiente código, en Python, para a abrir un arhivo:\nwith open(\u0026#34;archivo.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: data = file.read() print(\u0026#34;Archivo leído\u0026#34;) print(\u0026#34;Log final\u0026#34;) El resultado de este código es:\nArchivo leído Log final En este código todo sucede de manera perfectamente secuencial.\nPero en lenguajes con programación asíncrona, esta operación que es tardada en términos computacionales se puede hacer de manera asíncrona, es decir fuera de orden.\nconst fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#34;archivo.txt\u0026#34;, \u0026#34;utf8\u0026#34;, (err, data) =\u0026gt; { console.log(\u0026#34;Archivo leído\u0026#34;); }); console.log(\u0026#34;Esperando a que se lea el archivo\u0026#34;); El resultado de este código es:\nEsperando a que se lea el archivo Archivo leído Observa cómo en esta versión, el código que está ANTES: console.log(\u0026quot;Archivo leído\u0026quot;), se ejecuta DESPUÉS. Esto es una demostración de código asíncrono.\nLa explicación a esto está en que con la programación asíncrona podemos modificar cuándo se ejecutan las cosas. Pero otra visión es que se pueden ejecutar cosas en diferentes \u0026ldquo;lados\u0026rdquo; o \u0026ldquo;momentos\u0026rdquo; y tú elegir cuándo usas los resultados de la ejecución.\nUsamos este ejemplo de abrir un archivo porque por su naturaleza es lento (comparado) con cálculos u operaciones comunes.\nLa programación asíncrona es un forma de ejecutar las acciones de tu programa en la que no se espera siempre que una acción o instrucción termine para continuar con el programa.\nComo vimos en el primer ejemplo, en la programación síncrona (también llamada bloqueante [blocking]), ninguna acción comienza hasta que le previa haya terminado. En la programación asíncrona, con técnicas o palabras reservadas específicas le indicamos al motor de ejecución que no es necesario a que una acción termine para continuar con la siguiente, pero también le podemos decir qué hacer cuando la acción termine. Por esto mismo, la programación asíncrona también se conoce como no bloqueante (non-blocking).\nPara qué sirve la programación asíncrona # Veamos las restricciones que tenemos, para entender por qué es útil. Cuando creas un sistema, la velocidad de ejecución puede verse limitada por dos categorías de cosas:\nDe los cálculos que estás haciendo De la información que estás obteniendo o guardando en algún lugar En el primer caso, llamamos a la ejecución CPU bound y en el segundo I/O bound. En español me gusta llamarle limitado por el procesador y limitado por la entrada y salida de datos.\nCPU bound - limitado por la cantidad de cálculos que puedes hacer # Cuando tu programa es pesado en los cálculos que tiene que hacer, como cuando tienes que procesar multimedia, hacer multiplicación de matrices o cosas similares, puedes decir que tu programa es CPU bound, o que está limitado por el poder de procesamiento. Es decir, mientras más poderoso sea el procesador, más rápido será tu programa. Esto también es cierto si tienes múltiples procesadores y puedes distribuir el cómputo entre ellos, por ejemplo:\nSi tienes un procesador con múltiples cores o múltiples hilos de ejecución físicos Si tienes múltiples computadoras en una red En el primer caso, necesitas una plataforma que te ayude a utilizar el poder de procesamiento de los múltiples cores, sea implícitamente o explícitamente. Por ejemplo plataformas como la máquina virtual de Erlang (llamada BEAM), automáticamente distribuyen la carga en los múltiples cores disponibles. En otros lenguajes como en Python, tienes que hacerlo explícitamente, pero incluso eso tiene limitaciones. Pero esto que te estoy diciendo es programación concurrente.\nLa programación asíncrona se puede ver como una herramienta para manejar la programación concurrente y hacerla más sencilla. Piénsala como en una capa de abstracción sobre la programación concurrente, que te permite expresar de forma explícita que otras partes del programa pueden estarse ejecutando en otro tiempo o en otro espacio (proceso o hilo).\nI/O bound - limitado por la velocidad de entrada y salida de datos # Cuando un programa consume o produce mucha información tiene que ponerla en algún lugar. Este lugar puede ser:\nLa memoria RAM El disco duro (o sistema de archivos) La red (mandarla o pedirla a otra computadora) Cuando tu programa hace mucho esto, se dice que el programa está limitado por la velocidad de entrada y salida de datos, o I/O bound.\nLa programación asíncrona te puede ayudar de manera más sencilla, sobre todo en el caso de las peticiones de red. ¿Cómo? Justo en el ejemplo que vimos antes de abrir un archivo: mientras esperas a que el disco duro lea el archivo y lo mande por el bus de datos y se cargue en la memoria RAM (que son AÑOS computacionalmente hablando), podemos seguir haciendo otras cosas. Igual que en el caso anterior, estos procesos son concurrentes, y una de las maneras más sencillas de expresarlo es con la programación asíncrona, en el que simplemente decimos que en algún momento podemos usar el resultado de la lectura del archivo.\nExactamente pasa lo mismo en el caso de las peticiones de red (que son EONES comparadas con la lectura de archivos o cálculos comunes). De hecho, el manejo de esas peticiones y de todo lo relacionado con entrada y salida de datos es uno de los secretos de por qué Node.js es tan bueno para manejar peticiones HTTP.\nConclusión # Entender la programación asíncrona es esencial en la programación moderna, muchos lenguajes y sobre todo entornos de ejecución lo implementan. Entenderla y usarla te ayudará a crear programas más eficientes y que cumplan con el rendimiento que tus usuario esperan. En un artículo futuro veremos una comparación entre programación asíncrona y programación concurrente manejada de otras maneras.\n","date":"31 octubre 2024","externalUrl":null,"permalink":"/2024/10/31/qu%C3%A9-es-la-programaci%C3%B3n-as%C3%ADncrona/","section":"Posts","summary":"\u003cp\u003eLa programación asíncrona es uno de los primeros temas avanzados que encontrarás\nal programar, especialmente si desarrollas aplicaciones web. Esto es aún más\ncomún si haces \u003cstrong\u003eJavaScript\u003c/strong\u003e, que es un lenguaje que se usa en entornos de\nejecución asíncronos.\u003c/p\u003e","title":"¿Qué es la programación asíncrona?","type":"posts"},{"content":"","date":"31 octubre 2024","externalUrl":null,"permalink":"/tags/async/await/","section":"Tags","summary":"","title":"Async/Await","type":"tags"},{"content":"","date":"31 octubre 2024","externalUrl":null,"permalink":"/tags/concurrencia/","section":"Tags","summary":"","title":"Concurrencia","type":"tags"},{"content":"","date":"31 octubre 2024","externalUrl":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript","type":"tags"},{"content":"Uno de los algoritmos más fáciles de entender, que incluso sin preparación aplicamos en la vida real y que se enseña en las primeras clases de programación es la búsqueda binaria. Vamos a hablar de este algoritmo y su relación profunda con las ciencias de la computación y la información en general.\nBúsqueda binaria en la vida real # ¿Alguna ves has jugado \u0026ldquo;Adivina Quién\u0026rdquo;? Es un juego de mesa en el que cada jugador tiene un tablero con un conjunto de personajes con características físicas distintas, como el color de pelo, diferentes accesorios, y otros rasgos distintivos. Cada jugador escoge secretamente un personaje y el otro lo tiene que adivinar, haciendo preguntas que le permitan ir eliminando a los personajes que el otro jugador no ha elegido. ¿Cuál es la mejor estrategia para adivinar con la menor cantidad de preguntas? Podrías pensar que es por cosas muy distintivas, por ejemplo, si hay dos personajes con sombrero, y preguntas si tiene sombrero, puede parecer una buena estrategia, pero no lo es.\nEn este caso, suponiendo que tenemos 40 personajes y solo dos tienen sombrero y suponiendo que tienes 40 personajes, sólo 5% de las veces te ayudará reducir significativamente el número de personajes, por lo que la mayoría de las veces será una pregunta extra si la haces inicialmente. Lo mejor es empezar por las características que dividan el conjunto de personajes en dos grupos más o menos iguales. Por ejemplo, si hay 40 personajes y 20 tienen el pelo largo y 20 el corto, la pregunta si el personaje tiene el pelo largo, te dejará con 20 personajes. La siguiente pregunta debería ser algo similar.\nEsto es exactamente lo que hace la búsqueda binaria, ir partiendo el conjunto de elementos en dos grupos más o menos iguales e ir eliminando la mitad en cada paso.\nBúsqueda binaria en la computación # El algoritmo de búsqueda binaria se aplica para encontrar un valor en una colección ordenada de elementos. Esto es para tener una forma sencilla de eliminar la mitad del espacio de búsqueda en cada paso. Y puedes pensar justamente que la necesidad de tener que ordenar los elementos es precisamente una de sus des\nImplementación en pseudocódigo # Aquí puedes ver una implementación de la búsqueda binaria en pseudocódigo:\nbúsqueda_binaria(arreglo, elemento_buscado): inicio = 0 fin = longitud(arreglo) - 1 mientras inicio \u0026lt;= fin: medio = (inicio + fin) // 2 # división entera si arreglo[medio] == elemento_buscado: retornar medio sino si arreglo[medio] \u0026lt; elemento_buscado: inicio = medio + 1 sino: fin = medio - 1 retornar -1 # Elemento no encontrado En pocas palabras, nombramos dos índices, inicio y fin, que van a ser los que nos dicen en qué parte vamos a buscar. Después, calculamos el centro de la lista, sumando el inicio y el fin y dividiendo entre dos. Otra forma de calcularlo sería restando el inicio y el fin, dividiendo entre dos y sumándole el inicio. Estas dos formas son equivalentes.\nAhora, comparamos el elemento buscado con el elemento en el centro. Si es igual, hemos encontrado el elemento y terminamos. Si es menor, tenemos que agarrar la parte de la lista que está a la derecha, es decir, los elementos mayores. Para esto, el inicio es un elemento a la derecha del medio (inicio = medio + 1) y el fin se queda igual. Si el elemento buscado es mayor, tenemos que agarrar la parte de lista que está a la izquierda, y ahora el que cambia es el fin.\nDe esta manera, en cada paso nuestro espacio de búsqueda se reduce a la mitad.\nSi llegamos a un punto en el que el inicio es mayor que el fin, entonces no encontramos el elemento y retornamos -1 (el -1 es una forma de que el programa nos diga que no encontramos el elemento, muy usada en programación).\nComplejidad # Con un arreglo pequeño pensarás que la búsqueda binaria es más lenta una búsqueda aleatoria o secuencial y así es, pero recuerda que los algoritmos eficientes se notan cuando el tamaño de los datos crece.\nAl ir cortando sucesivamente a la mitad el espacio de búsqueda, la complejidad de la búsqueda binaria crece en forma logarítmica.\nExpliquemos un poco eso. Un logaritmo es la función que nos ayuda a encontrar el exponente al que hay que elevar un número para obtener otro. En la búsqueda binaria, el número que queremos \u0026ldquo;obtener\u0026rdquo; (en verdad, es recorrer) es el número de elementos en el arreglo que vamos a buscar.\nSuponiendo que en cada paso hacemos más o menos 5 operaciones, por ejemplo, para buscar en un arreglo de 1000 elementos y tomando en cuenta lo que hemos visto de cómo se va reduciendo el espacio de búsqueda, tendríamos la siguiente sucesión:\nElementos por buscar: 1000\nOperaciones totales: 5\nElementos por buscar: 500\nOperaciones totales: 10\nElementos por buscar: 250\nOperaciones totales: 15\nElementos por buscar: 125\nOperaciones totales: 20\nElementos por buscar: 62\nOperaciones totales: 25\nElementos por buscar: 31\nOperaciones totales: 30\nElementos por buscar: 15\nOperaciones totales: 35\nElementos por buscar: 7\nOperaciones totales: 40\nElementos por buscar: 3\nOperaciones totales: 45\nElementos por buscar: 1\nOperaciones totales: 50\nObserva cómo es que el número de operaciones no creció al mismo ritmo que el número de elementos. El número de operaciones creció sumó sólo 5 operaciones cada que duplicamos el número de elementos. Aquí es donde está el logaritmo, como estamos duplicando o multiplicando por dos, la base de nuestro logaritmo es el 2. ¿Cuánto \u0026ldquo;pasos\u0026rdquo; vamos a tener que hacer? Cuantas veces tengamos que duplicar el número de elementos para llegar al número total de elementos del arreglo en el peor de los casos. Esto es el logaritmo base 2.\nAsí que la complejidad de la búsqueda binaria es $$O(\\log n)$$. Donde $$n$$ es el número de elementos en el arreglo.\nImplementaciones # Vamos a ver dos implementaciones en Python, una iterativa y otra recursiva.\nEmpezamos con la iterativa:\ndef binary_search(arreglo, elemento_buscado): inicio = 0 fin = len(arreglo) - 1 while inicio \u0026lt;= fin: medio = (inicio + fin) // 2 if arreglo[medio] == elemento_buscado: return medio elif arreglo[medio] \u0026lt; elemento_buscado: inicio = medio + 1 else: fin = medio - 1 return -1 Y la versión recursiva:\ndef binary_search(arreglo, elemento_buscado, inicio=0, fin=None): if fin is None: fin = len(arreglo) - 1 if inicio \u0026gt; fin: return -1 medio = (inicio + fin) // 2 if arreglo[medio] == elemento_buscado: return medio elif arreglo[medio] \u0026lt; elemento_buscado: return binary_search(arreglo, elemento_buscado, medio + 1, fin) else: return binary_search(arreglo, elemento_buscado, inicio, medio - 1) Debido a la sintaxis de Python, la versión recursiva es un poco más verbosa, por el manejo que tienes que hacer de los parámetros por defecto, pero si no fuera por eso, en general me gusta más la versión recursiva.\nFinalmente, si quieres hacer un programa que funcione con esta forma de búsqueda, tienes que asegurarte de que las inserciones en el arreglo sean ordenadas, una forma sencilla es usar un algoritmo parecido para encontrar el lugar adecuado para insertarlo.\nUso en el mundo real # Lo que vimos en la sección anterior es para que entiendas cómo funciona, pero lenguajes como Python, Ruby y otros, probablemente ya tengan implementaciones de este algoritmo muy común. Por ejemplo, en Python tenemos el módulo bisect que permite hacer lo mismo con muchas menos líneas. Ejemplo:\nimport bisect lista = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] elemento = 5 indice = bisect.bisect_left(lista, elemento) # en realidad nos dice el valor más pequeño que es mayor o igual al elemento buscado # si el índice es más grande que el número de elementos, no está en la lista if indice != len(lista) and lista[indice] == elemento: print(f\u0026#34;El elemento {elemento} está en el índice {indice}\u0026#34;) else: print(f\u0026#34;El elemento {elemento} no está en la lista\u0026#34;) Puedes ver más detalles del módulo bisect en la documentación oficial.\nConclusión # La búsqueda binaria es uno de los algoritmos que todos los desarrolladores deberíamos conocer. Espero que este artículo te haya ayudado a entender cómo funciona y su importancia.\n","date":"26 octubre 2024","externalUrl":null,"permalink":"/2024/10/26/qu%C3%A9-es-la-b%C3%BAsqueda-binaria/","section":"Posts","summary":"\u003cp\u003eUno de los algoritmos más fáciles de entender, que incluso sin preparación\naplicamos en la vida real y que se enseña en las primeras clases de programación\nes la \u003cstrong\u003ebúsqueda binaria\u003c/strong\u003e. Vamos a hablar de este algoritmo y su relación\nprofunda con las ciencias de la computación y la información en general.\u003c/p\u003e","title":"¿Qué es la búsqueda binaria?","type":"posts"},{"content":"","date":"26 octubre 2024","externalUrl":null,"permalink":"/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 octubre 2024","externalUrl":null,"permalink":"/tags/b%C3%BAsqueda/","section":"Tags","summary":"","title":"Búsqueda","type":"tags"},{"content":"Martin Kleppmann es un desarrollador de software, investigador y profesor muy prolífico. Hablemos de su trabajo, ideas y de por qué es alguien que podrías admirar.\nSu carrera # Martin ha desarrollado su carrera e investigación alrededor del software deTambién trabaja en seguridad de sistemas distribuidos, un tema relacionado al anterior, pero digamos que para temas de mayor escala.\nEs profesor en la Universidad de Cambridge, pero parece que nunca se ha separado de la industria, por ejemplo, como emprendedor, fundó Rapportive: una empresa que creó un plug-in que te permitía ver los detalles de tus contactos directamente en tu bandeja de entrada de email. Rapportive fue adquirida por LinkedIn por nada más y nada menos que por 15 millones de dólares.\nTambién ha participado en proyectos de código abierto, con los siguientes proyectos:\nAutomerge: una biblioteca para crear software local-first, que es principalmente un CRDT (Conflict-free Replicated Data Type), es decir, una estructura de datos que sirve para sincronizar información entre varios procesos que compartan esta misma estructura, de manera automática. Está disponible para JavaScript, Swift y Rust. Apache Avro: un formato de serialización de datos que compite con protocol buffers y JSON, usado principalmente en el campo de ciencia e ingeniería de datos. Apache Samza: es un framework para procesar flujos de datos de manera distribuida en tiempo real, que puede cooperar con Kafka y otros sistemas de procesamiento de datos. Kleppmann también es un gran contribuidor a la comunidad tanto con pláticas y artículos como con un libro que es por lo que más se le conoce: Designing Data-Intensive Applications.\nIdeas sobre el desarrollo de software # Martin es un gran proponente de los sistemas distribuidos en todas sus formas y de todos los aspectos realacionados con estos, desde los temas conceptuales hasta la implementación y la seguridad. Actualmente está trabajando con local-first software, que es aquel funciona principalmente en un entorno local, pero que puede aprovechar las ventajas de tener una conexión a una red para hacer diferentes operaciones, como sincronizar datos o colaborar en tiempo real.\nEn su libro Designing Data-Intensive Applications analiza las características de software que manejan grandes cantidades de datos, y que cumple con tres características arquitectónicas: disponibilidad, escalabilidad y mantenibilidad. Este libro ha sido muy influyente en la industria, sobre todo para aquellos que quieren mejorar sus habilidades de diseño de software relacionadas con sistemas de backend distribuidos y bases de datos.\nSi quieres aprender más acerca de todos los temas que hemos mencionado, que giran alrededor de sistemas distribuidos, manejo de grandes cantidades de datos, diseño de software y software local-first, te recomiendo ver la lista de reproducción de videos.\nCuriosidades # Muchas personas buenas en el campo de la computación son buenas en otras cosas o tienen múltiples intereses. Martin es un gran músico, compuso una ópera llamada \u0026ldquo;Die Türme des Februar\u0026rdquo;, que se estrenó en 2007.\nReferencias # Página personal de Martin Kleppmann Designing Data-Intensive Applications Twitter de Martin Kleppmann GitHub de Martin Kleppmann ","date":"20 octubre 2024","externalUrl":null,"permalink":"/2024/10/20/desarrolladores-que-deber%C3%ADas-admirar-martin-kleppmann/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003eMartin Kleppmann\u003c/strong\u003e es un desarrollador de software, investigador y profesor muy prolífico.\nHablemos de su trabajo, ideas y de por qué es alguien que podrías admirar.\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003eSu carrera\n    \u003cdiv id=\"su-carrera\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#su-carrera\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003eMartin ha desarrollado su carrera e investigación alrededor del software deTambién trabaja en seguridad de sistemas distribuidos, un tema relacionado al anterior,\npero digamos que para temas de mayor escala.\u003c/p\u003e","title":"Desarrolladores que deberías admirar: Martin Kleppmann","type":"posts"},{"content":"","date":"20 octubre 2024","externalUrl":null,"permalink":"/tags/martin-kleppmann/","section":"Tags","summary":"","title":"Martin-Kleppmann","type":"tags"},{"content":"","date":"20 octubre 2024","externalUrl":null,"permalink":"/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas-Distribuidos","type":"tags"},{"content":"","date":"20 octubre 2024","externalUrl":null,"permalink":"/tags/software-local-first/","section":"Tags","summary":"","title":"Software-Local-First","type":"tags"},{"content":"","date":"19 octubre 2024","externalUrl":null,"permalink":"/tags/arquitectura-de-software/","section":"Tags","summary":"","title":"Arquitectura-De-Software","type":"tags"},{"content":"","date":"19 octubre 2024","externalUrl":null,"permalink":"/tags/dise%C3%B1o-de-software/","section":"Tags","summary":"","title":"Diseño-De-Software","type":"tags"},{"content":"Hay una confusión enorme sobre el diseño de software. Cuando se habla de arquitectura, se empieza a hablar de patrones de diseño, infraestructura, y otras cosas con las que no nos conviene meternos en ese nivel.\nEs por eso que en este artículo vamos a proponer una taxonomía para los diferentes grados de diseño de software. Pero antes hablemos de por qué te conviene hacer una distinción clara.\nPor qué te conviene distinguir los grados de diseño de software # Lo primero que debemos entender es que hacer software implica diseñar software. Las raíces de la palabra diseñar son las mismas que las de la palabra designar: las dos cosas tienen que ver con decisiones.\nTeniendo esto presente, nos conviene ponerle atención al diseño desde el principio, para crear software que cumpla tanto con las funciones como con las características que se esperan de él.\nLos grados de abstracción en diseño de software # Hablemos de cada uno de los grados de abstracción en diseño de software.\nArquitectura de soluciones # El propósito del software es resolver problemas para un usuario. Tomando en cuenta el contexto completo, se define la arquitectura de la solución.\n","date":"19 octubre 2024","externalUrl":null,"permalink":"/2024/10/19/los-diferentes-grados-de-dise%C3%B1o-de-software/","section":"Posts","summary":"\u003cp\u003eHay una confusión enorme sobre el diseño de software. Cuando se habla de arquitectura, se empieza\na hablar de patrones de diseño, infraestructura, y otras cosas con las que no nos conviene\nmeternos en ese nivel.\u003c/p\u003e","title":"Los diferentes grados de diseño de software","type":"posts"},{"content":"Hay una confusión enorme sobre el diseño de software. Cuando se habla de arquitectura, se empieza a hablar de patrones de diseño, infraestructura, y otras cosas con las que no nos conviene meternos en ese nivel.\nEs por eso que en este artículo vamos a proponer una taxonomía para los diferentes grados de diseño de software. Pero antes hablemos de por qué te conviene hacer una distinción clara.\nTambién presentaremos una serie de recursos que puedes usar más para aprender de cada uno de estos niveles de abstracción en el diseño de software.\nPor qué te conviene distinguir los grados de diseño de software # Lo primero que debemos entender es que hacer software implica diseñar software. Las raíces de la palabra diseñar son las mismas que las de la palabra designar: las dos cosas tienen que ver con decisiones. Cuando diseñamos entendemos que estamos tomando decisiones y documentándolas por adelantado. Pero aunque ni las tomemos por adelantado, ni las documentemos, esas decisiones están ahí y por lo tanto el diseño existe.\nTeniendo esto presente, nos conviene ponerle atención al diseño desde el principio, para crear software que cumpla tanto con las funciones como con las características que se esperan de él.\n¿Ahora bien, por dónde empezamos a diseñar? Es aquí en donde entran los grados de abstracción en diseño: conocer el nivel que necesitamos nos ayudará a empezar en el lugar adecuado.\nLos grados de abstracción en diseño de software # Hablemos de cada uno de los grados de abstracción en diseño de software, qué es lo que se espera y cómo contribuya a la solución final.\nArquitectura de soluciones # El propósito del software o de cualquier sistema es resolver problemas para un usuario. Estos sistemas están dentro de un contexto completo que le da sentido a su existencia. Es en este nivel en donde se define la arquitectura de la solución.\nTomando en cuenta el contexto completo de dónde va a funcionar el software, la organización o los individuos que lo van a usar, el contexto social, económico e incluso político, se define la arquitectura de la solución, es decir, se toman en cuenta los componentes principales que van influir en que el software pueda cumplir con su propósito.\nEste nivel de diseño es el más alto relacionado con el software y requiere capacidad técnica, pero también amplias capacidades a nivel de negocio, administración y otros campos relacionados con el funcionamiento de las organizaciones.\nLo anterior implica que este nivel es poco específico en cuanto los detalles de la solución, pero tiene gran impacto tanto en el que software cumpla con lo que se espera de él, como con conseguir los recursos necesarios para su desarrollo. Además las decisiones que se toman aquí tienen un gran impacto en los negocios que solicitan el software.\n¿Qué tanto debe saber sobre construcción de software un arquitecto de soluciones? Como dijimos, este nivel requiere poca especificidad técnica, pero gran capacidad para combinar conocimientos de lo que es posible construir con el software, el contexto del negocio y proyección de los cambios que el entorno va a sufrir. Este es un rol más amplio que profundo.\nUn arquitecto de soluciones debe ser el traductor entre lo que el negocio necesita, tomando en cuenta el contexto amplio de este, y el tipo de software que se puede construir o adquirir.\nRecursos para aprender arquitectura de soluciones # En esta sección te presento algunos recursos que te pueden ayudar a aprender sobre este nivel de abstracción en el diseño de software, pero recuerda que nada sustituye la experiencia práctica:\nSolution Architecture Foundations. Este libro es una excelente introducción a la arquitectura de soluciones y tiene un enfoque práctico.\nAn Elegant Puzzle: Systems of Engineering Management. Está escrito por un ingeniero de software y líder de ingeniería en grandes empresas de software. Este libre es un conjunto de ensayos sobre la administración de equipos de ingeniería, pero también incluye valiosas lecciones sobre cómo guiar a una organización en la que su principal activo es el software.\nArquitectura de software # El siguiente nivel de abstracción es la arquitectura de software. Esta actividad es una de las más mal entendidas y por lo tanto mal ejecutadas a mi parecer. La arquitectura tiene que ver con las características que una pieza de software demuestra a nivel estructural, es decir, cualidades que surgen de la interacción de sus componentes.\nUn error muy común al intentar practicar la arquitectura de software es irse demasiado rápido a los detalles de implementación (si vamos a usar tal o cuál patrón de diseño, etc). Mi propuesta es que la arquitectura de software se practique en un nivel de abstracción más alto, es decir, más cerca de las necesidades del negocio.\nPor lo tanto, la principal actividad en este nivel es transformar las necesidades del negocio en características de software. A estas características las llamamos atributos de estructurales o de calidad. Pero la arquitectura de software también se encarga de lograr que el software haga las cosas que el negocio necesita.\nTambién toma en cuenta la estructura de la organización y su composición para definir la forma en que el software se va a desarrollar.\n¿Qué tanto debe saber sobre construcción de software un arquitecto de software? Un arquitecto de software, según la tradición medieval, es el constructor principal. Por lo tanto, debe tener una muy amplia experiencia técnica, conocer cómo funcionan la mayoría de los componentes principales comunes del software, pero también debe tener experiencia tratando con las necesidades del negocio.\nUn arquitecto es el principal traductor entre lo que el negocio necesita y cómo se puede construir o armar un sistema que cumpla con esas necesidades.\nRecursos para aprender arquitectura de software # En este apartado hay muchos recursos, los que yo te recomiendo son:\nSoftware Architecture in Practice, 4th Edition. Si tuviera la necesidad de elegir un solo libro para aprender arquitectura de software, este sería el que recomendaría. Analiza todos los aspectos fundamentales para construir una arquitectura de software sin centrarse en el conocimiento trivial del que muchos creen que se trata la arquitectura.\nFundamentals of Software Architecture. En este libro encontrarás todas las ideas fundamentales clásicas sobre arquitectura de software, y los términos que se usan para habla sobre estos temas.\nJust Enough Software Architecture: A Risk-Driven Approach. Aquí encontrarás un enfoque diferente para la arquitectura de software: el enfocado en los riesgos. Este libro te ayudará a encontrar el equilibrio al tomar decisiones en tu arquitectura.\nDiseño de sistemas # Una vez que sabemos qué características y funciones debe tener el software y cómo las vamos a lograr debemos de ponerle nombre y detalles a cada pieza de software. De esto se encarga el diseño de sistemas.\nEste, para mi, es el nivel más clásico y conocido en el diseño de software y el que más le emociona a la mayoría de los desarrolladores. Es aquí donde dices que vas usar tal o cuál base de datos específica, si vas a usar réplicas de lectura, cómo vas a manejar a un millón de usuarios concurrentes, e incluso detalles de bajo nivel como el almacenamiento de datos y el tipo de infraestructura que vas a usar.\nTambién es aquí donde muchas de las entrevistas de trabajo se centran cuando se quiere poner a prueba la capacidad técnica de un desarrollador puro, ya que es un paso intermedio entre la arquitectura, que tiene que ver mucho con el negocio, y la programación, que es todo lo que haría un desarrollador que a penas está empezando.\nDemostrar habilidad en este nivel es un proxy para entender qué tanto has desarrollado software, pero tristemente, al igual que todas las medidas que se convierten en el objetivo, ha perdido gran parte de su capacidad evaluadora ya que se puede simular fácilmente (estudiando los problemas clásicos de entrevistas).\n¿Vale la pena estudiarlo aisladamente? Sí, pero es no es suficiente. Este nivel no se trata de seguir recetas de diseño de sistemas, aunque se pueda entender así, sino de conocer cómo se implementan las soluciones arquitectónicas ahora con los detalles de implementación. Así que su verdadero valor viene de la experiencia desarrollando software.\nCreo que esta pregunta ya es obvia, pero demos una respuesta explícita al igual que en las otras secciones: ¿Qué tanto debe saber sobre construcción de software un diseñador de sistemas? Mucho, y mientras más experiencia real tenga, mejor.\nUn diseñador de software lleva la visión arquitectónica dibujada en papel a su forma final, lista para ser implementada.\nRecursos para aprender diseño de sistemas # El área de diseño de sistemas es muy amplia y recomiendo mucho estudiarla por partes. Primero, puedes empezar por los problemas clásicos, usando uno de los libros que te prepara para entrevistas como referencia, pero después tienes que profundizar:\nAcing the System Design Interview. Este libro te prepara para las entrevistas de trabajo, tocando todos los temas fundamentales de diseño de sistemas.\nSystem Design Interview – An Insider’s Guide. Otro libro que te prepara para la entrevista de diseño, pero es un poco más informal que el anterior. Tiene una segunda parte que puedes encotrar aquí: System Design Interview - An Insider\u0026rsquo;s Guide: Volume 2.\nAhora sí, podemos empezar a profundizar:\nDesigning Data-Intensive Applications. Este trata sobre el diseño de sistemas de alta disponibilidad, escalabilidad y mantenibilidad y que tratan con muchos datos. Analiza cómo se usan los sistemas que manejan datos para lograrlos y se va a un poco más abajo para que veas cómo están construidos, así que también te prepara para el nivel de abajo.\nBuilding Microservices. Una de las formas más comunes de diseñar sistemas a grana escala es usando microservicios. Aunque no siempre los vayas a usar, entender los patrones fundamentales y los problemas que resuelven te ayudará a implementar esos principios en otros contextos.\nFoundations of Scalable Systems. La escalabilidad es un tema clave en el diseño de sistemas, entender los medios para lograrla te ayudará a ser un mejor diseñador.\nDiseño de código # Para mi, el siguiente nivel tiene que ver con la implementación de los diseños. La pregunta en este nivel es: ¿Cómo cumplo con las características y funcione que se esperan de esta pieza de software?\nYa dijimos que el software siempre tiene que ver con decisiones, de hecho podríamos decir que una base de código es un conjunto de decisiones registradas en un lenguaje de programación. Un programador que quiere cumplir con las funciones y características que se esperan de sus programas hace bien en tomar decisiones por adelantado y en adoptar un conjunto de prácticas que le ayuden a cumplir con lo que casi siempre se espera de esos sistemas de software.\nEn esta parte es donde se aplican los patrones de diseño, los principios de división modular y de separación modular, donde se eligen nombres y donde se escoge el mejor algoritmo para resolver un problema específico. El comportamiento alto nivel de los sistemas depende completamente de las decisiones que se tomen a esta nivel y que se cumpla con lo que se espera de cada uno de los componentes.\nAquí es donde se elige si se usa un bubble sort, un merge sort o un quicksort para ordenar una lista, si se usa la cierto módulo de terceros para una funcionalidad o si mejor lo implementamos.\nLa pregunta de las otras secciones no aplica aquí, este nivel es el más técnico y en el que se está poniendo en práctica todo lo que sabemos de construcción de software.\nUn programador, usa el diseño para lograr que cada pieza de software cumpla con lo que se espera de ella.\nRecursos para aprender diseño de código # En este nivel vamos a encontrar muchos recursos, pero muchos de ellos se contradicen entre sí, por lo que creo que es fundamental escoger una escuela de pensamiento y seguirla, pero también echarle un vistazo a las otras y contrastar los puntos de vista, para que generes tu propio estilo.\nA continuación recomiendo mis libros favoritos en este nivel:\nA Philosophy of Software Design. Este es mi libro favorito respecto a diseño de código porque creo que viene de alguien con experiencia y errores reales. Contradice muchos consejos encontrados en \u0026ldquo;Clean Code\u0026rdquo;, que es el libro más admirado en este aspecto, pero que creo que ha envejecido muy mal.\nModern Software Engineering. Te presenta las prácticas más modernas para desarrollar software, igual, escrito por un ingeniero de software con mucha experiencia.\nEn este artículo te recomiendo otros libros que te pueden ayudar a mejorar tu diseño de código.\nConclusión # En cada nivel de diseño requerimos diferentes tipos de conocimiento y habilidades. Estas cuatro niveles no son necesariamente niveles secuenciales de desarrollo de carrera. Es decir, un muy buen programador no tiene por qué aprender a diseñar a nivel de sistemas, por ejemplo, podría dedicarse a cada vez diseñar mejor componentes individuales o incluso algoritmos específicos. Por ejemplo, los desarrolladores de drivers o contribuidores individuales en equipos gigantes que se dedican una parte del sistema.\nTambién, si estás implementando software con un objetivo ya definido, es poco probable que necesites aprender sobre arquitectura de soluciones o arquitectura de software a muy alto nivel, ese aprendizaje sólo te distraerá del conocimiento que realmente necesitas para resolver el problema.\nY también funciona en la otra dirección. Conocer los detalles de implementación de cierto algoritmo no te hará un mejor arquitecto de software o de soluciones.\nAsí que ya sabes, ningún conocimiento es mejor que otro aunque puede que algunos piensen que así sea, cada uno tiene su lugar y su propósito.\n","date":"19 octubre 2024","externalUrl":null,"permalink":"/2024/10/19/los-diferentes-grados-de-dise%C3%B1o-de-software/","section":"Posts","summary":"\u003cp\u003eHay una confusión enorme sobre el diseño de software. Cuando se habla de arquitectura, se empieza\na hablar de patrones de diseño, infraestructura, y otras cosas con las que no nos conviene\nmeternos en ese nivel.\u003c/p\u003e","title":"Los diferentes grados de diseño de software","type":"posts"},{"content":"Un intérprete es un programa que lee código fuente y se encarga de ejecutarlo. En este artículo vamos a hablar de sus etapas y las principales tareas que realiza, para darte la idea de cómo funciona y si lo deseas, puedas tener idea de cómo hacerlo tu mismo.\nEmpecemos por hablar de la diferencia con un compilador.\nIntérprete vs compilador # Ambos tipos de programas tienen la característica de recibir código fuente, pero la diferencia está en lo que devuelven, y por lo tanto en las etapas que les permiten lograrlo.\nUn compilador traduce el código fuente a otro lenguaje, normalmente a un lenguaje máquina que puede ser ejecutado por un procesador de una arquitectura específica. Pero esto no es necesariamente así, ya que la principal tarea del\ncompilador es traducir. Un ejemplo es el compilador de Java: no compila al lenguaje de una arquitectura de procesador específica, sino a bytecode que puede ser ejecutado por la JVM. Si no sabes que es el bytecode, hablamos de él en este artículo.\nLos compiladores tradicionales compilan el código fuente a código máquina, es decir, a las instrucciones que un procesador puede ejecutar directamente. Así, si quieres ejecutar un programa de C o de C++ en un procesador con arquitectura x86, necesitas un compilador traduzca para las instrucciones de esta arquitectura. Si después requieres ese mismo programa para ARM, necesitas compilar de nuevo.\nUn intérprete también recibe el código fuente, pero en lugar de devolver la traducción en otro lenguaje, ejecuta el código fuente directamente. A veces este proceso tiene como producto secundario la traducción del código fuente en un lenguaje intermedio, pero su objetivo principal es la ejecución.\nAhora sí hablemos de las etapas de un intérprete.\nLas etapas de un intérprete # Para ejecutar el código de un programa, podemos dividir el trabajo en varios pasos. Para entenderlo pongamos un ejemplo. Supongamos que alguien te pide que hagas una tarea, por ejemplo, un trabajo escolar. Si tú fueras el intérprete, tendrías que hacer más o menos los siguientes pasos:\nLeer las instrucciones de la tarea. Entender claramente y sin ambigüedades lo que se te pide. Crear un plan para ejecutar la tarea. Ejecutar uno a uno los pasos del plan. Esos son los pasos que un intérprete hace para ejecutar un programa.\nTokenización: Leer el código en fuente y transformarlo en una forma que pueda entender. Parsing: Convertir el código fuente en una estructura de datos que pueda ser ejecutada. En nuestro plan esto serían los pasos 2 y 3. Ejecución: Ejecutar uno a uno los pasos del plan para lograr el resultado. Parsing o Parseo - Análisis léxico y sintáctico # A veces a la etapa completa de leer el código fuente y convertirlo en una estructura de datos que pueda ser ejecutada se le llama Parsing.\n¿Cómo puede un programa informático leer un programa y entenderlo? Lo hace de forma limitada, claro, pero lo suficiente para poder ejecutar el código. Un lenguaje de programación es un lenguaje creado a partir de un alfabeto (un conjunto de símbolos), que a su vez forman palabras y estas palabras forman sentencias. Un programa, por lo tanto, es una secuencia de sentencias.\nPara que un intérprete \u0026ldquo;entienda\u0026rdquo; un programa, la primera etapa consiste en convertir el código fuente (un conjunto de símbolos), en una secuencia de palabras conocidas por el intérprete. Esto es un tipo de clasificación de las palabras. A la representación interna de estas palabras en el intérprete se le llama tokens. Debido a que en un lenguaje es muy importante el orden de las palabras, esta clasificación debe mantener el orden de las palabras. Como te imaginarás, este proceso es al que se le llama tokenización.\nDespués de tener la lista de palabras conocidas, necesitamos \u0026ldquo;entenderlas\u0026rdquo;. Como un lenguaje tiene una estructura, esta estructura.\nDespués, este conjunto de tokens es convertido en una estructura de datos llamada el Árbol de Sintaxis Abstracta o AST (Abstract Syntax Tree). Este proceso se llama parsing, que en inglés significa \u0026ldquo;analizar\u0026rdquo;.\nConstrucción del AST # Ya con la lista ordenada de tokens que representan el programa, tenemos que construir la estructura de datos que representa las operaciones que vamos a ejecutar, el AST.\nEsta estructura se parece a un árbol, con cada nodo representando una operación que a su vez puede estar compuesta de más operaciones, es una estructura recursiva. Por ejemplo, si tenemos un programa muy sencillo como a = 1 + 2, el AST podría verse así:\n{: .align-center}\nEn el esquema anterior puedes ver lo que más o menos es un árbol de sintaxis abstracta: una estructura que nos va ayudar a ejecutar el programa. Para mi, este es el centro tanto de un compilador como de un intérprete, si tienes bien definido este árbol (y por lo tanto todas las operaciones que son posibles de representar en él), tienes hecho la mitad del trabajo, tanto para compilar a otro lenguaje como para ejecutar directamente el trabajo.\nPasemos a la siguiente etapa.\nEjecución # Lo que sigue es lo más sencillo de entender (pero tal vez no de implementar): la ejecución del programa. El intérprete debe tener la capacidad de actuar sobre el sistema operativo para ejecutar las operaciones representadas en el AST. Si el intérprete corre en alguna otra cosa que no sea directamente el sistema operativo, por ejemplo en una máquina virtual, u otro programa, las acciones son diferentes, pero la idea es la misma: debe tener la capacidad de actuar sobre el programa en el que corra.\nOpcional: optimización # Varios de los intérpretes modernos tienen que se usan en entornos de producción, tienen una etapa que no es absolutamente necesaria, pero que da una ventaja significativa en el rendimiento y uso común: la optimización del la ejecución.\nEstas optimizaciones pueden darse desde mejoras en el AST hasta la generación de código específico para la arquitectura del procesador en el que se ejecute el programa y ejecutarlo inmediatamente. Hablamos de esta última técnica.\nCompilación Just In Time (JIT) # Una forma de optimización usada por los intérpretes y máquinas virtuales es lo que se conoce como Just In Time Compilation. La idea es sencilla:\nSe ejecuta el código fuente original mientras se observa el comportamiento de este programa con un perfilador (o profiler). Una vez que el perfilador detecta cosas que se pueden optimizar, un compilador especializado en la arquitectura del procesador en el que el intérprete está corriendo genera código máquina específico para es arquitectura de las partes que se pueden optimizar. El código máquina optimizado se ejecuta mientras se sigue observando el comportamiento del programa. Si el programa no se comporta de la forma esperada, esta parte de la ejecución se cancela y se vuelve a ejecutar el código fuente original. Tenemos un artículo completo sobre JIT en este enlace.\nConclusión # Ahora entiendes mejor cómo funcionan los intérpretes de manera general. Este conocimiento te puede ayudar cuando trabajes con ellos y probablemente tengas algún problema directamente relacionado con su funcionamiento interno.\nTambién tienes el conocimiento básico para avanzar a aprender cómo hacer el tuyo en caso de que lo necesites. En un artículo futuro hablaré sobre cómo hacer un intérprete de un lenguaje de programación sencillo, para entender todavía mejor el funcionamiento.\n","date":"28 septiembre 2024","externalUrl":null,"permalink":"/2024/09/28/c%C3%B3mo-funciona-un-int%C3%A9rprete/","section":"Posts","summary":"\u003cp\u003eUn intérprete es un programa que lee código fuente y se encarga de\nejecutarlo. En este artículo vamos a hablar de sus etapas y las principales\ntareas que realiza, para darte la idea de cómo funciona y si lo deseas, puedas\ntener idea de cómo hacerlo tu mismo.\u003c/p\u003e","title":"¿Cómo funciona un intérprete?","type":"posts"},{"content":"","date":"28 septiembre 2024","externalUrl":null,"permalink":"/tags/compiladores/","section":"Tags","summary":"","title":"Compiladores","type":"tags"},{"content":"","date":"28 septiembre 2024","externalUrl":null,"permalink":"/tags/int%C3%A9rprete/","section":"Tags","summary":"","title":"Intérprete","type":"tags"},{"content":"","date":"28 septiembre 2024","externalUrl":null,"permalink":"/tags/lenguajes-de-programaci%C3%B3n/","section":"Tags","summary":"","title":"Lenguajes-De-Programación","type":"tags"},{"content":"TensorFlow es una de las herramientas más populares e influyentes en el campo de la del aprendizaje automático. En este artículo vamos a ver qué es exactamente y cómo funciona.\n¿Qué es TensorFlow? # Siempre que hablamos de TensorFlow se dice que es una \u0026ldquo;biblioteca (o librería) para hacer aprendizaje automático, pero este definición no es muy explícita y por eso vamos a ver cómo nos permite crear modelos de aprendizaje.\nPara crear modelos de aprendizaje automático, tenemos que hacer muchos cálculos matemáticos, la gran mayoría son operaciones de multiplicación de matrices. Estos cálculos no son eficientes en un procesador tradicional y por eso se requiere de toda la ayuda que se pueda conseguir para hacerlos lo más rápido posible y gastando menos energía.\nEs aquí donde entra TensorFlow, una biblioteca que permite representar estos cálculos mediante grafos de cómputo y después ejecutarlos en procesadores especializados como tarjetas gráficas y otros procesadores eficientes en operaciones matemáticas pesadas. Además, TensorFlow abstrae al usuario final (tú), de los detalles de implementación de muchas funciones y operaciones matemáticas que se usan mucho en el aprendizaje automático. Y finalmente, con su API de alto nivel, Keras, te permite crear diferentes tipos de redes neuronales sin que tengas que pelearte con los detalles de implementación.\nY es aquí donde empieza lo interesante. ¿Qué es un grafo de cómputo? ¿Cómo llegamos a él y para qué nos sirve? Veamos.\nGrafos de cómputo de TensorFlow # Para entenderlo, vamos a ver un ejemplo sencillo de un cálculo y su representación, por ejemplo, sumemos dos números, que llamaremos X y Y.\n¿Cómo representa TensorFlow esto? Este es el grafo de cómputo que podemos ver con una herramienta de análisis de TensorFlow llamada TensorBoard:\n{: .align-center}\nPuedes pensar en este grafo como una serie de nodos que representan cada uno una operación sobre conjuntos de datos numéricos llamados tensores. Cuando ejecutamos este grafo, los tensores fluyen por estos nodos, transformándose en cada uno, hasta que obtenemos el resultado final de la operación. (Los nodos que dicen Identity son operaciones de copia o lectura de valores, útiles para el funcionamiento interno de TensorFlow).\nLa otra cosa que podemos notar hasta abajo de la gráfica son los dos nodos que representan nuestros números simples: X scalar y Y scalar, ya que los definimos como números simples, que también pueden pensarse como tensores de una dimensión.\nFormalmente, TensorFlow te da una serie de estructuras de datos, que puedes ir construyendo poco a poco para definir todas las operaciones que necesites hacer.\nEn una red neuronal, estos grafos son mucho más complicados, pero justo ese es el trabajo de TensorFlow: ayudarte a definirlos y a ejecutarlos en el hardware más conveniente para tu proyecto.\nUsar los grafos de cómputo de TF te permite varias cosas más:\nOptimización de las operaciones: TensorFlow tiene todo un sistema de optimización llamado Grappler, que se encarga varias optimizaciones. Paralelización. Con las operaciones divididas, TensorFlow puede verificar qué operaciones son independientes y puede ejecutarlas en otros procesadores si están disponibles. Exportación. Una vez teniendo las operaciones definidas en un grafo, no necesitamos de Python para ejecutarlas, así que TensorFlow puede ejecutarlas en otros dispositivos y usando otros lenguajes. Esta definición de grafos de cómputo no es la única forma de trabajar con TensorFlow, ya que desde su versión 2.0, también permite trabajar con un modo más imperativo, que se siente más integrado con Python y más dinámico: la ejecución adelantada (en inglés: eager execution). Con esta forma de ejecución, las operaciones se van ejecutando inmediatamente después de definirlas. Esto es más fácil de programar y de leer, pero deja poco espacio para la optimización. Es justamente como la comparación entre un lenguaje compilado y uno interpretado.\nTensorFlow y Keras # Keras era otra biblioteca que se creó por separado, para hacer más fácil de usar la versión 1.0 de TensorFlow, que era bastante más verbosa de programar (por sólo soportar grafos de cómputo estáticos).Sin embargo, en la versión 2.0 de TensorFlow, Keras se volvió parte del paquete.\nKeras te permite crear modelos de aprendizaje profundo de manera sencilla. Es la manera fácil de usar TensorFlow, pero también te permite complicarte tanto como quieras o necesites (esperamos que sea esto último). Keras usa el principio de \u0026ldquo;revelación progresiva de la complejidad\u0026rdquo;, lo que significa que puedes empezar de manera muy sencilla e ir aprendiendo cosas conforme vayas avanzando en hacer cosas más complejas.\nAsí que la forma más común de usar TensorFlow para crear tus modelos de machine learning es mediante la interfaz de Keras, que además de todo te provee de utilidades que son de uso muy común en las redes neuronales. Por ejemplo, provee regularizadores, inicializadores, funciones de activación, optimizadores, y muchas utilidades más. Es por eso que ya casi no se concibe el uso de TensorFlow para casos comunes sin usar Keras.\nTensorFlow y MLIR # MLIR es una herramienta para crear compiladores hecha por parte del mismo equipo que hizo LLVM, la infraestructura para compiladores que está detrás de la mayoría de los compiladores modernos.\nLa especialidad de MLIR es hacer traducciones para arquitecturas de hardware no tradicionales,usando un lenguaje intermedio multi-capa al que le puedes agregar más plugins para diferentes arquitecturas de ejecutores. MLIR es muy usado para computación de alto rendimiento, justamente la que necesitamos para crear modelo de aprendizaje automático complejos en tiempos y con costos razonables.\nAsí que TensorFlow, aprovechando este sistema, usa MLIR para compilar los grafos de cómputo y los modelos para hardware específico, para que se pueda obtener el mejor rendimiento posible.\nTensorFlow y su relación con el hardware # Después de la sección anterior, es muy probable que la relación de TF con el hardware quede muy clara: TensorFlow ayuda a que se pueda compilar de mejor manera el código con los cálculos para poder ejecutarlo en el hardware especializado.\nIF soporta gran variedad de tipos de hardware y es por eso que hasta el momento es la biblioteca de machine learning con mejor soporte para distribuir tus modelos en diferentes dispositivos, desde procesadores especializados hasta que corran directamente en tu teléfono o navegador.\nConclusión # Si quieres hacer machine learning, lo más probable es que tengas que aprender TensorFlow, una herramienta muy útil para hacer los modelos usados hoy.\nEspero que lo que hablamos sobre TensorFlow en este artículo te haya ayudado a entenderlo un poco más. En otro artículo hablaremos de su competidor más directo: PyTorch.\n","date":"16 septiembre 2024","externalUrl":null,"permalink":"/2024/09/16/c%C3%B3mo-funciona-tensorflow/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003eTensorFlow\u003c/strong\u003e es una de las herramientas más populares e influyentes\nen el campo de la del aprendizaje automático. En este artículo vamos a ver\nqué es exactamente y cómo funciona.\u003c/p\u003e","title":"¿Cómo funciona TensorFlow?","type":"posts"},{"content":"","date":"16 septiembre 2024","externalUrl":null,"permalink":"/tags/ai/","section":"Tags","summary":"","title":"AI","type":"tags"},{"content":"","date":"16 septiembre 2024","externalUrl":null,"permalink":"/tags/tensorflow/","section":"Tags","summary":"","title":"Tensorflow","type":"tags"},{"content":"","date":"30 agosto 2024","externalUrl":null,"permalink":"/tags/dato/","section":"Tags","summary":"","title":"Dato","type":"tags"},{"content":"","date":"30 agosto 2024","externalUrl":null,"permalink":"/tags/matin-kleppmann/","section":"Tags","summary":"","title":"Matin-Kleppmann","type":"tags"},{"content":"Uno de los libros más recomendados para todos los desarrolladores modernos es \u0026ldquo;Designing Data-intensive Applications\u0026rdquo; de Martin Kleppmann. En este artículo corto vamos a hablar de por qué vale la pena leerlo.\n¿Quién es Martin Kleppmann? # Martin es un desarrollador, investigador, escritor y profesor de ciencias de la computación bastante prolífico. Actualmente trabaja en la Universidad de Cambridge y ha trabajado en empresas como Rapportive(que él fundó y fue comprada por LinkedIn, y también trabajó ahí).\nEs también al autor de Secret Colors. Un libro de criptografía de llave pública y llave privada para niños, de la editorial Round Robin.\nKleppmann es un experto en todo lo que tiene que ver con estructuras y manejo de datos. En el presente (2024), su interés está en la coordinación de datos entre sistemas locales, es decir, el software funciona principalmente en un dispositivo que puede estar o no conectado a una red y después puede sincronizarse con otros sistemas remotos, para adquirir más funciones como respaldos o sincronización.\nPero su trabajo más notable hasta el momento es Designing Data-intensive Applications (DDiA a partir de ahora). Veamos por qué.\n¿De qué trata Designing Data-intensive Applications? # Podemos resumir DDiA como un libro de diseño de software enfocado en los datos y sus interacciones. Es un libro de diseño en el sentido amplio: abarca desde la arquitectura de software, hasta la elección de algoritmos para lograr las características arquitectónicas deseadas.\nEl libro tiene tres grandes partes:\nEn la primera habla de los principios fundamentales de los sistemas que hacen uso intensivo de datos. Habla de las características arquitectónicas que los sistemas intensivos es datos deben tener para ser usables. También se sientan las formas básicas de almacenar y representar datos a diferentes niveles.\nEn la segunda parte, se habla de sistemas distribuidos y sus implicaciones y las dificultades que conllevan. Aquí se tratan temas como replicación, particiones y transacciones. También se tratan los temas fundamentales para tener datos confiables: consistencia y consenso.\nAquí se habla de sistemas que derivan datos de otros datos, como índices, caches y cosas similares, como puedes notar, elementos que son fundamentales en cualquier sistema de software serio moderno.\nSe habla de todo lo necesario para aprender el manejo de grandes cantidades de datos, desde las formas de modelarlos y almacenarlos, hasta distribuirlos y procesarlos para crear subproductos útiles.\nEl estilo del libro # DDiA tiene un estilo bastante relajado, nada acercado a la academia, más bien, es amigable y fácil de leer. Además tiene un poco de humor sutil que hará el libro todavía más disfrutable.\nPara complementar, el libro tiene imágenes, algunas dibujadas a mano que te ayudan a ubicarte en el gran esquema de todas las ideas que trata.\nAsí que si te preocupa que sea un libro denso, para nada lo es.\nQué beneficios obtendrás al leerlo # Si eres un desarrollador de software con experiencia, especialmente en el backend, podrás profundizar tu experiencia en el entendimiento de la forma en la que se tratan los datos para crear sistemas confiables, escalables y mantenibles. Toma en cuenta que este libro, como su nombre lo dice está enfocado en el diseño. Este libro te dará ideas prácticas para aplicarlas a tus proyectos.\nSi estás en cualquier otra área del desarrollo de software, este libro te ayudará a entender mejor cómo funciona la capa de almacenamiento de datos en cualquier sistema y puede ayudarte a hacerlo mejor en tu área, porque en todas las capas y áreas del desarrollo necesitamos tratar con datos, a veces poco, a veces mucho.\nConclusiones # Si quieres leer un libro sobre diseño de software, no puedes fallar con Designing Data-intensive Applications. Vale mucho más la pena que otros libros de diseño de software por su profundidad y practicidad, además de que te va a dar de qué platicar con otros desarrolladores de software que pueden estar en el mismo camino de desarrollo profesional que tú.\n","date":"30 agosto 2024","externalUrl":null,"permalink":"/2024/08/30/por-qu%C3%A9-debes-leer-designing-data-intensive-applications/","section":"Posts","summary":"\u003cp\u003eUno de los libros más recomendados para todos los desarrolladores modernos\nes \u0026ldquo;Designing Data-intensive Applications\u0026rdquo; de \u003ca\n  href=\"https://martin.kleppmann.com/\"\n    target=\"_blank\"\n  \u003eMartin Kleppmann\u003c/a\u003e.\nEn este artículo corto vamos a hablar de por qué vale la pena leerlo.\u003c/p\u003e","title":"Por qué debes leer Designing Data-intensive Applications","type":"posts"},{"content":"Git es una herramienta que se considera obligatoria para los desarrolladores modernos por ser el programa usado para versionamiento de código usado por la mayoría de los proyectos.\nPero no es ningún secreto que Git es una herramienta difícil de comprender y que el 90% de los desarrolladores le dan el uso más básico, temiendo romper algo y por eso tener que usar comandos más avanzados.\nHablemos de por qué es así y después veamos algunas alternativas interesantes.\nLos orígenes de Git # Al igual que otros sistemas de control de versiones, Git nació como soporte al desarrollo de uno de los proyectos de software más importantes de todos los tiempos: el kernel de Linux. Fue creado por Linus Torvalds.\nSu objetivo no era ser una herramienta de uso masivo y fácil de usar, sino trabajar sin las limitantes de las herramientas que existían en ese momento. Y claramente, Linus lo creó a su manera. Algo interesante es que se llama \u0026ldquo;Git\u0026rdquo; porque en inglés británico es una palabra despectiva que se usa para llamar a alguien tonto o desagradable. Linus nombra sus proyectos como a sí mismo, y como cualquiera lo podría llamar así a él, decidió ponerle ese nombre a su sistema de manejo de versiones.\nGit empezó a ser usado por la comunidad de Linux en 2005 y después por otros proyectos Open Source, pero su éxito se disparó cuando en 2008 surgió GitHub que facilitó su uso. Por ser una herramienta tan útil, ahora la tenemos como el estándar en versionmiento de código.\nPero no es el único sistema de control de versiones moderno, hablemos de dos alternativas.\nFossil # Fossil fue creado por el autor de SQLite, Richard Hipp, y al igual que Git,nació para soportar a este proyecto de software libre, el principal de su Hipp.\nAl buscar un sistema de control de versiones moderno, Richard no encontró nada que lo convenciera al cien por ciento, por lo que decidió crear Fossil, con las siguientes características:\nIntegración de Wiki y Tickets: Fossil tiene incluye estas herramientas a las que Hipp y su equipo estaban acostumbrados. Foro y chat: Fossil está pensado para también ser el centro de conversación del proyecto. Autosync: permite que los cambios se sincronicen automáticamente sin tener que andar haciendo magia con las ramas y los commits. Personalmente, me gusta mucho la idea de tener todo integrado en un mismo sistema, y pienso que el que sistemas como Jira y Confluence se integren directamente con GitHub, Bitbucket y cosas similares, es una señal de que esta integración es un muy buena idea que ayuda a que el proceso de software sea más fluido.\nPuedes encontrar más información en fossil-scm.org, para instalarlo por tu cuenta. Pero también existe una versión hosteada en la que de manera gratuita podrás tener el servicio de Fossil, equivalente a GitHub: Chisel.\nPijul # Pijul es un sistema de control de versiones pensado para ser lo más fácil de usar. Tiene un fundamento matemático: la teoría de parches (patch theory), lo cuál te da garantías interesantes, como la facilidad de uso y la reducción de errores catastróficos. Combina las dos formas principales en las que se han creado sistemas control de versiones: los sistemas basados en spapshots (como la mayoría de los sistemas de control de versiones más conocidos, incluido Git) y los sistemas basados en parches (como Darcs, un SVC poco conocido pero más fácil de usar).\nLos sistemas basados en snapshots son más rápidos pero más frágiles y difíciles de usar y los basado en parches son lentos. Es por eso que Pijul cobina lo mejor de ambos tipos de sistemas y mientras se mantiene lo suficientemente rápido sigue siendo fácil de usar incluso en situaciones en las que Git se vuelve complejo, como en merges, conflictos y cherry-picks. En un post posterior hablaremos ge Pijul.\nPuedes encontrarlo en pijul.org, te recomiendo que si quieres probar algo fundamentalmente diferente a Git, pero con las mismas funciones externas, le des una oportunidad.\nConclusión # No vamos a reemplazar a Git en el corto plazo y probablmente nunca lo hagamos por lo extendido que está su uso (piensa en el efecto Lindsey), pero es bueno saber que existen alternativas. Estas herramientas nos enseñan cosas interesantes sobre el desarrollo de software, como que casi siempre hay más de una forma de lograr lo que queremos. Ojalá que en el futuro, Git tome algunas de las ideas de estos proyectos y mejore su experiencia de usuario.\n","date":"19 julio 2024","externalUrl":null,"permalink":"/2024/07/19/alternativas-a-git/","section":"Posts","summary":"\u003cp\u003eGit es una herramienta que se considera \u003cem\u003eobligatoria\u003c/em\u003e para los desarrolladores\nmodernos por ser el programa usado para versionamiento de código usado por\nla mayoría de los proyectos.\u003c/p\u003e\n\u003cp\u003ePero no es ningún secreto que Git es una herramienta difícil de comprender y\nque el 90% de los desarrolladores le dan \u003cstrong\u003eel uso más básico\u003c/strong\u003e, temiendo romper algo\ny por eso tener que usar comandos más avanzados.\u003c/p\u003e","title":"Alternativas a Git","type":"posts"},{"content":"","date":"19 julio 2024","externalUrl":null,"permalink":"/tags/fossil/","section":"Tags","summary":"","title":"Fossil","type":"tags"},{"content":"","date":"19 julio 2024","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"19 julio 2024","externalUrl":null,"permalink":"/tags/pijul/","section":"Tags","summary":"","title":"Pijul","type":"tags"},{"content":"","date":"19 julio 2024","externalUrl":null,"permalink":"/tags/version-control/","section":"Tags","summary":"","title":"Version-Control","type":"tags"},{"content":"StrangeLoop fue una de las mejores conferencias de tecnología del mundo porque en ella se tratan temas poco comunes relacionados con la computación, el desarrollo de software e incluso el arte, y lo mejor: la combinación entre entras cosas.\nSi te gusta reflexionar sobre temas profundos de la computación, te recomiendo mucho que le eches un ojo a las pláticas de esta conferencia, la mayoría están disponibles en su canal de YouTube.\nEn este artículo te recomendaré cinco de las que me han parecido las mejores pláticas de la conferencia. Todas están en inglés, aunque parece que puedes poner traducción automática en YouTube. Empecemos.\nEl desastre en el que estamos metidos - Joe Armstrong # Esta es la plática más representativa de todas las ediciones de StrangeLoop. Su título original es \u0026ldquo;The Mess We\u0026rsquo;re In\u0026rdquo;. Joe Armstrong fue el creador del lenguaje Erlang y una gran figura en la industria del desarrollo de software, co-creador del lenguaje Erlang y de su máquina virtual, que aún hoy siguen esando adelantados a su tiempo.\nJoe habla de lo complejo que es el ambiente en el que los desarrolladores trabajamos, recordándonos la complejidad de las computadoras. La plática nos hace ver por qué es un milagro que existan sistemas funcionales y lo frágiles que son.\nArmstrong explora varios problemas, incluído el problema medioambiental que las computadoras pueden generar con su consumo de energía.\nEsta imagen tiene un resumen de los problemas que menciona:\n{: .align-center}\nSi quieres cobrar conciencia o recordar la complejidad a la que nos enfrentamos, pero sobre todo entender puedes ver la charla aquí: The Mess We\u0026rsquo;re In\nDeja de escribir programas muertos - Jack Rusher # Jack Rusher nos habla de cómo muchas de las cosas a las que ya estamos acostumbrados como programadores en realidad son cosas que hemos heredado de las limitaciones que teníamos en el pasado, y que no hemos hecho el esfuerzo por cambiar.\nGran parte de lo que hacemos y creemos muy normal son fósiles de que nos tienen atados al pasado, pero ahora tenemos la capacidad de hacer muchas cosas más dinámicas e interesantes.\nEsta plática te puede abrir la mente respecto a nuevas formas de programar y te presenta entornos modernos, dinámicos y no convencionales que pueden cambiar la forma en la que trabajamos.\nLa puedes ver aquí: Stop Writing dead programs\nDesarrollo de juegos en 8 bits - Kevin Zurawel # El desarrollo de software siempre ha estado limitado por el hardware en el que se va a ejecutar, pero como la mayoría de veces las computatadoras son mucho más poderosas de lo que necesitamos, no nos damos cuenta la mayoría de los desarrolladores de software.\nEl desarrollo de juegos para plataformas antiguas (claro, modernas en su tiempo) presentaba retos muy interesantes para los desarrolladores, de los cuáles podemos aprender sobre todo para tener idea de los compromisos que se tienen que hacer para lograr cosas increíbles para la época.\nKevin Zurawel es un experto en desarrollo de juegos y actualmente tiene una página dedicada al desarrollo de juegos retro llamada Famicom.party.\nSi quieres aprender más sobre el desarrollo de software en condiciones extremadamente limitadas puedes verla aquí: Game Development in Eight Bits\nHaciendo fáciles las cosas difíciles - Julia Evans # Saber explicar cosas complejas es una de las habilidades más importantes que se pueden tener como miembro de un equipo de desarrollo. Julia Evans es una de las mejores personas en el mundo en hacer esto.\n\u0026ldquo;Algunas veces me tardo 10 años en aprender cosas básicas\u0026rdquo;, dice Julia en esta conferencia, y creo que es algo con lo que todos nos podemos idenfificar, porque todos nos enfrentamos con este ripo de situaciones.\nDurante la plática, Julia analiza el comportamiento de herramientas que usamos continuamente, nos hace ver cómo tinen un comportamiento no esperado y cómo podemos mejorar nuestro entendimiento.\nTambién nos habla de la importancia de usar herramientas que reduzcan la carga cognitiva mediante permitirte la inspección detallada de lo que está pasando.\nJulia Evans es una gran contribuidora a la comunidad de desarrollo de software con sus explicaciones y herramientas esclarecedoras sobre temas comunes pero a la vez complejos del desarrollo de software.\nSi quieres aprender más sobre cómo simplificarte las cosas complejas del desarrollo de software, puedes ver la charla aquí: Making hard things easy\nUna probadita de tipos dependientes - David Christiansen # Los sistemas de tipos siempre han sido algo que causa fuertes reacciones en los programadores, sea en contra o a favor. Mi teoría es que la mayoría de las personas que los odian es porque no han (o hemos) trabajado con un buen sistema de tipos.\nHay lenguajes con sistemas de tipos muy avanzados que te permiten de verdad hacer cosas útiles, y los más avanzados son los que tienen sistemas de tipos dependientes. Estos sistemas de tipos te permiten crear diseños con tus programas de tal manera que el compilador puede comprobar muchas cosas por adelantado.\nSi nunca has escuchado de ellos, esta plática es una muy buena introducción junto con una colección de lenguajes que los tienen.Puedes verla aquí: A Little Taste of Dependent Types.\nConclusión # Aprender de los grandes presentadores y pensadores que han presentado en StrangeLoop es una gran idea que no tiene ningún costo. No te pierdas la oportunidad de dejar que te hagan pensar en cosas profundas de tu profesión, y que te lleven por lugares que tal vez ni siquiere habías pensado que existían.\n","date":"30 marzo 2024","externalUrl":null,"permalink":"/2024/03/30/5-pl%C3%A1ticas-de-strageloop-que-tienes-que-ver/","section":"Posts","summary":"\u003cp\u003e\u003cem\u003eStrangeLoop\u003c/em\u003e fue una de las mejores conferencias de tecnología del mundo\nporque en ella se tratan temas poco comunes relacionados con la\ncomputación, el desarrollo de software e incluso el arte, y lo mejor: la\ncombinación entre entras cosas.\u003c/p\u003e","title":"5 pláticas de StrageLoop que tienes que ver","type":"posts"},{"content":"","date":"30 marzo 2024","externalUrl":null,"permalink":"/tags/charlas/","section":"Tags","summary":"","title":"Charlas","type":"tags"},{"content":"","date":"30 marzo 2024","externalUrl":null,"permalink":"/tags/software-engineering/","section":"Tags","summary":"","title":"Software-Engineering","type":"tags"},{"content":"","date":"30 marzo 2024","externalUrl":null,"permalink":"/tags/strangeloop/","section":"Tags","summary":"","title":"Strangeloop","type":"tags"},{"content":"","date":"30 marzo 2024","externalUrl":null,"permalink":"/tags/talks/","section":"Tags","summary":"","title":"Talks","type":"tags"},{"content":"Para algunos, la respuesta a la pregunta del título es simplemente \u0026ldquo;software\u0026rdquo;, porque parece tan obvia que el mismo nombre lo dice. Y aunque el software tiene una definición concreta, en este artículo vamos a desmunazar los productos de un proceso de desarrollo de software. Lo que quiero que veas es que el desarrollo de software no sólamente es crear programas que fucncionen, ya que para que el software sea efectivo tiene que evolucionar, y aquí entra el punto importante.\n¿Qué es un sistema de software? # Un sistema de software incluye varias cosas, algunas obvias, otras no tanto. Vamos a analizar de la más a la menos visible.\nEl software corriendo # Esta es la parte más visible y en la que muchos se quedarían. El software en ejecución significa una computadora ejecutando instrucciones que cumplan con el propósito del software. Si pudiéramos hacer que la computadora ejecutara lo que necesitamos de mnanera mágica, sin tener que darle instrucciones a sus diferentes partes, esta parte seguiría existiendo.\nEjemplos del software en ejecución son:\nUna página web mostrando la infomación que un cliente necesita Word recibiendo las instrucciones de tu teclado y mostrando lo que escribes en la pantalla grep buscando la expresión regular que quieres encontrar en un conjunto de documentos A veces, dependiendo del proceso pactado, no entregamos el software corriendo, sino entregamos artefactos que tienen que ser ejecutados para poner el software corriendo.\nEjecutables # Los ejecutables son los artefactos que hacen que sea posible realizar las tareas que pensamos para nuestro software. Estos artefactos pueden tomar muchas formas, por ejemplo, pueden ser archivos compilados .exe, empaquetados .dmg (de MacOS), o incluso compilados que contienen instrucciones para una arquitectura de procesador específica.\nEn el caso de lenguajes y plataformas interpretadas los ejecutables son directamente el código fuente, que además requieren que el usuario final tenga un entorno preparado en su computadora para poder correrlo.\nCódigo fuente # El código fuente, para mi, es la parte medular de los resultados de un proceso de desarrollo de software. Tiene la información necesaria para realizar las tareas que el software tiene que hacer y tras pasar por un proceso (compilación, empaquetamiento, despliegue, etc), se pueden producir los ejecutables que darán vida al software ejecutándose.\nEl entregar el código fuente al usuario final dependerá del acuerdo comercial al que se llegue al inciar el proyecto (por ejemplo, le podemos entregar el puro ejecutable como hace la mayoría del software comercial o de fuente cerrada), pero también podríamos entregar el código fuente entero para que la persona que lo recibe pueda hacer cosas importantes:\nRevisarlo: con el fin de que el software cumpla exactamente con lo que se desea y no tenga funciones ocultas no deseadas Extenderlo: crear nuevas funciones o mejorar las existentes Repararlo: si se encuentra alguna falla, eliminarla Mantenerlo: A veces, las dependencias del software van quedando desactulizadas y hay que hacer modificaciones en este para que siga funcionando Actualizarlo: llevarlo a nuevas versiones de su lenguaje o hacer que compile o produzca ejecutable para nuevas plataformas Como puedes ver, si quieres que tu software evolucione y se adapte a nuevas necesidades o incluso simplemente para que se mantenga funcional a través del tiempo, lo ideal es que tengas el código fuente a tu disposición. Es aceptado que el código funete debe incluir un conjunto de pruebas automáticas que permitan verificar su funcionamiento más eficientemente. Estas prubas pueden incluir:\nPruebas unitarias: las que prueban las unidades más básicas del código, como funciones o métodos Pruebas de integración: corren el sistema como si fueran un usuario y permiten verifcar que funcione correctamente Pero el código fuente no basta para que el mantenimiento a través del tiempo sea óptimo.\nDocumentación # Esta palabra tan temida por los desarrolladores de software en realidad es uno de nuestos productos y a la vez insumos más importantes. La documentación es información sobre el software puesta en un lugar persistente.\nEsta documentación debe incluir por lo menos:\nExplicación de lo que el sistema hace. Es lo que le llamaríamos \u0026ldquo;los requerimientos\u0026rdquo;. Diseño del sistema: Se habla de cómo está construido el sistema, por qué se pensó de esta forma y cómo eso cumple con lo que se requería. Incluye la arquitectura a diferentes niveles y el registro de las decisiones junto con su justificación. Documentación técnica. En esta parte se habla de la tecnología usada: los lenguajes usados, las plataformas sobre las que corre, las bases de datos, los sistemas operativos etc. Además una buena idea es incluir las bases sobre las que se escogieron estos elementos. Documentación para desarrolladores. Esta es la documentación que habla de lo que un desarrollador tiene que hacer para seguir desarrollando el proyecto o para hacer que el software se ejecute, sea desplegarlo en un sistema de usuario final o producir los ejecutables. Esta documentaión incluye la documentación del código en el que se describe su funcionamiento interno y el diseño que tiene. Manual de usuario. Opcional, pero dependiendo de la complejidad de las fucniones que el softwae haga y de su intefaz, puede convertise en un elemento absolutamente necesario. En este se describen a detalle las cosas que el usuaio puede hacer y las consecuencias de estas acciones. Hasta aquí se quedarían algunos, ¿pero podemos ir más allá? Sobre todo pensemos en que, para que el software sea exitoso, necesita evolucionar. ¿Quién crea nuevo código?\nUn equipo funcional # En teoría, con todo lo anterior cualquier desarrollador de software podría tomar un proyecto y seguirlo evolucionando, pero esta teoría se queda lejos de la práctica por varias razones. La primera es que necesariamente todos los artefactos anteriores van a tener defectos o estar incompletos, por lo que para que un nuevo equipo o desarrllador tome el proyecto requerirá hacer lo que llamamos \u0026ldquo;arqueología de software\u0026rdquo;, intentando completar y entender las decisiones no documentadas y todas las demás partes de información faltantes.\nAún si los artefactos producidos estuvieran completos, el que un nuevo equipo tome el proyecto requiere tiempo y esfuerzo para estudiarlos y empezar a producir nuevas funciones o a corregir errores. Si queremos que el proceso de desarrollo continue rápidamente, lo mejor es que el equipo que lo desarrolló lo siga evolucionando.\nLos mejores proyectos de software incluyen a un grupo de personas que conocen la forma de desarrollo más eficiente, las partes delicadas del proyecto, los fallos pendientes por componer, y las cosas que le faltan.\nAdemás, este grupo de personas tienen una forma de trabajar y de coordinación eficiente que puede ayudarlos a ser más productivos.\nCon esto podemos concluir que el resultado del proceso de desarrollo de software no es solo una serie de artefactos, sino que también puede inlcuir a un equipo de personas que sereian los más adecuados para seguirlo desarrollando.\nPero hablemos de un elemento no tangible.\nNuevo conocimiento # Siempre que alguien escribe software, su mente se modifica de tal manera que volver a su estado anterior es imposible. Este nuevo estado en el que la mente del programador se encuentra contine información sobre el problema que acaba de resolever, de tal manera que si desapareciera todo el código fuente y toda la documentación junto con los ejecutables, para este desarrollador no sería tan desastroso porque volver a producrilos le tomaría una fracción del tiempo que ya gastó en hacerlos.\nEsta modificación en la mente de las personas es un elemento no visible pero sin duda valioso, que permite crear cada vez software más complejo y con mayores capacidades.\nConclusión # El proceso de desarrollo de software no sólamente produce software corriendo o ejecutables. Nuestro trabajo produce otras cosas de valor de las que deberíamos ser conscientes y buscar optimizar, evitando la simpleza de pensar que lo único que vale es el software corriendo, que cómo puedes ver en este artíulo, es una parte mínima de todo el valor que puedes producir, eso sin contar el valor que tu software produce al ser ejecutado por las personas que le pueden sacar provecho.\n","date":"9 marzo 2024","externalUrl":null,"permalink":"/2024/03/09/qu%C3%A9-producimos-los-desarrolladores-de-software/","section":"Posts","summary":"\u003cp\u003ePara algunos, la respuesta a la pregunta del título es simplemente \u0026ldquo;\u003cem\u003esoftware\u003c/em\u003e\u0026rdquo;,\nporque parece tan obvia que el mismo nombre lo dice. Y aunque el \u003cstrong\u003esoftware\u003c/strong\u003e\ntiene una definición concreta, en este artículo vamos a desmunazar los productos\nde un proceso de desarrollo de software. Lo que quiero que veas es que el\ndesarrollo de software no sólamente es crear programas que fucncionen, ya\nque para que el software sea efectivo tiene que \u003cstrong\u003eevolucionar\u003c/strong\u003e, y aquí\nentra el punto importante.\u003c/p\u003e","title":"¿Qué producimos los desarrolladores de software?","type":"posts"},{"content":"","date":"9 marzo 2024","externalUrl":null,"permalink":"/tags/ingenieria-de-software/","section":"Tags","summary":"","title":"Ingenieria-De-Software","type":"tags"},{"content":"","date":"9 marzo 2024","externalUrl":null,"permalink":"/tags/software/","section":"Tags","summary":"","title":"Software","type":"tags"},{"content":"","date":"14 diciembre 2023","externalUrl":null,"permalink":"/tags/chakra/","section":"Tags","summary":"","title":"Chakra","type":"tags"},{"content":"Ya hemos explicado antes qué es un engine de JavaScript. Como resumen, es el programa encargado de correr tus programas de JavaScript: recibe tus archivos o código de JS y ejecuta las acciones en el sistema operativo en el que se está ejecutando.\nEstos engines actualmente son programas complejos que no solamente interpretan el código, sino que lo analizan y compilan a código máquina para que sea más eficiente su ejecución.\nEn este artículo vamos a hablar de algunos engines de JavaScript populares y en dónde puedes encontrar su código o sus ejecutables para que los puedas usar. Pero antes hablemos de la utilidad que puede tener un motor de JS fuera de un navegador.\nUsos de un motor de JS # A veces, queremos darle a nuestros usuarios una manera de ejecutar código de manera arbitraria o de modificar el sistema mediante instrucciones que ellos mismos metan en nuestras plataformas o programas. En vez de crear todo un lenguaje o de implementar nuestro propio compilador o intérprete, podemos embeber o incluir un motor de un lenguaje conocido y con implementaciones robustas y disponibles para su uso. Esta es exactamente el caso de uso que los engines de JS que podemos encontrar implementados cumplen.\nUn ejemplo de quién usa engine fuera de un navegador es un proyecto que ha cambiado el mundo del desarrollo web y que es muy popular: NodeJS, es un entorno de ejecución de JavaScript que se basa en el motor V8 de Google y que sirve principalmente para crear aplicaciones web. Mediante el uso de V8, puedes crear servidores web usando JavaScript, y Node se encarga de envolverlo para que puedas usar todas funcionalidades que te ofrece el sistema operativo en el que se está ejecutando.\nOtro ejemplo de uso de un motor de JS fuera de un browser es MongoDB, que usa el motor SpiderMonkey de Mozilla para ejecutar código de JavaScript en sus bases de datos.\nSi buscas más, puedes encontrar un montón de ejemplos en los que un motor de JavaScript es usado fuera de un navegador.\nEngines de JavaScript # Ahora sí, hablemos de los diferentes motores de JavaScript en orden de popularidad.\nV8 # Es el motor desarrollado por Google, usado principalmente en Chrome, NodeJS y Deno. Actualmente también está detrás de Microsoft Edge. Es el más popular y el que más desarrollo tiene. Está escrito en C++ y ha tenido varias iteraciones, mejorando los componentes internos. Además cuenta con un JIT compiler que lo hace eficiente en la mayoría de los casos. Otra ventaja de V8 es que puede ejecutar también WebAssembly.\nSi quieres desarrollar algo que tenga soporte completo del estándar ECMAScript, sea estable y tenga buen rendimiento, con V8 no te puedes equivocar. La desventaja es que tendrás que usarlo como un biblioteca de C++, o por lo menos customizarlo un poco para que se adapte a tus necesidades y hagas los puentes con tu programa, plataforma o lenguaje de programación, tal como Deno (que está escrito en Rust).\nPuedes ver su blog técnico aquí: https://v8.dev/blog. Además, si quieres aprender cómo hacer complejos o quieres contribuir, su código fuente está disponible de manera abierta en GitHub: V8 Github.\nSpiderMonkey # Este motor de JS está desarrollado por Mozilla y es usado en Firefox, Servo y en MongoDB. Igual que V8, está escrito en C++, pera también incluye partes en Rust e incluso en JavaScript. A parte de ejecutar JS, también puede ejecutar WebAssembly.\nSi tienes un proyecto en Rust o C++, SpiderMonkey puede ser una gran opción. La principal diferencia con V8 es la velocidad de desarrollo, puedes esperar menos cambios que puedan romper tu código, pero también menos mejoras y actualizaciones, que con V8.\nPuedes ver su documentación aquí: SpiderMonkey.\nChakraCore # Este motor fue desarrollado por Microsoft y es usado en Chakra (que es un runtime de JS incluye otras cosas más como API\u0026rsquo;s para poder darle más funcionalidad al engine), que a su vez era usado en Edge y Windows (Edge ahora usa Chromium).\nChakraCore está escrito en C++ y C, y presenta una API en C para usarlo en proyectos compatibles con esto. Puede ser compilado para cualquier sistema operativo de 64 bits, pero solamente para Windows para procesadores ARM y de 32 bits. Ya que Microsoft lo dejó de usar, se piensa ahora completamente como un proyecto a cargo de la comunidad.\nEn las pruebas que yo hice, fue el más fácil de compilar y usar, pero si te fijas en su repositorio, no tiene un desarrollo tan activo.\nPuedes ver su documentación aquí: ChakraCore. Nota como no está bajo el nombre de chakra-core y no en el repositorio de Microsoft.\nJavaScriptCore # Este es el motor desarrollado por Apple, usado en Safari principalmente. Al igual que los otros, está escrito en C y C++, pero tiene bindings para Objective-C, Swift y C. Así, se puede usar para darle la capacidad a aplicaciones de iOS y macOS de ejecutar código de JS, pero si tienes algo más en C en que puedas envolverlo, sin ningún problemas puedes usarlo en cualquier proyecto.\nPuedes ver su documentación aquí: JavaScriptCore.\nRhino # También es desarrollado por Mozilla, pero esta vez escrito en Java. Rhino viene incluido en algunas distribuciones de Java. Así que si tienes un proyecto en Java, Rhino es una gran opción, pero debes estar atento a las características que soporta, porque parece que su desarrollo no está tan activo.\nPuedes ver su documentación aquí: Rhino.\nEngines ligeros # Existen una gran variedad de engines de JS más ligeros, no con todas las características de los que acabamos de ver, con la idea de que los puedas embeber en proyectos que dispongan de pocos recursos, tal como sistemas embebidos o proyectos de IoT. Otro buen caso de uso para estos es cuando no requieras las funcionalidades completas de JS sino simplemente soporte básico en tu programa.\nAquí una lista de los más populares:\nQuickJS: Desarrollado por Fabrice Bellard, quien también creó FFmpeg. QuickJS sólo pesa 210Kb en su forma más sencilla. Duktape: También es muy pequeño, promete funcionar en sistemas con 160Kb de memoria y 64Kb de RAM. Está escrito en C y soporta la ES2015 o ES6. Espruino. Corre en sistemas con 128Kb de memoria y 8Kb de RAM. Está escrito también en C y está pensado para darle soporte a sus propias tarjetas de microncontroladores de bajo consumo, programadas en JS. Pero aún así, lo puedes usar en cualquier proyecto que sea compatible con su API de C o correrlo directamente. Conclusión # Espero que esta lista de motores de JavaScript te sea útil para conocer más del ecosistema del que muchos sólo somos usuarios y para entender que JS te puede servir para darles superpoderes a tus sistemas y plataformas. Ya hay muchos proyectos que te permiten hacerlo reduciendo el trabajo al mínimo.\n","date":"14 diciembre 2023","externalUrl":null,"permalink":"/2023/12/14/engines-de-javascript-y-sus-usos/","section":"Posts","summary":"\u003cp\u003eYa hemos explicado antes qué es un \u003ca\n  href=\"/2020/05/17/que-es-un-engine-de-javascript.html\"\u003eengine de JavaScript\u003c/a\u003e. Como resumen, es el programa encargado de correr tus programas de JavaScript: recibe tus archivos o código de JS y ejecuta las acciones en el sistema operativo en el que se está ejecutando.\u003c/p\u003e","title":"Engines de JavaScript y sus usos","type":"posts"},{"content":"","date":"14 diciembre 2023","externalUrl":null,"permalink":"/tags/javascript-engine/","section":"Tags","summary":"","title":"Javascript-Engine","type":"tags"},{"content":"","date":"14 diciembre 2023","externalUrl":null,"permalink":"/tags/v8/","section":"Tags","summary":"","title":"V8","type":"tags"},{"content":"","date":"13 diciembre 2023","externalUrl":null,"permalink":"/tags/mojo/","section":"Tags","summary":"","title":"Mojo","type":"tags"},{"content":"Chris Lattner{:target=\u0026quot;_blank\u0026quot;}, uno de los creadores de LLVM y Swift, ha estado desarrollando un nuevo lenguaje basado en la sintaxis de Python pero pensado para atacar su punto más débil: la velocidad de ejecución.\nEste lenguaje se llama Mojo, y está siendo publicitado como un lenguaje para hacer aplicaciones de inteligencia artificial. Como ya dijimos, su enfoque principal está en ser un lenguaje que produzca programar eficientes, por lo que puede ser usado para cualquier aplicación que requiera alto rendimiento o hacer una gran cantidad de cálculos, justo como las aplicaciones de machine learning.\nEn este artículo veremos el motivo detrás de su nacimiento, sus características y analizaremos si te conviene aprenderlo o deberías buscar alguna otra alternativa. Primero, entendamos la fundación de Mojo.\nMLIR - Representación intermedia multi-capa # LLVM es un proyecto que se define como infraestructura para la construcción de compiladores. Imagínate que es como un framework para construir compiladores. Muchos de los lenguajes actuales están creados usando este proyecto. Por ejemplo Rust, Swift y Julia están construidos sobre LLVM.\nUna de las partes que hace muy útil a LLVM es su representación intermedia. Esta representación intermedia permite que los diferentes lenguajes de programación que funcionan sobre él se aprovechen de las optimizaciones que LLVM hace sobre el código intermedio. El flujo del código es el siguiente:\nEl código fuente es compilado a código intermedio (IR). El IR es optimizado. El IR es compilado a código de máquina. De hecho, se dice que Swift es sólo azúcar sintáctico sobre la representación intermedia de LLVM, es decir, que se parece mucho a esta representación intermedia y aprovecha sus características.\nMLIR (Multi-layer Intermediate Representation o Representación intermedia multi-capa) es una representación intermedia de más alto nivel que la representación intermedia tradicional. No en el sentido de que sea más fácil de entender para los humanos, sino que en vez de mapearse directamente con una infraestructura de compilación, representa un modelo más abstracto que puede ser mapeado a diferentes infraestructuras de compilación, de manera especializada para cada una de ellas. Así permite que un mismo código fuente pueda ser compilado para diferentes ejecutores, como GPU\u0026rsquo;s, TPU\u0026rsquo;s, CPU\u0026rsquo;s, etc, sin tener que crear una nueva representación intermedia o crear nuevo código fuente.\nEntra Mojo 🔥 # Toda esta explicación anterior es para entender que Mojo es para MLIR lo que Swift es para LLVM. Aprovecha gran parte de las características de MLIR para crear un lenguaje de programación que pueda usar ejecutores especializados en cómputo de alto rendimiento como GPU\u0026rsquo;s y TPU\u0026rsquo;s, pero presentando una sintaxis más amigable para los humanos, a diferencia de CUDA, o C++, por ejemplo.\nMojo te ayuda aprovechar el paralelismo masivo de los GPU\u0026rsquo;s sin tener que preocuparte por aprender un nuevo lenguaje o siquiera tener que pensar en dónde finalmente se ejecutará tu programa.\nYa que Python es la lingua franca del mundo de la inteligencia artificial, Mojo inicialmente fue pensado como una extensión de Python (lo que llamaríamos un superconjunto de Python), en el sentido de que todo el código válido en Python es código válido en Mojo, muy parecido a la relación que existe entre la sintaxis de TypeScript y JavaScript.\nCaracterísticas de Mojo # Las pruebas iniciales de Mojo revelan que puede ser hasta 68,000 veces más rápido que Python en ciertas tareas (sí, leíste bien sesenta y ocho mil), mientras que C++ llega a ser sólo 5,000 veces más rápido. Claro, esto no habla muy bien de Python, pero debes pensar en que su objetivo no es ser un lenguaje de alto rendimiento, sino un lenguaje de alto nivel y fácil de usar.\nMojo quiere aprovechar la facilidad de uso de Python junto con su ecosistema de bibliotecas y desarrollos para hacer un ecosistema de desarrollo de inteligencia artificial más rápido y fácil de usar. Una de las primeras diferencias con Python es que es un lenguaje compilado.\nHablemos de algunas de las cosas que Mojo le aumenta a Python:\nSistema de tipos progresivos. Te permite usar el sistema de tipos tanto como lo necesites (por eso es progresivo). Pero debes tener en cuenta que los tipos te sirven tanto para verificar que el programa es correcto como para optimizar el código que se genera.\nAbstracciones sin costo. Muy parecido a Rust, Mojo te da acceso a usar abstracciones de alto nivel que no incrementan el costo de ejecución.\nSeguridad de memoria. Tiene un sistema de seguridad de memoria parecido al de Rust, mediante la pertenencia y el préstamo de referencias (ownership + borrow checker).\nMetaprogramación. Te permite crear código parametrizado que se transforma en tiempo de compilación.\nComo puedes ver, Mojo es un lenguaje muy interesante que aprovecha las características que hemos aprendido en lenguajes modernos que han sido útiles para crear mejores sistemas. El uso de MLIR es la base de su rendimiento, que permite que los programas que generas se puedan optimizar para ejecutores de diferentes tipos, incluidos algunos masivamente paralelos.\n¿Deberías aprenderlo? # Mojo es un lenguaje que servirá tanto para hacer aplicaciones de IA como herramientas de bajo nivel para sistemas operativos, por lo que yo lo pensaría como un lenguaje de programación de sistemas de última generación que permitirá hacer cosas muy interesantes en el futuro.\nAhora mismo (Diciembre de 2023), es un lenguaje de código cerrado, es decir, su desarrollo está llevado por una empresa privada y el código fuente no está disponible para que otros lo vean o contribuyan. Según Lattner, esto permite inicialmente que se se avance de manera más efectiva, en lo que personalmente estoy de acuerdo. Se espera que Mojo sea de código abierto cuando alcance el nivel de madurez necesario.\nAdemás, está en una etapa muy temprana de su desarrollo en la que ni siquiera cumple con todas las características de Python, por lo que todo lo que aprendas ahora sólo será un vistazo que te puede ayudar a definir si lo quieres usar cuando salga su versión lista para producción.\nPersonalmente, creo que es un buena inversión del tiempo si estás metido en crear aplicaciones de alto rendimiento, programación de sistema o quieres crear sistemas que usen inteligencia artificial como una de sus características principales. Por el contrario, para desarrollo web creo que tomará un poco más de tiempo en serte útil.\nOtro caso para el que puede serte útil es para aprender las características de los lenguajes modernos, como los tipos progresivos o la seguridad de memoria mediante el préstamos de referencias.\nConclusión # Mojo es un lenguaje interesante, muy prometedor y que está en la raya de la innovación en creación de lenguajes y características modernas. Si eres curioso y te gustan en general los lenguajes de programación, creo que es una gran opción para empezar a aprender y tal vez en el futuro recoger los beneficios si cumple con sus promesas.\n","date":"13 diciembre 2023","externalUrl":null,"permalink":"/2023/12/13/mojo-un-lenguaje-prometedor/","section":"Posts","summary":"\u003cp\u003e\u003ca\n  href=\"https://www.nondot.org/sabre/\"\n    target=\"_blank\"\n  \u003eChris Lattner\u003c/a\u003e{:target=\u0026quot;_blank\u0026quot;}, uno de los creadores de \u003ca\n  href=\"https://llvm.org\"\n    target=\"_blank\"\n  \u003eLLVM\u003c/a\u003e y \u003ca\n  href=\"https://www.swift.org/\"\n    target=\"_blank\"\n  \u003eSwift\u003c/a\u003e, ha estado desarrollando un nuevo lenguaje basado en la sintaxis de \u003cstrong\u003ePython\u003c/strong\u003e pero pensado para atacar su punto más débil: \u003cstrong\u003ela velocidad de ejecución\u003c/strong\u003e.\u003c/p\u003e","title":"Mojo 🔥: un lenguaje prometedor","type":"posts"},{"content":"","date":"13 diciembre 2023","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"A veces, los programadores usamos muy libremente los conceptos. Uno de ellos es el de Real Time. En este artículo vamos a hablar de lo que significa realmente el término, lo vamos a definir claramente y sobre todo aprenderemos a diferenciar los distintos niveles o garantías que debe ofrecer un sistema en tiempo real.\n¿Qué es Real Time? # Un sistema que provee garantías de Tiempo Real o Real Time es aquel que garantiza que una tarea se va a ejecutar en un tiempo determinado. Esto es muy importante en sistemas críticos, como los que se usan en la industria automotriz, aeroespacial, médica, en los que ejecutar NO ejecutar una tarea en un tiempo determinado puede tener consecuencias catastróficas.\nPero también hay sistemas en los que es deseable que una tarea se ejecute antes de cierto tiempo, por ejemplo, cuando estamos transmitiendo información en forma de audio o video de algo que es importante que se comunique rápidamente. Así, podemos hacer llamadas o videollamadas que son útiles.\nLos dos casos anteriores, nos dan la pauta para por lo menos distinguir dos tipos de sistemas Real Time:\nHard Realtime. Son sistemas que deben garantizar con un 100% de certeza que la tarea que quieres que hagan se va a realizar máximo en el tiempo qu especifica el mismo sistema. En estos sistemas no hay margen de error, si el sistema no puede cumplir con el tiempo especificado se considera que falló, por lo que no es seguro operarlo. Este tipo de sistemas se usan en ocasiones en las que es muy muy importante que la tarea en cuestión se ejecute lo más rápido posible, normalmente porque el no hacerlo o tener un retraso podría tener consecuencias mortales o catastróficas.\nSoft Realtime. Los sistemas de este tipo, garantizan que mínimo cierto porcentaje de las veces que un sistema se ejecute, la tarea se va a ejecutar en el tiempo especificado, normalmente lo más rápido posible. A diferencia de los sistemas de tiempo real fuerte, puede que cierto número de acciones tarden un poco más de lo esperado, pero esto no llevaría a pensar que el sistema falló. Este tipo de sistemas se usa para cosas no tan críticas pero en las que es deseable que la tarea está lista lo más rápido posible, por ejemplo, en juegos, aplicaciones de videoconferencia, sistemas de coordinación de trabajo (Figma, Google Docs, etc).\nCómo puedes lograr un sistema Real Time # Lo primero en que debemos pensar es qué tipo de realtime necesitamos. Como te puedes imaginar, lograr un sistema Hard Realtime es mucho más complicado que lograr un sistema Soft Realtime. Esto es porque en el primero, no hay margen de error, mientras que en el segundo, podemos relajarnos un poco.\nAlgunas sugerencias para lograr sistemas realtime son:\nUsa un ecosistema que esté pensado para esto. Hay lenguajes de programación y plataformas que mediante diferentes técnicas te ayudan a lograr funcionalidades real time, pero normalmente se queden al nivel de aplicaciones de soft realtime. Algunos ejemplos son lenguajes que aprovechan la concurrencia y controlan efectivamente el tiempo de ejecución de tu programa o te permiten hacerlo de manera sencilla, como: Go, Elixir y NodeJS.\nUsa un lenguaje de programación que te de control granular sobre el tiempo de ejecución. Con esto principalmente me refiero a una cosa: que no tengan recolector de basura. Recuerda que este proceso puede parar el programa por un tiempo no conocido y de manera no controlada, por lo que si quieres lograr aplicaciones hard realtime, será una tarea extremadamente difícil. Lamento decírtelo, pero si quieres asegurar que tu programa se comporte como deseas, vas a tener que controlar casi cada detalle, en lenguajes como C, C++ o Rust.\nAsegura la fiabilidad de tu infraestructura. Para que un sistema realtime sea confiable, vas a necesitar que la infraestructura sea resistente a fallas. Esto lo logras eliminando puntos únicos de fallo, es decir, aquellos puntos de tu programa o infraestructura que si fallan hacen que todo el sistema se caiga. Para lograr esto tienes que pensar en arquitecturas distribuidas, redundancia de datos, escalamiento automático, etc.\nEspero que estos consejos te sirvan y si se me está pasando alguno, por favor, déjame un comentario.\nConclusión # Conocer los diferentes niveles de servicio que un sistema puede garantizar y comprender las características que presentan, te puede ayudar a tomar en serio la responsabilidad de diseñar un sistema realtime y la dificultad que implica.\nPiensa profundamente si realmente se requiere un sistema con estas características (sobre todo si es hard realtime) y si es así, toma en serio la responsabilidad de diseñarlo y construirlo, espero que los consejos que te di en este artículo te sirvan para lograrlo.\n","date":"9 diciembre 2023","externalUrl":null,"permalink":"/2023/12/09/qu%C3%A9-es-real-time-en-sistemas-de-software/","section":"Posts","summary":"\u003cp\u003eA veces, los programadores usamos muy libremente los conceptos. Uno de ellos es el de Real Time. En este artículo vamos a hablar de lo que significa realmente el término, lo vamos a definir claramente y sobre todo aprenderemos a diferenciar los distintos niveles o garantías que debe ofrecer un sistema en tiempo real.\u003c/p\u003e","title":"¿Qué es Real Time en sistemas de software?","type":"posts"},{"content":"","date":"9 diciembre 2023","externalUrl":null,"permalink":"/tags/real-time/","section":"Tags","summary":"","title":"Real-Time","type":"tags"},{"content":"","date":"9 diciembre 2023","externalUrl":null,"permalink":"/tags/sistemas-cr%C3%ADticos/","section":"Tags","summary":"","title":"Sistemas-Críticos","type":"tags"},{"content":"","date":"9 diciembre 2023","externalUrl":null,"permalink":"/tags/tiempo-real/","section":"Tags","summary":"","title":"Tiempo-Real","type":"tags"},{"content":"","date":"28 agosto 2023","externalUrl":null,"permalink":"/tags/criptograf%C3%ADa/","section":"Tags","summary":"","title":"Criptografía","type":"tags"},{"content":"","date":"28 agosto 2023","externalUrl":null,"permalink":"/tags/hash/","section":"Tags","summary":"","title":"Hash","type":"tags"},{"content":"En este artículo profundizaremos sobre las garantías de seguridad mínimas que una función hash debe cumplir para ser criptográficamente segura. En un artículo anterior: ¿Qué es un hash? ya hablamos más detalladamente de la definición y de los algoritmos que puedes usar aún hoy de manera segura.\nEmpecemos por una pequeña definición de lo que es una función hash en la criptografía.\n¿Qué es un hash? # Un hash es una función que te devuelve un valor de tamaño fijo independientemente del tamaño de la entrada, esto implica una compresión de datos. Las funciones hash que son usadas en criptografía, tienen la característica de entregar valores completamente impredecibles, tanto para un humano como para una computadora. Es decir que no hay manera de saber qué valor va a entregar una función hash para un valor dado si no le has pasado ese valor antes.\nLo anterior no quiere decir que las funciones hash devuelvan algo diferente cada vez que las ejecutas, sino que para un valor dado, siempre devuelven el mismo resultado, y aquí es donde radica su utilidad.\nUn hash perfecto se comportaría como un generador de valores aleatorios, pero debido a lo que hemos dicho anteriormente, deben ser deterministas al mismo tiempo que impredecibles.\nPara medir la seguridad de una función hash, se usan tres pruebas, que se conocen como las garantía de seguridad de un hash.\nEstas garantías son:\nResistencia a la primera preimagen Resistencia a la segunda preimagen Resistencia a la colisión Cada una de estas garantías se refiere a un tipo de ataque que se puede hacer a una función hash. Vamos a explicarlas pero antes aclaremos algunos términos.\nImagen y preimagen # En matemáticas, una función es una relación entre dos conjuntos de valores, uno de entrada y uno de salida. En la mayoría la de las funciones matemáticas comunes, cada valor de entrada tiene un único valor de salida.\nTomemos como ejemplo: $$f(x) = x + 1$$, esta función toma un valor $$x$$ y le suma $$1$$, por lo que cada valor de $$x$$ tiene un único valor de salida, porque sabemos que un número cualquiera tiene solamente un sucesor.\nPero no todas las funciones se comportan así, por ejemplo: $$f(x) = x^2$$. En esta función el valor 4 puede ser generado por dos valores de entrada diferentes: $$2$$ y $$-2$$.\nCuando vemos una función así no es común que nos definan el conjunto de entrada, así que asumimos que el conjunto de entrada o dominio es el conjunto de los números reales, y el conjunto de salida o codominio es el conjunto de los números reales.\nPensemos en el dominio y codominio como conjuntos amplios en los que los valores de entrada y salida podrían estar. La imagen de una función es el conjunto de valores que están en el codominio, es decir, los valores que la función puede devuelve. La preimagen es el conjunto de valores que pueden ser entrada de la función.\nEn términos prácticos para nosotros los programadores, la imagen es casi equivalente al codominio, y la preimagen es el dominio.\nEsta imagen sacada de Wikipedia lo ilustra un poco mejor:\n{: .align-center}\nLa imagen es el área amarilla, mientras que Y es el codominio, y X es el dominio. Lo último que nos hace falta saber es que aunque imagen y preimagen son los conjuntos de entradas y salidas del algoritmo, también nos podemos referir así a un valor individual de este conjunto.\nApliquemos los aprendido al ejemplo de la función $$f(x) = x^2$$. El dominio es el conjunto de los números reales, y el codominio también es el conjunto de los números reales. La imagen es el conjunto de los números reales positivos que tengan una raíz cuadrada, y la preimagen es el conjunto de los números reales. Un ejemplo concreto: para el valor 4 considerado como resultado de la función o imagen, tendría dos preimágenes: $$2$$ y $$-2$$.\nAhora sí, hablemos de la primera garantía de seguridad de un hash.\nResistencia a la primera preimagen # Aquí debes poner atención a los valores que se dan para hacer la prueba de seguridad. Presta atención a cuando se dice \u0026ldquo;dado un valor\u0026rdquo;, estos son la valores que suponemos que ya se conocen.\nEn la primera garantía es: Dada una imagen es computacionalmente inviable encontrar una preimagen que la genere.\nEn palabras de programadores: Dado un hash, es computacionalmente inviable encontrar un valor que al ser pasado a la función hash, genere ese hash.\n¿Por qué decimos un valor que genere ese hash y no el valor que genere ese hash? Porque para un valor de salida, puede haber más de un valor de entrada que lo genere. Especialmente para los hashes, su conjunto de valores posibles es infinito: todas las combinaciones de bits posibles de cualquier tamaño.\n¿Cuál es el tamaño del conjunto de posibles salida? Eso depende del hash usado y su número de bits. Por ejemplo, el SHA-256 genera hashes de 256 bits, por lo que su conjunto de posibles valores es $$2^{256}$$, que es un número muy grande, pero no infinito, por lo que es posible que dos valores generen el mismo hash. Cada uno de esos valores sería una preimagen de un hash dado.\nEntonces ya tenemos todo el escenario: nos han dado un hash y tenemos que encontrar uno de los infinitos valores que pueden producir ese hash, una preimagen.\nPues bien, para un hash criptográficamente seguro esta operación debe de ser imposible de realizar de manera más eficiente que usando fuerza bruta, es decir, probando todos los valores posibles hasta encontrar uno que genere el hash dado.\nPara que un hash sea considerado seguro, hallar una preimagen por fuerza bruta debería tomar $$2^{n}$$ operaciones, donde $$n$$ es el número de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, toma $$2^{256}$$ operaciones, que es un número muy grande, computacionalmente inviable.\nPor ejemplo, imagina que puedes hacer 1 millón de operaciones por segundo, aproximadamente $$2^{19}$$. Encontrar una primera preimagen para el SHA-256 te tomaría $$2^{256} / 2^{19}$$, es decir $$2^{247}$$ segundos, mientras que lo que se calcula que ha durado el universo son $$2^{38}$$ segundos.\nPongamos un ejemplo en Python. Supongamos que la función hash es un hash seguro, y que la función mensaje_aleatorio devuelve un mensaje diferente cada vez. Pon atención en lo que recibe la función primera_preimagen:\ndef primera_preimagen(h): m = mensaje_aleatorio() while hash(m) != h: m = mensaje_aleatorio() return m Este debería ser el mejor ataque que se pueda hacer sobre un hash seguro.\nResistencia a la segunda preimagen # Esta garantía de seguridad es muy parecida a la primera, pero lo que se recibe aquí es una preimagen y se debe encontrar otra preimagen que genere el mismo hash.\nLa garantía de seguridad debería ser la misma: encontrar una segunda preimagen debería ser computacionalmente inviable, es decir, que tomaría $$2^{n}$$ operaciones, donde $$n$$ es el número de bits del hash.\nPongamos un ejemplo en Python. Observa que usamos la función primera_preimagen que definimos antes:\ndef segunda_preimagen(m): h = hash(m) m2 = primera_preimagen(h) return m2 Este ataque no implica más que hashear el mensaje y encontrar una primera preimagen de ese hash. Si el hash es resistente a la primera preimagen, entonces también lo será a la segunda.\nParece que esta garantía no tiene mucho sentido, pero vayamos a la tercera y la más conocida.\nResistencia a colisiones # Una colisión es cuando dos valores diferentes generan el mismo hash. Ya mencionamos que, al tener un conjunto infinito de valores de entrada y tener un conjunto muy grande (pero limitado) de valores de salida, es inevitable que suceda esto, de hecho, en este caso, un conjunto infinito de valores de entrada generan el mismo hash.\nPero hagamos un caso concreto. Imagina que tu hash recibirá cadenas de bits de 512 bits, y generará un hash de 256 bits. Esto significa que el conjunto de posibles valores de entrada es $$2^{512}$$ y el de posibles valores de salida es $$2^{256}$$. A cada valor de salida le corresponden $$2^{512}/2^{256} = 2^{512-256}$$ valores de entrada, es decir, que para cada valor de salida hay $$2^{256}$$ valores de entrada que generan el mismo hash.\nBueno, pues la tercera garantía de seguridad indica que debe ser computacionalmente inviable encontrar una colisión. En este caso no se nos da nada, ni una imagen (hash), ni una preimagen (valor de entrada). Se puede escoger cualquier valor de entrada para encontrar una colisión.\nAquí entra la segunda garantía de seguridad, si la función hash es resistente a la segunda preimagen, es resistente a colisiones. En Python, el mejor algoritmo para encontrar una colisión debería ser el siguiente para un hash seguro:\ndef encontrar_colision(): m = mensaje_aleatorio() return encontrar_segunda_preimagen(m) La garantía de seguridad que debe de cumplir un hash seguro es que encontrar una colisión debería tomar $$2^{n/2}$$ operaciones, donde $$n$$ es el número de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, tomaría $$2^{128}$$ operaciones, que sigue siendo un número muy grande, computacionalmente inviable.\n¿Por qué $$2^{n/2}$$? Porque es más fácil encontrar un par de valores que generen el mismo hash sin tener restricciones, que encontrar un valor que genere un hash dado.\nSi haces $$N$$ hashes, puedes tener ~$$N^2$$ oportunidades para encontrar una colisión por que puedes comparar cada hash con todos los demás. Esto es lo que se conoce como la paradoja del cumpleaños.\nCómo se vuelve inseguro un hash # Un hash seguro se comporta de manera completamente impredecible con respecto a su valor de entrada. Los hashes inseguros empiezan a dar muestras de regularidad en sus salidas o tienen salidas demasiado pequeñas.\nDe esta manera, es posible encontrar métodos estadísticos para analizar las salidas y así encontrar patrones que permitan encontrar colisiones o preimágenes más fácilmente.\nPero en realidad, tiene mucho que ver con su construcción y las formas en las que puedes truquear los valores que le das para reducir el número de pasos que se necesitan para encontrar una preimagen o una colisión.\nConclusión # En este artículo vimos las tres garantías de seguridad que debe cumplir una función hash para ser criptográficamente segura. Te sirven para entender claramente de lo que se habla cuando se han encontrado colisiones en un hash, y poder evaluar la gravedad de la situación.\n","date":"28 agosto 2023","externalUrl":null,"permalink":"/2023/08/28/las-tres-garant%C3%ADas-de-seguridad-de-un-hash/","section":"Posts","summary":"\u003cp\u003eEn este artículo profundizaremos sobre las garantías de seguridad mínimas que una función hash debe cumplir para ser criptográficamente segura. En un artículo anterior: \u003ca\n  href=\"/2021/12/02/algoritmos-criptograficos-que-es-un-hash.html\"\u003e¿Qué es un hash?\u003c/a\u003e ya hablamos más detalladamente de la definición y de los algoritmos que puedes usar aún hoy de manera segura.\u003c/p\u003e","title":"Las tres garantías de seguridad de un hash","type":"posts"},{"content":"","date":"28 agosto 2023","externalUrl":null,"permalink":"/tags/md5/","section":"Tags","summary":"","title":"Md5","type":"tags"},{"content":"","date":"28 agosto 2023","externalUrl":null,"permalink":"/tags/sha-256/","section":"Tags","summary":"","title":"Sha-256","type":"tags"},{"content":"La filosofía es una de las ramas más importantes del saber humano y, para mi, es la fundación de todas las demás ramas del conocimiento y de las ciencias. En este artículo hablaremos de la filosofía de la computación y cómo esta te puede ayudar como programador o desarrollador de software.\nEmpecemos primero hablando de qué es la filosofía y luego combinándola con la computación.\n¿Qué es la filosofía? # La filosofía busca responder las preguntas fundamentales de la existencia humana. Casi ninguna de las preguntas importantes se ha podido responder de manera definitiva, pero lo interesante que nos puede ofrecer la filosofía es una análisis profundo de las posibles respuestas y de las implicaciones de cada una de ellas. Así, se ha generado mucho conocimiento que nos ayuda a entender mejor el mundo y a nosotros mismos.\nAdemás, la filosofía ha desarrollado métodos que nos pueden ayudar a examinar temas difíciles de manera efectiva.\nPongamos un ejemplo. Una de las grandes preguntas que muchos filósofos han intentado responder es \u0026ldquo;¿Cuál es la mejor forma de vivir?\u0026rdquo;. No hay una respuesta definitiva, pero en la exploración se han encontrado y propuesto muchas prácticas que mejoran la vida humana y que sirven en diferentes situaciones.\nAdemás han surgido modelos de pensamiento que consisten en una serie de ideas y prácticas que pueden darle sentido a una vida bien practicadas: Estoicismo, Epicureismo, etc. Combinadas pueden servirte para mucho para analizar una situación en la vida o para encontrar una forma de actuar.\nEn resumen: la filosofía te ayudará a pensar mejor sobre cuestiones importantes en la vida y en las diferentes áreas de importancia. ¿Cómo se puede relacionar esto con la computación?\n¿Qué es la filosofía de la computación? # La filosofía de la computación es lo que acabamos de describir pero aplicado a las preguntas que le conciernen a la computación. Preguntas fundamentales para todos los que tenemos tratos profundos con las computadoras:\n¿Qué es la computación? ¿Qué es una computadora? ¿Qué es un programa? ¿Qué es computable? ¿Qué es programar? ¿Qué es un lenguaje de programación? ¿Cómo puedo crear programas útiles? Estas preguntas parecen tener un respuesta concreta pero hay algunas situaciones en los que podemos dudar de qué tan útil o real es lo que sabemos.\nLa filosofía no se queda allí, tiene por lo menos las siguientes áreas:\nLa ontología. En la que se preguntan cosas como las que acabamos de ver, que tienen que ver con la existencia y la definición de las cosas La semántica. El significado de los términos que usamos La axiología. Analiza los valores que fundamentan la computación y los eventos relacionados con estos La epistemología. Es el análisis del conocimiento y las formas de obtenerlo: ¿cómo podemos conocer más acerca de la computación? ¿Cómo podemos saber si lo que sabemos es correcto? ¿Cómo sabemos que sabemos? La metodología. Qué métodos podemos seguir para practicar la computación y la obtención de conocimiento de esta de la mejor manera La estética. Analiza la percepción que tenemos de los artefactos computacionales y los conceptos relacionados con encontrar agradable o de valor esa percepción: orden, belleza, significado, etc. La ética. Está basada en la axiología, es decir, en la definición de lo que consideramos de valor y qué acciones o prácticas nos acercan o alejan de lo que consideramos que puede ser \u0026ldquo;bueno\u0026rdquo; como resultado de la computación Como puedes ver, es amplia, pero cada una de las áreas te puede ayudar en temas específicos en tu práctica diaria.\nA diferencia de la filosofía común, la filosofía de la computación tiene mucho menos de existencia y a penas hay unos cuántos escritos y personas que la han practicado en los últimos años, así que si te introduces estarás en un campo en que tendrás que aplicar las técnicas filosóficas a esta área específica, y es probable que te lleves muchas sorpresas.\n¿Por qué es importante la filosofía de la computación? # La filosofía de la computación o de ciencias de la computación te puede ayudar dándote los fundamentos que necesitas sobre todo para enfrentarte a las cuestiones difíciles de tu trabajo.\nTener fundamentos para definir lo que quieres lograr, dónde están los límites de tu trabajo y qué es posible, te puede hacer mucho más disfrutable tu día a día.\nNo es algo sin lo que puedas trabajar, pero mientras más sepas de esta área, sin duda más disfrutarás de tu trabajo.\nPero esto va mucho más allá: todas las ideas importantes del desarrollo de software tienen un camino en la filosofía de la computación, así que si quieres desarrollar mejor software, sin duda es un área fundamental.\n¿Cómo aprender filosofía de la computación? # Recomiendo mucho empezar por lo básico y para esto me ha servido el canal de Camilo Chacón Sartori en YouTube, en el que tiene una serie en la que te introduce a las partes de la filosofía de la computación.\nPero también tiene un video que se llama ¿Qué es la filosofía de computación?, en el que te da una introducción básica.\nDespués, puedes empezar a leer sobre los autores que han escrito de esto por años. Yo recomiendo a William J. Rapaport con su escrito A Philosophy of Computer Science.\nY finalmente, para profundizar todavía más, tenemos el libro del mismo autor, publicado en 2023: Philosophy of Computer Science: An Introduction to the Issues and the Literature.\nSi le echas un ojo a esto y te parece intimidante, puedes entrar por algo que tiene una menor barrera y que también incluiría en el área de la filosofía de la computación: la filosofía de la información. Para esto recomiendo mucho el libro Data and Reality de William Kent. En el canal tenemos un resumen de este libro.\nConclusión # Aprender filosofía de la computación es una muy buena idea para tu carrera. Te ayudará a plantearte y a intentar resolver las preguntas importantes. Este intento de contestar las preguntas importantes relacionadas con la computación y el desarrollo de software te dará más armas para enfrentarte a los problemas del día a día y a disfrutarlos más.\nFinalmente, las herramientas que desarrollas en el estudio de estos problemas te puede ayudar mucho más allá de la filosofía: te ayudará a resolver problemas de manera más efectiva.\n","date":"19 agosto 2023","externalUrl":null,"permalink":"/2023/08/19/qu%C3%A9-es-la-filosof%C3%ADa-de-la-computaci%C3%B3n/","section":"Posts","summary":"\u003cp\u003eLa filosofía es una de las ramas más importantes del saber humano y, para mi, es la fundación de todas las demás ramas del conocimiento y de las ciencias. En este artículo hablaremos de la filosofía de la computación y cómo esta te puede ayudar como programador o desarrollador de software.\u003c/p\u003e","title":"¿Qué es la filosofía de la computación?","type":"posts"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/tags/computaci%C3%B3n/","section":"Tags","summary":"","title":"Computación","type":"tags"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/tags/filosof%C3%ADa/","section":"Tags","summary":"","title":"Filosofía","type":"tags"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/tags/filosof%C3%ADa-de-la-computaci%C3%B3n/","section":"Tags","summary":"","title":"Filosofía-De-La-Computación","type":"tags"},{"content":"Las ciencias de la computación a veces parecen algo mítico para los desarrolladores, algo que sólo aquellos que trabajan en Big Tech o en la NASA pueden entender. Pero si programas, es algo ya que usas a diario, por lo que te conviene comprenderlo mejor.\nEmpecemos por el principio definiendo qué son y cómo te pueden ayudar.\n¿Qué son las ciencias de la computación? # Las ciencias de la computación son un campo de estudio que busca entender los principios que rigen el fenómeno de la computación en general. Podemos definir la computación como el proceso de transformar información en algo útil, normalmente de manera dirigida.\nLas ciencias de la computación abarcan desde la definición y estudio conceptual de los principios que rigen la computación, hasta la implementación de algoritmos y estructuras de datos, junto con su ejecución en medios físicos. Esta última parte es la que más nos concierne como desarrolladores.\nComo podrás ver, es un campo muy amplio, pero muy interesante y que puede darte una visión más amplia de lo que haces día a día, pero que además te puede ayudar a comprender los componentes principales del entorno en el que tus programas corren y cómo funcionan.\nAlgunos de los principios temas que trata son:\nLo que es posible calcular y lo que no En qué medios se puede ejecutar un programa Cuáles son formas eficientes y confiables de almacenar información Cómo se puede representar la información Cómo se puede transmitir la información sin que se corrompa Cómo se puede transformar la información de manera eficiente Cómo proteger la información Cómo coordinar varias computadoras Cómo podrás ver, son problemas a los que nos enfrentamos día a día en nuestro trabajo de manera continua.\n¿Por qué son importantes? # La mayoría de los problemas que resolvemos en nuestro trabajo diario ya han sido resueltos en el pasado, por personas usando conocimientos que podemos considerar como ciencias de la computación y puestos en práctica en forma de algoritmos y estructuras de datos, implementados en los lenguajes de programación que usamos. También los frameworks y librerías que usamos son implementaciones de estos principios.\nPero, ¿qué pasa cuando quieres hacer algo que va más allá de lo que tu lenguaje o tu plataforma te ofrece por default? Aquí es donde entra el conocimiento de cómo funciona la computación de manera más profunda, los principios que rigen la computación, y las técnicas para resolver problemas.\nSi quieres hacer cosas que vayan más allá de lo común, las ciencias de la computación te pueden proporcionar las herramientas y habilidades para lograrlo de manera sostenible.\nSaber ciencias de la computación puede hacer la diferencia entre primero, que seas capaz de crear eficazmente lo que te estás imaginando y segundo que sea exitoso y pueda seguir creciendo.\n¿Cómo aprender ciencias de la computación? # La parte más importante de este artículo es cómo aprender ciencias de la computación. Si cursaste la universidad en una carrera relacionada con la computación, es probable que ya tengas las bases, o por lo menos la idea de los temas principales que puedes estudiar.\nPero lo triste es que casi siempre se enseña de manera segregada (se tratan los temas por separado sin ver la relación entre ellos) y desactualizada (se presenta la visión de los años 70s o 80s).\nPor eso, independientemente de tu formación, te recomiendo que leas los siguientes libros:\nComputational Thinking. En este libro tendrás una introducción a los temas principales del pensamiento computacional, algo completamente necesario para entender las ciencias de la computación. Great Principles of Computing. Para mi este libro presenta la visión más moderna de las ciencias de la computación. En el artículo \u0026ldquo;Libros que todo desarrollador debería leer: ciencias de la computación\u0026rdquo;, encontrarás más recomendaciones. Si no sabes nada de ciencias de la computación puede empezar con algo más ligero como:\nComputer Science Distilled CS50 Si tienes alguna otra recomendación, no dudes en ponerla en los comentarios.\nConclusión # Aprender ciencias de la computación es una buena idea para tu carrera, independientemente de la etapa en la que te encuentres o de la rama de la programación a la que te dediques. Te ayudará a evitar la frustración de no saber por qué algo no funciona, o peor aún, que funcione y no saber por qué.\nConsulta los recursos que recomendamos en este artículo y empieza a aprender hoy mismo. Además en este blog encontrarás muchos artículos relacionados con las ciencias de la computación, así que no dudes en explorarlos.\n","date":"12 agosto 2023","externalUrl":null,"permalink":"/2023/08/12/por-qu%C3%A9-debes-aprender-ciencias-de-la-computaci%C3%B3n/","section":"Posts","summary":"\u003cp\u003eLas ciencias de la computación a veces parecen algo mítico para los desarrolladores, algo que sólo aquellos que trabajan en \u003cem\u003eBig Tech\u003c/em\u003e o en la \u003cem\u003eNASA\u003c/em\u003e pueden entender. Pero si programas, es algo \u003cem\u003e\u003cstrong\u003eya que usas a diario\u003c/strong\u003e\u003c/em\u003e, por lo que te conviene comprenderlo mejor.\u003c/p\u003e","title":"¿Por qué debes aprender ciencias de la computación?","type":"posts"},{"content":"","date":"12 agosto 2023","externalUrl":null,"permalink":"/tags/ciencias-de-la-computaci%C3%B3n/","section":"Tags","summary":"","title":"Ciencias-De-La-Computación","type":"tags"},{"content":"","date":"12 agosto 2023","externalUrl":null,"permalink":"/tags/computer-science/","section":"Tags","summary":"","title":"Computer-Science","type":"tags"},{"content":"","date":"12 agosto 2023","externalUrl":null,"permalink":"/tags/cs/","section":"Tags","summary":"","title":"Cs","type":"tags"},{"content":"","date":"29 junio 2023","externalUrl":null,"permalink":"/tags/conocimiento/","section":"Tags","summary":"","title":"Conocimiento","type":"tags"},{"content":"","date":"29 junio 2023","externalUrl":null,"permalink":"/tags/epistemolog%C3%ADa/","section":"Tags","summary":"","title":"Epistemología","type":"tags"},{"content":"La epistemología es la rama de la filosofía que estudia la naturaleza del conocimiento. Una de sus principales tareas es la de estudiar cómo se adquiere el conocimiento y cómo se representa.\nLa matriz de Rumsfeld es una herramienta que nos ayuda a representar el conocimiento y a identificar qué conocimiento nos falta para tomar decisiones. En este artículo vamos a ver cómo funciona y cómo nos puede ayudar.\nLa matriz de Rumsfeld # Según nuestro grado de conocimiento y la consciencia que tenemos de él, podemos clasificarlo en 4 categorías:\nLo que sabemos que sabemos Lo que sabemos que no sabemos Lo que no sabemos que sabemos Lo que no sabemos que no sabemos La representación tradicional es la siguiente:\n{: .align-center}\nPero no me gusta porque pone las cuatro categorías como del mismo tamaño. Mi representación personal, que me parece que guarda mejor las proporciones es esta:\n{: .align-center}\nBueno, haciéndola un poco más legible (y rompiendo las proporciones) quedaría así:\n{: .align-center}\nPero quiero que te quedes con la idea de una frase que escuché en una serie llamada Dark: \u0026ldquo;Lo que sabemos que sabemos es una gota, lo que no sabemos es un océano.\u0026rdquo;\nEjemplos # Pongamos algunos ejemplos de cada categoría para entenderlos mejor.\nCategoría 1: Lo que sabemos que sabemos # En este área están todas las cosas que nuestra consciencia puede encontrar y a veces incluso explicar. Por ejemplo si eres programador sabes que sabes algún lenguaje de programación, como Python, Go, Scala. Hablando del futuro sabemos que es muy probable que todos estos lenguajes tengan nuevas versiones, o que se encuentren vulnerabilidades en ellos y que se tengan que actualizar.\nTambién podríamos incluir el conocimiento académico, cosas que hayamos estudiado recientemente y cosas similares.\nCategoría 2: Lo que sabemos que no sabemos # Siguiendo el ejemplo de los lenguajes de programación, normalmente sabemos uno o dos, pero estamos conscientes de que no conocemos su funcionamiento interno, o que no conocemos otros lenguajes, por ejemplo Ocaml, Haskell, etc. O sabemos que no podemos montar una infraestructura de Kubernetes, pero sabemos que existe y que hay gente que lo sabe hacer, así que podríamos investigarlo. También hay cosas que son imposibles de conocer y lo sabemos, por ejemplo, cuando va a salir exactamente la próxima versión de Python.\nCategoría 3: Lo que no sabemos que sabemos # Aquí se empiezan a poner difíciles las cosas, ¿cómo que hay cosas que no sabemos que sabemos? Este es el conocimiento tácito, cosas que hemos adquirido indirectamente o que ya están tan interiorizadas que no nos damos cuenta que sabemos. Por ejemplo cuando eres programador no te das cuenta que estás haciendo matemáticas con el simple hecho de programar. Entonces sabes matemáticas (por lo menos una rama de ellas), pero no te das cuenta. Otro ejemplo es con nuestro lenguaje natural, sabemos conjugar en todas las formas de subjuntivo, pero no sabíamos ni cómo se llama eso.\nUna sub-categoría este tipo de conocimiento es el que tenemos pero no nos damos cuenta que es relevante para el problema en cuestión que estamos tratando.\nCategoría 4: Lo que no sabemos que no sabemos # Esta es la más difícil de entender, en inglés le llaman los \u0026ldquo;unknown unknowns\u0026rdquo; y son todas aquellas cosas que no sabíamos siquiera que teníamos que preguntar. En el caso de los lenguajes de programación, por ejemplo está el caso de los lenguajes que ni siquiera hemos escuchado su nombre, o de todos aquellos conceptos que no sabemos que existen. Por ejemplo, si no sabemos que existe la programación funcional, no sabemos que no sabemos programación funcional.\nRespecto al futuro, este conocimiento son aquellas cosas que no podemos prever que pasarán, por ejemplo, que un proyecto dejará de mantenerse de manera súbita, que su autor principal morirá, etc.\nCuando eres completamente nuevo en un campo, esta parte es tan abrumadora y se come completamente a la categoría 2, las de las cosas que sabemos que no sabemos, que es muy fácil pensar que sabes todo lo que hay que saber, pero no es así. Cuando vas conociendo más el área o el tema, vas sacando cosas de esta categoría y las vas poniendo en la categoría 2, las cosas que sabes que no sabes, y ahí es cuando empiezas a de verdad conocer algo.\nLo más peligroso (y también la mayores oportunidades) para los proyectos y para nosotros están en esta categoría.\n¿Cómo nos ayuda esta clasificación? # Esta matriz nos da consciencia de la cantidad de conocimiento que nos hace falta y nos hace pensar además que hay cosas que ni siquiera nos imaginamos que no sabemos.\nLa matriz de Rumsfeld, está principalmente considerada como una herramienta para la toma de decisiones y el análisis de riesgos. Las principales formas de aplicarla son:\nAl planear de proyectos, en donde podemos analizar las cuatro categorías para encontrar los riesgos de que un proyecto sea factible y salga en el tiempo y presupuesto planeados. Al escoger tu stack tecnológico. Recuerda que cuando empiezas a conocer algo puedes sentir que lo sabes todo y tener una confianza excesiva al tener pocas preguntas sobre el tema, pero esto sólo es una señal de que la categoría 4, los desconocidos desconocidos, es demasiado grande. Eso es exactamente lo que pasa con las tecnologías demasiado nuevas o que estás empezando a conocer, lo que puede hacer que un proyecto se vuelva inviable. Por eso, guiarte por esta matriz para escoger la tecnología que vas a usar te puede proteger de tomar decisiones demasiado arriesgadas. Desarrollo de software resiliente. Al evaluar contra qué te deberías proteger, vale tener en cuenta que hay cosas que son imposibles de predecir o imposibles de saber. Esto te llevará a fortalecer las áreas del sistema críticas para recuperarse de cualquier problema, conocido o desconocido, que puedan afectar su funcionamiento general. Conclusión # La matriz del conocimiento nos ayuda a poner los pies en la tierra respecto a los riesgos y lo que de verdad podemos considerar que sabemos. Úsala para planear tus proyectos, escoger tu tecnología y proteger tus sistemas contra cosas que pueden ser catastróficas.\n","date":"29 junio 2023","externalUrl":null,"permalink":"/2023/06/29/la-matriz-del-conocimiento-para-devs/","section":"Posts","summary":"\u003cp\u003eLa epistemología es la rama de la filosofía que estudia la naturaleza del conocimiento. Una de sus principales tareas es la de estudiar cómo se adquiere el conocimiento y cómo se representa.\u003c/p\u003e","title":"La matriz del conocimiento para devs","type":"posts"},{"content":"","date":"27 junio 2023","externalUrl":null,"permalink":"/tags/creatividad/","section":"Tags","summary":"","title":"Creatividad","type":"tags"},{"content":"","date":"27 junio 2023","externalUrl":null,"permalink":"/tags/resoluci%C3%B3n-de-problemas/","section":"Tags","summary":"","title":"Resolución-De-Problemas","type":"tags"},{"content":"Hay algunas personas que creen que el desarrollo de software sólo trata de resolver problemas analíticamente, pero lo cierto es que para encontrar soluciones siempre se requiere de creatividad.\nSin embargo, muchas veces pensamos que la creatividad como desarrolladores de software no es nuestro fuerte, pero no hay nada más lejos de la realidad. Si te has dedicado exitosamente a esto por un tiempo, has demostrado que eres creativo o creativa, sólo que no de la manera que se considera tradicionalmente, eso que tiene que ver con el arte, la belleza y otras cosas.\nTu creatividad generalmente se demuestra en la aplicación y mezcla de ideas para resolver problemas en nuevas situaciones.\nEn el libro \u0026ldquo;Mind Management, Not Time Management\u0026rdquo; de David Kadavy, se habla de un ciclo de creatividad y en este artículo lo quiero aplicar a nuestro trabajo de desarrollo de software.\nEl ciclo de la creatividad # Creo que esto no te va enseñar nada nuevo, porque probablemente lo has vivido muchas veces. Pero vamos a ponerle estructura y nombres a los diferentes pasos para que podamos replicarlo de manera más consciente.\nEl ciclo de la creatividad está compuesto por cuatro fases:\nPreparación: Tienes que obtener la mayor cantidad información, estudiar el problema y se analizar las posibles soluciones. En nuestro caso incluso puede que tengamos que hacer algunas pruebas de concepto. Es muy importante entender que en esta etapa no vas resolver el problema, si encuentras algún tipo de bloqueo debes dejarlo pasar y seguir explorando. Incubación: En esta fase tienes que de pensar en el problema, se hace otra cosa, se descansa, se duerme, se hace ejercicio. Tu mente procesará lo que acabas de leer, de manera inconsciente. Iluminación: Esta parte no la puedes forzar, a veces incluso tienes que repetir las dos fases de manera cíclica hasta que llega la respuesta. Aquí es donde todo parece que hace click y la solución aparece \u0026ldquo;de la nada\u0026rdquo; (ya sabes que no es así porque has hecho mucho trabajo previo.) Verificación: Ahora que tienes una idea, falta comprobarla y más importante aún: llevarla a cabo. En esta tienes que asegurarte que la solución que encontraste es correcta, o tienes que hacer lo suficiente para empezar a probarla. Puede que te equivoques y tengas que volver a empezar el ciclo, pero con nuevos conocimientos. Este ciclo me pareció muy interesante porque se me hace equivalente en pasos a los pasos que George Polya propone. En su libro \u0026ldquo;How to Solve It\u0026rdquo; habla de cuatro pasos para resolver problemas:\nEntender el problema == Preparación e Incubación Idear un plan == Incubación e Iluminación (La parte más difícil, Polya dice que si tienes un plan, ya casi resolviste el problema) Llevar a cabo el plan == Verificación Revisar el plan == Verificación Ejemplo # El ejemplo más clásico en el que usamos el ciclo de la creatividad naturalmente es cuando estamos resolviendo un bug difícil. Veamos los pasos:\nPreparación: Intentamos entender el bug, y el comportamiento esperado, consultamos la documentación o el código que lo está produciendo. Si es lo suficientemente difícil, este bug se va con nosotros a dormir.\nIncubación: Después de sentirte derrotado por el bug, te alejas, ya sea porque terminó el día de trabajo, porque te vas a hacer otras cosas o porque simplemente te quieres despejar.\nIluminación: Durante alguna otra actividad, como bañándote, caminando, haciendo ejercicio o también cuando regreses al código, ves la solución, como si siempre hubiera estado ahí, de manera obvia.\nVerificación: Implementas la solución y pruebas que todo esté funcionando como debería.\n¿Ves cómo sí te ha pasado? Ese es el ciclo de la creatividad, que nosotros usamos resolviendo problemas. Veamos algunas formas de extenderlo y aprovecharlo mejor.\nAplicación: el poder de la preparación # Ahora que ya tienes un nombre para esto que te pasa muy constantemente, puedes aprovecharlo para desencadenarlo intencionalmente.\nAntes, pensemos un poco. ¿Cuál es la parte del ciclo que nos interesa aprovechar? Para mi es el poder de incubación, que es lo que produce la iluminación, o sea, lo que hace que te lleguen las ideas para resolver tu problema de manera creativa.\nPero, ¿cómo vas a incubar si no tienes nada que hacer crecer? Es aquí donde entra el valor de la preparación. Si quieres resolver un problema difícil, inclusive uno que sientes que ahora mismo está un poco por encima de tus capacidades, la mejor manera de hacerlo es aprovechando este ciclo. Primero te preparas lo mejo que puedas, estudiando el problema, analizando los posibles caminos que puedes seguir e incluso haciendo algunas pruebas de concepto. Seguro que esto ya lo haces.\nDespués y esto es la parte más importante de este artículo (y la que te puede estar fallando), tienes que alejarte del problema. Así es, olvídate de él, cambia de problema, ve a dormir, sal a pasear, date un baño. Tienes que hacer algo que ocupe tu mente.\nDavid Kadavy dice en su libro que esto te permite olvidarte de las ideas que no funcionan y fortalecer las que sí, y me parece una buena propuesta. Si lo comparas con un algoritmo, buscar una solución a un problema es como hacer una búsqueda en un árbol, sólo que este árbol tiene más ramas de las que puedes seguir, así que tienes que podarlas. La incubación es la poda, que además fortalece las ramas que es más probable que te lleven a la solución.\nEsto también se puede aplicar de manera más sencilla.Por ejemplo, ¿tienes que diseñar una pieza de software y sientes que no tienes ni idea de por dónde empezar? Combinando las enseñanzas de Polya con el ciclo de la creatividad, lo primero es definir completamente el problema. Una vez que sientas que lo has entendido (muchas veces ayuda ponerlo por escrito e incluso pedir que alguien más lo revise).\nDespués de esto, sobre todo si no tienes una solución clara, o propuestas que hacer, busca alejarte lo más posible. Es por eso que muchos profesionales veteranos y exitosos tienen actividades alternas, alejadas de la programación e incluso de la computadora. Cuando regreses a trabajar sobre el problema, es mucho más probable que tengas una solución.\nSe que esto suena mágico, pero nada te puede convencer más que la propia que ya tienes resolviendo problemas de otro estilo. Si esto no funciona, recuerda que puedes repetir el ciclo tantas veces como sea necesario.\nClaro, esto no asegura que la solución te llegará mágicamente siempre, pero con esto aumentamos las probabilidades de que tu naturaleza creativa trabaje por ti.\nConclusión # Siempre que puedas, frente a problemas difíciles, aplica este ciclo: prepárate lo mejor que puedas, explorando soluciones, asegurándote de entender todas la variables del problema, escribiendo la definición del problema. Después aléjate de problema, así permitirás que se incube.\nFinalmente, regresa y trata de resolverlo de nuevo. Claro que después de esto tienes que ejecutar y verificar tu solución.\nEspero que esta información te sea útil y que la puedas aplicar en tu día a día.\n","date":"27 junio 2023","externalUrl":null,"permalink":"/2023/06/27/sigue-el-ciclo-de-la-creatividad/","section":"Posts","summary":"\u003cp\u003eHay algunas personas que creen que el desarrollo de software sólo trata de resolver problemas analíticamente, pero lo cierto es que para encontrar soluciones siempre se requiere de creatividad.\u003c/p\u003e\n\u003cp\u003eSin embargo, muchas veces pensamos que la creatividad como desarrolladores de software no es nuestro fuerte, pero no hay nada más lejos de la realidad. Si te has dedicado exitosamente a esto por un tiempo, has demostrado que eres creativo o creativa, sólo que no de la manera que se considera tradicionalmente, eso que tiene que ver con el arte, la belleza y otras cosas.\u003c/p\u003e","title":"Sigue el ciclo de la creatividad","type":"posts"},{"content":"","date":"22 junio 2023","externalUrl":null,"permalink":"/tags/desarrollo-de-software/","section":"Tags","summary":"","title":"Desarrollo-De-Software","type":"tags"},{"content":"La mente es la principal herramienta del desarrollador de software. Puedes ayudar a que se desempeñe mejor si le das, a su vez, herramientas que te permitan organizar, comprender, combinar y analizar más rápido la información. Estas herramientas además te pueden ayudar a ver cosas claramente que antes eran imposibles de ver, o a llegar más profundo en los análisis.\nEstas herramientas son los modelos mentales, que en este artículo explicaremos, pero además daremos algunos ejemplos que te servirán directamente como desarrollador. Estos ejemplos son, a nuestro modo de ver, los modelos esenciales que debes conocer. Empecemos dando una definición clara.\n¿Qué son los modelos mentales? # Un modelo mental es una estructura que te permite organizar la información que recibes o que observas, para que puedas ver aspectos particulares de esta, aplicarle proyecciones o simplemente para que puedas entenderla mejor. También se puede pensar en ellos como en lentes que te permiten ver el mundo de una forma particular.\nLos desarrolladores de software estamos acostumbrados a usar modelos para representar la realidad. Recuerda que un modelo es una abstracción, una representación simplificada de la realidad que se enfoca en ciertos elementos y deja fuera otros.\nLos modelos mentales son esto mismo, pero la diferencia es que tienen aplicación a través de muchas situaciones. Estos modelos mentales te permiten usar la información de manera más eficiente y, a veces, ver la realidad más claramente. Charlie Munger, uno de los principales proponentes de los modelos mentales, dice que para pensar efectivamente, debes tener una malla o red de modelos mentales que puedas usar para pensar mejor. Algo a lo que se pueden parece un poco es a los patrones de diseño, pero aplicados a la vida real.\nNuestro objetivo es ayudarte a construir esta malla de modelos mentales que te permitan ser más efectivo en el desarrollo de software. Empecemos con los más básicos.\nLa navaja de Ockham # Este es uno de los modelos mentales que más personas conocen. En líneas generales establece que cuando estés buscando explicaciones a algo que hayas observado y estés decidiendo entre varios posibles caminos, el más sencillo es el que tiene la mayor probabilidad de ser la explicación correcta.\n¿Cómo se puede aplicar a los problemas que nos enfrentamos comúnmente como desarrolladores? Siempre que estés decidiendo entre diferentes diseños que cumplen con los requerimientos actuales, escoge el más sencillo de los diseños, sin dejarte influir demasiado por que podrías necesitar en el futuro. Esto se conecta con el principio de YAGNI (You aren\u0026rsquo;t gonna need it), que dice que no debes implementar cosas que no necesitas ahora, porque podrías necesitarlas en el futuro. También se conecta con el principio de buscar la simplicidad al máximo en el desarrollo de software.\nTambién lo puedes aplicar a los procesos que modelas en el software: cuando estés descubriendo el por qué de algo,\nEl mapa no es el territorio # Los desarrolladores de software trabajamos creando modelos de la realidad que pueden ser representados dentro de una computadora, muchas veces para simular procesos o simplemente capturamos ideas que ya son abstractas para que corran dentro de la computadora.\nUn mapa es un modelo de un territorio físico. Pero podemos cometer el error de pensar que el mapa y el territorio son equivalentes, cuando lo cierto es que, al ser un modelo, el mapa es una representación imperfecta y simplificada del territorio real.\nAsí son todos los modelos y debemos recordarlo, para muchos casos, la mayoría yo diría, no existe un modelo absolutamente correcto y todos dejan algo fuera. Todos son arbitrarios y si alguien de nuestro equipo tiene una visión diferente, deberíamos escucharla, tratar de entenderla y ver cómo podemos integrar ambas visiones en un solo modelo.\nTus representaciones, tus modelos, no son la realidad, por lo que siempre pueden mejorarse. Además de que confiar en un modelo como en una guía perfecta te puede llevar a cometer errores graves. Es por eso que es bueno recordar siempre, que los modelos (los mapas) son representaciones imperfectas de la realidad (el territorio), y que algunos son más convenientes que otros para diferentes acciones o situaciones, además de que no existe EL MODELO correcto para cierta situación.\nSi aplicas este modelo mental a los mismos modelos mentales, verás por qué necesitas una variedad de ellos para poder pensar mejor.\nEl ganador se lo lleva todo # Hay procesos en el mundo, de hecho, muchos, en los que los \u0026ldquo;premios\u0026rdquo; (puedes pensar en ellos como las recompensas o beneficios de una actividad) no se distribuyen uniformemente, sino que las ganancias se acumulan en un sólo lugar, para que unos pocos se lleven la mayoría de los beneficios.\nEn la actualidad, muchos procesos se comportan así, pero además se exacerba con la tecnología digital, en la que los ganadores de procesos como por la creación de contenido. Para aplicar este modelo, debes aprender a ver quién se lleva la mayoría de los beneficios.\nEste modelo aplicado al software se puede ver en la puesta en marcha de las aplicaciones, pero de forma inversa. A diferencia de lo que puede pasar en otras industrias, un proyecto a medio terminar provee un valor casi nulo. Yo me atrevería a decir que un proyecto de software que no esté en producción, vale cero. Así que, siempre esfuérzate por entregar el software o ponerlo en manos de tus usuarios lo más pronto posible.\nLa falacia del costo hundido # Todos hemos enfrentado esta pregunta: ¿sigo invirtiendo tiempo y esfuerzo en este proyecto que no está dando resultados? ¿Hasta cuando debo seguir invirtiendo en este proyecto?\nA veces llegamos a la conclusión de que lo mejor sería dejar de invertir en ese proyecto YA MISMO, pero algo nos detiene: el tiempo y esfuerzo que ya hemos invertido. Esto es el costo hundido. Los seres humanos tenemos naturalmente más aversión por perder algo, que deseos de ganar más cosas.\nPensar que lo que ya invertimos lo vamos a perder si dejamos algo que no nos ha dado resultados (y no tiene pinta de que los vaya a dar) nos detiene de tomar decisiones que son muy claras: si no hubiéramos invertido ese tiempo y esfuerzo, no tendríamos razones para seguir invirtiendo en este proyecto o aunque sea para mantenerlo. O sea que una inversión pasada, en vez de producirnos beneficios, nos está produciendo pérdidas, por el puro temor a perderla.\nEste modelo mental se puede aplicar a los proyectos de desarrollo de software que después de cambiar de estrategia muchas veces no han dado rendimientos. Además como desarrolladores a veces estamos orgullosos de la arquitectura o los logros técnicos de cierto sistema o cierta parte del código, pero ha llegado el momento de reemplazarla por algo que se adecúe mejor a las necesidades actuales.\nRecuerda que el esfuerzo o tiempo que ya invertiste nunca es una razón suficiente para mantener algo, sobre todo si hay razones para tomar otro camino.\nRendimientos decrecientes # Hay muchos procesos en la vida cotidiana en los que observamos que \u0026ldquo;mientras más, mejor\u0026rdquo;. Como máquinas de generalización que somos, tendemos a extender este pensamiento a todas las cosas en la vida, pero muchas cosas, no se comportan así.\nDe eso trata la ley de rendimientos decrecientes, te hace entender que no siempre más es mejor. De hecho, en la mayoría de los procesos naturales se cumple una ley:\nPor cada unidad añadida, el rendimiento de la siguiente unidad va a disminuir.\nAsí es: hay muchas cosas en la naturaleza que mientras más tienes de ellas, cada cosa que añades te va a dar menos beneficios que la cosa anterior que añadiste. Algunos ejemplos empíricos:\nHacer ejercicio es muy bueno, si haces por lo menos 1 hora 4 veces a la semana ejercicio de cierto tipo te vas a sentir muy bien (claro combinado con otros factores como la buena alimentación). Pero si haces el doble de ejercicio, no te vas a sentir el doble de bien, de hecho si llegas a cierto punto, como hacer 3 horas diarias te vas a sentir excesivamente cansado y puede que con el tiempo tu cuerpo muestre señales de fatiga.\nSi estás en un restaurante y pides un postre, el primero te va a saber muy bien, pero si pides otro, el segundo no te va a saber tan bien como el primero, y si pides otro, puede que te enfermes y termines odiando ese postre específico.\nCuando riegas una planta, echarle agua es bueno hasta cierto punto, si le echas demasiada, la planta se va a ahogar y se va a morir.\nSalir al sol está bien, es bueno para nuestra salud si lo haces a la hora correcta y cuidas la cantidad de sol a la que te expones. Pero si te expones demasiado, te vas a quemar y vas a tener problemas de salud.\nEl dinero: tener dinero es bueno hasta cierto punto, pero a partir de cierta cantidad (que a mi parecer depende de el lugar en el que vivas), que si la superas 1) no te va a hacer más feliz, 2) te meterá en problemas que no tenías antes. La siguiente gráfica muestra la relación entre estos bienes y la felicidad:\n{: .align-center}\nEn estos ejemplos hablamos de cosas buenas que primero te van dando cada vez menos beneficios, y luego se pueden volver perjudiciales. Para aplicarlo al desarrollo de software piensa en los siguientes ejemplos:\nEquipos: Un equipo bien balanceado es necesario para hacer proyectos serios, pero eso no significa que mientras más grande el equipo, mejor. Cada persona agregada al proyecto va agregando menos valor que la anterior y muy rápido se llega al punto en el que una persona más añadida daña la productividad del equipo.\nHoras de trabajo: A (casi) todos nos gusta nuestro trabajo y para lograr nuestros objetivos, en general, debemos de ponerle bastantes horas. Sin embargo, si trabajamos demasiado en un corto espacio de tiempo van a pasar dos cosas progresivamente: 1) Cada hora de trabajo sin que te distraigas va a rendir menos y 2) si sigues trabajando a pesar de esto, vas a cometer errores que después te puede costar mucho tiempo arreglar, o incluso cometer errores que no puedas arreglar, catastróficos (por ejemplo: un DELETE sin WHERE).\nAbstracción: En el desarrollo de software, la abstracción es una herramienta esencial y siempre se necesita de ella para crear buen software. Pero si abstraes demasiado, tu código se vuelve inmantenible y muy difícil de entender. Igual que con otras cosas, el punto de retornos negativos de la abstracción es muy fácil de alcanzar.\nPruebas unitarias: Las pruebas unitarias son una gran herramienta tanto para asegurar la calidad del software como para ayudar en su diseño. Sin embargo, hay una tendencia a querer buscar que todo tu código esté cubierto por pruebas unitarias: tener 100% de cobertura. Este es un caso muy característico de rendimientos decrecientes: mientras más pruebas unitarias tengas, cada prueba unitaria que agregues va a darte menos beneficios que la anterior, pero se pone peor. Intentar tener 100% de pruebas te lleva a hacer código que mucho más complejo y difícil de mantener.\nPara mi, este es uno de los modelos mentales más útiles, debido a que estamos en un mundo en el que ser eficiente en recursos te puede dar una gran ventaja competitiva.\nRecursos para seguir aprendiendo sobre modelos mentales # Los siguientes libros y blogs(todos en inglés) te pueden enseñar mucho más de modelos mentales y su aplicación:\nFarnam Street: Blog y sus libros sobre modelos mentales. Super Thinking: The Big Book of Mental Models The Model Thinker: What You Need to Know to Make Data Work for You Un medio más reciente es el canal de Vicky Zhao en YouTube que además de hablar de modelos mentales, también habla de cómo usarlos para comunicarte claramente. Conclusión # Los modelos mentales son herramientas para organizar la información que son muy útiles para personas que trabajan principalmente pensando y analizando el mundo real. Los desarrolladores de software pertenecemos a ese grupo, así que aprender a modelar la realidad de forma más efectiva puede darnos una gran ventaja para resolver problemas y así avanzar más rápido en nuestra carrera.\nSeguiremos creando más artículos hablando de esto, para darte herramientas que te permitan ser un mejor desarrollador de software y mejor profesional.\n","date":"22 junio 2023","externalUrl":null,"permalink":"/2023/06/22/modelos-mentales-para-desarrolladores-modelos-elementales/","section":"Posts","summary":"\u003cp\u003eLa \u003cstrong\u003emente\u003c/strong\u003e es la principal herramienta del desarrollador de software. Puedes ayudar a que se desempeñe mejor si le das, a su vez, herramientas que te permitan \u003cem\u003eorganizar, comprender, combinar y analizar más rápido la información\u003c/em\u003e. Estas herramientas además te pueden ayudar a ver cosas claramente que antes eran imposibles de ver, o a llegar más profundo en los análisis.\u003c/p\u003e","title":"Modelos mentales para desarrolladores: modelos elementales","type":"posts"},{"content":"","date":"22 junio 2023","externalUrl":null,"permalink":"/tags/modelos-mentales/","section":"Tags","summary":"","title":"Modelos-Mentales","type":"tags"},{"content":"Los principios SOLID, se enseñan como verdades incuestionables sobre el buen desarrollo de software. Aunque, justo por la educación, antes era completamente partidario de estos, con el tiempo me fui dando cuenta de varias de las fallas que presentan.\nEn este artículo te voy a hablar de las fallas generales como conjunto, pero también es un índice para una serie de artículos que escribí sobre cada uno de ellos, analizándolo a profundidad.\nAmbigüedad # Cuando buscas la explicación sobre cómo aplicar alguno de estos principios, normalmente encuentras muchas explicaciones diferentes. Algunas de estas explicaciones se contraponen, siguen siendo ambiguas, o de plano no se entienden.\nCon el principio que más pasa es con el \u0026ldquo;Single Responsibility\u0026rdquo; (SRP), en el cuál diferentes personas no nos ponemos de acuerdo respecto a lo que una \u0026ldquo;Responsabilidad\u0026rdquo; significa. Pero también pasa con la aplicación de los demás principios a diferentes entornos de programación.\nComplican exageradamente el código # La aplicación sin razonamiento profundo de estos principios puede complicar el código de manera exagerada, sobre todo en lenguajes inflexibles o con sistemas de tipos complicados (sí, te estoy viendo a ti, Java), que justo es donde más se aplica.\nEl ejemplo más claro de esto es el \u0026ldquo;Dependency Inversion Principle\u0026rdquo;, que te lleva a hacer cosas bastante raras en el código para lograrlo, como ya dije, sobre todo cuando el sistema de tipos te lo complica.\nY aunque es cierto que a veces es necesario y bastante útil hacer lo que este principio propone, para mi el 80% del software no lo necesita y sólo estás haciendo una sobre-ingeniería que no se justifica.\nSe usan como un código moral # Los principios SOLID, entre otras cosas, normalmente se usan para avergonzar a las personas que no los conocen o no los aplican. Normalmente hablan de tu valía como desarrollador@ de software basado en el supuesto conocimiento de cosas como estas, y otros principio o reglas (completamente) arbitrarias, sobre todo basadas en el libro Clean Code.\nEsta revoltura de principios morales y conveniencia técnica es un gran error para la comunidad de software, ya que lleva a la sobre-ingeniería, a la aplicación ciega de principios y técnicas que no tienen sentido en tu caso particular e incluso al desprecio del trabajo de otros programadores.\nPara mi, este es el punto más grave, tal vez no directamente de los principios SOLID, sino de la forma en la que se enseñan.\nAnálisis más profundo # En este blog hemos escrito 5 artículos analizando cada uno de los principios que lo componen, viendo si conviene aplicarlos y describiendo alternativas. En la mayoría de los casos incluso hablamos de principios más profundos (lo que nos hace ver que los \u0026ldquo;principios SOLID\u0026rdquo; debería ser algo como \u0026ldquo;reglas SOLID\u0026rdquo;).\nAquí los puedes ver:\nSRP: Análisis de los Principios SOLID: Principio de Responsabilidad Única OCP: El Principio Abierto/Cerrado LSP: El Principio de Sustitución de Liskov ISP: El Principio de Segregación de Interfaces DIP: El Principio de Inversión de Dependencias Espero que estos artículos te sirvan para analizar más profundamente lo que todos enseñan como dogmas que se deben de seguir al pie de la letra, bajo la amenaza de no ser un buen programador o programadora que se irá al infierno de los desarrolladores si no lo sigue.\n","date":"17 junio 2023","externalUrl":null,"permalink":"/2023/06/17/son-aplicables-y-pr%C3%A1cticos-los-principios-solid/","section":"Posts","summary":"\u003cp\u003eLos \u003cstrong\u003eprincipios SOLID\u003c/strong\u003e, se enseñan como verdades incuestionables sobre el buen desarrollo de software. Aunque, justo por la educación, antes era completamente partidario de estos, con el tiempo me fui dando cuenta de varias de las fallas que presentan.\u003c/p\u003e","title":"¿Son aplicables y prácticos los principios SOLID?","type":"posts"},{"content":"","date":"17 junio 2023","externalUrl":null,"permalink":"/tags/principios/","section":"Tags","summary":"","title":"Principios","type":"tags"},{"content":"","date":"17 junio 2023","externalUrl":null,"permalink":"/tags/solid/","section":"Tags","summary":"","title":"Solid","type":"tags"},{"content":"","date":"15 junio 2023","externalUrl":null,"permalink":"/tags/career/","section":"Tags","summary":"","title":"Career","type":"tags"},{"content":"","date":"15 junio 2023","externalUrl":null,"permalink":"/tags/desarrollo-de-carrera/","section":"Tags","summary":"","title":"Desarrollo-De-Carrera","type":"tags"},{"content":"","date":"15 junio 2023","externalUrl":null,"permalink":"/tags/historia/","section":"Tags","summary":"","title":"Historia","type":"tags"},{"content":"En este artículo vamos a hablar de los libros que te pueden ayudar a avanzar en tu carrera como desarrollador de software, que desde mi punto de vista, son esenciales.\nAlgunos desarrolladores piensan que basta simplemente con aprender a programar o diseñar software bien, pero lo cierto es que también hay que tener otras habilidades y conocimientos para que tu carrera avance a buen ritmo, y llegues a puestos de liderazgo si así lo deseas.\nEn este post hablaremos de tres tipos de libros:\nConsejos de carrera para desarrolladores y habilidades blandas Libros de historia de la computación Temas que te pueden ayudar a desarrollar habilidades de soporte Como siempre, si tienes alguna recomendación, puedes dejarla en los comentarios. Empecemos.\nDesarrollo de carrera # En estos libros verás consejos específicos de desarrolladores experimentados sobre la carrera de programador, qué habilidades y actitudes te conviene desarrollar.\nThe Pragmatic Programmer | David Thomas \u0026amp; Andrew Hunt # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEste es uno de los mejores libros sobre la carrera como programador, que te da consejos de dos programadores muy muy experimentados. Su tema principal es el pragmatismo, que es una filosofía que te dice que no hay una sola forma de hacer las cosas, sino que debes adaptarte a las circunstancias y hacer lo que sea necesario para lograr tus objetivos. Otra forma de ver el pragmatismo es que hay que ser práctico, y no darle tantas vueltas a las cosas.\nA grandes rasgos trata estos temas:\nIntroducción a la filosofía pragmática Cómo ser pragmático al desarrollar software (nota que no es al programar, sino al crear programas) Herramientas que te pueden servir para desarrollar buen software Cómo llevar un proyecto pragmáticamente Estaba en la duda de clasificarlo entre los libros de desarrollo de software o desarrollo de carrera, porque aunque habla sobre técnicas específicas y temas técnicos, su espíritu es una meta-habilidad o una actitud hacia el desarrollo y hacia la vida: el pragmatismo.\nPuedes comprarlo aquí: The Pragmatic Programmer{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nThe Practice of Programming | Brian W. Kernighan \u0026amp; Rob Pike # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nBrian W. Kernighan es un desarrollador de software, programador y científico de la computación de las grandes ligas. ¿Has escuchado sobre AWK? Es un programa y lenguaje programación legendario, y se llama así por sus creadores: Alfred Aho, Peter Weinberger y Brian Kernighan.\nRob Pike es uno de los co-creadores del lenguaje de programación Go, y también es un desarrollador de software con mucha experiencia. Ha co-creado otros lenguajes de programación, como Oberon.\nEn \u0026ldquo;The Practice of Programming\u0026rdquo; explican todas las prácticas que un desarrollador de software debe tener o aprender para desarrollar software exitosamente. Este libro se guía por los siguientes principios:\nSimplicidad Claridad Generalidad Automatización Estos principios son aplicados a cosas como el estilo, la documentación, las pruebas, etc. Al igual que el libro anterior, estaba dudando en clasificarlo como libro de desarrollo de software, pero creo que el enfoque general, aunque muy técnico, va más enfocado en el desarrollo de una mentalidad conveniente.\nPuedes comprarlo aquí: The Practice of Programming{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nCode Ahead | Yegor Bugayenko # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nYegor Bugayenko es un autor poco conocido de este lado del mundo, pero en Rusia es más famoso. Ha escrito varios libros sobre programación como \u0026ldquo;Elegant Objects\u0026rdquo; (1 y 2). Pero también escribió este libro sobre la carrera de programador, que es muy bueno.\nYo lo describiría como una visión cínica de la carrera de programación, con algunas recomendaciones sobre actitudes, formas de trabajo y tácticas para progresar en tu carrera. No creo que se deba tomar como una guía, sino más bien como un contrapeso a las opiniones de carrera más tradicionales, para ampliar tu visión. Además sí creo que dice algunas verdades incómodas que no a todos les gustará escuchar.\nEl punto débil de libro es su formato (que para mi falló completamente), en el que trató de hacer un historia de ficción (supongo que al estilo de The Phoenix Project), pero que en realidad sólo consiste en una serie de explicaciones del protagonista.\nA pesar de lo mencionado anteriormente, creo que es un libro que vale mucho la pena leer y que te puede ayudar a ver las cosas desde otra perspectiva.\nPuedes comprarlo en Amazon: Code Ahead{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nThe Phoenix Project | Gene Kim, Kevin Behr \u0026amp; George Spafford # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEste libro, a diferencia del anterior es una novela que sí salió bien, en la que describe la progresión de alguien del área de IT que obligadamente se convierte en líder del área. Describe como es que las áreas de IT se convierten de cuellos de botella en partes que agregan valor a la empresa.\nEl libro da los fundamentos de DevOps, y cuáles son los principios que todos los equipos de desarrollo de software deberían seguir para producir software más efectivamente.\nAunque está enfocado en la operación y la entrega del software, a final de cuentas, es donde todos queremos que nuestro software llegue, así que todos los desarrolladores de software se pueden beneficiar de los principios que presenta.\nSe ha convertido en un clásico, y con justa razón. Lo puedes comprar aquí: The Phoenix Project{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nLibros de historia de la informática # En esta sección recomendaremos algunos libros que creemos que te pueden ayudar a conocer más la historia de tu campo y que por lo tanto te ayudarán a aprender de lo que ya se ha hecho. Esto te ayudará a no cometer los mismos errores y más mejor, \u0026ldquo;pararte en hombros de gigantes\u0026rdquo; para poder ver más lejos.\nAfortunadamente, de estos tenemos tanto libros en inglés como en español.\nHistoria de los lenguajes de programación: Años 1940-1959 | Manuel Rubio # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nAquí, Manuel Rubio explica el nacimiento de las lenguajes de programación y cómo esto va de la mano con la historia de la computación. Me gusta mucho de este libro que te da una visión más amplia que la centra en US que normalmente nos dan en la escuela y en la mayoría de los libros de computación.\nManuel hizo una investigación muy amplia, cuestiona algunas cosas implícitamente (¿de verdad fue Ada Lovelace la primera programadora?) y te da una visión más amplia de lo que significa la computación.\nMe gusta mucho que resalta algunas cosas que nos siguen sucediendo hoy:\nNos cuesta naturalmente despegarnos del trabajo El campo siempre se ha resistido a las innovaciones Siempre creemos que lo que viene después de lo que ya sabemos tiene menos valor En el blog hicimos ya un resumen de este libro{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;} y también hicimos un resumen en video pero sinceramente te recomiendo leerlo completo.\nLo puedes comprar aquí: Historia de los lenguajes de programación{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}. Si necesitas un descuento para comprarlo, no dudes en contactarme o contactar a Manuel, que es muy accesible y una gran persona.\nMentes Geniales | Camilo Chacón Sartori # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nCamilo Chacón Sartori es un gran desarrollador de software, pronto Doctor en Ciencias de la computación y escritor. Ha escrito varios libros de programación o temas relacionados y en realidad es un escritor (y lector, ¿se puede ser buen escritor sin leer mucho?) muy prolífico.\nEn este libro, habla de 12 personas que han contribuido de diferentes formas al desarrollo de la computación y se les ha reconocido con el Premio Turing. Aunque no es un libro histórico en todo el sentido de la palabra, además de que no sigue una cronología, sí habla de importantes eventos históricos de la computación y desarrollo.\nLo recomiendo porque no sólamente te habla de los logros de las personas que menciona, analiza su entorno, te cuenta sobre su personalidad y extrae lecciones. Además, te deja las fuentes y referencias por si quieres leer más de ellos.\nAlgunos de los personajes que a mi me impactaron:\nManuel Blum - El creador de CAPTCHA Michael Stonebraker - El creador de PostgreSQL Barbara Liskov - Una gran proponente de los tipos abstractos de datos Leslie Lamport - Un gran matemático que ha contribuido a la computación con cosas como el algoritmo de Paxos y TLA+ Richard Manning Karp - Un matemático que ha contribuido a la computación con cosas como el algoritmo de Karp-Rabin y el análisis de complejidad de algoritmos Sin duda te llevarás muchas buenas lecciones y aprendizajes sobre el desarrollo de la computación de este libro. Lo puedes comprar aquí: Mentes Geniales{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nDealers of Lightning: Xerox PARC and the Dawn of the Computer Ag | Michael A. Hiltzik # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEn los años 70 y 80\u0026rsquo;s, la compañía Xerox (sí, la de las impresoras), consiguió un equipo de personas muy hábiles con la tecnología. Eran conocidos como el PARC (Palo Alto Research Center) y fueron los creadores de muchas de las tecnologías que hoy usamos, como:\nLa primera computadora personal La interfaz gráfica La impresora láser Todas estas tecnologías cambiaron el mundo, ayudando a crear la tecnología que hoy en día nos da trabajo y ha moldeado todas las industrias y la vida en general.\nEste libro está basado en entrevistas con las personas que vieron de cerca estas creaciones y que muestran cómo es que Xerox nunca vio el potencial de las creaciones de este equipo de ingenieros. Si quieres aprender sobre la historia de la tecnología que tenemos hoy, ver cómo se forman equipos de altísimo rendimiento y aumentar tus posibilidades de crear algo que sea digno de mención, este libro es un gran recurso.\nPuedes comprarlo aquí: Dealers of Lightning{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nLa Catedral de Turing | George Dyson # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEn este libro se narra el comienzo de la computación después de la segunda guerra mundial y de todos los actores que tuvieron un impacto en el desarrollo de la computación moderna.\nEs una crónica muy completa, junto con la explicación de muchos conceptos de la computación. El autor, hijo del físico Freeman Dyson, tuvo acceso a muchos de los actores de la historia y a sus documentos, lo que le permitió hacer una libro que revela muchos detalles.\nSin duda es algo que muchos dedicados a esta área del conocimiento queremos leer. Lo puedes comprar aquí: La Catedral de Turing{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nOtros temas relacionados # Finalmente, como última parte de este artículo y de la serie de libros recomendados. Quiero poner algunas recomendaciones sobre temas y habilidades alternas a la programación que te ayudarán tanto como programador como a desarrollar tu carrera.\nAlgunos de estos temas o libros pensarás que no tienen nada que ver, pero te puedo asegurar que son habilidades y temas de soporte necesarios que te van a ayudar a resaltar.\nHow to solve it | George Polya # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nGeorge Polya fue un matemático del Siglo XX que contribuyó en el área de heurística y resolución de problemas. Fue un gran profesor al mismo tiempo que un gran investigador. Este libro es una combinación de ambas facetas de él: le preocupaba que las matemáticas se enseñaran bien al mismo tiempo que él era muy bueno haciendo matemáticas.\nEn este escrito, Polya establece los pasos a seguir para resolver problemas matemáticos, pero que por extensión también nos sirve a los desarrolladores para aprender a establecer un método para resolver los problemas que encontramos día a día en nuestro trabajo.\nLos cuatro pasos que propone son:\nPlantear y entender correctamente el problema Idear un plan para resolverlo (aquí da algunas técnicas comunes) Ejecutar el plan Revisar el resultado, el proceso y los aprendizajes Cuando lo leí, noté inmediatamente que era un libro que se debería dar en todas las escuelas relacionadas con la ingeniería o la computación, ya que nos da claridad, o por lo menos una idea de cómo empezar a resolver algo.\nLo puedes comprar aquí: How to solve it{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}, pero también lo puedes leer gratis: Cómo plantear y resolver problemas.\nEnfócate | Cal Newport # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nLa atención es uno de los bienes más preciados que tenemos los seres humanos, ya que a nuestra mente consciente sólo entra aquello a lo que la dirigimos o enfocamos. Pero cuando más beneficios da es cuando la enfocamos en una sola cosa por un periodo prolongado. Es como si nuestra mente fuera acelerando y tomando impulso para resolver un problema.\nEsa es la tesis principal de \u0026ldquo;Enfócate\u0026rdquo;, un profesor de ciencias de la computación, muy interesado en temas como el logro académico, la productividad intelectual y el rendimiento a pesar de los obstáculos modernos.\nEn este libro, presenta un caso muy sólido para convencerte de apartar tiempo ininterrumpido para lograr tus tareas más difíciles. Además, relata cómo él lo logra y te da algunos consejos para que tú lo puedas hacer.\nCreo que este libro es especialmente relevante para los desarrolladores de software por el entorno en el que trabajamos y porque muchos de los problemas que enfrentamos rebasan nuestra capacidad o conocimiento actual, por lo que necesitamos toda la ayuda posible para poder resolverlos.\nPuedes comprarlo aquí: Enfócate{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nAccelerate | Nicole Forsgren # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\n¿Qué es lo que distingue a un equipo de alto rendimiento en la entrega de software de uno de bajo rendimiento? La medida más básica es el tiempo que toma un cambio en ser liberado o en llegar a producción. En este libro se habla de 1) cómo medir esto y 2) los factores que llevan a un equipo a mejorar esas métricas.\nEn realidad el libro es el resultado de un estudio de muchos equipos de desarrollo de software, en el que descubrieron varias cosas acerca de los equipos de alto rendimiento, entre ellas:\nLas prácticas técnicas que tienen El tipo de liderazgo que los guía Qué tipo de arquitecturas siguen Qué prácticas de administración de recursos humanos siguen Cómo hacen todo el trabajo sostenible Además el libro habla de la forma en la que se realizó el estudio. Sin duda, es un libro muy valioso para los desarrolladores de software que quieren mejorar su rendimiento y el de sus equipos. Puedes comprarlo aquí: Accelerate{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nData and Reality | William Kent # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nCreo que como programadores, gran cantidad del tiempo lo dedicamos a procesar datos, o a crear representaciones datos de procesos externos a la computación. Esto es el modelado de datos, y es de lo que este libro habla, pero de manera bastante especial.\nWilliam Kent hace un análisis profundo de las cosas a las que estamos acostumbrados: modelos, datos, registros, relaciones, atributos, entidades. Primero, intenta definirlas y después aplicarlas al modelado de datos, explorando las implicaciones de definición. Es un libro que te va a hacer pensar bastante, relacionado con la epistemología, la ontología y en nuestra percepción de la realidad.\nAunque el libro te deja con más dudas que respuestas, deja algo totalmente claro: no existe una forma correcta de modelar el mundo, sólo representaciones más convenientes para un caso u otro, ya que todas son arbitrarias.\nYo leí la tercera edición, que es la que única que está en producción actualmente. Esta tiene comentarios de otro modelador de datos muy experimentado, pero que según Hillel Wayne cambió completamente el libro.Hillel recomienda leer la segunda edición, que aunque ya no está en impresión, lo puedes encontrar en PDF{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}. Yo tengo pendiente leer la segunda edición, pero tengo altas expectativas ya que incluso la tercera me dejó grandes enseñanzas.\nConclusión # Para avanzar en tu carrera no basta con aprender sólo habilidades técnicas, también hacen falta algunas meta-habilidades, habilidades paralelas y conocimiento de la historia de tu profesión.\nTener estos conocimientos te puede hacer destacar de los demás profesionales, y son especialmente útiles si quieres lograr un puesto de liderazgo. Así que sigue preparándote, recuerda que un libro bien editado es de las mejores inversiones que puedes hacer.\n","date":"15 junio 2023","externalUrl":null,"permalink":"/2023/06/15/libros-que-todo-desarrollador-de-software-deber%C3%ADa-leer-desarrollo-de-carrera/","section":"Posts","summary":"\u003cp\u003eEn este artículo vamos a hablar de los libros que te pueden ayudar a avanzar en tu carrera como desarrollador de software, que desde mi punto de vista, son esenciales.\u003c/p\u003e","title":"Libros que todo desarrollador de software debería leer: desarrollo de carrera","type":"posts"},{"content":"Hablemos sobre los libros de arquitectura de software que te enseñarán a tomar en cuenta los aspectos importantes de este campo y te pueden hacer mejor desarrollador. Como muchos desarrolladores con experiencia mencionan, la arquitectura es un rol, no un puesto de trabajo. Como rol, lo puedes ejercer parcialmente, y todos los desarrolladores deberíamos hacer arquitectura de software a diferentes escalas. El arquitecto que sólo hace diseños no debería existir.\nEn ninguno de estos libros vas a encontrar la sugerencia de que el arquitecto es un puesto de trabajo que sólo se dedica a hacer \u0026ldquo;planos\u0026rdquo;, sino que lo verás como una habilidad más que los desarrolladores de software debemos de tener. Empecemos con las recomendaciones, y como siempre, si quieres contribuir con alguna recomendación, puedes hacerlo en los comentarios.\nDesigning Data-Intensive Applications | Martin Kleppmann # {:.align-center}{:target=\u0026quot;_blank\u0026quot;}\nAceptémoslo: 90% de las aplicaciones útiles necesitan procesar grandes cantidades de datos para funcionar. A veces sólo a eso se dedican.\nEs por eso que un libro como este, que habla del funcionamiento interno de diferentes sistemas que procesan grandes cantidades de datos, su arquitectura y las técnicas que los hacen funcionar, es un libro esencial para los desarrolladores de software modernos.\nAlgunos temas que vas a poder aprender son:\nLas características de un buen sistema que procesa información Las estructuras de datos que le dan el poder sistemas como las bases de datos Modelos de datos y lenguajes de consulta Replicación Todos estos temas son esenciales para ser un buen desarrollador de software.\nPuedes comprarlo aquí: Designing Data-Intensive Applications{:target=\u0026quot;_blank\u0026quot;} o en Amazon{:target=\u0026quot;_blank\u0026quot;}\nSofware Architecture for Developers y The C4 Model | Simon Brown # {:.align-center}{:target=\u0026quot;_blank\u0026quot;}\nSimon Brown es un desarrollador y arquitecto que enseña a otros desarrolladores a practicar lo mejor posible la arquitectura de software.\nSimon explica en Software Architecture for Developers lo que es la arquitectura de software, desde su comparación con la arquitectura de edificios, las cosas en las que se parece y diferencia, junto las responsabilidades y el conocimiento que es necesario para esta actividad.\nEn el \u0026ldquo;The C4 Model\u0026rdquo; explica una forma específica de comunicar la información que el diseño de un sistema contiene, incluyendo cuatro diagramas a diferentes niveles de abstracción, con el objetivo de que quienes lo analicen se lleven una buena idea de cómo funciona el sistema.\nPuedes comprarlos aquí: Software Architecture for Developers{:target=\u0026quot;_blank\u0026quot;}, también puedes comprarlos por separado, pero te llevas un mejor valor si los compras juntos.\nFundamentals of Software Architecture | Mark Richards \u0026amp; Neal Ford # {:.align-center}{:target=\u0026quot;_blank\u0026quot;}\n¿Quieres obtener el conocimiento más básico de arquitectura de software? En este libro, los autores te lo enseñarán.\nEmpieza desde lo esencial y avanza hasta las mejores prácticas para analizar las características que necesitas implementar. El libro pasa (a grandes rasgos) por los siguientes temas:\n¿Qué es la arquitectura de software? Cómo adquirir la forma de pensar de un arquitecto Estilos arquitectónicos Softskills para arquitectos Es un gran libro con muy buenas temas para empezar a practicar directamente, además escrito por expertos en el tema.\nPuedes comprarlo aquí: Fundamentals of Software Architecture{:target=\u0026quot;_blank\u0026quot;}\nSoftware Architecture the Hard Parts | Neal Ford, Mark Richards, Pramod Sadalage \u0026amp; Zhamak Dehghani # {:.align-center}{:target=\u0026quot;_blank\u0026quot;}\nLos sistemas distribuidos son lo que más se desarrolla hoy en día, debido a las necesidades de la industria. Saber crear arquitecturas distribuidas es algo que un desarrollador avanzado debe dominar.\nEn este libro se habla de tres cosas principales:\nBuenas ideas para empezar a hacer y documentar arquitecturas Separación: diseñar los componentes, los módulos, separación de datos, etc. Juntar todo de nuevo: contratos, service meshes, transacciones distribuidas, flujos de trabajo, etc. Es un libro que maneja temas avanzados y temas sobre los que tienes que saber bastante antes de empezar a leer el libro, así que te recomiendo empezar con los libros anteriores, además de obtener nociones de sistemas distribuidos.\nPuedes comprarlo aquí: Software Architecture the Hard Parts{:target=\u0026quot;_blank\u0026quot;}\nDomain Driven Design | Eric Evans # {:.align-center}{:target=\u0026quot;_blank\u0026quot;}\nEste libro es la Biblia del diseño dirigido por el dominio, un estilo que se enfoca en crear un modelo de software que refleje el negocio (o el dominio) de la mejor manera posible.\nLa principal idea de esta técnica es que los desarrolladores de software se entiendan y puedan hablar como un experto más en el dominio. Esto se logra creando un lenguaje común entre los desarrolladores y los expertos en el dominio, soportado por el modelo de software que se crea.\nCreo que aunque no siempre es aplicable, es bueno conocerlo y tener listas las técnicas para la aplicación completa o parcial de este estilo de diseño.\nPuedes comprarlo aquí: Domain Driven Design{:target=\u0026quot;_blank\u0026quot;}.\nUn libro alternativo a este, más moderno y ligero es: Learnig Domain Driven Design{:target=\u0026quot;_blank\u0026quot;}.\nSystem Design Interview 1 y 2 | Alex Xu # {:.align-center}{:target=\u0026quot;_blank\u0026quot;}\nEstos libros te enseña de manera concisa las bases del diseño de sistemas de software, desde los principios de diseño, hasta las diferentes partes que componen un sistema complejo que necesita soportar muchos usuarios.\nAlex Xu es un buen creador de contenido de muy buena calidad y en estos libros explica lo necesario de forma lo suficientemente sencilla. Te lo recomiendo si quieres aprender sobre una gran cantidad de temas relacionados con el diseño de sistemas y la arquitectura de software.\nPuedes ver la página en la que publica más información acerca de lo que hace en: ByteByteGo {:target=\u0026quot;_blank\u0026quot;}, además de que puedes suscribirte para aprender más sobre el diseño de sistemas y prepararte para entrevistas de trabajo.\nLo puedes comprar aquí: System Design Interview 1{:target=\u0026quot;_blank\u0026quot;} y System Design Interview 2{:target=\u0026quot;_blank\u0026quot;}\nConclusión # Hay una buena colección de libros que te pueden ayudar a ser un mejor desarrollador de software mejor preparado, fortaleciendo una parte que todos los desarrolladores tenemos que ejercer: la arquitectura de software.\nEmpieza con estos libros uno a uno, o úsalos como referencia para cuando tengas que resolver un problema específico.\n","date":"8 junio 2023","externalUrl":null,"permalink":"/2023/06/08/libros-que-todo-desarrollador-de-software-deber%C3%ADa-leer-arquitectura/","section":"Posts","summary":"\u003cp\u003eHablemos sobre los libros de arquitectura de software que te enseñarán a tomar en cuenta los aspectos importantes de este campo y te pueden hacer mejor desarrollador. Como muchos desarrolladores con experiencia mencionan, la arquitectura es un rol, no un puesto de trabajo. Como rol, lo puedes ejercer parcialmente, y todos los desarrolladores deberíamos hacer arquitectura de software a diferentes escalas. El arquitecto que sólo hace diseños no debería existir.\u003c/p\u003e","title":"Libros que todo desarrollador de software debería leer: arquitectura","type":"posts"},{"content":" The computer is the tool but not the object of study. - Peter Denning\nEntender la computación profundamente es importante para cualquier desarrollador de software, porque al avanzar en su carrera se encontrará con problemas relacionados con las principios más fundamentales de la computación. Piensa en los siguientes casos:\n¿Es mejor mantener este sistema como un monolito o dividirlo en microservicios? ¿Cómo puedo hacer que este sistema sea más rápido? ¿Cómo puedo hacer mi base de código más mantenible? ¿Cómo puedo representar mejor este problema en código? ¿Cómo puedo asegurar el mayor tiempo de actividad posible en el sistema? ¿Puedo garantizar que los mensajes que envío lleguen a su destino? ¿Cómo evito que la complejidad de esta base de código crezca más de lo que la voy a poder controlar? Tener herramientas para entender estos problemas evitará que te estanques o frustres, y te habilitará para crear sistemas que cumplan con lo se necesita de ellos. Además, te hará un miembro más valioso de cualquier organización.\nUn conocimiento sólido de cómo funciona la computación te ayudará por lo menos en los siguientes puntos:\n. Entender los entender los límites de lo que se puede hacer . Diseñar mejor software (y hardware si se necesita) . Trasladar mejor los problemas del mundo real a algo que la computadora pueda entender . Explicar en palabras comunes tus ideas . Descomponer los problemas computacionales en sus componentes básicos . Disfrutar más de tu trabajo\nEntender la computación profundamente incluye \u0026ldquo;mejorar tu lógica de programación\u0026rdquo;, un objetivo que muchos quieren lograr para obtener un nuevo puesto o trabajar en la empresa de sus sueños.\nEn este artículo vamos a hablar de los seis aspectos que tienes que entender acerca de la computación, digamos que son sus principios fundamentales. Además veremos cómo se relaciona esto con las cosas comunes que oímos acerca de las ciencias de la computación: complejidad, algoritmos, estructuras de datos, etc.\nAunque nos hemos dividido en áreas de dominios como:\n. Inteligencia artificial . Sistemas distribuidos . Computación en la nube . Tratamiento y análisis de datos . Seguridad informática . Muchas más y siguen apareciendo\nTodas estas áreas que tienen que ver con la computación obedecen a los mismos principios de los que hablaremos en este artículo.\nPero antes definamos qué es la computación.\n¿Qué es la Computación? # Aquí vamos a hablar de la computación como la disciplina de usar las computadoras y el software para lograr nuestros objetivos, sean estos científicos, de negocios, de entretenimiento, etc.\nEstos objetivos pueden ser tan arbitrarios y diversos como lo es la cantidad de personas que actualmente usan las computadoras para sus propios objetivos.\nLa computación se puede ver desde tres perspectivas diferentes:\nIt has been argued that there are three particularly lucid traditions in computer science: the theoretical tradition, the empirical tradition, and the engineering tradition. - Peter Denning\nSegún esto podemos ver la computación desde tres perspectivas:\nLa tradición teórica: ver la computación como una ciencia La tradición empírica: ver la computación en la práctica La tradición de la ingeniería: ver la computación como una herramienta Con tradición, el Denning se refiere a la forma en la que se ha desarrollado históricamente el área. Cada una de estas tradiciones ha desarrollado el área de una forma diferente, pero todas son importantes para entender la computación. Para que seamos profesionales completos, debemos entender lo suficiente de cada una de las áreas.\nLos límites de la computación # Algunas personas piensan que todo es posible dentro de una computadora. Sin embargo, \u0026ldquo;The Great Principles of Computing\u0026rdquo; nos dice que:\nComputing is governed by scientific principles and laws that tell us what computers can and cannot do. - Peter Denning\nQue podemos traducir como:\nLa computación está gobernada por principios y leyes científicas que nos dicen qué pueden y qué no pueden hacer las computadoras. - Peter Denning\nAsí que las computación tiene límites y estos están dictados por los principios científicos que conocemos de otras áreas como la física y las matemáticas.\nHistoria y nacimiento de la computación moderna # Aunque la computación en sí misma es mucho más que las computadoras que usamos, es importante entender cómo llegamos a este punto y junto con eso, las limitaciones que esto nos ha creado, así como las oportunidades que tenemos.\nEntender esta historia no te dará súper poderes de programación, pero te ayudará a saber donde estás parado en el flujo del tiempo.\nEste contexto te dará más bases para buscar por diferentes lados.\nModelos de computación # Un modelo de computación es una forma de representar una mediante un sistema matemático. Esto nos permite analizar el problema y encontrar soluciones.\nComunicación # Gran parte de la computación tiene que ver con transmitir datos entre diferentes partes que ejecutan los cálculos, pueden ser diferentes computadoras o diferentes ejecutores de una misma computadora. También puede incluir mover información entre diferentes lugares de almacenamiento.\nAsegurarnos de que la información llegue a su destino consistentemente y sin errores (o poder detectarlos y corregirlos) es uno de los problemas que la computación tiene que resolver. Esto es especialmente importante en los sistemas distribuidos.\nCálculos o Computación # En este \u0026ldquo;cristal\u0026rdquo; queremos entender que es lo que puede ser calculado o resuelto usando una computadora. Esto incluye conocer la complejidad de las soluciones y en general, si es posible resolver el problema, en qué tiempo y en qué medios de cómputo.\nPara esto se necesita un poco de matemáticas, pero además creatividad e inventiva, ya que hay que pensar en las diferentes formas en las que un algoritmo se puede comportar. Además, hay que saber notar y demostrar cuando un problema no tiene solución, o las soluciones que existen no son factibles.\nCoordinación # No es siempre cierto que \u0026ldquo;el orden de los factores no altera el producto\u0026rdquo;. Además, para aprovechar el poder completo de un sistema, normalmente se necesita coordinar las diferentes partes que lo componen. Esto es cierto sobre todo con los sistemas de cómputo actuales, pero además con los sistemas de software que ocupan muchas computadoras.\nLa coordinación tiene que ver con la concurrencia, el paralelismo y la forma de compartir datos y ponerse de acuerdo entre múltiples ejecutores para realizar una tarea de forma correcta.\nRecolección # ¿Cómo conseguimos los datos para procesar? ¿O cómo recogemos los resultados de la computación? ¿Cómo los almacenamos y acomodamos? Esto es la recolección de datos. Además en dónde guardarla, en qué estructura ponerla y cómo recuperarla, es parte importante de este pilar de la computación.\nEvaluación # Comprobar que los resultados de la computación son correctos, diseñar sistemas que puedan verificar los resultado y además medir el desempeño de los sistemas es una parte fundamental para hacer sistemas útiles.\nDiseño # No sólo se trata de echar código, también hay que pensarlo bien antes de ponerlo. El tiempo gastado en el diseño de un sistemas puede pagar dividendos grandes en el futuro. Los sistemas complejos, que son todos los que existen hoy, deben descomponerse en módulos para que sean manejables por los seres humanos.\nCómo descomponerlos, qué interfaces crear y qué tipo módulos tendrá el sistema es dominio del diseño de la computación.\nMás recursos # En este blog tenemos un post dedicado a los libros que te pueden servir para aprender más acerca de las ciencias de la computación: Libros para aprender ciencias de la computación.\nTambién puedes visitar la página Teach Yourself Computer Science, que tiene una lista de los temas que debes aprender y los recursos que puedes usar para aprenderlos.\nConclusión # Aprender ciencias de la computación es algo que todo desarrollador debe aprender en su carrera. Te puede ayudar a ser más eficiente, a disfrutar mucho más de tu trabajo y resolver problemas que antes no creías posibles. Pero como acabas de ver, es un camino largo, que requiere de bastante esfuerzo sostenido.\nSigue aprendiendo y verás cómo cada cosa nueva que le sumes a tus bases de conocimiento te ayudará a ser un mejor profesional.\nReferencias # A continuación algunas de las fuentes usadas para este artículo:\nThe Great Principles of Computing, Peter Denning y Craig Martell Teach Yourself Computer Science, https://teachyourselfcs.com/ Concrethe Mathematics, Ronald L. Graham, Donald E. Knuth y Oren Patashnik The Art of Computer Programming, Donald E. Knuth ","date":"30 mayo 2023","externalUrl":null,"permalink":"/2023/05/30/pilares-fundamentales-de-las-ciencias-de-la-computaci%C3%B3n/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003eThe computer is the tool but not the object of study. - \u003cstrong\u003ePeter Denning\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eEntender la computación \u003cstrong\u003eprofundamente\u003c/strong\u003e es importante para cualquier desarrollador de software, porque al avanzar en su carrera se encontrará con problemas relacionados con las principios más fundamentales de la computación. Piensa en los siguientes casos:\u003c/p\u003e","title":"Pilares fundamentales de las ciencias de la computación","type":"posts"},{"content":"Ya hablamos en un artículo anterior sobre los libros que te haría bien leer en el tema de ciencias de la computación. Ahora vamos a hablar sobre el tema de desarrollo de software, cómo crear mejor software y con mejor calidad. En este artículo también se incluyen libros sobre ingeniería de software por ser la disciplina más confiable para crear software de calidad.\nEmpecemos con las recomendaciones, espero que te sirvan.\nA Philosophy of Software Design - John Ousterhout # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEste es un libro que te da muchos consejos sobre cómo crear bases de código que sean más fáciles de evolucionar, mantener y sobre todo, de entender. Está escrito por John Ousterhout, el creador de RAMCloud, TCL/TK y co-autor del algoritmo de consenso para sistemas distribuidos Raft.\nEs un libro muy práctico y corto, que da consejos concretos sin grandes ínfulas de superioridad sobre cómo escribir mejor código. El tema principal es la complejidad, cuáles son sus síntomas y cómo puedes evitarla o manejarla. El libro se centra en en la experiencia del autor tanto escribiendo código y haciendo sistemas, como enseñando a otros a hacerlo en su clase \u0026ldquo;Software Design Studio\u0026rdquo;.\nEsto último (lo de dar clases) le da una visión privilegiada: ver los errores comunes que cometen los principiantes le permite atacar directamente los problemas en los que nos metemos por un mal diseño.\nOusterhout se centra en los temas que para mi son los fundamentales de desarrollo de software:\nLa complejidad y sus causas La abstracción La modularidad y los criterios para dividir un sistema en módulos Ocultar información de forma efectiva La mejor forma de comunicar información al resto del equipo Si quieres darle una probada antes de comprarlo, puedes leer el primer capítulo{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nY en este blog tenemos varios artículos hablando de sus ideas, puedes buscarlos con la etiqueta APoSD{:target=\u0026quot;_blank\u0026quot;}.\nPuedes comprarlo aquí: A Philosophy of Software Design{:target=\u0026quot;_blank\u0026quot;}\nMaking Software - Editado por Andy Oram \u0026amp; Greg Wilson # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEn este libro se habla de las prácticas comunes que creemos que nos ayudarán a desarrollar mejor software, pero desde el punto de vista del escepticismo. Se analizan estas prácticas y nos dice si realmente nos ayudan o no, y por qué, todo esto con base en estudios realizados a lo largo del tiempo en muchos equipos, junto con las opiniones de expertos en el tema.\nLos resultados probablemente te sorprendan, pero hay que recordar que ninguna práctica se comporta de la misma manera universalmente, es decir, lo que te sirva a ti puede no servirle a otro equipo. Así que aunque es una buena guía, nada es una verdad absoluta.\nCreo que este libro es fundamental para desarrollar una relación sana con las \u0026ldquo;buenas prácticas\u0026rdquo; y cuestionarte todas las cosas que te dicen respecto al desarrollo de software.\nPuedes comprarlo aquí: Making Software{:target=\u0026quot;_blank\u0026quot;}\nModern Software Engineering - Dave Farley # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEscrito por un gran ingeniero de software con mucha experiencia, explica técnicas efectivas para la organización del trabajo y la liberación de software lo más rápido posible. Dave es un proponente muy fuerte de la entrega continua y de la automatización de pruebas, y en este libro explica las técnicas asociadas a estos temas.\nAdemás explica por qué la ingeniería de software no tiene que ser una carga burocrática. La premisa básica es que toda práctica que no nos ayude a hacer mejor software más rápido, es una mala idea y no debería contar como \u0026ldquo;ingeniería\u0026rdquo;.\nPuedes comprarlo aquí: Modern Software Engineering{:target=\u0026quot;_blank\u0026quot;}\nThe Mythical Man-Month - Frederick Brooks # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nFrederick Brooks era un ingeniero de la computación que trabajó en el IBM System/360 y en el OS/360, sistemas muy grandes y que le dieron para después describir su experiencia en la serie de ensayos que conforman este libro.\nComo te lo podrás imaginar, aprendió mucho en los proyectos que realizó, sobre todo de la administración de equipos. En estos ensayos podrás llevarte sus aprendizajes. El además es el autor de otros ensayos como \u0026ldquo;No Silver Bullet\u0026rdquo; y de la famosa frase:\n\u0026ldquo;Adding manpower to a late software project makes it later.\u0026rdquo;\n\u0026ldquo;Añadir personal a un proyecto de software atrasado, lo atrasa más.\u0026rdquo;\nPuedes comprar el libro aquí: The Mythical Man-Month{:target=\u0026quot;_blank\u0026quot;}, pero también puedes leer la primera edición de forma gratuita aquí: The Mythical Man-Month en la universidad de Virginia{:target=\u0026quot;_blank\u0026quot;}.\nRefactoring - Martin Fowler # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nUno de los grandes clásicos en el desarrollo de software, establece la importancia y la forma en la que puedes refactorizar tu código. Refactorizar significa cambiar la implementación de tu código, haciéndola mejor, sin cambiar su funcionamiento externo, o la función que provee.\nMartin Fowler también es uno de los más grandes nombres en el campo del desarrollo de software por su gran experiencia tanto desarrollando software como escribiendo, por lo que puedes estar seguro de que sus consejos son de gran valor.\nPuedes comprarlo aquí: Refactoring{:target=\u0026quot;_blank\u0026quot;}\nSoftware Engineering at Google | Titus Winters, Tom Manshreck, Hyrum Wright # {:.align-center}{:target=\u0026quot;_blank\u0026quot;}\nEste libro explica la forma en la que se practica la ingeniería de software en Google, uno de los más grandes creadores de software de la historia. El libro abarca tres grandes áreas:\nLa cultura Los procesos Las herramientas El libro no habla tanto de código sino que se centra más en el desarrollo de software.\nAlgo que hay que tener en cuenta es que Google no tiene el monopolio de la verdad sobre el desarrollo de software, así que esta es una perspectiva que te va a dar ideas, y una visión más amplia de cómo desarrollar software.\nPuedes comprarlo en Amazon{:target=\u0026quot;_blank\u0026quot;} o leerlo gratis aquí: Software Engineering at Google{:target=\u0026quot;_blank\u0026quot;}\nConclusión # Estos son los libros que pude pensar como las mejores recomendaciones para aprender desarrollo de software.\nNo incluyo deliberadamente el más famoso de todos por lo menos entre los desarrolladores latinoamericanos: Clean Code. ¿Por qué? Aunque dice cosas útiles, muchas son obvias, explicadas mejor en otros libros y además el tono de superioridad que tiene el autor es muy molesto. Quienes lo han interiorizado se creen mejores simplemente por conocer esos consejos, que (aquí viene lo peor) a veces son contraproducentes.\nSi tienes alguna recomendación extra, puedes dejarla en los comentarios.\n","date":"25 mayo 2023","externalUrl":null,"permalink":"/2023/05/25/libros-que-todo-desarrollador-de-software-deber%C3%ADa-leer-desarrollo/","section":"Posts","summary":"\u003cp\u003eYa hablamos en un \u003ca\n  href=\"https://blog.thedojo.mx/2023/05/13/libros-que-todo-desarrollador-de-software-deberia-leer-cs.html\"\n    target=\"_blank\"\n  \u003eartículo anterior\u003c/a\u003e sobre\nlos libros que te haría bien leer en el tema de ciencias de la computación.\nAhora vamos a hablar sobre el tema de desarrollo de software, cómo crear mejor software y con mejor calidad.\nEn este artículo también se incluyen libros sobre ingeniería de software por ser la disciplina más\nconfiable para crear software de calidad.\u003c/p\u003e","title":"Libros que todo desarrollador de software debería leer: desarrollo","type":"posts"},{"content":"","date":"13 mayo 2023","externalUrl":null,"permalink":"/tags/ciencias-computacion/","section":"Tags","summary":"","title":"Ciencias-Computacion","type":"tags"},{"content":"Hablemos de algunos libros que te pueden ayudar a avanzar en tu carrera como desarrollador de software, por diferentes razones, por ejemplo te ayudarán a fortalecer tus bases, o te darán ideas para hacer mejor software, mejores arquitecturas o a mejorar como profesional en general.1\nEmpecemos por los fundamentos mismos de lo que hacemos. Los siguientes libros te ayudarán a entender mejor cómo funciona la computación desde sus raíces.\nAunque esta sección está en primer lugar, no significa que debas leerlos antes que todo. Por ejemplo, cuando aprendiste español no aprendiste primero teoría de lenguajes, semántica, semiótica y todas las cosas que soportan el lenguaje. Aprendiste a hablar y a escribir, y luego, para profundizar aprendiste los soportes teóricos, por gusto o por necesidad. Lo mismo pasa con la computación.\nLamentablemente, la mayoría de los libros de este artículo están en inglés. Pero aquí viene otro consejo que hemos aprendido con los golpes de los años: la gran mayoría de la información en ciencias de la computación está en inglés, y es un idioma indispensable para un desarrollador de software.\nEmpecemos con la lista de libros.\nComputational Thinking - Peter J. Denning y Matti Tedre # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEste libro me parece una lectura fundamental para todos los estudiantes de ciencias de la computación pero también para desarrolladores de software con más experiencia práctica.\nEstá escrito por Matti Tedre y Peter J. Denning, y es una lectura muy amena y fácil de entender. Pero no por eso es superficial, trata profundamente una pregunta: ¿qué es el pensamiento computacional? Explora el tema por varios aspectos:\nLas máquinas y el nacimiento de la computación como disciplina La ingeniería y el diseño de software La educación de las ciencias de la computación La relación de la ciencia tradicional con la computación Los dos autores son parte del grupo que se encarga de la recomendación de los temarios de ciencias de la computación de la ACM. Por lo que tienen una visión muy amplia de lo que es la computación y cómo se enseña. Este libro te dejará claro de lo que hablamos con \u0026ldquo;computación\u0026rdquo; y el tipo de pensamiento que se requiere para hacerla. También aclarará si todos necesitan estudiarla y algunos mitos alrededor de ella.\nPuedes comprarlo aquí: https://amzn.to/3LJf95S{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nComputer Science Distilled - Wladston Ferreira Filho # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nPara muchos esto parecerá una mala elección, sin embargo, para mi este libro tiene todo lo que se necesita para ser una buena introducción a los temas principales de la ciencias de la computación, de manera práctica y sencilla. Es cierto que por su extensión no puede tratar ninguno a profundidad, pero te da una visión amplia de todos los temas que tienes que conoces.\nExplica de manera sencilla los pilares principales de las ciencias de la computación y lo mejor es que te da referencias para que puedas profundizar en cada uno de los temas. Te servirá más si eres un principiante, pero aún si eres un desarrollador experimentado te puede servir para reforzar algunos temas que no tengas claro o para tener una referencia rápida de algunos temas.\nEste es un libro que creo que sí debes leer lo más temprano posible en tu carrera.\nPuedes comprarlo en Amazon{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;} o en su página oficial{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}.\nThe Elements of Computing Systems: building a modern computer from first principles - Noam Nisan y Shimon Schocken # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEn este libro encontrarás un entendimiento básico del funcionamiento de una computadora digital, pero desde el mismísimo fondo. Es un libro MUY profundo, en el que contruirás una computadora digital desde cero, tanto el hardware como el software.\nNo es un libro que recomiende leer al principio de la carrera ni mucho menos como un prerrequisito para empezar a trabajar, es más bien, algo que ir consumiendo con los años, para entender cada vez mejor cómo funciona fundamentalmente el aparato que usas a diario.\nEl principio más fundamental de este libro es \u0026ldquo;aprender haciendo\u0026rdquo;, por que lo que mejor se aprende es mediante la práctica.\nLo puedes comprar aquí: The Elements of Computing Systems{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nThe Great Principles of Computing - Peter J. Denning # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEn este libro, Peter J. Denning y Craig H. Martell explican los principios que le dan forma e influyen en el campo de la coputación. Estos principios están divididos en 6 categorías:\nCálculos Comunicación Coordinación Recolección Diseño Evaluación Cada uno de estos principios limitan y le dan formas a las tecnologías que usamos, por lo que entenderlos profundamente sin duda te ayudará a ser mejor usando las computadoras y más específicamente, a ser un mejor desarrollador de software.\nNo creo que este libro se tenga que leer antes de cualquier otra cosa, pero sí siento que mientras más temprano lo hagas en tu carrera, mejor.\nLo puedes comprar aquí: The Great Principles of Computing{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nThe Algorithm Design Manual - Steven S. Skiena # {: .align-center}{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nEste es uno de los mejores libros para aprender sobre algoritmos y estructuras de datos, es una lectura que te ayudará mucho.\nEstá escrito por Steven S. Skiena y va en su 3ra edición. Y es una lectura que puede ayudarte de manera no tan compleja a aprender sobre algoritmos y estructuras de datos. Es un libro bastante extenso y que va avanzando poco a poco en los temas relacionados con algoritmos y estructuras de datos, bellamente ilustrado, sin demasiada carga matemática.\nTampoco es un libro que te tengas que leer de principio a fin, o muy temprano en la carrera. Puedes empezar con los primeros capítulos lo más pronto posible e irlo estudiando con el tiempo, o dejando los temas más avanzados para cuando los necesites puntualmente.\nPuedes comprarlo aquí: The Algorithm Design Manual{:target=\u0026quot;_blank\u0026quot; rel=\u0026ldquo;noopener\u0026rdquo;}\nTambién puedes leer de manera gratuita la segunda edición en este link\nConclusión # Estas son mis recomendaciones en este apartado importante de nuestra área del conocimiento. Si tienes alguna recomendación, no dudes en ponerte en contacto conmigo para que la agregue.\nPersonalmente, siento que los libros son los mejores maestros que puedes tener. Un libro serio, bien escrito y bien editado es un maestro que acumula la experiencia de muchas personas, principalmente del autor, pero también de los editores, correctores y otras personas que participan en su creación.\nUn libro acumula muchos años de experiencia, y es la forma más directa de \u0026ldquo;parte en hombros de gigantes\u0026rdquo;. Es cierto, leerlos cuesta trabajo, pero es algo que te va a devolver mucho más de lo que inviertes en ellos.\nEn los próximos artículos hablaremos de libros de otras áreas relacionadas con el desarrollo de software, como la ingeniería de software, la arquitectura y otros temas variados.\nAlgunos de los links son links de afiliado de Amazon, por lo que puede que me lleve una pequeña comisión si compras el libro a través de ellos. Esto no afecta el precio que pagas por el libro además de que no afecta para NADA mi recomendación.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"13 mayo 2023","externalUrl":null,"permalink":"/2023/05/13/libros-que-todo-desarrollador-de-software-deber%C3%ADa-leer-ciencias-de-la-computaci%C3%B3n/","section":"Posts","summary":"\u003cp\u003eHablemos de algunos libros que te pueden ayudar a avanzar en tu carrera como desarrollador de software, por diferentes razones, por ejemplo te ayudarán a fortalecer tus bases, o te darán ideas para hacer mejor software, mejores arquitecturas o a mejorar como profesional en general.\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e","title":"Libros que todo desarrollador de software debería leer: ciencias de la computación","type":"posts"},{"content":"Gran parte de nuestro trabajo como desarrolladores consiste en modelar entidades del mundo real en el código, transformarlas, guardarlas y recuperarlas. Estas entidades se pasan entre diferentes procesos para producir un resultado. A veces también nos tenemos que inventar entidades para representar conceptos abstractos que no existen físicamente.\nModelar datos es una de las habilidades fundamentales cuando estamos desarrollando.Cuando estás programando un algoritmo, estás modelando un procedimiento de la vida real en código. Este proceso normalmente incluye datos, que son representaciones de entidades del mundo real.\nPor lo anterior, cualquier cosa que puedas aprender sobre modelado de datos, te ayudará directamente en tu carrera como desarrollador. En este artículo hablaremos de un libro muy especial que te puede ayudar a ser mejor en esta área, independientemente del nivel en el que te encuentres en tu carrera. Y si después de leerlo lo meditas más profundamente, puede que te ayude a desarrollar una forma de pensar más adecuada a los problemas que queremos resolver en la actualidad.\nData and Reality trata sobre modelado de datos, escrito po William Kent, alguien con mucha experiencia en el tema. El libro tiene tres ediciones la primera es de 1978, la segunda (una actualización) es de 2000 y la tercera, después que Kent murió, es de 2012.\nLa mejor de todas es segunda edición, ya que la tercera se podría considerar un libro completamente diferente, recortado y con comentarios de Steve Hoberman, otro modelador de datos pero siento que con un enfoque bastante diferente al de Kent.\nHablemos de los temas principales del libro y por qué te conviene leerlo. Pero antes, veamos algo de lo que se habla en el prefacio de la edición de 2012 que me parece muy relevante.\nBuscando las respuestas donde parece más sencillo # Hay muchas cosas difíciles de resolver en el desarrollo de software y parece que siempre estamos buscando la respuesta en el lugar que parece más obvio o en el que es más fácil buscar, en lugar de donde es más probable que encontremos las respuestas.\nEl ejemplo que utilizan en el libro para explicarlo y que me parece acertado es una broma acerca de un borracho que pierde sus llaves y se la pasa toda la noche buscando bajo una farola. Cuando alguien le pregunta por qué no busca en otro lado, el borracho responde que es porque AHÍ HAY MÁS LUZ.\nEn el desarrollo de software podría parecer que a veces hacemos exactamente lo mismo. Para buscar la solución a un problema siempre nos vamos a los mismos lados porque es donde nos sentimos cómodos o porque SIEMPRE SE HA BUSCADO AHÍ. Por ejemplo, nos centramos en la tecnología, en las plataformas o en los lenguajes. Pero es muy probable que el problema no esté ahí, sino en lugares más profundos.\nEs por eso que este libro se enfoca en cuestiones profundas del modelado de datos. No en los lugares comunes, ni siquiera en hablar de cómo hacerlo, sino en preguntas que te llevaran a pensar cosas de las que se habla poco y que probablemente modifiquen tu visión del mundo y tu forma de trabajar permanentemente.\nLa intención de este artículo es dejarte con más dudas, pero llevarte a lugares en los que tal ve no habías estado antes, tal como avanzar a un nuevo lugar en el mapa en un juego de video.\nCuestiones principales # Hablemos de los conceptos principales de representación de información en los sistemas electrónicos.\nEntidades # Cuando guardamos cosas en una base de datos o las representamos en código, casi siempre nos referimos a ellas como entidades.\nPor eso el libro empieza cuestionando, ¿qué es una entidad?\nLa primera respuesta es que una entidad \u0026ldquo;es un estado de la mente\u0026rdquo;. ¿Cómo? Está bastante rara esa definición. Esta frase significa que una entidad más allá de algo que exista en la realidad como algo identificable e indivisible, algo que tiene límites fijos, es algo a lo que nosotros le damos significado, y que nosotros delimitamos o entendemos en ciertos contextos. Esta delimitación normalmente no es singular, tiene que ser compartida por un grupo de personas para que tenga sentido.\nPongamos algunos ejemplos para entender eso. La leyenda del barco de Teseo relata que cuando él regresó de Creta, donde había matado al Minotauro, el pueblo de Atenas le rindió honores y conservó su barco en lo alto de una colina como un monumento para recordar su hazaña.\nCon el tiempo, el barco se fue deteriorando y se le fueron cambiando las partes, hasta que ya no quedó ninguna parte original.\nLa pregunta es: ¿sigue siendo el \u0026ldquo;Barco de Teseo\u0026rdquo;? ¿Es el mismo barco si no tiene ninguna parte original? ¿Es el mismo barco si se le cambia una sola parte, o muy pocas?\nEsta historia sirve para ilustrar que las entidades como objetos inmutables y permanentes no existen en la vida real, sino que son cosas que en nuestra mente delimitamos y que, junto con otras personas, les asignamos una identidad y un significado. El \u0026ldquo;Barco de Teseo\u0026rdquo; sigue siendo el mismo mientras nosotros lo consideremos así.\nExactamente así se comportan las entidades que como desarrolladores modelamos en nuestros programas. No son cosas permanentes, a veces ni siquiera cosas completamente definidas, sino que nosotros les asignamos límites y significado.\nLas personas, los objetos e incluso los conceptos están en constante evolución y parte de nuestro trabajo es capturar esa evolución en nuestros sistemas.\nIdentidad y cambio # Cuando queremos registrar algo en una computadora, normalmente necesitamos una forma de referirnos a ese registro para después poder recuperarlo. Esto que usamos para referirnos a las entidades se llama identificador.\nUn identificador es un elemento inmutable y único entre todas las entidades de nuestro sistemas. Aquí nos podemos encontrar con varios casos:\nLa entidad no tiene nada único por lo que podamos referirnos a ella (elementos que se repiten, por ejemplo libros producidos en serie) El conjunto de todos los atributos de la entidad puede constituir una identidad Las entidades tienen varios atributos únicos y hay que escoger uno Pensar en la naturaleza de nuestro problema, en los términos de arriba nos puede llevar a la solución de seleccionar un elemento identificador. Piensa en el primer caso, por ejemplo: cuando algo no tiene identificador natural, tendemos a asignar un identificador único arbitrario a la entidad cuando la metemos en el sistema.\nPor ejemplo, es un práctica muy común asignar identificadores numéricos incrementales. La primera entidad registrada del tipo es la 1, la segunda es la 2, etc. También se pueden usar los UUIDs, que son identificadores únicos generados aleatoriamente, y que por lo general evitan problemas como el de permitir que alguien adivine el identificador de otra entidad.\nPero si la entidad tiene un identificador único inmutable, ¿por qué no usarlo? ¿Puede ser una solución más natural?\n¿Qué pasa cuando lo que creíamos inmutable cambia? Eso es algo que normalmente rompe lo que hicimos y tenemos que idear formas de componerlo. Todo este tipo de preguntas pensadas por adelantado te pueden llevar a crear sistemas de software que soporten mejor el paso del tiempo y te den menos problemas cuando estén funcionando en producción.\nRelaciones # Will Kent afirma que las relaciones son el tejido de la información que representamos en nuestros sistemas. Se puede entender una relación como una asociación o una conexión entre mínimo dos entidades.\nLas relaciones tienen varias características que las pueden definir:\nGrado: El número de entidades de diferentes tipos que participan en la relación Dominios: El conjunto de valores que son válidos en cada lado de la relación Rol: El papel que juega cada entidad en la relación Complejidad (cardinalidad): el número de entidades de cada tipo que participan en la relación Aquí en las relaciones y su representación empezan a surgir diferentes preguntas y problemas ya de definición, por ejmplo: ¿cómo identificas una relación? Algunas relaciones sólo son significativas con un contexto, ¿cómo lo representas? ¿Deberían ser las relaciones entidades también?\nSin duda, leer este capítulo del libro te ayudará a plantearte todas estas cuestiones y a entender mejor cómo representar la información en tus sistemas.\nAtributos # Los atributos son los datos que \u0026ldquo;pertenecen\u0026rdquo; a una entidad. Forman el conjunto de información que tenemos sobre esta.\nLos atributos en el mundo real pueden ser infinitos, pero a nosotros normalmente sólo nos interesa un subconjunto de ellos. Data and Reality propone que los atributos son un conjunto de tres elementos:\nEl sujeto, la entidad a la que pertenece el atributo El objeto, el valor del atributo La relación, que es por lo que el sujeto y el objeto están conectados Supongamos por ejemplo el atributo nombre de una persona. \u0026ldquo;Él se llama Héctor\u0026rdquo;: El sujeto es la persona a la que nos estamos refiriendo, el objeto es el nombre \u0026ldquo;Héctor\u0026rdquo; y la relación es el hecho de que la persona se llama así.\nSi puedes ver, esto nos empieza a meter en problemas de definición. Son realmente los atributos, ¿relaciones?\nSímbolos y valores # Otra cosa que hay que aprender a distinguir cuando estamos modelando entidades y registrándolas es la diferencia entre el valor y el símbolo. Cuando ponemos un valor para representarlo en una computadora usamos una representación, esto es el símbolo. El valor es la entidad que estamos representando.\nPor ejemplo, hablando de atributos podemos querer expresar la altura de una persona. Esta altura se puede expresar como \u0026ldquo;172cm\u0026rdquo;, \u0026ldquo;1.72m\u0026rdquo;, \u0026ldquo;5'8\u0026rsquo;\u0026rsquo;\u0026rdquo;, 172 (como entero) etc. Todos estos son símbolos que representan el valor de la altura de la persona. Lo que en realidad queremos expresar es la distancia que existe entre dos puntos.\nCategorías # Cuando guardamos información en los sistemas informáticos normalmente queremos organizarla. Las categorías son una forma de hacerlo, y la manera intuitiva de entenderlo parece suficiente.\nSin embargo, la creación de categorías es algo que también se debe pensar muy bien, ya que esto repercutirá en la forma en que guardamos información y en cómo la recuperamos.\nAlgunos de los problemas en los que tienes que pensar:\n¿Qué pasa cuando una entidad puede pertenecer a más de una categoría? ¿Qué clasificación es más conveniente para el problema que estás resolviendo? Las respuestas a estas preguntas son completamente arbitrarias y finalmente dependen del problema y del campo para el que estés programando.\nFilosofía del conocimiento # Finalicemos este resumen hablando de la cosa más profunda o analítica que el libro trata: la naturaleza del conocimiento mismo. Hay varias posturas con respecto a \u0026ldquo;la realidad\u0026rdquo;. Las dos extremas son:\nNo existe una realidad objetiva, todo es subjetivo, y los seres humanos construyen esta realidad con su mente. Existe una realidad objetiva, y los seres humanos la perciben y la pueden conocer siempre. En el libro se habla sobre una postura intermedia, y que me parece completamente razonable: es que existe una realidad objetiva, pero que los seres humanos no la pueden conocer completamente, la accedemos a través de la percepción, pero como en mucha posturas filosóficas, la percepción es imperfecta.\n¿Qué es un modelo? # De esto ya hemos hablado repetidas veces en este blog, pero vamos a decirlo una vez más: uno modelo es una abstracción, una representación simplificada de la realidad.\nLo que el análisis de este libro nos hace entender es que esa representación simplificada tiene más que ver con NUESTRA VISIÓN y NUESTROS INTERESES que con una visión objetiva de la realidad.\nConclusión # La conclusión más grande que me gustaría sacar de este libro es esta:\nLa realidad es compleja, confusa y no tiene los límites que nos imaginamos. Todo el orden que intentamos poner en nuestros sistemas es en realidad uno de los múltiples órdenes posibles que podemos ponerle a la realidad, es un punto de vista, y eso no quiere decir que sea el mejor o el más correcto, o que los demás son incorrectos. La representación de la realidad en los sistemas de información dependerá siempre de para quién lo estemos haciendo, y del uso que se le vaya a dar.\nHablando del dominio de modelado de datos, no hay una distinción clara entre lo que es un atributo, una categoría y una relación, nosotros definimos cuándo un aspecto del mundo real se comporta como uno u otro.\nLas entidades, su naturaleza y permanencia, están completamente definidos por el uso que les vayamos a dar.\nEn resumen: gran parte de lo que creemos que es una representación objetiva, en realidad es una representación subjetiva y arbitraria. Pero eso no es malo, es como las cosas funcionan y tenerlo en cuenta nos ayudará a tener discusiones más productivas y a entender mejor los sistemas que construimos.\nAlgunas representaciones son más útiles que otras desde el punto de vista de otras personas, así que esforzarnos por entender lo que otros están viendo es muy buena idea.\n¿Qué sigue? # Pensar en todas estas cuestiones te ayudará a notar que no todo lo que tiene que ver con la tecnología y más importante aún: no siempre hay una respuesta correcta. Sigue flexibilizando tu pensamiento y abriéndolo, sigue pensando más allá de lo establecido y no te centres en la tecnología.\nNo seas como el borracho que busca las llaves perdidas bajo el poste porque ahí hay más luz, busca las llaves donde sea más probable encontrarlas.\n","date":"6 mayo 2023","externalUrl":null,"permalink":"/2023/05/06/por-qu%C3%A9-deber%C3%ADas-leer-data-and-reality/","section":"Posts","summary":"\u003cp\u003eGran parte de nuestro trabajo como desarrolladores consiste en \u003cstrong\u003emodelar entidades\u003c/strong\u003e del mundo real en el código, transformarlas, guardarlas y recuperarlas. Estas entidades se pasan entre diferentes procesos para producir un resultado. A veces también nos tenemos que inventar entidades para representar conceptos abstractos que no existen físicamente.\u003c/p\u003e","title":"¿Por qué deberías leer Data and Reality?","type":"posts"},{"content":"","date":"6 mayo 2023","externalUrl":null,"permalink":"/tags/data-and-reality/","section":"Tags","summary":"","title":"Data-and-Reality","type":"tags"},{"content":"","date":"6 mayo 2023","externalUrl":null,"permalink":"/tags/modelado-de-datos/","section":"Tags","summary":"","title":"Modelado-De-Datos","type":"tags"},{"content":"","date":"22 abril 2023","externalUrl":null,"permalink":"/tags/dependency-inversion/","section":"Tags","summary":"","title":"Dependency-Inversion","type":"tags"},{"content":"Este es el artículo final sobre el análisis de los principios SOLID. En este artículo veremos el principio de Inversión de Dependencias, el cual nos dice que las clases de alto nivel no deben depender de las clases de bajo nivel, sino que ambas deben depender de abstracciones.\nVeamos qué tan útil es en la vida real, aplicándolo día a día, cuáles son las formas de implementarlo y algunos ejemplos, asó como algunas críticas.\nPrincipio de Inversión de Dependencias # El principio se establece en dos partes:\nA. Los módulos de alto nivel no deberían depender de los módulos de bajo nivel, ambos deben depender de abstracciones. B. Las abstracciones no deberían depender de los detalles, los detalles deben depender de las abstracciones. Esto es el principio de Sustitución de Liskov, pero llevado al extremo. Veamos algunos ejemplos en Python.\nclass Database: def connect(self): pass def disconnect(self): pass def query(self, sql): pass class MySQLDatabase(Database): def connect(self): print(\u0026#34;Connecting to MySQL\u0026#34;) def disconnect(self): print(\u0026#34;Disconnecting from MySQL\u0026#34;) def query(self, sql): print(\u0026#34;Querying MySQL\u0026#34;) class PostgreSQLDatabase(Database): def connect(self): print(\u0026#34;Connecting to PostgreSQL\u0026#34;) def disconnect(self): print(\u0026#34;Disconnecting from PostgreSQL\u0026#34;) def query(self, sql): print(\u0026#34;Querying PostgreSQL\u0026#34;) class DatabaseManager: def __init__(self, database): self.database = database def connect(self): self.database.connect() def disconnect(self): self.database.disconnect() def query(self, sql): self.database.query(sql) class Model: def __init__(self, database_manager): self.database_manager = database_manager def save(self): self.database_manager.query(\u0026#34;INSERT INTO ...\u0026#34;) my_model = Model(DatabaseManager(MySQLDatabase())) En este ejemplo vemos claramente como la clase Model no depende directamente de una clase concreta de base de datos, sino que depende de una abstracción, la clase DatabaseManager. De esta manera el código de \u0026ldquo;alto nivel\u0026rdquo;, es decir, el modelo, no depende de un código de \u0026ldquo;bajo nivel\u0026rdquo;, la base de datos.\nAquí alto nivel, se refiere a la lógica de negocio, mientras que bajo nivel se refiere a la implementaciones de cosas no diferenciadas, como conexiones a base de datos y otras cosas similares.\nEsto se ve muy sencillo aquí, justo en un lenguaje de tipado dinámico. Pero en lenguajes de tipado estático, como Java, esto se vuelve un poco más complicado, sobre todo cuando quieres que las clases se puedan cambiar de manera dinámica.\nEs por esto que nació la técnica de Inyección de Dependencias, la cual consiste en inyectar una dependencia en una clase, en lugar de crearla dentro de la clase (la cuál tiene múltiples formas de aplicación). También se puede usar la Inversión de Control, que consiste en que en vez de que sea la clase o el método principal el que instancie alguna dependencia, sea un \u0026ldquo;contenedor\u0026rdquo;, que normalmente es un framework, el que se encargue de instanciar las dependencias y pasarlas a la clase o método que las necesita. Puedes leer más sobre DI vs IoC.\nFinalmente, existe también el descubrimiento de servicios, en el que se \u0026ldquo;pide\u0026rdquo; an Localizador de Servicios que nos de lo que necesitamos para trabajar. Puedes leer sobre la aplicación de esto aquí, en un artículo de Martin Fowler: Inversion of Control Containers and the Dependency Injection pattern\nA mi gusto, todo esto es muy complicado. Veamos algunas críticas a este principio.\nCrítica de Dan North # Analicemos la crítica de Dan North (un reconocido desarrollador de software, consultor y coach) a este principio, al que no le parecen útiles los principios SOLID, sino que prefiere el código simple:\nWhile there is nothing fundamentally wrong with DIP, I don’t think it is an overstatement to say that our obsession with dependency inversion has single-handedly caused billions of dollars in irretrievable sunk cost and waste over the last couple of decades. - Dan North\nEn resumen, Dan North dice que aunque el principio en sí mismo no tiene nada de malo, el hecho de que nos obsesionemos con la inversión de dependencias ha causado miles de millones de dólares en pérdidas irreversibles.\nVeamos otra cita de Dan North:\nMost dependencies don’t need inverting, because most dependencies aren’t options, they are just the way we are going to do it this time. So my - by now entirely unsurprising - suggestion is to write simple code, by focusing on use rather than reuse.\nEsta cita la podemos traducir como:\nLa mayoría de las dependencias no necesitan invertirse, porque la mayoría de las dependencias no son opciones, son simplemente la forma en que lo haremos esta vez. Así que mi - en este momento, completamente predecible - sugerencia es escribir código simple, centrándose en el uso en lugar de en la reutilización.\nEstoy completamente de acuerdo con esta crítica. La mayoría de veces no vas a necesitar reemplazar algo. Es mejor enfocarse en lo que va a suceder 98% de las veces que hacer algo súper complejo o que requiera de una gran cantidad de código en sí mismo como pegamento para que funcione.\nSegún el que propuso este principio, debería aplicarse siempre. Siempre deberías conectar cosas abstractas con otras cosas abstractas y luego hay algo que \u0026ldquo;rellena\u0026rdquo; estas cosas abstractas, o a lo que le puedes pedir que te de una implementación concreta de algo abstracto. Repito: a mi gusto es muy complicado y no es necesario en la mayoría de los casos.\nSin embargo, creo que hay casos, sobre todo aquellos en los que tienes concretamente los casos en las que las implementaciones pueden variar, en los que sí es útil. Por ejemplo imagina algo que tenga que conectarse a diferentes API\u0026rsquo;s para proveer el mismo servicio, como por ejemplo, para enviar mensajes de texto a través de múltiples canales. En este caso, sí es útil, porque puedes tener una interfaz que defina el comportamiento de un servicio de mensajería, y luego múltiples implementaciones de esta interfaz, una para cada canal de mensajería, e inyectar las implementaciones de forma dinámica o mediante configuración.\nConclusión # En este artículo hemos visto el principio de Inversión de Dependencias, el cual nos dice que las clases de alto nivel no deben depender de las clases de bajo nivel, sino que ambas deben depender de abstracciones.\nAunque puede ser útil en ciertos casos, para mi bastante específicos, creo que intentar aplicarlo siempre ha creado más problemas que luego hacen código difícil de entender y mantener, agregándole complejidad al código innecesariamente. Es mejor tener interfaces bien diseñadas, que sea fácil entenderlas y mantener en la cabeza.\nEn general, respecto a los principios SOLID, opino algo muy similar a lo que Dan North menciona: es más importante escribir código simple, que se entienda fácilmente.\nTodos los principios se pueden resumir en estos que son el fundamento de la buena programación:\nCódigo simple, lo más simple posible (Single Responsiility Principle) Ocultar información detrás de interfaces bien diseñadas (Single Responsibility Principle, Open/Closed Principle, Liskov Substitution Principle, Interface Segregation Principle) Pensar bien las abstracciones que se usarán y mejorarlas constantemente (Dependency Inversion Principle) Nunca tendrás el diseño perfecto y siempre podrás mejorar tanto la arquitectura como tu código. Mientras más simple sea el código original, más probable es que tu código evolucione en algo que cumpla con lo que se espera de él. Por eso, siempre debes estar mejorando tu diseño en lo que puedas, revisando el diseño y creando mejores abstracciones.\nPor último, siempre se habla de los principios SOLID como si fueran los dogmas de una religión y se habla de \u0026ldquo;violarlos\u0026rdquo; como si estos fueran obligatorios, o principios morales que siempre se deben seguir. Además, siempre se habla de ellos como si fueran las reglas que definen lo bueno y lo malo.\nPara mi, conviene más seguir principios más generales, que un acrónimo creado con nombres de principios rimbombantes, que muchas veces son tan ambiguos que nadie qué significan exactamente, y cuando tienen aplicaciones reales, son tan complicadas que no se conviene aplicar en la mayoría de los casos.\n","date":"22 abril 2023","externalUrl":null,"permalink":"/2023/04/22/el-principio-de-inversi%C3%B3n-de-dependencias/","section":"Posts","summary":"\u003cp\u003eEste es el artículo final sobre el análisis de los principios SOLID. En este artículo veremos el principio de \u003cstrong\u003eInversión de Dependencias\u003c/strong\u003e, el cual nos dice que las clases de alto nivel no deben depender de las clases de bajo nivel, sino que ambas deben \u003cstrong\u003edepender de abstracciones\u003c/strong\u003e.\u003c/p\u003e","title":"El principio de Inversión de Dependencias","type":"posts"},{"content":"","date":"22 abril 2023","externalUrl":null,"permalink":"/tags/inversion-dependencias/","section":"Tags","summary":"","title":"Inversion-Dependencias","type":"tags"},{"content":"","date":"20 abril 2023","externalUrl":null,"permalink":"/tags/agentes/","section":"Tags","summary":"","title":"Agentes","type":"tags"},{"content":"En este pequeño tutorial vamos a hablar de cómo puedes crear agentes que interactúen con el mundo exterior, usando LangChain y como modelo de lenguaje GPT-4. Como siempre, la mejor manera de aprender es haciendo algo, por lo que vamos a crear un agente\n¿Qué es un agente? # En este contexto, además de una cosa que puede actuar por sí mismo, se entiende que un agente puede hacer dos cosas más:\nDecidir qué hacer y qué herramienta usar Aprender a usar herramientas automáticamente (si le proporcionas las cosas que necesita) Los agentes tradicionalmente se entienden como programas que trabajan de manera autónoma y con su propio espacio de memoria, con los que te comunicas por medio de mensajes, pero que no tienes el control completo sobre ellos. Un agente puede decidir qué hacer con tu mensaje.\nCombinando ambos contextos, un agente es un pedazo del programa que actúa autónomamente, que decide cómo lograr lo que has pedido y que aprende a hacerlo por su cuenta. Al estar basado en un LLM, no está garantizado su éxito.\nAgentes en LangChain # LangChain provee de un conjunto de agentes prefabricados. Los más fáciles de usar están basados en un framework llamado ReAct, que propone una forma de crear estos agentes. Puedes ver el documento en el que se habla de ReAct en el siguiente documento: ReAct: Synergizing Reasoning and Acting in Language Models .\nBásicamente este framework da las guías para crear agentes que usen herramientas de manera efectiva. LangChain provee tres agentes básicos:\nzero-shot-react-description: este tipo de agentes determinan qué tipo de herramientas usar basándose en la descripción de las herramientas proporcionadas.\nreact-docstore: basado completamente en el framework ReAct, este tipo de agentes usan herramientas para buscar documentos y luego buscar términos en esos documentos. Recibe una herramienta de búsqueda y una de consulta.\nself-ask-with-search: utiliza una sola herramienta llamada \u0026lsquo;Intermediate Answer\u0026rsquo; que debe ser capaz de buscar respuestas correctas a preguntas. En el paper original de ReAct se usa Google como herramienta de búsqueda.\nconversational-react-description: está pensado para ser usado de manera conversacional, puede decidir qué herramienta usar y tiene memoria para recordar lo que ya se ha hablado.\nCreando un agente # El siguiente código crea un agente que puede usar herramientas para lograr sus objetivos:\n# Creando un agente con LangChain from langchain.agents import load_tools from langchain.agents import initialize_agent from langchain.agents import AgentType from langchain.llms import OpenAI llm = OpenAI(temperature=0) tools = load_tools([\u0026#34;serpapi\u0026#34;, \u0026#34;llm-math\u0026#34;], llm=llm) agent = initialize_agent( tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True ) print(\u0026#34;Este agente puede buscar en Google y hacer aritmética básica.\u0026#34;) while True: query = input(\u0026#34;Pregunta algo: \u0026#34;) if not query: break print(agent.run(query)) El código anterior es suficiente para crear una agente que tiene dos capacidades: buscar en internet con Google y hacer operaciones matemáticas básicas. El código es bastante simple, pero vamos a explicarlo paso a paso.\nComo siempre, la primera parte es importar las funciones y tipos necesarios:\nfrom langchain.agents import load_tools # Es una función que te ayuda a cargar las herramientas que los agentes serán capaces de usar from langchain.agents import initialize_agent # Es una función que te ayuda a crear un agente de manera sencilla from langchain.agents import AgentType # Es un tipo que te ayuda a especificar el tipo de agente que quieres crear, contiene todos los tipos de agentes que LangChain provee from langchain.llms import OpenAI # Es la clase que abstrae la conexión con el LLM que usaremos: GPT, creado por OpenAI Después, creamos una instancia de conexión con el LLM:\nllm = OpenAI(temperature=0) El que le digamos que queremos cero de temperatura significa que la respuesta será menos aleatoria, por lo que podemos pensar que será menos \u0026ldquo;creativa\u0026rdquo; o arriesgada. Esto es buena idea cuando quieres crear planes, usar herramientas con una interfaz formal, como una API. Para poder usarlo, tienes que poner en el entorno de ejecución la variable de entorno OPENAI_API_KEY con tu API key de OpenAI.\nSeguido de esto, cargamos las herramientas que queremos que el agente pueda usar, indicando el modelo de lenguaje que usará para interactuar con ellas:\ntools = load_tools([\u0026#34;serpapi\u0026#34;, \u0026#34;llm-math\u0026#34;], llm=llm) La primera es una herramienta para buscar en Google, se llama SerpApi, y permite usar la búsqueda que nosotros hacemos en Google mediante una interfaz más amigable para programas. La versión gratuita te da 100 búsquedas mensuales.\nLa segunda herramienta, llm-math, tiene como objetivo permitir que el agente haga matemáticas básicas, aunque tampoco están garantizadas porque se ejecuta código que el LLM devuelve. El prompt que usa es (lo traduzco a español después):\nYou are GPT-3, and you can\u0026#39;t do math. You can do basic math, and your memorization abilities are impressive, but you can\u0026#39;t do any complex calculations that a human could not do in their head. You also have an annoying tendency to just make up highly specific, but wrong, answers. So we hooked you up to a Python 3 kernel, and now you can execute code. If you execute code, you must print out the final answer using the print function. You MUST use the python package numpy to answer your question. You must import numpy as np. Question: ${Question with hard calculation.} ```python ${Code that prints what you need to know} print(${code}) ``` ```output ${Output of your code} ``` Answer: ${{Answer}} Begin. Question: What is 37593 * 67? ```python import numpy as np print(np.multiply(37593, 67)) ``` ```output 2518731 ``` Answer: 2518731 Question: {question} Traducido al español:\nEres GPT-3, y no puedes hacer matemáticas. Puedes hacer matemáticas básicas, y tus habilidades de memorización son impresionantes, pero no puedes hacer ningún cálculo complejo que un humano no pudiera hacer en su cabeza. También tienes una tendencia molesta a inventar respuestas específicas, pero incorrectas. Así que te conectamos a un kernel de Python 3, y ahora puedes ejecutar código. Si ejecutas código, debes imprimir el resultado final usando la función print. DEBES usar el paquete Python numpy para responder tu pregunta. Debes importar numpy como np. Pregunta: ${Pregunta con cálculos duros.} ```python ${Código que imprime lo que necesitas saber} print(${código}) ``` ```output ${Salida de tu código} ``` ``` Respuesta: ${Respuesta} Comienza. Pregunta: ¿Cuánto es 37593 * 67? ```python import numpy as np print(np.multiply(37593, 67)) ``` ```output 2518731 ``` Respuesta: 2518731 Pregunta: {Pregunta} Este módulo después extrae la respuesta de la salida del LLM y la ejecuta en un ejecutor de Python y extrae de aquí la respuesta.\nAunque por ser un ejecutor de Python tenemos garantizado que el cálculo es correcto, no tenemos garantizado que el código introducido sea adecuado, así que no confíes siempre en sus cálculos.\nDespués de eso inicializamos un agente, al que le pasamos las herramientas que usará, el modelo de lenguaje y el tipo de agente que queremos crear. Además, le decimos que escriba en la salida estándar todo su proceso con la opción verbose=True:\nagent = initialize_agent( tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True ) De este modo LangChain hará todo lo necesario para inicializar un agente que use actúe de manera autónoma. Ahora le podemos preguntar cosas:\nprint(\u0026#34;Este agente puede buscar en Google y hacer aritmética básica.\u0026#34;) # Creamos un loop para que while True: query = input(\u0026#34;Pregunta algo: \u0026#34;) if not query: break print(agent.run(query)) Recuerda que esto puede contestar preguntas que se puedan encontrar en internet y hacer aritmética.\nConclusión # En este tutorial hemos visto cómo crear un agente básico. Falta explorar los demás tipos de agentes, así como las demás herramientas que LangChain provee para que podamos crear agentes más complejos y funcionales. Además, hay que probar con diferentes agentes y ver cómo se comportan.\n","date":"20 abril 2023","externalUrl":null,"permalink":"/2023/04/20/creando-agentes-con-langchain-y-gpt-4/","section":"Posts","summary":"\u003cp\u003eEn este pequeño tutorial vamos a hablar de cómo puedes crear agentes que interactúen con el mundo exterior, usando LangChain y como modelo de lenguaje GPT-4. Como siempre, la mejor manera de aprender es haciendo algo, por lo que vamos a crear un agente\u003c/p\u003e","title":"Creando agentes con LangChain y GPT-4","type":"posts"},{"content":"","date":"20 abril 2023","externalUrl":null,"permalink":"/tags/gpt4/","section":"Tags","summary":"","title":"Gpt4","type":"tags"},{"content":"","date":"20 abril 2023","externalUrl":null,"permalink":"/tags/langchain/","section":"Tags","summary":"","title":"Langchain","type":"tags"},{"content":"","date":"17 abril 2023","externalUrl":null,"permalink":"/tags/aws/","section":"Tags","summary":"","title":"AWS","type":"tags"},{"content":"","date":"17 abril 2023","externalUrl":null,"permalink":"/tags/composici%C3%B3n/","section":"Tags","summary":"","title":"Composición","type":"tags"},{"content":"Composición:\nEs la acción de combinar componentes individuales para formar un sistema más complejo.\nComponer es la técnica más efectiva para construir software de manera organizada. La composición nos permite crear software complejo porque nos permite construir piezas pequeñas que resuelven problemas manejables y luego \u0026ldquo;juntarlas\u0026rdquo; para entregar la solución de nuestro problema.\nVeamos algunas formas de hacer composición en el software y por qué es más efectivo que otras formas de reutilizar código.\n¿Por que es importante aprender a usar la composición? # Nuestra habilidad para descomponer un problema en partes, depende directamente de nuestra habilidad para combinar soluciones. - John Hughes\nJohn Hughes es un gran proponente e investigador de la programación funcional en la actualidad. Él propone que la composición es importante porque nos da la confianza de poder romper nuestros problemas en problemas más pequeños, sabiendo que después podremos juntarlos de manera efectiva para entregar una solución al problema original.\nDivide y vencerás\nUna ventaja secundaria de dividir el software en piezas pequeñas, es que si diseñamos correctamente nuestros componentes y tenemos las herramientas adecuadas para unirlas después, podemos reutilizar las piezas que ya hemos construido en otras partes.\nVeamos dos formas de aplicar la composición en el software.\nComposición de funciones # Las funciones son la unidad de abstracción más pequeña que tenemos en la programación. Crear pequeñas funciones útiles que resuelvan problemas generales, de manera completa y precisa, es muy buena idea.\n¿Cómo aplicamos la composición? Puedes usar la composición al dividir tu problema principal en funciones sencillas y luego juntarlas.Veamos un ejemplo: vamos a crear un validador de contraseñas. Este debe verificar las siguientes condiciones:\nVerificar una longitud mínima, que podría ser 8 caracteres. Checar que no tenga ciertas palabras (lista negra). Verificar que tiene un número Verificar que tiene un carácter especial Podríamos hacer esto en una sola función que verificara todas estas características, una por una a través de un serie de if\u0026rsquo;s. Pero veamos una implementación usando composición, y sus ventajas.\ndef min_length(password, min_length): return len(password) \u0026gt;= min_length def has_number(password): return any(char.isdigit() for char in password) def has_special_char(password): return any(char in \u0026#34;!@#$%^\u0026amp;*()_+\u0026#34; for char in password) def not_in_blacklist(password, blacklist=[]): if not blacklist: blacklist = [\u0026#39;password\u0026#39;, \u0026#39;12345678\u0026#39;] return not any(word in password for word in blacklist) def validate_password(password, min_length, blacklist): return min_length(password, min_length) and \\ has_number(password) and \\ has_special_char(password) and \\ not_in_blacklist(password, blacklist) Quiero que te fijes especialmente en la última función, validate_password. Aunque funciona, es un poco rígida. La composición puede ayudarnos a hacerla más flexible.\ndef validate_password(password, min_length=8, blacklist=[\u0026#39;b1\u0026#39;, \u0026#39;b2\u0026#39;]): validators = [ lambda password: min_length(password, 8), has_number, has_special_char, lambda password: not_in_blacklist(password, [\u0026#39;palabra_uno\u0026#39;, \u0026#39;palabra_dos\u0026#39;]) ] return all(validator(password) for validator in validators) Esta función es más flexible, pudiendo agregar o quitar validadores sin tener que modificar más código, simplemente modificando la lista de validadores, pero todavía no es como la queremos. ¿Qué pasas si queremos agregar el conjunto de errores por los que falla una validación? Tenemos que ir acumulando:\ndef validate_password(password, min_length=8, blacklist=[\u0026#39;b1\u0026#39;, \u0026#39;b2\u0026#39;]): \u0026#34;\u0026#34;\u0026#34;Devuelve la lista de errores de la contraseña, si está vacía, la contraseña es válida\u0026#34;\u0026#34;\u0026#34; validators = [ {\u0026#34;validator\u0026#34;: lambda password: min_length(password, 8), \u0026#34;mesage\u0026#34;: \u0026#34;La contraseña es muy corta\u0026#34;}, {\u0026#34;validator\u0026#34;: has_number, \u0026#34;message\u0026#34;: \u0026#34;La contraseña no tiene un número\u0026#34;}, {\u0026#34;validator\u0026#34;: has_special_char, \u0026#34;message\u0026#34;: \u0026#34;La contraseña no tiene un carácter especial\u0026#34;}, {\u0026#34;validator\u0026#34;: lambda password: not_in_blacklist(password, [\u0026#39;palabra_uno\u0026#39;, \u0026#39;palabra_dos\u0026#39;]), \u0026#34;message\u0026#34;: \u0026#34;La contraseña tiene palabras prohibidas\u0026#34;} ] errors = [] reduce(lambda errors, validator: errors.append(validator[\u0026#34;message\u0026#34;]) if not validator[\u0026#34;validator\u0026#34;](password) else errors, validators, errors) return errors Aquí reduce que recibe una función, una lista de elementos por las que iterar y un valor inicial, nos ayuda a acumular los errores. Si quisiéramos hacerlo aún más flexible, podríamos hacer dos cosas:\nHacer que la función validate_password reciba una lista de validadores (junto con el mensaje), en vez de tenerlos definidos dentro de la función Definir una clase Validator que tenga un método validate y un atributo message y que reciba una función y un mensaje en su constructor, para tener una interfaz más clara. Composición matemática # Este tipo de composición fue un poco más empírica, simplemente juntando funciones. A veces, cuando oigas de composición, se van a referir a la composición de funciones en sentido matemático. Veamos un ejemplo en Python:\nfrom string import ascii_letters LETTERS = set(ascii_letters) def quitar_no_ascii(texto): return \u0026#39;\u0026#39;.join([char for char in texto if char in LETTERS]) def reemplazar_acentos(texto): accents = { \u0026#39;á\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;é\u0026#39;: \u0026#39;e\u0026#39;, \u0026#39;í\u0026#39;: \u0026#39;i\u0026#39;, \u0026#39;ó\u0026#39;: \u0026#39;o\u0026#39;, \u0026#39;ú\u0026#39;: \u0026#39;u\u0026#39;, \u0026#39;ñ\u0026#39;: \u0026#39;n\u0026#39; } return \u0026#39;\u0026#39;.join([accents.get(char, char) for char in texto]) def limpiar_cadena(texto): return quitar_no_ascii(reemplazar_acentos(texto)) El código anterior deja una cadena solamente con letras ASCII, sin acentos. Lo que ves en la función limpiar_cadena es una composición de funciones, en el sentido matemático, aplicar una función después de otra, o la salida de una como argumento de la otra.\nSiempre que pienses en un proceso que lleve una cadena de pasos, lo puedes representar como una cadena de funciones. En lenguajes funcionales hay operadores para hacer esto.\nPuedes pensar en este tipo de composición como en hacer fluir la información por un conjunto de funciones. Ejemplos en lenguajes como Haskell, Clojure y Elixir te pueden ayudar a expandir sobre esto, puedes buscarlo como \u0026ldquo;composición funcional\u0026rdquo;.\nComposición de objetos # Otra técnica que te puede ayudar a crear mejor software es la composición de objetos. Esta se entiende como formar objetos más complejos a partir de objetos más simples. Aunque la herencia es una forma de composición, al hacer completamente dependientes una clase de otra, no es la mejor forma de crear objetos complejos. De hecho, hay grandes dudas sobre si la herencia es una buena idea. Pero no estamos aquí para discutir sobre las ventajas y desventajas de la herencia, sino para aprender a usar otros tipos de composición.\nUna forma de crear objetos complejos, en vez de tener la relación \u0026ldquo;es un\u0026rdquo; que nos da la herencia, es tener la relación \u0026ldquo;tiene un\u0026rdquo;. No estamos diciendo que la herencia nunca se deba usar, pero en muchas ocasiones podemos pensar en la composición como una alternativa mejor.\nObserva el siguiente ejemplo, en el que representamos la información de un usuario y su relación con al entidad Empleado:\nclass Usuario: def __init__(self, nombre, apellido, email, password): self.nombre = nombre self.apellido = apellido self.email = email class Empleado: def __init__(self, usuario, puesto, salario): self.info_usuario = usuario self.puesto = puesto self.salario = salario Esta implementación está menos acoplada o es menos dependiente que la implementación basada en herencia. Por ejemplo, si queremos evolucionar la clase Usuario, no tenemos que hacer que nada de esto afecte directamente a la clase Empleado.\nOtra forma de usar la composición es la delegación, a la que le dedicaremos más tiempo en un futuro. Esta te la puedes imaginar como que un objeto le deja todo el trabajo a otro a través, por ejemplo, de un método. Esto es más común en lenguajes no basados en clases, ya que se da de manera más natural, como en JavaScript, donde puedes usar Object.assign para copiar las propiedades de un objeto a otro.\nConclusión # Aprender a usar la composición es obligatorio para desarrollar buen software. Lo quieras o no, mientras desarrollas, siempre estás juntando componentes, es decir componiendo, si conoces las técnicas correctas, podrás crear software de mejor calidad de manera más rápida.\nPiensa en el desarrollo de software como el arte de deconstruir los problemas, resolverlos por cachitos y después juntar las soluciones de regreso para tener la solución completa.\n","date":"17 abril 2023","externalUrl":null,"permalink":"/2023/04/17/composici%C3%B3n-en-el-software/","section":"Posts","summary":"\u003cp\u003eComposición:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eEs la acción de combinar componentes individuales para formar un sistema más complejo.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eComponer es la técnica más efectiva para construir software de manera organizada. La composición nos permite crear software complejo porque nos permite construir piezas pequeñas que resuelven problemas manejables y luego \u0026ldquo;juntarlas\u0026rdquo; para entregar la solución de nuestro problema.\u003c/p\u003e","title":"Composición en el software","type":"posts"},{"content":"","date":"17 abril 2023","externalUrl":null,"permalink":"/tags/fp/","section":"Tags","summary":"","title":"Fp","type":"tags"},{"content":"","date":"17 abril 2023","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"17 abril 2023","externalUrl":null,"permalink":"/tags/instrumentaci%C3%B3n/","section":"Tags","summary":"","title":"Instrumentación","type":"tags"},{"content":"En una arquitectura de microservicios, las operaciones muchas veces abarcan múltiples servicios y recursos tales como gateways, microservicios, balanceadores de carga, bases de datos entre otros. La naturaleza distribuida de los microservicios es lo que hace invaluable la instrumentazión de software.\nSi nuestro código provee información de traceo para requests, y logs, podemos decir que está instrumentado y que podemos observar cómo se está desempeñando nuestro sistema.\nLa instrumentación de servicios es especialmente útil para identificar y resolver problemas de rendimiento y errores. Los datos recolectados pueden ser usados para planear la capacidad de nuestros servicios al ayudarnos a entender el tráfico y patrones de uso en nuestras aplicaciones.\nExisten varias soluciones para instrumentar nuestros servicios, como OpenTelemetry, Zipkin y datadog. AWS también ofrece una Distribución de OpenTelemetry para poder usar OpenTelemetry como backend de obserbabilidad mientras usas X-Ray o cualquier otra solución de terceros para recibir datos de telemetría y proveer procesamiento, agregación y visualización de éstos.\nEn este post, les voy a contar sobre mi experiencia al instrumentar un microservicio en Go usando Gin y AWS X-Ray.\nGin # Gin es un framework para el lenguaje de programación Go para crear aplicaciones web, se destaca por ser ligero y tener un alto rendimiento, diseñado para facilitar la creación de aplicaciones web escalables de una manera rápida.\nOfrece una API minimalista, un router robusto, soporte para middleware y características de seguridad integradas, lo que lo convierte en una opción ideal para construir microservicios y otras aplicaciones web de alto rendimiento.\nSi bien Gin puede tener una curva de aprendizaje empinada y características limitadas integradas, su simplicidad y capacidad de extensión lo convierten en una opción popular para los desarrolladores que priorizan el rendimiento y la escalabilidad.\nCrear un servicio de Gin desde cero está fuera del alcance de esta publicación, pero puedes leer más sobre Gin en la página oficial de su documentación.\nAWS X-Ray # AWS X-Ray es un servicio de AWS que recolecta datos sobre los requests servidos por tu aplicación y provee herramientas para ver, filtrar y obtener información sobre esos datos para identificar problemas y oportunidades de optimización.\nAlgunos puntos a favor de X-Ray sobre otras herramientas similares son:\nFacilidad de integración con otros servicios de AWS. No hay infraestructura extra qué mantener (el daemon de X-Ray está incluído en las plataformas AWS Elastic Beanstalk y AWS Lambda). Puede funcionar sólo como visualizador (usando OpenTelemetry como tracer). Para servicios soportados, el SDK de X-Ray puede enviar y rastrear automáticamente los \u0026ldquo;ID de request\u0026rdquo; entre los servicios. Es administrado por AWS. Los primeros 100k rastreos del mes son gratis. El primer millón de rastreos obtenidos o escaneados cada mes es gratis. Sin embargo algunos puntos en contra son:\nAWS X-Ray sólo puede ser usado con aplicaciones corriendo en Amazon EC2, Amazon EC2 containser service, AWS Lambda, y AWS Elastic Beanstalk. Después de agotar los rastreos gratuitos del mes, cada rastreo indexado y consultado tiene un costo. Soporte limitado de lenguajes: Mientras que el SDK de X-Ray tiene soporte para varios lenguajes de programación, no soporta todos los lenguajes o plataformas, lo cual puede limitar su utilidad en algunos casos. Vendor lock-in: El uso de X-Ray puede llevar a la dependencia exclusiva de AWS, ya que es un servicio propietario disponible sólo en la plataforma de AWS. Esto puede limitar su capacidad para cambiar a otros proveedores de nube o herramientas en el futuro. Si, después de leer algunos de los pros y contras, aún estás inclinado a usar X-Ray, entonces puedes seguir leyendo.\nRequerimientos # Para ver la información de rastreo en AWS X-Ray, necesitas una cuenta de AWS y una aplicación corriendo en la infraestructura de AWS o que esté integrada con los servicios de AWS. Además, necesitarás:\nUna instancia del X-Ray daemon, que se puede ejecutar como un binario o como un contenedor de Docker. Puedes encontrar instrucciones detalladas sobre cómo ejecutar y configurar el daemon aquí. Para éste artículo, estaré usando el binario para OS X. Tu aplicación debe de tener los permisos necesarios para interactuar con AWS X-Ray y otros servicios que use. IAM Role # Para permitir que tu aplicación mande información sobre tus requests a X-Ray, tienes que proveerle al daemon de X-Ray un rol. Para crear un rol, vamos a entrar a nuestra consola web de AWS y de allí navegamos a la página principal de IAM y allí encontraremos el botón \u0026ldquo;Create Role\u0026rdquo; (o \u0026ldquo;Crear Rol\u0026rdquo; si tienes configurado tu panel de AWS en español).\nEn el asistente, selecciona \u0026ldquo;AWS Account\u0026rdquo; para Trusted Entity y da click en \u0026ldquo;Next\u0026rdquo;/\u0026ldquo;Siguiente\u0026rdquo;. En la siguiente pantalla, busca por la política de permisos llamada \u0026ldquo;AWSXRayDaemonWriteAccess\u0026rdquo;. Da click en \u0026ldquo;Next\u0026rdquo;/\u0026ldquo;Siguiente\u0026rdquo; para continuar..\nAgrega un nombre y descripción para el rol, y después da click en \u0026ldquo;Create Role\u0026rdquo;. Ésto te llevará a la lista de roles. Busca el rol que acabas de crear para ver y copiar su ARN.\nX-Ray Daemon # Ahora que ya tenemos el rol para el daemon, vamos a configurarlo.\nPara mi proyecto de prueba, solo tuve que cambiar algunos valores de la configuración, como el nivel del logger, especificar el modo local a verdadero, y agregar el ARN del rol que creamos y la región de AWS en la que estamos operando nuestros servicios.\nAquí está la configuración que usé:\n# Send segments to AWS X-Ray service in a specific region Region: \u0026#34;us-west-2\u0026#34; Socket: # Change the address and port on which the daemon listens for UDP packets containing segment documents. UDPAddress: \u0026#34;127.0.0.1:2000\u0026#34; # Change the address and port on which the daemon listens for HTTP requests to proxy to AWS X-Ray. TCPAddress: \u0026#34;127.0.0.1:2000\u0026#34; Logging: # Change the log level, from most verbose to least: dev, debug, info, warn, error, prod (default). LogLevel: \u0026#34;dev\u0026#34; # Turn on local mode to skip EC2 instance metadata check. LocalMode: true # Assume an IAM role to upload segments to a different account. RoleARN: \u0026#34;arn:aws:iam::269174633178:role/X-Ray_Daemon_role\u0026#34; # Daemon configuration file format version. Version: 2 En la guía del desarrollador de AWS X-Ray puedes aprender más sobre otros valores que puedes configurar.\nInstrumentando tu microservicio en Go # Ahora que ya tenemos el X-Ray daemon configurado y corriendo, podemos proceder a instrumentar nuestro servicio.\nAWS recomienda empezar agregando rastreo para requests entrantes envolviendo los controladores de servicio con xray.Handler. Pero, como estamos usando Gin, el enfoque que implementaremos es ligeramente diferente.\nMientras buscaba recursos sobre cómo instrumentar una aplicación con Gin, me encontré con éste middleware, el cual está basado en la función xray.Handler.\nÉste middleware hace el mismo trabajo que xray.Handler, abrirá y cerrará un segmento para cada request recibido. También se encargará de manejar el header para IDs de rastreo (\u0026quot;x-amzn-trace-id\u0026quot;), que es un header que contiene un identificador que será generado para cada petición nueva y que será propagado a travéz de todos nuestros microservicios.\nAsí que vamos a agregar el middleware a las rutas que queremos intrumentar:\n// as part of my gin routes v1.GET(\u0026#34;/auth/roles\u0026#34;, xraymid.Middleware(xray.NewFixedSegmentNamer(\u0026#34;GetRoles\u0026#34;)), controller.GetRoles) Aquí estamos agregando el middleware de X-Ray (con el alias xraymid) a una ruta del grupo v1. El valor que estamos pasando como argumento a NewFixedSegmentNamer debe de ser un nombre descriptivo para tu ruta. Éste será el nombre para el grupo principal de rastreo para éste endpoint.\n¡Bien! ¡Ahora veamos si funciona! Inicia tu servicio y verifica que el daemon esté corriendo.\nDespués de hacer un request, podemos ver en los logs del daemon algo como:\n2023-03-21T13:10:47-06:00 [Debug] Received request on HTTP Proxy server : /GetSamplingRules 2023-03-21T13:10:48-06:00 [Debug] processor: sending partial batch 2023-03-21T13:10:48-06:00 [Debug] processor: segment batch size: 1. capacity: 50 2023-03-21T13:10:48-06:00 [Info] Successfully sent batch of 1 segments (0.109 seconds) 2023-03-21T13:10:49-06:00 [Debug] Send 1 telemetry record(s) ¡Parece que está funcionando! Vamos a ver qué dice la consola de AWS.\nEn tu consola web de AWS, ve a CloudWatch y en el panel lateral busca la opción para X-Ray, y da click en la opción \u0026ldquo;traces\u0026rdquo;.\nSi todo salió bien, deberías estar viendo el número de rastreos recibidos recientemente, y una tabla con la información de esos rastreos.\nEn la tabla de registros, da click en alguno. Aparecerá la vista de rastreo/seguimiento, donde puedes ver la información registrada.\nAquí podemos ver los datos de seguimiento. Hasta el momento sólo estamos creando un segmento y cerrándolo para cada llamada, por lo que no tenemos mucha otra información, pero podemos ver el código de estado de respuesta, el tiempo que tomó para que se atendiera la solicitud y, por supuesto, el mapa de seguimiento, que por ahora incluye sólo el cliente y el servicio.\nCreando sub segmentos # Ahora que tenemos nuestra configuración básica de instrumentación, ¿qué más podemos rastrear?\nHasta el momento, solo estamos rastreando una solicitud y algunos de sus metadatos. Pero, ¿qué pasa si queremos ser más detallados?\nDigamos que tenemos un proceso intensivo que se ejecuta como parte de la solicitud; podemos agregar un subsegmento para monitorearlo.\nEn algún lugar de mi servicio, se ejecuta el siguiente código cuando llamo al endpoint auth/roles:\n// dentro de alguna función roles := make([]Role, len(rolesList)) for i, roleItem := range rolesList { role, err := u.buildRole(roleItem) if err != nil { return model.RoleList{}, err } roles[i] = role } Aquí podemos envolver el bucle for en un subsegmento para ver cuánto tiempo del request tarda en ejecutar éste proceso.\nPara crear el subsegmento, envolvemos el ciclo:\nerr = xray.Capture(ctx, \u0026#34;BuildRolesDetail\u0026#34;, func(ctx1 context.Context) error { for i, roleItem := range rolesList { role, err := u.buildRole(roleItem) if err != nil { return err } roles[i] = role } if err = xray.AddMetadata(ctx1, \u0026#34;No. roles built\u0026#34;, len(roles)); err != nil { return nepErrors.InternalServerError.WithDetail(err.Error()) } return nil }) Vamos a correr nuestro servicio y llamemos de nuevo nuestro endpoint instrumentado.\nÉste es el nuevo registro en AWS CloudWatch -\u0026gt; Traces:\nAhora podemos ver que la petición tomó 215ms, y de esos, el ciclo BuildRolesDetail tomó 205ms.\n¿Ya estás pensando en las posibilidades? ¡Deberías! puedes usar xray.AddMetadata para agregar cualquier dato que te sea de utilidad. Únicamente toma en cuenta que el Daemon de X-Ray sólo envía a AWS hasta 64KB de metadata por segmento.\nInstrumentando clientes de AWS con X-Ray # Instrumentar clientes de AWS usando el SDK-V1 es bastante sencillo, puedes seguir la guía oficial para hacerlo.\nNo hay mucha documentación sobre cómo instrumentar clientes de AWS usando el AWS SDK-v2, pero la configuración es bastante sencilla.\nEn algún lugar en el código de tu servicio, estás inicializando tu(s) cliente(s) de AWS. Para instrumentarlos, necesitas proveer a tus clientes con un cliente HTTP de X-Ray y pasar el contexto del request para cada llamada.\ncfg, err := config.LoadDefaultConfig(ctx) if err != nil { return nil, err } // Create an HTTP client httpClient := \u0026amp;http.Client{} // Set the HTTP client as the AWS configuration\u0026#39;s HTTP client cfg.HTTPClient = httpClient // Create an X-Ray client xrayClient := xray.Client(httpClient) dynamoClient := dynamodb.NewFromConfig(cfg, func(options *dynamodb.Options) { // Wrap the http.Client with an xray.Client options.HTTPClient = xrayClient }) Aquí, estoy agregando el cliente HTTP de X-Ray al cliente de AWS DynamoDB.\nUna vez hecho esto, llamemos de nuevo a nuestro endpoint instrumentado.\nYo estoy corriendo DynamoDB localmente, pero ya puedes ver qué tanto tiempo toma cada llamada a DynamoDB. También podemos ver que el mapa de rastreo ha sido acualizado para mostrar mi instancia local de DynamoDB.\nConclusión # Instrumentar un servicio con X-Ray es relativamente sencillo, pero puede complicarse muy rápido dependiendo de las cosas que queremos monitorear. Debido a esto, el esfuerzo para agregar trazabilidad a su servicio puede variar de caso en caso.\nOtra cosa a considerar es el límite de 64KB por segmento. Puede que no sea suficiente si deseas rastrear muchos subsegmentos o agregar más metadatos. Existen formas de evitar esto, pero están fuera del alcance de esta publicación.\nEn conclusión, implementar X-Ray en un microservicio en Go es un proceso sencillo que puede beneficiar enormemente la observabilidad y las capacidades de resolución de problemas de tu aplicación. El proceso de integración es relativamente fácil, y el SDK de X-Ray proporciona una serie de características útiles que facilitan la trazabilidad de las solicitudes y la identificación de cuellos de botella. Sin embargo, es importante tener en cuenta que X-Ray tiene algunas desventajas, como el costo asociado con su uso y las limitaciones de sus capacidades de muestreo.\nNo obstante, con una consideración cuidadosa y una implementación adecuada, X-Ray puede ser una herramienta invaluable para la depuración y optimización de tu arquitectura de microservicios. Así que no dudes en probarlo y ver cómo puede mejorar el rendimiento y la confiabilidad de tus microservicios en Go.\n","date":"17 abril 2023","externalUrl":null,"permalink":"/2023/04/17/instrumentando-microservicios-en-go-con-gin-y-aws-x-ray/","section":"Posts","summary":"\u003cp\u003eEn una arquitectura de microservicios, las operaciones muchas veces abarcan múltiples servicios y recursos tales como gateways, microservicios, balanceadores de carga, bases de datos entre otros. La naturaleza distribuida de los microservicios es lo que hace invaluable la instrumentazión de software.\u003c/p\u003e","title":"Instrumentando microservicios en Go con Gin y AWS X-Ray","type":"posts"},{"content":"","date":"17 abril 2023","externalUrl":null,"permalink":"/tags/microservicios/","section":"Tags","summary":"","title":"Microservicios","type":"tags"},{"content":"","date":"17 abril 2023","externalUrl":null,"permalink":"/tags/programaci%C3%B3n/","section":"Tags","summary":"","title":"Programación","type":"tags"},{"content":"","date":"15 abril 2023","externalUrl":null,"permalink":"/tags/llm/","section":"Tags","summary":"","title":"Llm","type":"tags"},{"content":"","date":"15 abril 2023","externalUrl":null,"permalink":"/tags/tutorial/","section":"Tags","summary":"","title":"Tutorial","type":"tags"},{"content":"Los grandes modelos de lenguaje o LLM\u0026rsquo;s (Large Language Models) han sido noticia en este 2023. Es por eso que han surgido muchos proyectos y herramientas que permiten crear software basado en estas herramientas.\nEn este artículo vamos a poner un pequeño tutorial de una herramienta creada para hacer aplicaciones basadas en LLM\u0026rsquo;s: LangChain.\n¿Qué es LangChain? # Las aplicaciones basadas en procesamiento de lenguaje natural, sea como una herramienta de comunicación o como su producto principal, normalmente requieren fuentes de información para potenciar sus capacidades.\nTambién es una muy buena idea que estas aplicaciones puedan actuar por sí mismas usando las instrucciones creadas por un LLM. Para hacer esto podemos usar agentes.\nLangChain provee componentes que te permiten lograr estas dos tareas, para que tú los uses como quieras, pero también te provee de cadenas de componentes (composición de software, ¿te suena?) con casos de uso comunes, digamos que prefabricados, para hacer software basado en LLM\u0026rsquo;s de manera más rápida.\nHablemos de qué componentes te provee LangChain para empezar a construir tus programas basados en LLM\u0026rsquo;s.\nComponentes principales # LangChain provee varios tipos de componentes, muchos de los cuales son abstracciones de los conceptos más usados en la interacción con LLM\u0026rsquo;s, veamos algunos de ellos:\nTexto. La abstracción más básica es la que representa un texto cualquiera que le mandamos a un LLM. Este texto puede provenir de diferentes fuentes, como archivos, por ejemplo.\nDivisores de texto. Generalmente, un modelo de lenguaje no puede consumir mucho texto al mismo tiempo, por lo que para poder procesar textos grandes hay que mandárselos por partes. Este componente se encarga de ayudarte a dividir el texto en partes que el LLM pueda procesar.\nÍndices. Es una abstracción que presenta el texto de mejor manera para que un LLM pueda acceder a la información mejor. Los índices se tienen que guardar de alguna manera y LangChain provee una interfaz para guardarlos en una base de datos especializada.\nModelo. Esto es la interfaz con un modelo de lenguaje. Te lo puedes imaginar como el equivalente a un conector a base de datos, abstraen los detalles de la conexión y te dan una interfaz común.\nAgente. Un agente puede recibir instrucciones en forma de alguna abstracción de texto, para ejecutar acciones en sistemas externos o consultando para consultar al LLM.\nCadena. Las cadenas son conjuntos de componentes que sirven para resolver problemas comunes o crear aplicaciones completas.\nYa que entendemos las cosas que LangChain nos da, veamos cómo usarlas.\nCreando una aplicación de ejemplo # Vamos a crear una aplicación que nos permita consultar todos los posts de este blog y contestar preguntas. Por suerte, existe una cadena que ya nos permite hacer esto.\nInstalación # Primero veamos los requisitos: además de LangChain, necesitas los siguientes paquetes:\nopenai chromadb tiktoken Por lo que tu requirements.txt debería verse así:\nlangchain openai chromadb tiktoken Aquí, recomiendo usar un entorno virtual con Anaconda, sobre todo si tienes planes de seguir trabajando con cosas relacionadas con procesamiento de datos.\nPara hacer la creación e instalación puedes correr los siguientes comandos si tienes conda:\nconda create -n entorno_langchain pip conda activate entorno_langchain pip install requeriments.txt Aquí entorno_langchain es el nombre de nuestro entorno virtual y puede ser cualquiera que tú quieras. También, para empezar, necesito una fuente de datos para empezar a probar, por lo que voy a copiar algunos posts de este blog, que están en formato markdown y pueden ser consumidas sin ningún programa adicional. Voy a crear una carpeta llamada docs y dentro copiaré los archivos markdown de este blog, que están en _posts. Tú puedes poner ahí los diferentes archivos que quieras consultar, tal vez directamente en docs.\nMi estructura de archivos se ve así (mi carpeta de trabajo es thedojo_agent):\nthedojo_agent ├── docs │ ├── _posts │ │ ├── 2018-10-28-bienvenidos.md ... muchos archivos más ├── requeriments.txt Teniendo esto listo podemos seguir el ejemplo básico del tutorial de LangChain.\nCreando un script mínimo que funciona # Dentro de un archivo que se llame main.py vamos a escribir el siguiente código:\nfrom langchain.document_loaders import TextLoader from langchain.indexes import VectorstoreIndexCreator loader = TextLoader(\u0026#34;./docs/_posts/2023-04-07-cuando-separar-el-codigo.md\u0026#34;) index = VectorstoreIndexCreator().from_loaders([loader]) query = \u0026#34;¿Cuándo separar el código?\u0026#34; print(index.query(query)) query = \u0026#34;¿Qué es un módulo?\u0026#34; print(index.query_with_sources(query)) Primero importamos el componente TextLoader que nos permitirá cargar texto de un archivo y el componente VectorstoreIndexCreator que nos permitirá crear un índice y almacenarlo como un vector.\nYa nos estamos empezando a meter en cosas que no son tan conocidas. Vamos a explicarlas. Un índice es parecido a lo que se hace en las bases de datos, se analiza la información del texto para guardarle de manera organizada, para que cuando necesitemos encontrar algo, sea fácil de encontrar. Por ejemplo, podría estar organizado por palabras clave y con las referencias a donde se puede encontrar en los textos.\nQue se guarde como un vector tiene que ver con la forma en que trabajan los modelos de lenguaje. Lo que en realidad ve un modelo es una lista de tokens, que son números que representan el texto. Cuando un modelo te da una respuesta, te da una lista de tokens junto con la probabilidad de que cada token vaya en ese orden. Esto son los \u0026ldquo;embeddings\u0026rdquo;, y a final de cuenta son colecciones de números, como listas, lo que se conoce como vectores en este mundo del procesamiento de datos.\nAsí que primero generamos un índice, que consiste en un conjunto de vectores y después lo guardamos.\nEso es justo lo que hacen las dos líneas que siguen al import.\nloader = TextLoader(\u0026#34;./docs/_posts/2023-04-07-cuando-separar-el-codigo.md\u0026#34;) index = VectorstoreIndexCreator().from_loaders([loader]) Después de esto, ahora consultamos el texto de dos formas:\nPrimero que nos de la respuesta solita. Que nos de la respuestas junto con la fuente de donde la sacó. Este ejemplo básico ya empieza a hacer por nosotros lo que queríamos en un principio: consultar un texto y obtener una respuesta.\nVamos a ir un poco más hondo en el código.\n¿Qué hace VectorstoreIndexCreator? # La parte que más magia esconde es el objeto VectorstoreIndexCreator. Este objeto es una composición de otros que cumplen estos roles:\nUn \u0026ldquo;cortador\u0026rdquo; de texto, que ayuda a procesar el texto de la fuente. Un modelo de lenguaje para generar los embeddings. Un almacén de datos, en nuestro caso, un Vectorstore, o una base de datos que almacene vectores. El objeto ya hace por nosotros todo el trabajo, el flujo de información, desde la fuente, que en el ejemplo es un texto cargado desde un conjunto de archivos, hasta el almacén de datos, que en el ejemplo es ChromaDB, que es una base de datos que almacena vectores.\nChromaDB puede correr en memoria o como servidor, pero aquí corre como base de datos en memoria, usando por debajo DuckDB, una base de datos completamente en memoria, así que cuando salgas del programa, se borra todo.\nVamos a dejar para un artículo futuro la creación de un índice, explicando sus parámetros.\nSi quieres ver un ejmplo funcionando, Alex y yo hicimos un ejemplo y platicamos más de esto en este directo:\n¡Esperamos tus comentarios!\n","date":"15 abril 2023","externalUrl":null,"permalink":"/2023/04/15/usando-langchain-para-crear-software-basado-en-llms/","section":"Posts","summary":"\u003cp\u003eLos grandes modelos de lenguaje o LLM\u0026rsquo;s (Large Language Models) han sido noticia en este 2023. Es por eso que han surgido muchos proyectos y herramientas que permiten crear software basado en estas herramientas.\u003c/p\u003e","title":"Usando LangChain 🦜 para crear software basado en LLM's","type":"posts"},{"content":"","date":"7 abril 2023","externalUrl":null,"permalink":"/tags/aposd/","section":"Tags","summary":"","title":"Aposd","type":"tags"},{"content":"Hay quienes afirman que mientras más pequeñas sean tus clases o funciones, mejor. Hasta llegan a poner un límite de la líneas que pueden ir en un método o función. Esto crea código súper fragmentado que llega a ser complejo por el simple hecho de tener muchos elementos individuales que luego se tienen que unir mediante más código. Además, trazar la causa de algo a través de un código similar es casi imposible o, por lo menos, te puede tomar mucho tiempo.\nEs por eso que otros proponentes sobre diseño de software mencionan que mientras más cosas estén detrás de un interfaz y que oculten una implementación, mejor. Esto implica que las funciones y los métodos deben tener un tamaño razonable, sin llegar a ser demasiado grandes. Y este es el punto de este artículo, ¿cómo sabemos cuando es buena idea separar el código en otro módulo? Recuerda que a lo que nos referimos con módulo es cualquier construcción de tu lenguaje que permita encapsular una implementación: clases, funciones, paquetes, etc.\nDominar la división de software en módulos es una pilar del buen diseño de software. Veamos algunos de los criterios que John Ousterhout propone en su libro A Philosophy of Software Design, precisamente en el capítulo nueve que llama \u0026ldquo;¿Mejor juntos o separados?\u0026rdquo; (\u0026ldquo;Better together or better apart?\u0026rdquo;). Empecemos hablando de cuándo es mejor dejarlo junto.\nLo que tienes que mantener enfrente es que la meta de hacerte es pregunta es disminuir complejidad de tu código en general, pero también de hacerlo más fácil de evolucionar haciéndolo más modular.\nCuando dejarlo junto o combinarlo # Acceso a la información. Lo primero que hay que considerar es la información con la que el módulo trata. Si es un slo conjunto de información que en sí mismo es difícil de separar, entonces el código que trata con él debería permanecer junto. También te puedes imaginar un protocolo como HTTP, que para simplemente para verificar que el mensaje está bien formado, se requiere de un información para parsearlo. En este caso, el parseo y la verificación del mensaje deberían estar juntos.\nCercanía semántica. Si dos partes de código se pueden categorizar fácilmente bajo la misma categoría, muy probablemente ese código puede estar bajo la misma clase, módulo o paquete. El ejemplo que da Ousterhout tiene que ver con cadenas de texto y las funciones que las transforman.\nDependencia. Si siempre que quieras entender una parte, de código tienes que mirar a otra, estas dos piezas de código probablemente deben de vivir bajo el mismo módulo. Esto mismo aplica si se usan siempre (o casi siempre) juntas esas dos piezas de código.\nEliminación de código duplicado. Esta es una situación a la que hay que prestarle especial atención. Si notas que estás duplicando código en alguna parte, lo más sensato es juntarlo en un alguna clase o función y llamar desde los diferentes lugares en donde lo estás ocupando. Aquí hay que poner un poco de atención: si este código duplicado son unas pocas líneas, puede que no sea conveniente pasar por la molestia de crear un nuevo módulo y las cosas que se requieren para integrarlo en tu código actual. Algo todavía mejor que puedes hacer es refactorizar tu código para que en vez de se llame en diferentes lugares, se reduzca el número de lugares en donde se llama. Esto es posible sobre todo con las excepciones, dependiendo de tu lenguaje de programación y su estilo de manejo de errores.\nJuntar el código a veces traerá un beneficio extra: eliminarás interfaces que no necesitas. Imagínate dos piezas de código que siempre llamas en secuencia, por ejemplo, la función obtenerHash y verificarHash. Si el 99% de las veces necesitas verificar un hash después de crearlo y al revés, casi siempre que verificas un Hash es porque lo acabas de crear, entonces es mejor que ambas funciones estén juntas, algo como crearHashVerificado. Esto es una buena señal de que el código debería estar junto: si terminas con menos interfaces que al principio, o con interfaces más sencillas.\nCuando separar el código # Algunas personas cuentan la líneas de código y creen que esto es un buen indicador de cuando romper una pieza de código en varias. Esto no es conveniente porque aunque es cierto que mientras más grande sea algo, más probable es que sea difícil de entender, no tiene por qué ser así si está bien organizado.\nUn buen criterio para separar el código es por su nivel de abstracción. No es buena idea tener junto código general y específico para la misma funcionalidad en el mismo módulo, ya que cambios en las funcionalidades específicas podrían afectar a la implementación más general.\nEjemplo: imagina que tienes que crear un editor de texto. Un editor de texto tiene funciones generales como insertar texto donde está el cursor, pero también funcionalidades más específicas, como por ejemplo, seleccionar texto con una interfaz gráfica. Aquí decimos que la inserción de texto es general porque todos los editores de texto lo tienen, mientras que la selección de texto es específica porque no todos los editores de texto tienen una interfaz gráfica (piensa que puedes editar texto mediante instrucciones en un API, por ejemplo).\nEn este caso, dejar en el core solamente las funciones más básicas de edición de texto es buena idea. La selección y borrado de texto pueden ser implementados en otro módulo usando las funciones que el core provee.\nEsto lo puedes ver en práctica en los sistemas diseñados en capas, sobre todo en los MVC: el modelo tiene toda la información específica del negocio, la vista todo lo relacionado con la interfaz hacia el exterior y el controlador la conexión entre estas dos partes. Hay componentes extra, como el ORM o el sistema que se encargue de persistir la información. Aunque esto es un buen comienzo, no es suficiente. Tu propio código debe ser organizado de forma que sea fácil de entender siguiendo estos principios.\nEjemplo: funcionalidad de UNDO (Deshacer) en un editor de texto # John Ousterhout da el ejemplo de la funcionalidad de \u0026ldquo;deshacer\u0026rdquo; en editor de texto. Eso que sucede cuando das CTRL+Z en casi cualquier programa. ¿En qué consiste? En que cuando se realiza una acción, se guarda para que pueda ser contrarrestada con la acción contraria. Esta función puede ser implementada en el módulo central del editor o fuera de él. ¿Cuál es la mejor opción? Imagina que no sólo tienes que poder deshacer acciones directas en el texto, sino también cosas como selecciones o posicionamiento del cursor.\nUna forma de hacerlo sería implementarlo directamente en el módulo o clase encargado de manejar el texto, guardando la lista de acciones que se pueden deshacer y cuando se invoque la acción de deshacer o rehacer, este módulo sería el encargado de ejecutar las acciones de regreso. Este diseño crearía una interacción un poco extraña entre el módulo de interfaz, por ejemplo y el módulo de texto, ya que las acciones de interfaz que se tengan que deshacer, viajarían hacia \u0026ldquo;arriba\u0026rdquo;.\n{: .align-center}\nUn mejor diseño sería separar completamente el módulo de encargado de mantener las acciones que se pueden deshacer, al que podemos llamar Historia. Este módulo sería encargado de guardar y administrar todas las acciones que el usuario tiene disponibles para rehacer o deshacer. Las acciones pueden estar autocontenidas: cada una tiene además información sobre cómo revertirla. ¿Quién pone las acciones en la historia? El módulo que realizó la acción. Por ejemplo, si es una inserción de texto, el encargado sería el módulo core, encargado de manejar el texto. Si es una selección visual, puede ser el módulo de interfaz de usuario. Las acciones son clases con una interfaz común que el módulo de historia puede invocar para deshacer o rehacer.\n{: .align-center}\nConclusión # Aprender a separar tu código es algo que se logra con la práctica y que sin duda vale la pena hacer, porque un código con una complejidad controlada logra un equilibrio entre módulos demasiado pequeños (que hacen muy poco) y demasiado grandes (que juntan mucha información).\nLa guía principal para saber cuándo separar o juntar tu código es esta: escoge la estructura que genere menores dependencias, oculte mejor el conocimiento y cree interfaces más simples.\n","date":"7 abril 2023","externalUrl":null,"permalink":"/2023/04/07/cuando-separar-el-c%C3%B3digo/","section":"Posts","summary":"\u003cp\u003eHay quienes afirman que mientras más pequeñas sean tus clases o funciones, mejor. Hasta llegan a poner un límite de la líneas que pueden ir en un método o función. Esto crea código súper fragmentado que llega a ser complejo por el simple hecho de tener muchos elementos individuales que luego se tienen que unir mediante más código. Además, trazar la causa de algo a través de un código similar es casi imposible o, por lo menos, te puede tomar mucho tiempo.\u003c/p\u003e","title":"Cuando separar el código","type":"posts"},{"content":"","date":"7 abril 2023","externalUrl":null,"permalink":"/tags/ousterhout/","section":"Tags","summary":"","title":"Ousterhout","type":"tags"},{"content":"Continuemos con el estudio de los principios SOLID. En esta ocasión hablaremos del cuarto principio: El principio de segregación de interfaces.\nRecuerda que el objetivo de estos artículos no es explicártelos como si fueran una religión que estás mal si no sigues, sino analizarlos bajo una luz crítica y decidir si de verdad son útiles o podemos usar otro principio.\nAnalicemos primero el enunciado, junto con algunos ejemplos y veamos si nos conviene aplicarlo directamente o no.\nEl principio de segregación de interfaces # La frase que define el principio es:\nLos clientes no deberían ser forzados a depender de interfaces que no usan.\nCreo que el nombre y este enunciado lo hace sonar demasiado complicado para lo que es: se trata de pensar bien tus interfaces para que no sean lo más sencillo que se pueda. \u0026ldquo;Los clientes\u0026rdquo; son todas las partes del código que usan una interfaz.\nAl hacer tus interfaces lo más sencillas que puedas, evitarás que los clientes tengan que implementar métodos que no usan, y que no deberían tener que implementar.\nPongamos un ejemplo de la vida real:\n¿Te ha tocado llenar un formulario que te pregunta cosas que no te aplican? Por ejemplo un formulario que te pregunta por los datos de tus hijos independientemente si no tienes o no. Sin duda es molesto y una pérdida de tiempo. Aquí, te están forzando a cumplir con una interfaz que no usas.\nLo mismo exactamente puede pasar con el software. Si una interfaz, por ejemplo, al usar un método con muchos parámetros obligatorios que no siempre se ocupan, o una clase con métodos que corresponden a otros usos.\nEsto se puede dar cuando tienes una clase o una función que implementa algo que puede ser ocupado en diversos lugares (estos son sus clientes). Imagina que los diferentes lugares tienen ligeras variaciones, por las que hay que modificar la interfaz para que se pueda usar en cada uno de ellos. Hacer esto te llevaría a crear una interfaz complicada de usar y además frágil.\nEs por esto que John Ousterhout da varios consejos relacionados:\nMientras más simple la interfaz, mejor. Son mejores los módulos de propósito general, que después puedan ser especializados o combinados para crear interfaces específicas, para cada caso. Crear las interfaces pensando en el caso más común. Sin embargo, este último consejo de Ousterhout puede ir en contra de este principio, pero aquí preferimos la practicidad sobre la pureza. Más adelante daremos un ejemplo.\nEjemplos de aplicación # Empecemos con un ejemplo que nos pude ayudar a entender el problema y la solución mediante un conjunto de clases.\nUsemos un ejemplo común este blog: una plataforma para enviar mensajes a diferentes canales, como Telegram, WhatsApp, Messenger, Instagram. Una forma de representar la interfaz de un mensaje sería la siguiente:\n{: .align-center}\nAunque podríamos nombrar algunos de estos argumentos como opcionales (lo cuál evitaría que en estricto sentido los clientes estén forzados a usarlos), la interfaz sigue siendo confusa e impráctica. Por ejemplo, si quieres mandar algo por SMS, no tienes la opción de mandar tarjetas multimedia.\nUna mejor solución sería crear un interfaz base, con especializaciones para cada caso. Por ejemplo:\n{: .align-center}\nEsta forma no sigue la herencia (un mensaje con tarjetas es un mensaje de texto), sino la composición (un mensaje con tarjetas tiene un mensaje de texto). Esto nos permite tener una interfaz más sencilla y fácil de usar, que puede ser especializada por cada caso.\nLlevándolo al extremo # Si llevamos este consejo al extremo, podemos quedar con una cantidad tan grande de interfaces y tan especializadas que el código quedaría más difícil de entender y mantener. Imagínate el infierno que sería navegar por ese código. Recuerda que las interfaces son simplemente la parte accesible de una funcionalidad. Ousterhout dice que a veces, la complejidad viene de la cantidad de cosas con las que tenemos que tratar.\nAdemás, separar el código a veces conlleva código extra: el que se usa para seleccionar qué interfaz o código usar.\nAsí que la pregunta básica es: ¿cuándo debo separar o romper código que hace algo en partes más pequeñas? Pensar que este principio es la guía más fuerte es un error, el análisis debe ir mucho más al fondo, no sólo pensar en las interfaces y si alguien está \u0026ldquo;obligado\u0026rdquo; a implementar o lidiar con cosas que no usa.\nPor ejemplo, ¿qué pasa si el 90% de las veces que vayas a usar un módulo como una función vas a usarla en la versión más complejas? ¿Valdrá la pena separarla en dos funciones? Yo creo que vale más la pena que los lugares donde no la usas completa, se trate de manera especial.\nPara un análisis más profundo, escribiré un artículo basado en el capítulo \u0026ldquo;Better Together o Better Apart?\u0026rdquo; de A Philosophy of Software Design de John Ousterhout.\nConclusión # Aunque es una buena idea que las interfaces sean demasiado complejas para no forzar al código que las usa a implementar cosas que no le corresponden, llevarlo al extremo podría hacer que tu base de código sea más compleja de lo que empezó.\nEste principio de diseño no debería ser la única fuente de decisión para saber si deber segregar o como diríamos más cotidianamente separar una interfaz. Recuerda que al separar la interfaz estás separando la implementación y la lógica de tu programa, por lo que debes pensarlo muy bien antes de hacerlo.\nFinalmente, es muy poco probable que te pase algo similar si piensas en hacer interfaces que sean lo más sencillo posible.\n","date":"1 abril 2023","externalUrl":null,"permalink":"/2023/04/01/el-principio-de-segregaci%C3%B3n-de-interfaces/","section":"Posts","summary":"\u003cp\u003eContinuemos con el estudio de los principios SOLID. En esta ocasión hablaremos del cuarto principio: El principio de segregación de interfaces.\u003c/p\u003e\n\u003cp\u003eRecuerda que el objetivo de estos artículos \u003cstrong\u003eno es explicártelos como si fueran una religión que estás mal si no sigues\u003c/strong\u003e, sino analizarlos bajo una luz crítica y decidir si de verdad son útiles o podemos usar otro principio.\u003c/p\u003e","title":"El principio de segregación de Interfaces","type":"posts"},{"content":"","date":"1 abril 2023","externalUrl":null,"permalink":"/tags/isp/","section":"Tags","summary":"","title":"Isp","type":"tags"},{"content":"","date":"1 abril 2023","externalUrl":null,"permalink":"/tags/principios-solid/","section":"Tags","summary":"","title":"Principios-Solid","type":"tags"},{"content":"Hay un dicho que tiene que ver con la guerra que es un gran consejo para crear gran software:\nDivide y vencerás\nDividir un problema para resolverlo por partes tiene muchas ventajas, en este artículo vamos a hablar de ellas, así como de las técnicas y los criterios que puedes seguir para hacerlo efectivamente. Específicamente, en este artículo vamos a hablar de cómo dividir la aplicación en módulos. Pero antes definamos lo que es un módulo.\n¿Qué es un módulo? # En este artículo los módulos son cualquier cosa que encapsule una implementación detrás de una API o interfaz. Los módulos tienen diferentes nombres dependiendo del lenguaje de programación, pueden ser:\nPaquetes en Python Módulos en JavaScript Clases y paquetes en Java Bibliotecas en C Aplicaciones en Erlang o Elixir Un microservicio en una arquitectura de distribuida Otro sistema Esta lista no es para nada exhaustiva, pero comunica la idea de lo que es un módulo conceptualmente, repitiendo: cualquier artefacto que encapsule una implementación o funcionalidad detrás de una API, es decir que tenga una asignación de responsabilidad (según David L. Parnas).\nVentajas de dividir tu aplicación en módulos # ¿Qué es más sencillo? ¿Subir 100 escalones de 15cm o dar un salto de 15m? Humanamente ni siquiera es posible dar un salto de 15m, por lo que tenemos que recurrir a usar las escaleras.\nLo mismo sucede intelectualmente, la mayoría de los problemas que resolvemos en programación son más grandes de lo que puede caber en nuestra mente en un tiempo determinado. Es por esto que tenemos que descomponer los problemas en partes más pequeñas.\nLa modularización te permite cambiar el sistema de forma más sencilla, mientras respetes la interfaz entre los módulos (su API), puedes cambiar el módulo que resuelve cierta parte del problema sin afectar el sistema entero. A esto a veces le llaman programación por contrato.\nCrear módulos lo más independientes posible te permite reutilizarlos en otros sistemas, lo que llamamos reutilización de código. Si sigues los lineamientos de tu lenguajes de programación, probablemente puedas crear el artefacto para distribuirlo y que incluso otras personas lo usen.\nFinalmente, dependiendo de lo independiente que sean los módulos, puedes asignarle la tarea de la implementación a otras personas.\nDesventajas # Al igual que si pudiéramos mágicamente dar un salto de 15m nos evitaría construir unas escaleras, con todo lo que ello implica, el uso de módulos en tu aplicación agregar algo más de complejidad.\nEn primera, se requiere una infraestructura para que los módulos puedan comunicarse entre sí. Si los módulos son construcciones naturales de tus sistema de programación, entonces sólo tienes que preocuparte por usarlos bien y crear interfaces convenientes.\nPero si estás haciendo sistemas independientes, microservicios, etc. entonces también tienes que preocuparte por el transporte de información, la seguridad, etc. Este tipo de modularidad convierte tu aplicación en un sistema distribuido, lo que agrega gran complejidad.\nAdemás, dividir en módulos introduce el riesgo de crear complejidad adicional debida a las dependencias entre los módulos.\nPero normalmente, las ventajas de modularizar te habilitan para lograr cosas que no es posible hacer de otra forma, así que ahora surge la pregunta, ¿por dónde empiezo?\nCriterios para dividir tu aplicación en módulos # Esto en realidad es una exploración de las diferentes formas en las que tu aplicación podría estar dividida y las abstracciones que creas. ¿Los divido por grupos de funcionalidades? ¿Por el tipo de información a los que tienen acceso? ¿Por el lugar en el que van a estar implementados? ¿Por el nivel de abstracción?\nDavid Parnas explica en \u0026ldquo;On the Criteria to be Used in Decomposing Systems into Modules\u0026rdquo; dos diferentes formas o criterios de dividir un sistema en módulos:\nLa que él piensa que era la más común cuando se escribió el artículo, es la de dividir el programa en sus pasos lógicos. Después de hacer un diagrama de flujo del proceso que quieres automatizar o representar, los pasos del diagrama se convierten en módulos.\nLa segunda forma es la de dividir o \u0026ldquo;cortar\u0026rdquo; el programa en módulos por especialidad, es decir, por las cosas que saben hacer y que ocultan de los demás módulos. Estos módulos encapsulan decisiones de diseño.\nEjemplo práctico: una pasarela de pago # La función de una pasarela de pago es procesar las transacciones de pago de los usuarios. Debe registrar datos como quién hace el pago, a quién se lo hace, el monto, la fecha y hora, el método de pago y el estado de la transacción.\nHagamos el ejercicio de descomponer el sistema en módulos. Primero usemos el primer criterio. Pensando en el flujo de operaciones que se tienen que hacer podemos pensar en los siguientes pasos:\nRecibir los datos de la transacción a ejecutar. Recibir los datos de pago del usuario. Validar los datos de la transacción. Intentar ejecutar la transacción. Registrar el estado de la transacción. Notificar a los involucrados del resultado de la operación. Vamos a delimitar las funciones para hacerlo más sencillo: pongamos que sólo se puede pagar con tarjeta de crédito y que se notificará al usuario por correo electrónico.\nLos módulos que podríamos crear usando este flujo son:\nMódulo de recepción de datos. Este sistema recibe los datos de la transacción a ejecutar y los pone en una base de datos. También se encarga de validarlos.\nMódulo de recepción de datos del usuario. Recibe los datos de pago del usuario y actualiza el registro de la transacción.\nMódulo de ejecución de la transacción. Lee los datos de la transacción de la base de datos e intenta ejecutar la transacción, actualizando el registro con el resultado de la operación.\nMódulo de notificación. Es capaz de leer el registro de la base de datos para extraer los datos de la transacción y enviar un correo electrónico al usuario.\nMódulo central. Se encarga de coordinar el funcionamiento de los demás módulos, los llama en el orden correcto y maneja los errores.\nEste diseño sin duda funcionaría, pero tiene algunas desventajas. ¿Qué pasaría si se aumentara la información que se tiene que registrar de la transacción? A todos los módulos les afectaría, ya que todos leen de un repositorio central que es la base de datos. ¿Y si en vez de recibir los datos por separado, se quisiera leer todos los datos de un archivo para ejecutar pagos en masa? Por lo menos dos módulos saldrían afectados, el de recepción de información de la transacción y de información del usuario.\nPara dividir el trabajo en varios equipos, antes tendría que establecerse la forma en la que se van a guardar los datos en la base de datos y cualquier cambio les afectaría a todos.\nDividiendo por especialidad # En vez de dividirlo por el flujo de operaciones, como si fuera una cadena de producción usemos el criterio de la especialidad, o de ocultar información. ¿Cuáles son las decisiones de diseño que quisiéramos ocultar detrás de una interfaz?\nUsando este criterio podemos tener los siguientes módulos:\nMódulo de recepción de información. Recibe todos los datos, tanto de la transacción como se pago y los valida. Envía estos datos al almacenamiento indicado mediante una interfaz. ¿Qué decisiones de diseño oculta? La forma en la que se reciben y validan los datos\nMódulo de registro de transacciones. Recibe la información de las transacciones, las almacena y es capaz de devolver la transacción solicitada. También puede actualizar los datos de una transacción y borrarla. ¿Qué decisiones de diseño oculta? La forma en la que se persiste la información. Ninguno de los otros módulos necesita saber cómo se almacenan los datos.\nMódulo de procesamiento de transacciones.. Este módulo recibe los datos absolutamente necesarios para procesar una transacción con la institución bancaria, la ejecuta y devuelve un estado de la transacción. Tiene funciones para ejecutar, re-intentar y revertir transacciones. ¿Qué decisiones de diseño oculta? La comunicación con la institución bancaria, la forma en la que se reciben los datos de estas y el procesamiento de errores en la transacción.\nMódulo de notificaciones. Es capaz de mandar notificaciones por correo electrónico, recibiendo los datos de los destinatarios y el mensaje que se tiene que mandar. ¿Qué decisiones de diseño oculta? La forma de comunicación con los medios de transporte de notificaciones, en este caso, el correo electrónico.\nMódulo de coordinación o central. Es el encargado de usar los módulos anteriores para procesar el pago.\nLa principal diferencia de este diseño con el anterior, es la forma en la que los módulos se comunican y la información que cada módulo debe de tener. Cualquier cambio en la implementación de sus funciones no afectará a los demás módulos, sobre todo cambios en la persistencia de la información, que era un punto crítico en el diseño anterior.\n¿Que pasa si quisiéramos cambiar la forma en la que se reciban los datos, por ejemplo, con el archivo para procesar los pagos en masa? El módulo de recepción de información se vería afectado o reemplazado, pero los demás módulos no.\nSi queremos dividir el trabajo en equipos, cada equipo puede trabajar en un módulo siempre y cuando se establezca la interfaz de su módulo, y las dependencias entre ellos se reducen.\nResumen # No existe una forma absolutamente correcta de dividir tu sistema, casi siempre es subjetiva y todas presentan ventajas y desventajas. Pero una decisión con la que no te puedes equivocar es la de aislar los detalles de implementación y las decisiones de diseño en módulos autocontenidos.\nPiensa en un módulo como en una caja que sabe hacer algo y que puedes usar en varios lugares de tus sistema, no como en un paso de un proceso, que normalmente lo casa con esa posición y lo hace poco reutilizable, además de que puede hacer que no esté tan autocontenido como debería, dejando escapar información que crea dependencias entre módulos.\nRecursos para aprender más # El artículo en el que está basado este artículo es \u0026ldquo;On the Criteria to be Used in Decomposing Systems into Modules\u0026rdquo; de David L. Parnas.\nOtro recurso del que tal vez ya estés harto de escuchar si lees este blog es A Philosophy of Software Design. Aquí se explican varios principios para poder descomponer tu aplicación en módulos de forma efectiva, tomando como principal referencia este artículo de Parnas, y expandiéndolo con la experiencia de Ousterhout.\nConclusión # Descomponer tus aplicaciones en módulos es algo esencial en el desarrollo de software. Pensarlo un poco antes de hacerlo nos dará una gran ventaja para crear software de mejor calidad, que sea más fácil de mantener y que podamos evolucionar mejor.\nEsta descomposición no siempre te va a salir bien a la primera, por lo que hay que tener la capacidad de evaluar la efectividad de tu diseño y la humildad para reconocer o aceptar los puntos débiles y cambiarlos. Es cierto que ciertas plataformas te pueden ayudar a descomponer mejor tu aplicación que otras, por lo que también es un gran punto a considerar cuando estés eligiendo la tecnología para tu próximo proyecto.\nSigue cultivando esta habilidad, porque es de lo más importante que un desarrollador de software puede saber, pensando también que a futuro tal vez seamos en gran parte diseñadores mientras la implementación estará a cargo de máquinas (te estoy viendo, Codex).\n","date":"25 marzo 2023","externalUrl":null,"permalink":"/2023/03/25/descomponiendo-tu-aplicaci%C3%B3n-en-m%C3%B3dulos/","section":"Posts","summary":"\u003cp\u003eHay un dicho que tiene que ver con la guerra que es un gran consejo para crear gran software:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDivide y vencerás\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eDividir un problema para resolverlo por partes tiene muchas ventajas, en este artículo vamos a hablar de ellas, así como de las técnicas y los criterios que puedes seguir para hacerlo efectivamente. Específicamente, en este artículo vamos a hablar de cómo dividir la aplicación en módulos. Pero antes definamos lo que es un módulo.\u003c/p\u003e","title":"Descomponiendo tu aplicación en módulos","type":"posts"},{"content":"","date":"25 marzo 2023","externalUrl":null,"permalink":"/tags/dise%C3%B1o/","section":"Tags","summary":"","title":"Diseño","type":"tags"},{"content":"","date":"25 marzo 2023","externalUrl":null,"permalink":"/tags/m%C3%B3dulos/","section":"Tags","summary":"","title":"Módulos","type":"tags"},{"content":"A veces limitamos el uso de la palabra API a un programa que nos regresa información mediante una conexión web, generalmente en un formato que una máquina puede procesar. Pero muchas otras veces se usa de manera más amplia. En este artículo hablaremos de otras acepciones y qué tiene que ver con la buena programación.\nApplication Programming Interface # La realidad es que el inicialismo \u0026ldquo;API\u0026rdquo; es casi auto-explicativo: Interfaz de Programación de Aplicación. Bueno, vamos a analizarlo un poco.\nInterfaz # Primeramente es un interfaz. Una interfaz es el lugar en donde dos sistemas o entidades convergen e interactúan. Podemos entender como interfaz a la parte que te permite usar un aparato electrónico, por ejemplo. En una computadora, su interfaz para los humanos son el teclado, la pantalla y el mouse o trackpad. En una televisión, la interfaz es la pantalla, el control remoto y los controles integrados en el cuerpo principal.\nLa interfaz normalmente esconde la mayor parte del sistema y muestra solamente las partes que son relevantes o que se pueden usar por un sistema externo. En el caso de la computadora, ver o interactuar directamente con el procesador o la RAM no nos interesa, por eso la computadora expone un conjunto limitado de todas las características que la componen. Esta interfaz en realidad representa una abstracción de lo que el sistema completo es. Este elemento habilita y simplifica el uso de este sistema. Las interfaces definen la forma de un sistema para entidades externas a él.\nUna interfaz podría entenderse como un iceberg: la parte \u0026ldquo;visible\u0026rdquo; o con la que puedes interactuar es la punta, mientras que la gran masa es la funcionalidad que está oculta y a la que no puedes acceder.\n{: .align-center}\n(Probablemente ese iceberg está mal dibujado: The topple of an iceberg: You\u0026rsquo;re drawing it wrong)\nInterfaz de Programación # Ya que sabemos que es una interfaz, ahora agreguemos el siguiente término: programación. Que sea un interfaz de programación nos indica la forma en la que esta interfaz puede ser usada: mediante el fino arte de la programación. Otra forma en la que creo que suena bien la traducción es Interfaz Programática. Así como las interfaces visuales se entienden mediante la visión, las interfaces programáticas se entienden y usan con programas.\n¿Qué hace que una interfaz pueda ser usada de manera sencilla por un programa? Listemos algunas de las características:\nLa comunicación con la interfaz se puede hacer por medio un programa. La manera más sencilla es por medio de texto plano en formatos establecidos o formatos binarios. Estos pueden ser, por ejemplo, HTTP y para facilitar más las cosas JSON o XML. Hay formatos binarios usados como Protcol Buffers. Pero no tiene que ser ninguno de estos. Mientras el formato se pueda procesar de manera automática con un programa, es una interfaz de programación. Por ejemplo, una aplicación podría escribir a un archivo y la otra simplemente leerlo de ahí (ejem. así funcionan los sockets en UNIX). O por ejemplo, la \u0026ldquo;aplicación\u0026rdquo; puede ser cargada en el mismo espacio de memoria y ser usada por el mismo entorno de ejecución. La interfaz puede recibir peticiones o instrucciones creadas por un programa. Muy en la línea del punto anterior, la interfaz debe exponer formas de que otro programa la llame mediante medios programables. Si la interfaz cumple con esto, entonces es una interfaz de programación.\nInterfaz de Programación de Aplicación # El último término nos dice a quién la pertenece esta interfaz: a otra APLICACIÓN. Esto nos dice que la interfaz pertenece a un programa para que otro programa se comunique.\nResumen: un API es lo que permite la comunicación entre dos programas de manera automática, es decir, sin que tengan que intervenir humanos en esa comunicación. Le permite a un programa usar otro.\nCon el tiempo, lo que llamamos \u0026ldquo;aplicación\u0026rdquo; se ha extendido para referirse a cualquier programa o parte de un programa, como un módulo, una clase, etc.\nUso de \u0026ldquo;API\u0026rdquo; en el contexto actual # Recapitulemos: una API es una interfaz entre dos programas, que permite a ambos una comunicación unidireccional o bidireccional.\nEl uso más común tiene que ver con interfaces que tienen comunicación a través de una red de computadoras, como Internet. Normalmente son un servidores HTTP que pueden responder con formatos que pueden ser procesados de automáticamente de manera sencilla, los más comunes son JSON y XML. Dependiendo de los estándares que sigan, estas API\u0026rsquo;s pueden ser llamadas RPC (Remote Procedure Call), ReST (Representational State Transfer) o SOAP (Simple Object Access Protocol).\nEste tipo de comunicación a través de la red tiene varias versiones, no sólo HTTP. Por ejemplo, existen alternativas más modernas como gRPC (Google Remote Procedure Call), que usa HTTP2 como medio de transporte y Protocol Buffers com formato de serialización (el lenguaje que puede ser fácilmente procesado por otro programa).\nSeguro existen muchas otras formas de crear un API en un sistema distribuido pero la idea básica ya la tienes. Este es el uso más común de la palabra.\nAhora hablemos de otro uso de la palabra: en el diseño de software.\nAPI\u0026rsquo;s en el diseño de software # Cuando se usa la palabra API en contexto de diseño de software, normalmente se refiere a la interfaz que otro sistema, módulo, o en general, componente del software presenta.\nPor ejemplo, podemos decir que una clase tiene un API en el sentido de que presenta una cara a los demás parte del sistema para que lo usen, pero sobre todo oculta la implementación de las funciones que da. Como te podrás dar cuenta, una API es la parte pragmática de una abstracción, y por eso es importante entenderlas.\nEl diseño del API de tus módulos, clases y aplicaciones en general es importantísimo para hacer buen software.\nRetomando lo que siempre repetimos en este blog: las interfaces bien diseñadas te permiten ocultar información que no quieres que otras partes del sistema tengan en cuenta.\nPor ejemplo en Elixir, la forma de crear separación entre diferentes partes del sistema, a parte de módulos, son lo que llamamos aplicaciones. Esta aplicación puede tener un API bien definida que permita que sea 1) fácil de usar 2) que oculte todos los detalles de implementación posibles para que no se escape nada de información no concerniente a otras aplicaciones.\nCómo diseñar una buena API # En esta sección voy a mencionar lo que a mi me ha servido para crear interfaces que, al mismo tiempo que son fáciles de usar, son efectivas escondiendo información.\nLas interfaces deben tener una complejidad relativa a la funcionalidad que están ocultando. Es decir si tienes una función o clase que hace muy poquito, como por ejemplo, hacer un cálculo sencillo y casi auto-explicativo, no te conviene que tengas que pasar veinte datos diferentes para que lo puedas usar, lo único que vas a lograr es que tu programa sea más complicado de usar. En cambio, si la funcionalidad que está detrás de la API es grande y compleja, por supuesto que vale más la pena que la interfaz sea más compleja y requiera que pienses más para usarla.\nComo analogía: el control de una bicicleta consiste en un manubrio análogo, mientras que el de un avión tiene decenas (¿tal vez más de 100?) de botones.\nEsto está muy relacionado con el concepto que John Ousterhout presenta en \u0026ldquo;A Philosophy of Software Design\u0026rdquo;: crear módulos profundos, es decir, que tengan una interfaz lo más pequeña posible en relación con su funcionalidad, que debe ser lo más grande posible. Como un iceberg.\nDocumenta bien las interfaces. No sirve de mucho una interfaz que nadie sepa como usar. Como en las películas de ciencia ficción donde encuentran aparatos que nadie tiene idea de cómo funcionan, así nos puede pasar con una pieza de software. La documentación de la interfaz debe incluir, además de los nombres de los métodos o llamadas, los tipos de datos esperados (enteros, flotantes, cadenas, fechas), el comportamiento dependiendo de la entrada y el tipo y estructura de la información que devuelve. Es supremamente importante además que se mencione si el uso de la interfaz tiene un efecto secundario, como el disparo de un correo, la creación o manipulación de un archivo.\nExplica la razón de ser. Esta parte de la documentación cuenta como un ejercicio que tiene dos objetivos: aclararte a ti mismo la razón de la existencia de la interfaz (aquí te vas a dar cuenta de que tal vez no vale la pena crearla o de que debe ser diferente de alguna forma). Si encuentras una buena explicación, entonces definitivamente el contenedor que tiene una API debe ser creado, y lo que vale la pena ser creado en programación, vale la pena ser documentado.\nNo ocultes información demasiado temprano. Los puntos anteriores te pueden ayudar a no caer en este error, pero por si las dudas vamos a dejarlo claro: no tienes por qué separar o crear abstracciones de todo y ponerlo detrás de una API. La separación de implementaciones a final de cuentas puede crear una carga extra: cómo transferir la información. El caso más claro es el de las interfaces que se comunican a través de un red, en las que necesitamos usar una capa de transporte. Pero en otras ocasiones también implica un poco de trabajo extra, que puede no valer la pena si no estamos en la etapa correcta.\nVentajas de usar un API bien diseñada # Usar un API tiene varias ventajas, pero yo veo tres principales que pueden llevar tu desarrollo a niveles que no esperabas. Hablemos de ellas y tú evaluarás si es algo que te interese.\nMenor carga cognitiva # Al separar tu software en varios componentes o aplicaciones que trabajen mediante interfaces, puedes reducir el número de cosas que tienes que mantener en la cabeza debido a que no te preocuparás por todos los detalles: solamente te interesarás por la interacción entre las API\u0026rsquo;s o tu software y un API.\nEsto es justo lo que pasa cuando un front-end se hace separado de un backend. Después de establecer la forma de la API, cuando trabajas en un lado, en front por ejemplo, sólo te preocupas de mostrar los datos que sabes a recibir de la interfaz sin preocuparte de los detalles de procesamiento o de almacenamiento de información de los que el backend se hace cargo.\nMejor evolución del software # Esto se logra gracias a que, si los diferentes componentes de un sistema están comunicados por API\u0026rsquo;s claramente definidas, que además protejan bien los detalles de implementación de escaparse, estas partes pueden cambiarse internamente sin necesidad de afectar a otras parte si la forma de la interfaz se respeta. Además permite extender el software si creamos otro componente con la misma interfaz pero otro funcionamiento, por ejemplo.\nPodríamos decir que las piezas son intercambiables, tal como cuando tienes un foco que se descompone y quieres reemplazarlo por otro, o simplemente quieres cambiar tu viejo foco incandescente por uno de led. Mientras consigas uno con la misma interfaz y que trabaje con el mismo voltaje, no importa la \u0026ldquo;implementación\u0026rdquo;, es decir, cómo cumpla con su función de entregar luz: podría ser otro incandescente, fluorescente, de led, o incluso podrías poner una cámara o un ventilador.\nEsto se puede llevar al extremo si la interfaz que estás usando está estandarizada y tienes un programa que sepa utilizar este tipo de interfaces automáticamente. Por ejemplo esa es la idea de ReST y GraphQL.\n{: .align-center}\nLas interfaces proveen la función de \u0026ldquo;plug and play\u0026rdquo;, mientras el aparato tenga la misma interfaz, podemos conectar cualquier cosa, como en los contactos eléctricos.\nMejor separación del trabajo # Esto se puede inferir del comentario que hicimos, en el primer punto de las ventajas de usar un API. Si creas una interfaz estable y bien documentada, puedes delegar el trabajo de implementar las funciones detrás de esa interfaz a otra personas, otro equipo o de plano otra empresa.\nEn Open Source, por ejemplo, después de definir la API de un componente y hacer una implementación de referencia, se deja en manos de la comunidad crear otras implementaciones de ese módulo.\nCómo decidir los módulos # Finalmente, surge la pregunta, ¿cómo puedo decidir qué irá detrás de una interfaz y cómo crear la separación de funciones entre módulos?\nDe eso hablaremos en un artículo futuro, basándonos en un artículo de David L. Parnas, \u0026ldquo;On the Criteria to be Used in Decomposing Systems into Modules\u0026rdquo;.\nConclusión # Lo importante de saber que es un API es entender su función y tener técnicas para diseñarlas lo mejor posible. Recuerda, un API no se limita a un servidor web que sirve JSON, sino que es toda aquella interfaz que puede ser usada con un programa. De ahí que los navegadores expongan API\u0026rsquo;s como la File API, Fetch API, Device API, etc.{:target=\u0026quot;_blank\u0026quot;}, que no tienen nada que ver con una API de un servidor web, sino con el uso de otras partes del software y que mediante esta interfaz nos olvidamos de los detalles de implementación.\nCuando a ti te toque diseñar un API, recuerda su principal función: separar dos partes de un software al mismo tiempo que permites la comunicación.\n","date":"18 marzo 2023","externalUrl":null,"permalink":"/2023/03/18/qu%C3%A9-es-una-api/","section":"Posts","summary":"\u003cp\u003eA veces limitamos el uso de la palabra \u003cstrong\u003eAPI\u003c/strong\u003e a un programa que nos regresa información mediante una conexión web, generalmente en un formato que una máquina puede procesar. Pero muchas otras veces se usa de manera más amplia. En este artículo hablaremos de otras acepciones y qué tiene que ver con la buena programación.\u003c/p\u003e","title":"¿Qué es una API?","type":"posts"},{"content":"","date":"18 marzo 2023","externalUrl":null,"permalink":"/tags/abstracci%C3%B3n/","section":"Tags","summary":"","title":"Abstracción","type":"tags"},{"content":"","date":"18 marzo 2023","externalUrl":null,"permalink":"/tags/apis/","section":"Tags","summary":"","title":"Apis","type":"tags"},{"content":"","date":"18 marzo 2023","externalUrl":null,"permalink":"/tags/definiciones/","section":"Tags","summary":"","title":"Definiciones","type":"tags"},{"content":"Gran parte del trabajo que hacemos como desarrolladores de software consiste en \u0026ldquo;abstraer\u0026rdquo;, pero a veces no entendemos lo que esto significa.\nEn este artículo vamos a empezar explicando qué es la abstracción en general y luego cómo puedes mejorar tu habilidad de abstraer para programar más rápido y para crear mejores programas. La capacidad de crear mejores abstracciones te permitirá crear programas que no creías que pudieran existir o que tú pudieras crear.\nEmpecemos por las mismísimas bases.\nEtimología: ¿de dónde viene la palabra abstracción? # \u0026ldquo;Abstracción\u0026rdquo; viene del latín abstrahere, que tiene dos partes principales: abs que significa \u0026ldquo;fuera de\u0026rdquo;, \u0026ldquo;sin\u0026rdquo; o \u0026ldquo;a distancia\u0026rdquo; y trahere que significa \u0026ldquo;tirar\u0026rdquo;. La palabra abstrahere significa literalmente algo como \u0026ldquo;tirar fuera\u0026rdquo;.\nLa palabra abstrahere se usa en el sentido de \u0026ldquo;separar\u0026rdquo; o \u0026ldquo;extraer\u0026rdquo; en el contexto de la filosofía, la matemática y la física. En el contexto de las matemáticas, la abstracción es el proceso de separar un concepto de sus propiedades físicas.\nA veces entendemos el proceso de abstraer como la capacidad de generalización. Por ejemplo, si queremos abstraer el concepto de \u0026ldquo;mesa\u0026rdquo;, lo que hacemos es quitar todas las características concretas de todas las mesas que hemos visto en la vida y entonces vemos lo que tienen todas en común: nos permiten hacer algo sobre ellas, sea parados o sentados. De esta manera tenemos el concepto abstracto de una mesa en nuestra mente. Después podemos aplicar ese concepto a diferentes cosas que veamos.\nLos seres humanos somos máquinas de abstraer. Si a un niño pequeño le presentas unos cuantos gatos o perros, es capaz de aprender el concepto \u0026ldquo;gato\u0026rdquo; y extenderlo a otros gatos que vea aunque no se parezcan mucho a los que ya vio. Lo que no es capaz de hacer normalmente, es definir en palabras lo que es un \u0026ldquo;gato\u0026rdquo; de manera precisa.\nComo resumen: abstraer es \u0026ldquo;tirar fuera\u0026rdquo;, sacar las características que definen algo de su contexto concreto y ser capaz de entender ese concepto de manera general. Esta capacidad nos permite comprender el mundo y movernos en él.\nAlgunos definen las abstracciones como lo contrario: quitarle todo lo que no es necesario a un concepto para 1) resaltar y hacer visible lo que importa y 2) Ocultar detalles que no deben ser tomados en cuenta.\nA estas abstracciones a veces las llamamos modelos. ¿Te suena?\n{: .align-center}\nCómo la usamos en la programación # Aunque los seres humanos nos la pasamos abstrayendo todo lo que vemos en la vida real (de hecho, lo único que tenemos en nuestra cabeza son abstracciones), no siempre podemos hacer las siguientes dos cosas:\nDelimitar precisamente la abstracción Expresar o explicar esa abstracción a otras personas, en lenguaje común. Y esto precisamente es lo que necesitamos al programar: delimitar nuestras abstracciones y expresarlas en algún lenguaje de programación, como una tabla en una base de datos o de alguna otra forma que las computadoras puedan capturar y procesar, a esto es a lo que nos referimos cuando hablamos de abstraer en la programación.\nLo que hace más difíciles las abstracciones en la programación es que normalmente los conceptos no son tan sencillos e incluso son de áreas con las que no estamos familiarizados o no tenemos experiencia.\nLa capacidad de abstraer es muy importante en casi todo trabajo intelectual, sobre todo aquellos relacionados con la lógica, por eso es supremamente importante en la programación. Aquí es donde la programación se parece al trabajo de un matemático: debes traducir un problema informal de la vida real, normalmente en lenguaje natural a un lenguaje formal que una computadora pueda entender. Para hacer esto, debes dejar los aspectos más importantes del problema para representarlos de manera efectiva en tu programa final.\nPero recuerda que las abstracciones en programación también deben ocultar detalles que no queremos que se vean en otras partes del programa, por lo que se incluye una tarea más: refinar estas abstracciones hasta que contengan la información completamente necesaria.\nLa abstracciones las podemos ver en muchas formas en la programación:\nModelos de datos Tipos de datos Objetos Funciones Clases Módulos Interfaces Todas estas cosas que mencionamos tienen una característica en común: presentan una interfaz. Así estas abstracciones lo pueden ser en dos sentidos:\nLa representación de un concepto de la vida real en el programa El lugar donde se ocultan detalles o información detrás de una interfaz a otra parte del programa Ejemplos de abstracciones # Hablemos de algunos ejemplos y cómo caen en las definiciones que hemos hablado.\nCarrito de compras # Cuando queremos representar algo en un carrito de compra en un programa, lo que hacemos es abstraer el concepto de \u0026ldquo;carrito de compra\u0026rdquo; y representarlo en el programa.\nEn la vida real, un carrito o una bolsa de compra es donde almacenamos las cosas que estamos a punto de comprar mientras estamos en la tienda.\nLa abstracción del carrito de compra, entonces, es un conjunto de productos, cada uno con su precio y cantidad. En el programa, el carrito de compra es una lista de productos que se guarda mientras el usuario no termine de comprar.\nEn esta abstracción se mantuvieron las propiedades importantes: para no ir a pagar artículo por artículo, se tiene un contenedor que nos ayuda a mantener lo que vamos a comprar y pagarlo todo de una vez.\nLa abstracción consiste en que \u0026ldquo;tiramos fuera\u0026rdquo; esas propiedades y eliminamos los detalles, por ejemplo si es un carrito, una canasta, una bolsa, un acompañante que carga tus productos, etc.\nAquí entra otra de las características de las abstracciones. Aunque normalmente somos capaces de entender para lo que sirve el carrito de compra, si le preguntas a un cliente común sobre la abstracción, va a ser difícil que la ponga en palabras, por lo que simplemente usamos ese objeto para representar la abstracción para el usuario. No le decimos \u0026ldquo;contenedor de tus productos mientras terminas la compra\u0026rdquo; sino simplemente \u0026ldquo;carrito de compras\u0026rdquo;.\nEn la segunda forma en la que este carrito de compras puede ser una abstracción es que en tu programa, tal vez hay un clase que representa este contenedor. Para el resto del programa, este carrito tiene una interfaz que podría consistir en:\nAgregar producto Obtener total Vaciar carrito Agregar Cupón Obtener total La manera en que esta clase hace todas esas operaciones debería estar oculta de todo el resto del programa. Incluso la manera en que almacena la información sólo le concierne a esta abstracción. Esto permite ocultar información y hace que las piezas del programa sean menos dependientes entre ellas.\nAbstracción de un usuario # Esta es una de las abstracciones más comunes en los sistemas de software. ¿Qué características esenciales necesitamos de alguna entidad para que use nuestro sistema? Nota que mencionamos \u0026ldquo;entidad\u0026rdquo; y no \u0026ldquo;humano\u0026rdquo;, porque puede que el usuario de nuestro sistema sea otro sistema, por ejemplo.\nEn sistemas como AWS, GCP y Azure, por ejemplo, existen cuentas para computadoras o para que sean usadas por otro servicio (se llaman cuentas de servicio).\nPensando en esto, ¿qué representa a un usuario? Yo me atrevería a decir que los únicos datos absolutamente esenciales para esta abstracción son los que permiten verificar la identidad, aquellos que le permiten a la entidad comprobar que en efecto es ella, o en el caso de sistemas, que puede actuar en nombre de ella.\nPensando más ampliamente, la abstracción del usuario tendrá más atributos dependiendo de lo que aplicación haga. Imagínate una aplicación en la que los usuarios sean pacientes clínicos. ¿Qué datos nos interesan de una persona para esta aplicación?\nNiveles de abstracción # Cuando hablamos de abstracciones en programación, a veces se escucha el término \u0026ldquo;nivel de abstracción\u0026rdquo;. ¿A qué se refiere un \u0026ldquo;nivel\u0026rdquo;? La siguiente imagen nos puede ayudar a entenderlo:\n{: .align-center}\nMientras más cerca esté de la implementación técnica (llegando hasta el hardware), podemos decir que la abstracción está más \u0026ldquo;abajo\u0026rdquo;. Mientras más cerca esté de los pensamientos o la forma en la que los humanos vemos las cosas cotidianamente, la abstracción está más \u0026ldquo;arriba\u0026rdquo;.\nA esto se refiere la abstracción de bajo nivel y la abstracción de alto nivel. Cuando hacemos un programa, utilizamos una \u0026ldquo;cadena\u0026rdquo; de abstracciones, es decir, abstracciones que se sirven de otras abstracciones para funcionar. Usemos de nuevo el carrito de compras como ejemplo.\nEl carrito es la abstracción de más alto nivel, porque es la que más se acerca al pensamiento cotidiano. Esta se sirve de la abstracción del \u0026ldquo;contenedor\u0026rdquo;. Si lo implementamos como una lista, esta es la siguiente abstracción. La lista, dependiendo del lenguaje en el que estemos, puede servirse de la abstracción de un arreglo dinámico. El arreglo, a su vez, se sirve de la abstracción de los bloques y direcciones de memoria. La memoria usa la abstracción de los bits. Y finalmente los bits son un voltaje presente en un circuito, pero esto, a lo que llamamos \u0026ldquo;voltaje\u0026rdquo; sigue siendo una abstracción.\nUn nivel de abstracción está compuesto por todas las abstracciones de nuestro programa que están más o menos igual de separadas de el pensamiento humano. Por ejemplo, el carrito de compras, el checkout (terminar y pagar la compra), una biblioteca, un producto, etc. son abstracciones que están al mismo nivel porque son cosas que el usuario puede entender y con las que trata directamente. Una lista, un cola, un árbol (estructura de datos), una pila, son cosas que están al mismo nivel porque las entendemos como maneras de organizar datos.\nDificultades para abstraer # Abstraer no es tan sencillo como ha parecido hasta ahorita. Más bien, abstraer es algo que hacemos todo el tiempo, pero crear abstracciones adecuadas y expresarlas correctamente no es tan sencillo. De hecho, si te has dedicado a programar por un tiempo, puede que ya te hayas dado cuenta de eso. La primera dificultad es la naturaleza de la información.\nNo nos vamos a poner a filosofar sobre qué es lo que permite definir algo, para eso te recomiendo el libro Data and Reality de William Kent, que te romperá la cabeza con respecto a las abstracciones y las diferentes cosas que debes analizar para representar la realidad en una computadora, más concretamente, en una base de datos.\nLo único que quiero sacar de este libro por el momento es: el mundo real, a diferencia del mundo ideal que nos imaginamos, no tiene límites definidos, no existen los conceptos tan delimitados y tan claros como los queremos hacer ven en los diccionarios.\nEsto nos lleva a que las representaciones (las abstracciones que hacemos en el código) siempre sean subjetivas y arbitrarias. No existe LA ABSTRACCIÓN que represente la realidad sin fallas, todas ellas tienen un punto de vista y se tienen que adecuar para la función que las necesites. Una misma cosa puede ser representada de millones de maneras diferentes y todas estas maneras pueden ser válidas.\nOtra dificultad es lo que hablamos arriba sobre los niveles de abstracción. Algo para lo que se usan las abstracciones en la programación es para ocultar información entre componentes del sistema. Crear abstracciones que no revelen detalles no necesarios a veces no es tan sencillo, y se tienen que pensar detenidamente.\nFinalmente, la complejidad intrínseca de los elementos que representamos puede ser en sí mismo un gran reto para crear abstracciones convenientes. Por ejemplo, en vez de representar gatos, tenemos que representar un proceso de suministro de insumos para una cadena de producción, la logística compleja de programación de vuelos y asignación de aviones y tripulación para una aerolínea, o el estado de una conversación compleja entre dos entidades.\nEs por eso que a veces creemos que necesitamos ayuda para mejorar nuestras capacidades de abstracción.\nCómo mejorar tu capacidad de abstraer # Esta es una de las preguntas que todo programador se hace cuando quiere mejorar su manera y velocidad al programar. Cuando hablamos de \u0026ldquo;la manera\u0026rdquo; de programar, nos referimos a la calidad del código que produce.\nVamos a hablar de las técnicas que puedes seguir para mejorar tu capacidad de crear y expresar mejores abstracciones.\nConsigue información y ejemplos # Ya hemos dicho que los seres humanos somos muy buenos creando abstracciones por naturaleza, pero somos tan buenos que podemos crear abstracciones demasiado temprano cuando entendemos algo bien.\nPara evitar las abstracciones tempranas, consigue la mmayor cantidad de información posible. Mientras más ejemplos diferentes del mismo fenómeno o entidad tengamos, mejores abstracciones vamos a crear, ya que encontraremos ejemplos que se contradicen entre ellos, excepciones y casos límite (aquellos que están en los valores extremos o combinaciones de características raras).\nCrear niveles de abstracción cerrados # Es importante entender los niveles de abstracción porque esto nos permitirá diseñar abstracciones que no dejen pasar detalles de niveles superiores o inferiores hacia el otro lado de la cadena de abstracción. Por ejemplo, al cliente no le debería afectar si el carrito está implementado como una lista, un arreglo directamente, una tupla o un árbol. Dejar pasar esos detalles afectaría la experiencia del usuario, al mismo tiempo que haría más difícil de mantener el código.\nEstos niveles de abstracción se mantienen de dos formas:\nCreando conjuntos de abstracciones relacionados que tengan el mismo nivel. A esto le llamamos una \u0026ldquo;capa\u0026rdquo;. Creando interfaces que oculten los detalles de capas superiores o inferiores. Es muy difícil que este diseño te quede bien a la primera, por lo que debes tener en cuenta que tus interfaces y tus abstracciones irán evolucionando con el tiempo.\nEncontrar patrones # Quiero citar a Manuel Rubio en una respuesta que me dio personalmente:\nEstar atento a estos patrones y saber cómo aprovecharlos en nuestro beneficio puede ayudarnos a crear abstracciones del código que desarrollamos. Hay que ser metódico y organizar bien los datos, nombrar las cosas correctamente, mantener las responsabilidades desligadas unas de otras y entonces los patrones se ven claros.\nEste consejo está directamente ligado a la cantidad de información que tenemos sobre el problema. Mientras más diversa y rica sea, más probable es que encontremos los patrones que subyacen en los comportamientos y procesos que tenemos que abstraer (o modelar). Aquí lo importante es ser explícitos con esos patrones, expresarlos y documentarlos de la manera más clara posible.\nHaber visto y sobre todo documentado una gran cantidad de patrones también nos puede ayudar a diseñar abstracciones de manera más efectiva y rápida en el futuro. Esto es de lo que los patrones de diseño se tratan: soluciones comunes a problemas recurrentes. Sólo hay que ser muy cuidadosos de no encajar problemas en patrones que no corresponden completamente al problema, sólo por el hecho de querer salir rápido del problema o de querer aplicar cierto patrón.\nDiseña dos veces # El diseño del software puede hacerse como la escritura: primero escribes y después editas. Son dos etapas diferentes y tan independientes que dos personas diferentes las pueden hacer. El diseño en el software puede hacerse de manera parecida. Primero diseñas tus representaciones y puedes pedirle a alguien que te corrija o revise, o puedes hacerlo tú mismo después de haber dejado pasar un poco de tiempo.\nEsta revisión te llevará a pensar cosas como \u0026ldquo;¿Qué estaba pensando cuando escribí esto?\u0026rdquo; o \u0026ldquo;Creo que esta no es la abstracción correcta, porque deja escapar detalles no necesarios\u0026rdquo;, gracias a que normalmente te has parado un poco a distancia de tu propio diseño.\nDesarrolla la capacidad de absorber información # Debido a que tienes que representar cosas de dominios en los que probablemente no conoces, tener la capacidad de estudiar de manera efectiva te permitirá analizar la información necesaria para crear buenas abstracciones.\nExpande tu mente # Mientras más cosas sepas de diferentes campos o dominios, será más probable que encuentres cosas que te puedan servir para entender lo que estás tratando de representar y sobre todo para extraer sus componentes principales, así como la información que vale la pena excluir. Así que no te limites en aprender todo lo que puedas de todos los campos posibles, pero recuerda también que esto tiene rendimientos decrecientes: mientras más profundices en un campo, más te costará adquirir nueva información que valga la pena.\nEs por esto mismo que muchos programadores son buenos programando para ciertos dominios: financiero, de automatización industrial, de juegos, de programas científicos, etc. No lo podemos saber todo y muchas veces son el conocimiento de una sola área es suficiente para entretenernos por décadas.\nPractica # Este es el consejo más gastado de todos, pero aquí le vamos a dar un pequeño giro. No sirve de mucho para mejorar sólo hacer abstracciones sin reflexionar en ellas. Tienes que pensar detenidamente en tus diseños y contestar preguntas como:\n¿Qué información tenía disponible y pasé por alto? ¿Cómo hubiera podido conocer u obtener esa información? ¿Qué detalles de implementación dejé escapar de mi abstracción? ¿Quién pudo haberme dado más ejemplos sobre el problema? ¿Quién puede hacer una revisión sobre el diseño y darme comentarios para mejorar? A esto se le llama práctica enfocada y hay ejercicios llamados Code Katas que te pueden ayudar a mejorar en el diseño de software.\n¿Tienes algún consejo más que te haya ayudado a mejorar la forma en la que creas abstracciones? Me gustaría escucharlo en los comentarios.\nEvita los extremos # A veces nos pasamos con las abstracciones, tanto en el nivel como en el momento en el que lo hacemos. En esta sección nos referimos exclusivamente a las abstracciones que generalizan un proceso o concepto, y las que ocultan información de otras partes del programa.\nUna señal de que estamos abstrayendo demasiado es que haya una gran diferencia entre la dificultad natural del problema base y nuestro código. Por ejemplo, imagina que tienes que encontrar una cadena de texto en un texto más grande. La cadena a encontrar es una de tres posibles \u0026ldquo;Kilo\u0026rdquo;, \u0026ldquo;Mega\u0026rdquo;, \u0026ldquo;Giga\u0026rdquo;. ¿Valdrá la pena hacer la abstracción de un buscador general de cadenas cualquiera en textos arbitrarios con el uso de autómatas finitos deterministas? Lo más probable es que no: con un un simple \u0026ldquo;contains\u0026rdquo; o la función equivalente usado en el lugar de la búsqueda es suficiente.\nEsto se puede meter directamente con nuestro orgullo: lo fácil o sencillo no nos hace parecer inteligentes. Pero recuerda que la simplicidad es la mejor sofisticación. Mientras más simples sean tus diseños, mejor. Más fácil será reconocerlos en el futuro, más fácil será que otros los entiendan y lo mejor: los bloques de construcción simples son el mejor fundamento para crear cosas complejas mediante la composición de estos.\nEl otro punto importante es cuándo creamos estas abstracciones. Si quieres crear el programa más complejo desde el principio, lo más probable es que vas a tardar mucho en implementarlo, además de que puede que crees abstracciones que no vas a necesitar. Mejor usa las cosas más concretas posible hasta que de verdad el problema o los requerimientos de los usuarios te hagan generalizar algo. Es cierto que a veces prever algún cambio simplificará tu trabajo en el futuro, pero la mayoría de veces nos equivocamos. Lo hacemos tanto, que existe un inicialismo para refrenarnos de crear abstracciones prematuramente: YAGNI (You aren\u0026rsquo;t gonna need it - No lo vas a necesitar).\nEl costo de las abstracciones # Una abstracción del tipo que esconde código de otras partes del programa, es decir, de las que están detrás de una interfaz (Clase, módulo, función, etc), normalmente cuestan más en tiempo de diseño, de compilación o de ejecución. Normalmente en los tres, a menos que sea una abstracción con la que tengas mucha familiaridad. Esta es otra razón para refrenarnos de crear todas las abstracciones que se nos ocurran en un programa, o de crear cadenas de abstracciones demasiado grandes.\nEsto lo tienes que pensar sobre todo cuando los beneficios de crear cierta abstracción no están tan claros. Con algunos entornos, hay excepciones.\nZero-cost abstractions (Abstracciones sin costo) # Las abstracciones de costo cero son una propuesta de algunos entornos y lenguajes de programación modernos. Como abstraer normalmente supone un costo en el tiempo de ejecución del programa, las abstracciones sin costo proponen que, aunque puedes usar elementos de más alto nivel en el código, no te van a costar rendimiento en tiempo de ejecución.\n¿Entonces en dónde cuestan? Normalmente le cuestan al compilador, reemplazar o expandir macros en tiempo de construcción. Rust es un ejemplo de esto, aunque estas abstracciones están a bastante bajo nivel (te evitan manejos de memoria que podrían ser complicados, por ejemplo).\nConclusión # Mejorar tu capacidad de abstraer conceptos, pero sobre todo de representarlos de manera eficiente en el lenguaje de programación de tu elección te llevará lejos en la carrera de desarrollo de software.\nEste tema es de los más importantes en las ciencias de la computación y desarrollo de software, así que es algo de lo que puedes seguir aprendiendo a lo largo de toda tu carrera. Algunos documentos que puedes consultar para aprender más son:\nProgramación y Tecnología: Un camino equivocado hacia la construcción de artefactos Abstraction in Computer Science Education: An Overview Abstraction Espero que este artículo te sirva en tu camino profesional en la carrera de desarrollo de software.\n","date":"13 marzo 2023","externalUrl":null,"permalink":"/2023/03/13/qu%C3%A9-es-la-abstracci%C3%B3n/","section":"Posts","summary":"\u003cp\u003eGran parte del trabajo que hacemos como desarrolladores de software consiste en \u0026ldquo;abstraer\u0026rdquo;, pero a veces no entendemos lo que esto significa.\u003c/p\u003e\n\u003cp\u003eEn este artículo vamos a empezar explicando qué es la abstracción en general y luego cómo puedes mejorar tu habilidad de abstraer para programar más rápido y para crear mejores programas. La capacidad de \u003cstrong\u003ecrear mejores abstracciones te permitirá crear programas que no creías que pudieran existir o que tú pudieras crear\u003c/strong\u003e.\u003c/p\u003e","title":"¿Qué es la abstracción?","type":"posts"},{"content":"","date":"13 marzo 2023","externalUrl":null,"permalink":"/tags/abstraction/","section":"Tags","summary":"","title":"Abstraction","type":"tags"},{"content":"","date":"13 marzo 2023","externalUrl":null,"permalink":"/tags/abstracto/","section":"Tags","summary":"","title":"Abstracto","type":"tags"},{"content":"El tercer principio enunciado en los principios SOLID es el principio de sustitución de Liskov. ¿Qué significa este principio? Y más importante, ¿vale la pena seguirlo? Pero antes de hablar del principio, hablemos de Barbara Liskov, la persona que lo inspiró y que estableció los conceptos principales.\nUn poco de historia: Barbara Liskov # Barbara Liskov es una matemática muy reconocida en las ciencias de la computación por los grandes aportes que ha hecho. Es conocida por su trabajo en el diseño de lenguajes de programación y la teoría de tipos. En 1994 junto con Jeannette Wing publicó el artículo del que Robert Martin se sacó lo que el llamó \u0026ldquo;el principio de sustitución de Liskov\u0026rdquo; o \u0026ldquo;LSP\u0026rdquo; (Liskov Substitution Principle). Ya ves que los inicialismos le dan un aire de importancia a lo que escribes.\nEn su libro, \u0026ldquo;Mentes Geniales. La vida y obra de 12 grandes informáticos\u0026rdquo;, Camilo Chacón nos da una semblanza de las contribuciones de Barbara a las ciencias de la computación. Sus principales aportaciones, resumidas son:\nLenguajes de programación que aplican ideas de polimorfismo, modularidad, abstracción de datos y manejo de excepciones Sistemas distribuidos (inventó Paxos antes que Leslie Lamport) Abstracción de datos y tipos de datos abstractos Si quieres saber más de ella en poco tiempo, te recomiendo mucho su capítulo en ese libro, es muy interesante, además de que obtiene lecciones muy valiosas de su vida. Ahora sí hablemos de lo que más gente conoce de ella.\nEl principio de sustitución de Liskov # El artículo en el que lo definió se llama \u0026ldquo;A Behavioral Notion of Subtyping\u0026rdquo;. Tiene notación matemática que cuesta un poco leer si no tienes nociones de lenguaje matemático formal, pero resumiremos las ideas básicas aquí.\nEl espíritu del LSP está basado en las ideas de subtipado que Liskov describió en este artículo. Estas ideas tienen muy poco que ver en realidad con herencia en los lenguajes de programación orientados a objetos y mucho más con la abstracción y restricciones que hay que tener en cuenta para considerar que un tipo es un subtipo de otro. Es cierto que Liskov usó las jerarquías de clases para ilustrar sus ideas, pero el principio de su trabajo tiene que ver mucho más con el comportamiento externo de un tipo de datos que con la forma en la que se encapsula este comportamiento.\nPero vayamos a la parte más profunda de la teoría para entender si lo que Liskov propone tiene sentido.\n¿Qué es un tipo? # Un tipo es la definición de lo que un valor almacenado tiene, puede hacer o las operaciones que se pueden hacer sobre él.\nPongamos un ejemplo. En JavaScript el tipo Number define un valor que representa un número de cualquier tipo. Este tipo de dato define las operaciones que podemos hacer sobre los valores con este tipo, por ejemplo:\nPodemos usar el operador + para sumar dos datos de este tipo Podemos usar el operador - para restar dos datos de este tipo Las operaciones (excepto las comparativas) entre el tipo de dato Number siempre devuelven un valor de este tipo También definen la interfaz de este tipo de datos, es decir, la forma en la que podemos interactuar con ellos. Normalmente, en lenguajes orientados a objetos, esta interfaz está compuesta por los métodos públicos que se pueden llamar sobre este tipo de dato.\nPor ejemplo en JavaScript, el tipo Number tiene definido el método toString que nos devuelve este valor como una cadena de texto.\nPero Bárbara Liskov expandió esto, proponiendo lo que llamamos Abstract Data Type o Tipo de Dato Abstracto (les llamaremos ADT). Un tipo abstracto de dato es una definición de un tipo de dato.\nEste tipo de dato no tiene una implementación concreta, sino que define la interfaz que debe tener cualquier implementación de este tipo de dato, siendo responsabilidad del programador implementar esta interfaz.\nEjemplos de ADT\u0026rsquo;s son por ejemplo las Colas (Queues), Listas (Lists), Pilas (Stacks), etc. El ADT define que interfaz debe tener cualquier implementación de este, y cada lenguaje o programador puede implementarlo como le convenga.\nAhora, ¿qué es un subtipo?\n¿Qué es un subtipo? # Un subtipo es una derivación de un tipo. Esta derivación puede ser una variación, una generalización o una especialización de este tipo. Normalmente se usan para hacer especializaciones.\nY aquí es donde empezamos a entrar en el terreno del LSP. Una de las restricciones más importantes que Liskov propone es que si un tipo de dato tiene definido un método X, entonces cualquier subtipo de este tipo (que en relación con este se llama \u0026ldquo;supertipo\u0026rdquo;) también debe tener este método definido.\nPara hacerlo más generalizable podemos cambiar \u0026ldquo;método\u0026rdquo; por cualquier elemento visible en la interfaz de este tipo de dato.\nAsí, nos podremos usar que estas clases sean intercambiables entre ellas, sin siquiera tener que hacer consciente a la parte del programa que la usa de qué clase se está usando, mientras sea una clase derivada de la clase base.\nUn ejemplo de la vida real puede ser con un cámara. Todos tenemos en la mente las funciones básicas de una cámara electrónica:\nPodemos encenderla y apagarla Puede tomar fotos (disparador) Puede mostrarnos las fotos Podemos descargar las fotos Podemos borrar las fotos Mientras la cámara cumpla con esas características (su interfaz) no tendremos problema para usarla, independientemente de la marca o modelo de la cámara. Los subtipos del tipo de dato abstracto Cámara podría ser entonces:\nCámara DSLR Cámara Compacta Cámara Mirrorless Cámara de teléfono móvil En realidad en la programación, esta interfaz es un poco más estricta: los métodos deben de llamarse igual y tener la misma firma (parámetros y tipo de retorno). Es como si la cámara tuviera los botones en el mismo lugar y se usaran de la misma forma.\nY esto es básicamente el principio de sustitución de Liskov, la capacidad de usar clases derivadas de una clase principal sin ningún cambio en el código que rodea. ¿Crees que es útil?\nCrítica sobre el LSP # Tal como lo describimos aquí (mal llamado, para mi) principio de sustitución de Liskov parece una muy buena idea, ya que permitirá que crees nuevos comportamientos en partes específicas de tu código sin en tener que afectar a muchas partes de tu código.\nLo que no estuvo tan bien, históricamente, es que este principio siempre ha sido explicado y relacionado con la HERENCIA de clases, en lugar de poner énfasis en la abstracción de tipos de datos. Esto ha hecho que muchos desarrolladores piensen que esta práctica sólo aplica a la programación orientada a objetos y no al paradigma funcional, por ejemplo.\nDe hecho, el principio como es enunciado en Design Principles and Patterns dice:\nSubclasses should be substitutable for their base classes.\nLas subclases deben ser sustituibles por sus clases base.\nTambién, como se menciona en el artículo en el que se presenta originalmente este principio dice:\nFUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT\nFunciones que usen punteros o referencias a clases base deben ser capaces de usar objetos de clases derivadas sin saberlo\nComo puedes ver, el consejo es que está directamente relacionado con la herencia de clases y jerarquías de objetos. Incluso llega a hablar de punteros y referencias a clases base, es decir, a la clase padre.\nDe hecho, esto tiene cierta justificación, porque Barbara Liskov siempre habla de objetos. Lo que Liskov nunca hace es hablar de Clases y jerarquías de clases. Ella habla de tipos de datos abstractos, que son una abstracción de los objetos, por lo que esta idea se extiende a cualquier artefacto computacional que se encargue de encapsular un comportamiento.\n¿Qué es encapsular? Es ocultar la implementación y exponer sólo lo necesario para que el resto del programa pueda usarlo. Esto es lo que hace una clase, un módulo, una función, etc.\n¿Qué te recuerda esto? Lo mismo de lo que hemos hablado en los principios anteriores: abstracción. Esconder lo más que se pueda la información, Information Hiding, como le llamaría John Ousterhout.\nLo que es más, seguir esta idea de que diferentes tipos de datos puedan ser intercambiables hace que selecciones mejor los elementos que van a componer tu interfaz (en este caso le llamaríamos API).\nPara mí, las ideas de Liskov son un aplicación particular de la idea de ocultar la mayor cantidad de información posible dentro de interfaces lo mejor diseñadas posible, tal como se explica en el libro A Philosophy of Software Design de John Ousterhout.\nConclusión # La ideas sobre subtipos y la forma de usarlos lo mejor posible que Bárbara Liskov y Jeannette Wing propusieron son muy útiles para crear mejor código, sobre todo mejor separación y ocultado de la implementación.\nEsto lo vamos a repetir hasta el cansancio: ocultar información te ayudará a hacer que tus programas sea más fáciles de entender y de mantener.\nComo lección, podemos decir que seguir las guías de Liskov para el subtipado es una forma de aplicar este principio de diseño aún más amplio, digamos que en realidad la especificación de cómo deben comportarse los subtipos es más como una regla de diseño que un principio de diseño.\nEntender el verdadero significado de lo que Liskov propone, te ayudará a ver que no sólo se aplica a la programación orientada a objetos, tal como se enunciaba en SOLID originalmente, sino a muchas otras situaciones.\n","date":"6 marzo 2023","externalUrl":null,"permalink":"/2023/03/06/el-principio-de-sustituci%C3%B3n-de-liskov/","section":"Posts","summary":"\u003cp\u003eEl tercer principio enunciado en los principios \u003cstrong\u003eSOLID\u003c/strong\u003e es el principio de sustitución de Liskov. ¿Qué significa este principio? Y más importante, ¿vale la pena seguirlo? Pero antes de hablar del principio, hablemos de \u003cstrong\u003eBarbara Liskov\u003c/strong\u003e, la persona que lo inspiró y que estableció los conceptos principales.\u003c/p\u003e","title":"El principio de sustitución de Liskov","type":"posts"},{"content":"","date":"6 marzo 2023","externalUrl":null,"permalink":"/tags/liskov/","section":"Tags","summary":"","title":"Liskov","type":"tags"},{"content":"","date":"6 marzo 2023","externalUrl":null,"permalink":"/tags/lsp/","section":"Tags","summary":"","title":"Lsp","type":"tags"},{"content":"","date":"6 marzo 2023","externalUrl":null,"permalink":"/tags/solid-principles/","section":"Tags","summary":"","title":"Solid-Principles","type":"tags"},{"content":"En los últimos años los modelos de inteligencia artificial generativos han avanzado mucho. Esto es en parte gracias a una nueva arquitectura para las redes neuronales llamada transformer o de transformador, como les llamaremos en este artículo. Hablemos de en qué consiste esta arquitectura y por qué es tan revolucionaria o porque ha ayudado tanto a avanzar en el campo de la inteligencia artificial.\nRedes neuronales recurrentes (RNN) # Estas eran el estándar para hacer varias tareas, entre ellas la traducción. Las redes neuronales recurrentes se llaman así porque sus entradas se alimentan en ciclos, es decir, en vez de siempre mandar su salida a las siguientes capas, también manda la salida a capas anteriores o a la misma capa.\nEsta arquitectura permite que la red desarrolle memoria, algo que sirve bien para tratar con textos porque normalmente las palabras que van adelante están influidas por las que están antes.\nSin embargo, el entrenamiento de este tipo de redes neuronales requiere de mucho tiempo y recursos. Además, su memoria no es tan buena como para manejar textos muy largos. Así que la traducción o tratamiento de textos largos no les salía muy bien.\nAdemás, la forma secuencial de tratar las palabras las hace difíciles de entrenar. Aquí es cuando los investigadores de Google diseñaron otra arquitectura.\nRedes neuronales de transformador (Transformers) # Es una arquitectura más sencilla que las utilizadas anteriormente. Los transformadores están construidos en gran parte por mecanismos de atención. Podemos decir que tiene tres componentes principales:\nCodificación de posición Mecanismo de atención Mecanismo de auto-atención Hablemos de cada una de estas partes más detenidamente, explicadas para un desarrollador de software.\nCodificación de posición # Esta es la primera innovación del modelo transformador. En vez de procesar las palabras como una secuencia para conservar su orden, lo que limita el paralelismo o la capacidad de procesar varias palabras a la vez, se crean tuplas que contienen la palabra y su posición en el texto. Esto permite que la red pueda procesar varias palabras a la vez.\nLa posición del texto como se explica en Attention is all you need depende de una función basada en el seno y coseno, no un número entero de donde se encontró en el texto.\nEsta primera innovación permite que el entrenamiento sea paralelizable y por lo tanto que se puedan procesar más ejemplos, lo que mejora el aprendizaje.\nAtención # La atención se introdujo algunos años antes en el proceso de traducción automática. Este proceso consiste en que el modelo \u0026ldquo;mire\u0026rdquo; a otro texto para saber cómo traducir la palabra o el texto que está procesando. En las tareas de traducción, este mecanismo se da entre el texto que necesita ser traducido y la salida de la traducción.\nEl mecanismo de atención le da un peso diferente a cada palabra del texto original, con respecto a la palabra que ese está procesando. Este peso determina en donde se está \u0026ldquo;fijando\u0026rdquo; el modelo para procesar la palabra actual.\nEste mecanismo de atención es básicamente un montón de operaciones matriciales.\nAuto-atención # El mecanismo de atención anterior tiene que ver con la influencia que otro texto en la salida del proceso actual. El mecanismo de auto-atención se refiere al análisis del mismo texto que se está procesando, y la relación entre las palabras.\nEste mecanismo de auto-atención permite que el modelo encuentre patrones a través de muchos ejemplos de entrenamiento. Estos patrones tienen que ver con el significado de la palabra, los sinónimos, la gramática, etc.\nEsta es la parte más importante de un transformador y es lo que hace que los modelos que tienen esta arquitectura sean tan poderosos, permitiéndoles trabajar con textos largos y con una gran variedad de tareas, más allá de solamente traducción.\nEsta es una explicación muy básica de los mecanismos dentro de un modelo de transformador, si quieres aprender más a profundidad puedes leer:\nEl documento donde se presentó la arquitectura: Attention is all you need. The Illustrated Transformer, un artículo en donde con buenos dibujos se explica cómo funcionan. The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning), un artículo en donde se explica cómo funciona BERT, basado en ideas similares a las de los transformadores. Ventajas de los transformadores # La principal ventaja es que al ser más fáciles y eficientes de entrenar, se pueden crear modelos más grandes que normalmente harán mejor su tarea. Esto es lo que ha permitido que modelos como PALM y GPT-3 existan.\nLos modelos de transformador nos siguen sorprendiendo y parece que continuarán así en los próximos años.\nConclusión # Las redes neuronales con arquitectura de transformador permiten lograr cosas que no creíamos posibles y son la base de los grandes modelos de lengua natural como GPT-3. Conocer un poco más cómo funcionan nos puede dar una idea de lo que son capaces y sus límites, además de que es bastante interesante. Si quieres que hablemos de algún tema en específico puedes dejarnos un comentario.\n","date":"27 febrero 2023","externalUrl":null,"permalink":"/2023/02/27/qu%C3%A9-es-un-modelo-transformador-de-inteligencia-artificial/","section":"Posts","summary":"\u003cp\u003eEn los últimos años los modelos de inteligencia artificial generativos han avanzado mucho. Esto es en parte gracias a una nueva arquitectura para las redes neuronales llamada \u003cem\u003etransformer\u003c/em\u003e o de transformador, como les llamaremos en este artículo. Hablemos de en qué consiste esta arquitectura y por qué es tan revolucionaria o porque ha ayudado tanto a avanzar en el campo de la inteligencia artificial.\u003c/p\u003e","title":"¿Qué es un modelo transformador de inteligencia artificial?","type":"posts"},{"content":" ¿Qué es un \u0026ldquo;Code Review\u0026rdquo;? # Es la práctica que realizan los equipos de ingeniería de software para verificar los cambios de código antes de fusionarlos con el código fuente principal.\nDónde se aplica # En todas partes, cuando eres miembro de un equipo, como colaborador individual o como estudiante. Tienes la oportunidad de involucrarte, contribuir y dar tu opinión a código escrito por otra persona. Algunos ejemplos:\nDurante una sesión de \u0026ldquo;pair programming\u0026rdquo; # \u0026ldquo;Dos cabezas piensan mejor que una.\u0026rdquo;\nRevisando una pieza de código con alguien más, los desarrolladores podemos hacer recomendaciones, mejoras y adiciones a un sistema en tiempo real.\nEn aplicaciones de control de versiones, tales como # El Pull Request (PR) en GitHub. El Merge Request (MR) en GitLab. Estas funciones permiten a los desarrolladores proponer cambios en un código propiedad de otra persona. Es una forma de revisar y discutir cambios propuestos antes de fusionarlos, lo que permite a otros desarrolladores dejar comentarios, solicitar cambios o aprobar una solicitud de forma asíncrona.\nEn cualquier fragmento de código propuesto # Hay otros canales o formas de compartir código con un equipo. A veces, los desarrolladores lo hacen a través de Slack (u otros servicios de mensajería) u otra, simplemente compartiendo enlaces. Si como desarrollador notas algo para mejorar o agregar, tu equipo de tecnología debe ser el lugar que permita que esas interacciones y comentarios sucedan orgánicamente.\nBeneficios de la revisión de código # Esta práctica aumenta significativamente el trabajo en equipo. Involucrarse con el código de los demás e involucrar a otros en tus contribuciones aumenta el éxito en la creación de productos. Algunos de los beneficios son:\nSolución 77 temprana de errores # \u0026ldquo;Aquel de ustedes que esté libre de romper producción, que tire la primera piedra.\u0026rdquo;\nComo humanos, los ingenieros de software no están exentos de cometer errores, y es una gran ventaja contar con un equipo que te apoye, revise y libere tareas en conjunto. Durante una revisión de código, estos errores se pueden detectar y corregir.\nMejorar la calidad # \u0026ldquo;Es más barato hacer las cosas bien la primera vez.\u0026rdquo;\nEstablecer reglas en el estilo de código que aumenten la legibilidad, el mantenimiento y la escalabilidad del código ayuda a escribir software de calidad.\nIntercambio de conocimientos # El Code Review es una excelente herramienta para recibir y dar retroalimentación, aprender las mejores prácticas de los desarrolladores con más experiencia e intercambiar soluciones.\nSincronización # Con esta práctica, se puede saber en qué está trabajando cada miembro del equipo, evitar duplicación de esfuerzos y mantenerse actualizado con la lógica del negocio.\nPrimeros pasos # Una buena idea para aplicar correctamente esta práctica en tu equipo es establecer reglas antes de empezar.\nEstablezca una plantilla de descripción con los puntos mínimos que el equipo necesitará para comprender el contexto y el propósito de una solicitud de cambios de código y apliquen esa plantilla de manera consistente en todas las solicitudes futuras. El número mínimo de revisores para aprobar un fragmento de código; esto dependerá del tamaño del equipo. Canales o herramientas de comunicación al equipo cuando un código este listo para ser revisado. El tiempo entre las revisiones, es decir, que si un desarrollador marca un fragmento de código listo para revisarse y el equipo hace sugerencias o solicita cambios, y seguido de eso el desarrollador aplica los cambios solicitados, debe establecerse la cantidad de tiempo que debe pasar para solicitar una nueva revisión. Esta regla puede ser útil en equipos grandes que están involucrados en diferentes sistemas y necesitan dividir el tiempo entre el desarrollo y la revisión. En equipos pequeños, una regla de este tipo es opcional. Revisión efectiva # \u0026ldquo;Una buena revisión necesita de experiencia y profesionalismo y no de nivel de seniority.\u0026rdquo;\nSolo algunos desarrolladores son capaces de aplicar una buena revisión del código, esa es la razón principal por la que escribir esta publicación. El Code Review no es una práctica nueva en lo absoluto. Por el contrario, ha existido durante décadas, desde que las personas comenzaran a escribir código. Una de las primeras referencias a esta práctica como proceso formal se encuentra en el libro \u0026ldquo;The Mythical Man-Month\u0026rdquo; de Fred Brooks, publicado en 1975.\nEntonces, ¿por qué te pareció un tema importante? he estado trabajando con equipos de Ingeniería de Software durante aproximadamente 12 años y sigo leyendo comentarios que tienen un tono vago o agresivo o que carecen de explicación y contexto, lo que dificulta la aplicación efectiva de cambios en el código.\nLa revisión de código NO ES una práctica para # Demostrar superioridad. Hacer que otros se sientan inseguros. Imponer estilos de codificación. En resumen, ser un idiota. {: .align-center}\nAquí algunos ejemplos.\n{: .align-center}\nMala revisión: \u0026ldquo;Este código es malo. ¿Por qué estás haciendo una búsqueda lineal?\u0026rdquo;\nBuena revisión: \u0026ldquo;Este bloque de código podría optimizarse mediante el uso de una búsqueda binaria en lugar de una lineal. Esto mejoraría el rendimiento al buscar en grandes conjuntos de datos\u0026rdquo;.\nComo puedes ver en la mala revisión, hay más críticas que propuestas de alternativas o solución, o carece de la explicación del por qué se debe mejorar el código. Por el otro lado, la buena revisión ofrece una optimización, explicando por qué el enfoque diferente puede mejorar la función.\nMás malos ejemplos:\n\u0026ldquo;Este código apesta\u0026rdquo;. - Esto no es útil y no proporciona comentarios ni sugerencias para mejorar.\n\u0026ldquo;No entiendo lo que estás tratando de hacer aquí\u0026rdquo;. - Esto es desdeñoso y no proporciona comentarios constructivos. Si hay una duda genuina de la implementación lo ideal es expresar esa duda lo mejor posible.\n\u0026ldquo;Yo no lo haría de esta manera\u0026rdquo;. - Este comentario no es útil y le faltan razones o sugerencias para mejorar el código en revisión.\nLos comentarios en una revisión del código deben ser específicos, constructivos y aplicables, evitando agresiones personales, un lenguaje desdeñoso y generalizaciones.\nEvite por completo el uso de signos de exclamación e íconos para enfatizar comentarios negativos. Por último, recuerda que las malas interpretaciones son comunes en la comunicación escrita y pueden ocurrir aunque la intención sea buena.\nLa revisión de código SI ES una práctica para # Incentivar el trabajo en equipo. Reconocer el buen trabajo. Ser flexible con los estilos de código y aprender de el equipo. En resumen, es para ser un miembro del equipo. {: .align-center}\nAquí te dejo una sugerencia poderosa, no solo comentes lo que consideres que se puede cambiar o mejorar, sino también comenta lo que te gustó en una implementación, por ejemplo:\n\u0026ldquo;¡Buen trabajo! Este código está muy bien organizado y es fácil de entender. Aprecio especialmente cómo usaste las funciones integradas en la biblioteca estándar de Go para simplificar el código. ¡Sigue con el excelente trabajo!\u0026rdquo;\u0026quot; Adicionalmente, recuerda tomarte el tiempo. El trabajo es exigente y, a veces, no dedicamos suficiente tiempo a las revisiones, y comentamos \u0026ldquo;¡LGTM!\u0026rdquo; (Me parece bien) para seguir adelante, pero recordemos que el otro desarrollador dedicó tiempo a trabajar en esos cambios, por lo que vale la pena revisarlos con cuidado.\nOtra sugerencia que les dejo es establecer convenciones para los comentarios como lo es el uso del prefijo \u0026ldquo;NIT\u0026rdquo; (nitpicker), este se usa para sugerir un cambio, que no bloquea ni impide que ese el código en revisión sea aceptado o fusionado; es simplemente una \u0026ldquo;perfección\u0026rdquo; a la que estas apuntando pero que puede ser ignorada. Para obtener más información sobre convenciones de este tipo visten este sitio.\nMi código es el que esta en revisión # Por último, ser la persona que recibe las revisiones también requiere práctica.\nNo te lo tomes como algo personal. Aunque recibas un mal comentario, recuerda que el objetivo del equipo siempre será entregar un software de calidad. Se está revisando una parte de tu código, no su persona o tu trabajo en sí.\nSe un miembro de equipo. Otras personas usarán el código que escribiste hoy. Por lo tanto, es fundamental estar abierto a modificar tu trabajo por el bien del equipo y del producto final.\nResponde positivamente a los comentarios. Habrá casos en los que, como desarrollador que escribió el código en revisión, tendrás razones para creer que es la solución que debe fusionarse, sin embargo, si alguien solicita cambios o sugiere algo, debes comunicar tus razones de forma clara y justificada.\nParticipa en el intercambio de revisiones. No seas solo un espectador que genera código para ser revisado. Considera que independientemente de tu nivel, la experiencia que se obtiene leyendo código al máximo no se ve superada por nada.\nConclusión # Estamos en el año 2023, y la IA nos acompaña a diario en nuestras actividades, algunas prácticas desaparecerán pero los diferenciadores permanecerán. Una máquina puede decirnos qué está mal o dónde se puede mejorar una parte del código, sin embargo, la calidez, la empatía y el apoyo que otro ser humano puede brindarnos no se puede reemplazar (todavía), sigamos practicándolo y demos lo mejor de nosotros en todos los procesos en los que participamos.\n","date":"27 febrero 2023","externalUrl":null,"permalink":"/2023/02/27/code-review-la-practica-milenaria-que-seguimos-haciendo-mal./","section":"Posts","summary":"\u003ch2 class=\"relative group\"\u003e¿Qué es un \u0026ldquo;Code Review\u0026rdquo;?\n    \u003cdiv id=\"qué-es-un-code-review\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#qu%c3%a9-es-un-code-review\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003eEs la práctica que realizan los equipos de ingeniería de software para verificar los cambios de código antes de fusionarlos con el código fuente principal.\u003c/p\u003e","title":"Code Review: La practica Milenaria que seguimos haciendo mal.","type":"posts"},{"content":"","date":"27 febrero 2023","externalUrl":null,"permalink":"/tags/comunidad/","section":"Tags","summary":"","title":"Comunidad","type":"tags"},{"content":"","date":"27 febrero 2023","externalUrl":null,"permalink":"/tags/crecimiento-profesional/","section":"Tags","summary":"","title":"Crecimiento-Profesional","type":"tags"},{"content":"","date":"27 febrero 2023","externalUrl":null,"permalink":"/tags/gpt-3/","section":"Tags","summary":"","title":"Gpt-3","type":"tags"},{"content":"","date":"27 febrero 2023","externalUrl":null,"permalink":"/tags/mentoria/","section":"Tags","summary":"","title":"Mentoria","type":"tags"},{"content":"","date":"27 febrero 2023","externalUrl":null,"permalink":"/tags/productividad/","section":"Tags","summary":"","title":"Productividad","type":"tags"},{"content":"","date":"27 febrero 2023","externalUrl":null,"permalink":"/tags/transformadores/","section":"Tags","summary":"","title":"Transformadores","type":"tags"},{"content":"","date":"27 febrero 2023","externalUrl":null,"permalink":"/tags/transformers/","section":"Tags","summary":"","title":"Transformers","type":"tags"},{"content":"Este artículo está inspirado por lo que leí en el resumen del libro que Camilo Chacón Sartori está escribiendo y que muy amablemente me compartió para que le diera mi opinión. El libro se llama \u0026ldquo;Principios de programación\u0026rdquo;. Espero que pronto esté disponible, pero mientras, hablemos de la importancia de comprender los principios básicos de la computación y programación, con la esperanza de que te emociones por aprender más sobre ellos.\nEmpecemos hablando de qué son los principios.\n¿Qué es un principio? # En donde más se oye este término si no estás metido en ciencia es en ética. Por ejemplo, dice que una persona o una empresa tiene \u0026ldquo;principios\u0026rdquo;. ¿A qué se refiere?\nYo definiría un principio como un hecho que está en los fundamentos de un sistema de creencias. Por eso, cuando hablamos de una persona con principios, nos referimos a alguien que tiene bien claro lo que piensa del mundo y de las situaciones que se le presentan. Como consecuencia, tiene claro cómo actuará en cada situación.\nEn las ciencias, un principio es más o menos lo mismo, un hecho comprobado que da pie y soporte a una teoría más amplia, que nos permite comprender el mundo y generar más conocimiento, sea mediante la experimentación o la reflexión (esto incluye la inducción, deducción y predicción).\nEn las leyes, un principio es una guía general que da soporte a normas y leyes.\nComo resumen: un principio fundamenta un sistema de creencias, una teoría o una ley. Así que esto te puede dar una idea de lo importante que es entender los principios de tu profesión. Hablemos de los principios más importantes relacionados con la computación y el desarrollo de software.\nPrincipios importantes de la computación # Desde mi punto de vista, los principios más importantes tienen que ver con la naturaleza misma de la computación y nuestra manera de interactuar con ella. Entender los límites y lo que podemos hacer con una computadora es primordial para poder desarrollar software de calidad.\nEstos principios incluyen:\nLas mejores formas de representar información La complejidad de las operaciones en tiempo y espacio (memoria) Cosas imposibles de lograr con una computadora Los diferentes modelos de computación que se han inventado (¿o descubierto?) ¿Se te ocurre algún otro? Me gustaría leerlo en los comentarios.\nPrincipios de conducta # Como casi todas las carreras humanas, las ciencias de la computación y el desarrollo de software tiene prácticas que conviene seguir, sobre todo si se quiere dominarlas y pasarla bien haciéndola. A estos los llamamos principios de conducta.\n¿Qué prácticas nos conviene tener? La mayoría tiene que ver con la capacidad de tratar bien con las personas. Casi ningún software serio se puede hacer solo en tiempo razonable (pero por supuesto que hay excepciones). Por eso, considero que los principios de conducta más importantes son:\nLa capacidad de comunicar tus ideas efectivamente Responsabilidad Capacidad de resolver conflictos Organización del tiempo de trabajo Capacidad de dividir el trabajo y repartirlo Además de estas capacidades o principios se tienen que desarrollar otra conductas que son importantes individualmente:\nLa capacidad de aprender de forma efectiva Atención a los detalles Resiliencia y perseverancia Todas estas son cosas que casi cualquier profesional debe tener, pero son superlativamente importantes en el desarrollo de software si quieres avanzar. Aquí sólo hablamos de los nombres, pero si te interesa alguna puedes investigar más profundamente sobre ese principio.\nPrincipios de Programación (libro) # Camilo Chacón Sartori, un gran amigo de The Dojo MX, está terminando de escribir un libro que se llama \u0026ldquo;Principios de Programación\u0026rdquo; (tal vez para cuando leas esto ya esté disponible). En él, habla mucho más extensamente de los principios que hemos mencionado en este post.\nAhí podrás encontrar temas como las cosas que debes entender fundamentalmente de la computación hasta sus recomendaciones de lo que hace falta para tener una buena vida, claro, todo relacionado con la actividad de programar como tu profesión. No te lo pierdas si quieres seguir avanzando en tu carrera como desarrollador@ de software.\nConclusión # Conocer y aplicar los principios de la ciencias de la computación y relacionados con la creación de software te ayudará a disfrutar más del trabajo, a avanzar en tu carrera y conseguir mejores resultados. Continua profundizando en ellos y aprendiendo más formas de aplicarlos, para mejorar tu trabajo y tu vida.\nGracias a Camilo Chacón Sartori por escribir sobre este tipo de cosas y levantar temas tan importantes.\n","date":"17 febrero 2023","externalUrl":null,"permalink":"/2023/02/17/la-importancia-de-entender-los-principios-de-la-computaci%C3%B3n/","section":"Posts","summary":"\u003cp\u003eEste artículo está inspirado por lo que leí en el resumen del libro que \u003ca\n  href=\"https://camilochs.github.io/web/\"\n    target=\"_blank\"\n  \u003eCamilo Chacón Sartori\u003c/a\u003e está escribiendo y que muy amablemente me compartió para que le diera mi opinión. El libro se llama \u003cstrong\u003e\u0026ldquo;Principios de programación\u0026rdquo;.\u003c/strong\u003e Espero que pronto esté disponible, pero mientras, hablemos de la importancia de comprender los principios básicos de la computación y programación, con la esperanza de que te emociones por aprender más sobre ellos.\u003c/p\u003e","title":"La importancia de entender los principios de la computación","type":"posts"},{"content":"En el artículo anterior hablamos de las clases de complejidad y su relación con la criptografía. Hablamos brevemente de los problemas NP y de dijimos que pueden ser resueltos por una máquina de Turing no determinista en un tiempo razonable (complejidad polinomial).\nEn este artículo vamos a entender qué son las máquinas de Turing no deterministas, pero empecemos entendiendo la diferencia entre determinismo y no determinismo.\nDeterminismo y no determinismo # En la física y las ciencias existen básicamente dos tipos de sistemas basados en el conocimiento que podemos tener de su comportamiento en un momento dado.\nEl primer tipo es el de los sistemas deterministas, en el que saber el estado actual del sistema y el evento (o la entrada del sistema) nos permite predecir el estado futuro del sistema, sin errores y con una precisión infinita. En estos sistemas existen una serie de reglas que no se pueden romper y que nos dan la capacidad saber exactamente lo que sucederá. Estos sistemas son casi siempre simplificaciones del mundo real o sistemas creados y diseñados por el hombre. Ejemplos de estos sistemas son:\nEl juego de la vida El ajedrez El juego de Go Casi todos los problemas que analizamos en un clase de física son tratados como deterministas, por ejemplo, el movimiento de un proyectil, una mesa de billar, etc., aunque no lo sean realmente, se tratan como tales para simplificar el análisis. El segundo tipo son los sistemas no deterministas o estocásticos. En estos sistemas no tenemos la información suficiente para poder predecir estados futuros del sistema de manera precisa, solamente podemos predecir probabilidades. Algunos ejemplos de estos sistemas son:\nEl clima El comportamiento de una persona El comportamiento de un mercado de un mercado financiero Una selección aleatoria de elementos de un conjunto En pocas palabras, en un sistema determinista podemos predecir la salida si conocemos la entrada con toda seguridad. En un sistema no determinista o estocástico sólo podemos dar una probabilidad de que algo suceda en el mejor de los casos.\nMáquinas de Turing deterministas # Si no sabes lo que es una máquina de Turing tradicional, una de las mejores explicaciones que hemos encontrado está en el libro \u0026ldquo;La Mente nueva del Emperador\u0026rdquo;{:target=\u0026quot;_blank\u0026quot;} de Roger Penrose.\nLo que debes saber es que estas representan un modelo universal de computación, todo lo que se puede computar (calcular, o conocer con certeza) se puede representar en una máquina de Turing. Te la puedes imaginar como una máquina que lee de una cinta infinita que contiene tanto las instrucciones como los datos de entrada. ¿Te suena? Es como funcionan las computadoras actualmente: el ejecutor es el CPU y la cinta es la memoria.\nLa máquina de Turing como se definió es determinista, es decir siempre para el la misma entrada obtendremos la misma salida. En cada punto de su cálculo la máquina de Turing sabe exactamente qué hacer.\nAhora hablemos de otro modelo de computación: las máquinas de Turing no deterministas.\nMáquinas de Turing no deterministas # Apliquemos el concepto del \u0026ldquo;no determinismo\u0026rdquo; al modelo de computación de lo que acabamos de hablar. Recordemos que la en la máquina de Turing tradicional, para un mismo estado y una misma entrada de datos (o eventos), siempre obtendremos la misma acción. En contraparte, una máquina no determinista puede tener múltiples acciones para un mismo estado y una misma entrada o evento.\nEsto implica que este tipo de computación también puede tener múltiples resultados posibles para un mismo conjunto de entrada.\nEl comportamiento de una máquina de Turing no determinista es hasta cierto grado impredecible. Incluso con las mismas entradas y estados, la máquina puede devolver diferentes resultados en diferentes ejecuciones.\nEstas máquinas también fueron definidas (o más bien, mencionadas) en el mismo documento en que Turing definió las máquinas tradicionales: ON COMPUTABLE NUMBERS, WITH AN APPLICATION TO THE ENTSCHEIDUNGSPROBLEM{:target=\u0026quot;_blank\u0026quot;}. A estas él las llamó máquinas de selección (choice machines o c-machine). La definición más formal la podemos encontrar en un documento escrito por Rabin y Scott en 1959: Finite Automata and Their Decision Problems{:target=\u0026quot;_blank\u0026quot;}, en el que se habla de Autómatas Finitos No Deterministas (AFND), una especialización finita de las máquinas de Turing.\nA diferencia de los sistemas no deterministas de los que hablamos arriba, las máquinas de Turing no deterministas no es que tengan una probabilidad de pasar de un estado a otro, sino que la máquina puede \u0026ldquo;seleccionar\u0026rdquo; una transición de un estado a otro. En el documento de Turing mencionado anteriormente, se menciona que estas máquinas son \u0026ldquo;operadas\u0026rdquo; por un humano, que elige qué camino tomar, por eso las llamó máquinas de selección. En referencias más modernas no se especifica el mecanismo de selección.\nPara una misma entrada una máquina de Turing no determinista puede tener múltiples salidas posibles, algunas de ellas válidas y otras no. Para que una máquina de Turing encuentre el resultado correcto, debe probar todas las posibles salidas y seleccionar la correcta.\nUna NTM (Non-deterministic Turing Machine, así la llamaremos a partir de ahora) es una construcción matemática que no existe en la vida real, es decir, no hay computadora que funcione como una NTM.\nRelación entre las máquinas de Turing deterministas y no deterministas # Se ha demostrado que para cada máquina de Turing no determinista existe una máquina de Turing determinista equivalente. Lo malo es que esta máquina de Turing determinista necesita exponencialmente más nodos o pasos. Por ejemplo, si una NTM necesita tiene 100 posibles estados, entonces la máquina de Turing equivalente necesitará aproximadamente 2^100 estados.\nY aquí es donde entra la relación con los problemas NP.\nRelación con los problemas NP # Como te darás cuenta, las NTM tienen mucho que ver con la combinatoria, porque necesitan probar todas las posibles combinaciones de estados y transiciones para encontrar la solución correcta.\nSi ejecutáramos una NTM en una computadora, tendríamos que probar cada uno de esos estados. Esto es exactamente lo mismo que sucede con muchos problemas NP o NP-completo, para encontrar una solución se tienen que probar todas las posibles combinaciones en un conjunto de elementos.\nLas siglas NP significan Non-deterministic Polynomial (polinomial no determinista), y esto significa que en una NTM hay por lo menos un camino que resuelve el problema en un tiempo polinomial. El problema es saber cuál de todos los caminos.\nY de ahí viene su nombre. Todos estos problemas tienen una solución que corre en tiempo polinomial, pero para encontrarla tenemos que adivinar o probar todas las combinaciones.\nConclusión # Ahora que sabemos como funciona una máquina de Turing no determinista, que es una construcción teórica que nos sirve para hacer experimentos del pensamiento y además que tienen una relación muy estrecha con la teoría de la complejidad y los problemas NP.\n","date":"8 febrero 2023","externalUrl":null,"permalink":"/2023/02/08/m%C3%A1quinas-de-turing-no-deterministas-y-problemas-np/","section":"Posts","summary":"\u003cp\u003eEn el artículo anterior hablamos de las clases de complejidad y su relación con la criptografía. Hablamos brevemente de los problemas NP y de dijimos que pueden ser resueltos por una máquina de Turing no determinista en un tiempo razonable (complejidad polinomial).\u003c/p\u003e","title":"Máquinas de Turing no deterministas y problemas NP","type":"posts"},{"content":"","date":"8 febrero 2023","externalUrl":null,"permalink":"/tags/non-deterministic/","section":"Tags","summary":"","title":"Non-Deterministic","type":"tags"},{"content":"","date":"8 febrero 2023","externalUrl":null,"permalink":"/tags/ntm/","section":"Tags","summary":"","title":"Ntm","type":"tags"},{"content":"","date":"8 febrero 2023","externalUrl":null,"permalink":"/tags/turing/","section":"Tags","summary":"","title":"Turing","type":"tags"},{"content":"","date":"3 febrero 2023","externalUrl":null,"permalink":"/tags/complejidad-computacional/","section":"Tags","summary":"","title":"Complejidad-Computacional","type":"tags"},{"content":"La intuición a veces nos dice que cualquier cálculo numérico debería ser muy fácil para una computadora. Sin embargo, hay problemas numéricos y no numéricos que son imposibles de resolver para las computadoras actuales, independientemente de su poder de procesamiento.\nLa criptografía actual está soportada por una serie de problemas que suponemos muy difíciles de resolver de la ciencias de la computación.\nEn esta serie de artículos vamos a estar hablando de ellos para entenderlos a profundidad y sobre todo para entender cómo es que se relacionan con los algoritmos criptográficos, como con los algoritmos de llave pública, como Diffie-Hellman y RSA.\nPero primero hablemos de lo que consideramos un problema difícil de la computación y la complejidad computacional.\nComplejidad computacional # La complejidad computacional se puede entender como la cantidad de operaciones que un algoritmo ejecuta para finalizar. Esta cantidad de operaciones es una función (en el sentido matemático) de la entrada del problema. Puedes pensar en una función como una relación entre la entrada y el tiempo de ejecución.\nPor ejemplo, si te piden contar todas las letras \u0026ldquo;a\u0026rdquo; e una cadena, esto podría resolverse de la siguiente manera en Python:\ndef contar_a(string): count = 0 for char in string: if char == \u0026#34;a\u0026#34;: count += 1 return count ¿Cuántas operaciones tarda este algoritmo? Como dijimos depende de la entrada. Esa relación de dependencia es una función. Lo que la función nos dice es qué relación existe entre la entrada y la cantidad de operaciones que se ejecutan.\nEn este ejemplo específico, tenemos que hacer 1 ó 2 operaciones por cada letra de la entrada, y esto no cambia, independientemente de la longitud de esta cadena de entrada. Por lo tanto la función que describe la relación entre la entrada y la cantidad de operaciones es:\n$$f(n) = 2n$$\nDonde $n$ es la longitud de la cadena de entrada. Como esta relación crece proporcionalmente a la entrada, es decir, lo mismo que crece la entrada crece el tiempo de ejecución, decimos que este algoritmo es de complejidad lineal.\nComplejidad polinomial (P) # Un polinomio es una expresión matemática que consiste en sumas, restas, multiplicaciones, divisiones y potencias de números.\nUn algoritmo es de complejidad polinomial si su tiempo de ejecución es una función que consiste en multiplicaciones, sumas o elevaciones a ciertas potencias del tamaño de la entrada. Algunos ejemplos de complejidad polinomial son:\n$$f(n) = 2n$$\n$$f(n) = 3n^2$$\n$$f(n) = 4n^3$$\n$$f(n) = n^{log(n)}$$\nEn la práctica, si un algoritmo es tiene complejidad polinomial quiere decir que su ejecución es más o menos rápida (o por lo menos posible en caso de polinomios muy grandes) para cualquier entrada.\nLa notación Big O # La notación más usada para expresar la complejidad no es la de una función común como lo hemos hecho hasta ahora. Normalmente, lo que nos interesa es expresar o conocer el peor de los casos para un algoritmo específico. Por ejemplo, si estamos observando un algoritmo de búsqueda como el siguiente:\ndef buscar(lista, elemento): for i in range(len(lista)): if lista[i] == elemento: return i return -1 El peor de los casos es cuando el elemento esté en el último lugar. Por lo tanto, su complejidad en el peor de los casos depende directamente de la longitud de la lista de entrada. Podemos expresar esta complejidad con una función como:\n$$f(n) = n$$\nPero la notación Big O nos permite expresar esto de una manera más simple:\n$$O(n)$$\nEn el ejemplo de arriba, de la búsqueda de las letras \u0026ldquo;a\u0026rdquo; en una cadena, la complejidad que calculamos expresada como función en el peor de los casos es:\n$$f(n) = 2n$$\nEn la notación Big O se eliminan todas los valores constantes, y por la tanto esta complejidad se expresa como:\n$$O(n)$$\nEquivalente al ejemplo anterior. Lo que tienes que recordar de la notación Big O es que te da un límite superior de operaciones que se ejecutarán para un algoritmo. Este límite lo podemos pensar como una línea que el algoritmo nunca va a tocar y mucho menos a rebasar, esto se llama una asíntota en matemáticas, por lo que también se le conoce como notación asintótica.\nEn este artículo no vamos a hablar de cómo calcular más complejidades, pero probablemente lo hagamos en uno futuro. A este tipo de cálculo, o análisis de algoritmos se le llama \u0026ldquo;análisis asintótico\u0026rdquo;.\nAhora, con esta notación, estamos listos para seguir hablando de las clases de complejidad.\nComplejidad súper polinomial # Una clase que estaría bien separar de los polinomios que acabamos de hablar, es la de los tiempos súper polinomiales. Estos algoritmos tienen una complejidad que crece muy rápido con respecto a su entrada. Por ejemplo:\n$$O(n^{n ^ 2})$$\n$$O(n!)$$\n$$O(2^n)$$\nEstos tres ejemplos crecen más rápido que cualquier función polinomial que común que podamos representar como $$O(n^k)$$, siendo k una constante (que normalmente es un número pequeño).\nA esta clase de complejidad la empezamos ya a considerar como problemas intratables en la computación. Pero hablemos, dentro de los tiempos súper polinomiales de otra clase característica.\nComplejidad Exponencial (EXP) # La clase de complejidad exponencial se expresa como $$O(2^n)$$. Cuando un algoritmo tiene un complejidad de esta categoría o mayor, se considera completamente incalculable.\nPor ejemplo, si midiéramos la entrada en bits y tuviéramos una entrada de 100 bits, el número de operaciones sería $$2^{100}$$. Suponiendo que una buena computadora pudiera hacer 1,000,000 de operaciones por segundo, esta tardaría $$2^{81}$$ segundos en completar el cálculo. Sin embargo, calculamos que el universo \u0026ldquo;sólo\u0026rdquo; ha existido por menos de $$2^{34}$$. Así de grande es la complejidad exponencial.\nTe preguntarás si con una computadora más rápida podemos resolver el problema. Veamos el récord de la computadora más poderosa en 2023, que puede hacer 1,000,000,000,000,000,000 de operaciones por segundo. Esto es $$2^{59.8}$$. Esto significa que una computadora de este tamaño tardaría $$2^{40.2}$$ segundos. \u0026ldquo;Poco\u0026rdquo; más que la edad del universo.\nEste tipo de algoritmos son los que hay que ejecutar para encontrar una llave por fuerza bruta. Si quieres por ejemplo encontrar una llave de AES, tendrías que hacer $$2^128$$ intentos, en el peor de los casos.\nTiempos polinomiales no deterministas (NP) # Hasta ahora hemos hablado de tiempos polinomiales que estamos seguros que siempre se van a comportar como los conocemos o incluso van a mejorar.\nPara las clases que hemos hablado existe su equivalente no determinista.\n¿Qué tiene que ver el determinismo con la complejidad? El determinismo en las clases anteriores significa que sabemos con certeza que el resultado está abajo de la línea de complejidad que la notación Big O describe.\nEn el caso de los tiempos polinomiales no deterministas significa que una máquina de Turing no determinista puede resolver el problema en un tiempo polinomial. El que la máquina sea no determinista significa que no sabemos si el resultado está abajo de la línea de complejidad que la notación Big O describe, o que a veces lo logrará y otras veces no.\nEsto en otras palabras, significa que para los problemas con complejidad NP se puede adivinar una solución en un tiempo finito no muy grande, pero no se puede encontrar esta solución o garantizar que se encontrará en un tiempo razonable para cada una de las entradas del algoritmo.\nOtra característica que tienen los problemas NP es que aunque encontrar una solución sea difícil, verificarla es fácil.\nUn ejemplo de un problema NP es el de encontrar una llave de AES cuando conocemos el texto plano. Usando la fuerza bruta por ejemplo, podríamos encontrar la llave en un golpe de suerte y podríamos verificar que la llave es la correcta comparando el texto plano con el texto descifrado, si son iguales, entonces la llave es correcta.\nMuchos de los problemas NP tienen que ver con combinatoria, con problemas que tienen que ver con la cantidad de combinaciones posibles que hay en un conjunto de elementos, justo como las llaves criptográficas.\nNP-Complete # Los problemas NP-Complete son la clase más difícil de resolver dentro de los problemas NP. Estos problemas se pueden transformar en otros problemas NP-complete, lo que significa que si se puede resolver un problema NP-complete, se puede resolver cualquier otro problema NP-complete en un tiempo razonable.\nProblemas que creemos que son difíciles y problemas NP # La criptografía actual se basa en problemas que creemos que son por lo menos NP. ¿Por qué usamos la palabra \u0026ldquo;creemos\u0026rdquo;? Porque no podemos probar que son NP, pero hasta el momento nadie ha encontrado una forma de resolverlos en tiempo polinomial, pero creemos que lo pueden ser. Lo ideal sería usar problemas que sean NP-Complete, pero no hay muchos problemas NP-Complete que se puedan usar en la criptografía, además de que existe la posibilidad de que si resuelven un problema NP-Complete, se resuelvan todos los problemas NP-Complete, lo que rompería la criptografía actual.\nConclusión # La criptografía moderna se basa en problemas muy difíciles de resolver para cualquier computadora, para los que no existe un algoritmo eficiente que pueda encontrar una solución garantizada cada vez. Algunos de estos problemas son fáciles de verificar una vez que se propone una solución y son justo estos los que son más útiles para la criptografía.\nLo más interesante es que la criptografía simétrica crea un problema NP con sus llaves: encontrar una llave de cifrado es casi imposible en un tiempo razonable, pero verificar si es correcta si se tiene el tiempo original es muy fácil.\nEn los próximos artículos hablaremos específicamente de algunos de estos problemas, sobre todo aquellos en los que la criptografía asimétrica se basa.\n","date":"3 febrero 2023","externalUrl":null,"permalink":"/2023/02/03/problemas-dif%C3%ADciles-de-la-computaci%C3%B3n-y-su-relaci%C3%B3n-con-la-criptograf%C3%ADa-problemas-np/","section":"Posts","summary":"\u003cp\u003eLa intuición a veces nos dice que cualquier cálculo numérico \u003cem\u003edebería\u003c/em\u003e ser muy fácil para una computadora. Sin embargo, hay problemas numéricos y no numéricos que son imposibles de resolver para las computadoras actuales, independientemente de su poder de procesamiento.\u003c/p\u003e","title":"Problemas difíciles de la computación y su relación con la criptografía: Problemas NP","type":"posts"},{"content":"","date":"25 enero 2023","externalUrl":null,"permalink":"/tags/aprendizaje/","section":"Tags","summary":"","title":"Aprendizaje","type":"tags"},{"content":"¿Sientes que sabes un poquito de muchas cosas pero no te sientes con lo confianza de decir que eres experto en algo? Muchos desarrolladores de software sentimos eso, exacerbado por la gran cantidad de herramientas, lenguajes y situaciones que las necesidades del negocio nos impone.\nEn este artículo vamos a hablar acerca de un un consejo encontrado en el libro Apprenticeship Patterns que en español llamaríamos \u0026ldquo;Patrones para aprendices\u0026rdquo;. En este libro se mencionan una serie de consejos con acciones para los desarrolladores de software que se consideran aprendices. En realidad es una buena idea siempre tener \u0026ldquo;la mentalidad del aprendiz\u0026rdquo;, aquella que considera que tiene mucho que aprender y se mantiene humilde.\nLos consejos de este libro se enmarcan en la misma forma que lo que conocemos como patrones de diseño, en cada uno se dan tres partes:\nContexto: describe una situación típica en la que puedes estar en la que el consejo puede ser útil Problema: describe específicamente el conflicto que surge y que se puede resolver con el consejo Solución: describe las acciones que puedes tomas para resolver el problema de manera efectiva Aunque este libro tiene sus cosas negativas, tiene grandes consejos, como el que vamos a ver en este artículo. Empecemos a hablar de él.\nLa situación y el problema # Eres un desarrollador o desarrolladora de software que se desenvuelve más que decentemente en su trabajo. Te piden algo y aunque no lo conozcas, tienes la habilidad de entender lo suficiente del problema rápidamente para \u0026ldquo;sacar\u0026rdquo; el trabajo. Sin embargo, cuando te preguntan en qué te sientes más cómodo programando, o en qué podrías decir que eres un experto, te sientes inseguro de contestar.\nEl problema es que no te has dado el tiempo de conocer nada profundamente y sabes un poco, muy poco de hecho, de muchas cosas, generalmente las cosas más superficiales. No entiendes los principios de funcionamiento de las cosas que usas.\nLa solución # En el principio que David Hoover nombra \u0026ldquo;Cava más hondo\u0026rdquo; (Dig Deeper), sugiere lo siguiente:\nEn vez de sólo conformarte por entender lo mínimo aprende a estudiar aquellos problemas que se te presentan con más profundidad. Aprender a investigar el funcionamiento fundamental de las herramientas, lenguajes y técnicas que usas te separará de los desarrolladores que se conforman con el conocimiento mínimo necesario que el día a día nos deja.\nLeer las especificaciones y la documentación. Esto te va a dar el conocimiento directo de la fuente primaria de la información. Es muy importante leerlo directamente del primer creador porque nadie (o muy pocas personas más) te pueden explicar el trasfondo del asunto tan bien como él. Existen miles de tutoriales o videos ahí afuera, que son útiles en ciertas situaciones, pero para profundizar, hay pocas cosas mejores que las referencias o documentos de diseño originales.\nAprender a usar las herramientas de tu entorno a profundidad. La mayoría de los lenguajes de programación tienen herramientas que te permiten entender cómo está corriendo cierta parte del programa. Si tu lenguaje no lo tienen, existen herramientas a nivel del sistema operativo que te permitirán entender el funcionamiento a fondo.\nEntiende los problemas a fondo. Cuando estés analizando código, un tutorial, o alguien que te explique algo, intenta entender las ideas que están en el fondo de las cosas que te están explicando, no sólo las cosas que están en la superficie. Intenta absorber el pensamiento que los guió a la solución que están presentando. Para hacer esto, debes reconstruir el contexto en el que surgió el problema y la solución que se presenta.\nVentajas # Tener estas habilidades te permitirá entender cómo debería funcionar algo, además de el funcionamiento real en acción de lo que estás usando. Si algo no te gusta como funciona, puedes cambiarlo o mejorarlo.\nAl tener conocimiento profundo en ciencias de la computación, es probable que puedas resolver cosas que nunca te imaginaste o que crees una solución que se destaque y deje a las soluciones existentes muy por detrás.\nFinalmente, este conocimiento te puede dar la capacidad de ayudar a tu equipo, enseñándole cosas que harán que tanto ellos como tu empresa avancen más rápido.\nConclusión # Te preguntarás: ¿de dónde sale el tiempo para aprender esto? Puedes apartar un poco de tiempo de tu trabajo, pero debido a las exigencias que el día a día impone, debes considerar esto como un ejercicio de aprendizaje que la mayoría de las veces va a correr por tu cuenta.\nProfundizar en algo es una habilidad que tienes que desarrollar si quieres destacar en tu carrera. El libro menciona una idea que me gusta: el conocimiento profundo es lo que distingue a los constructores de catedrales de los que hacen software común. Me gusta la idea de pensar en el software como una construcción y pensar que puede ser algo tan bonito y tan grande como una catedral.\nAsí que ya sabes: si quieres ser un desarrollador o desarrolladora de software que es capaz de construir catedrales, cava más hondo.\n","date":"25 enero 2023","externalUrl":null,"permalink":"/2023/01/25/patrones-para-aprendices-cava-m%C3%A1s-hondo/","section":"Posts","summary":"\u003cp\u003e¿Sientes que sabes un poquito de muchas cosas pero no te sientes con lo confianza de decir que eres experto en algo? Muchos desarrolladores de software sentimos eso, exacerbado por la gran cantidad de herramientas, lenguajes y situaciones que las necesidades del negocio nos impone.\u003c/p\u003e","title":"Patrones para aprendices: Cava más hondo","type":"posts"},{"content":"","date":"25 enero 2023","externalUrl":null,"permalink":"/tags/patrones-de-aprendizaje/","section":"Tags","summary":"","title":"Patrones-De-Aprendizaje","type":"tags"},{"content":"","date":"25 enero 2023","externalUrl":null,"permalink":"/tags/profundizar/","section":"Tags","summary":"","title":"Profundizar","type":"tags"},{"content":"Tanto para Java como para otros lenguajes que son interpretados, por ejemplo Python o JavaScript, se genera una representación intermedia como resultado de la ejecución o compilación. A este código le llamamos bytecode.\nHablemos de qué es y para qué existe.\n¿Qué es el bytecode? # El bytecode es una representación intermedia de tu programa que tiene dos características principales:\nNo es tan legible como el código fuente, por ser más compacta. Es independiente de la arquitectura de la máquina, por lo que siempre es la misma representación para tu máquina virtual. El objetivo del bytecode entonces es conservar la semántica de tu programa, pero de una forma que sea más fácil de ejecutar en una máquina virtual o el intérprete.\nSe llama bytecode porque normalmente es una secuencia de bytes que representan tanto las instrucciones como los datos.\nEjemplo de un bytecode # Veamos el ejemplo de Elixir y el código de bytes que produce, para entender el con un ejemplo.\ndefmodule Hello do def greet do IO.puts \u0026#34;Hello, world!\u0026#34; end end El proceso que Elixir sigue para ejecutarse es el siguiente:\n{: .align-center}\nFuente: Getting each stage of Elixir’s compilation all the way to the BEAM bytecode.\nLa Bogdan/Björn Erlang Abstract Machine (BEAM) tiene un set de instrucciones, que constituyen su bytecode. Estos aunque están semi-documentados aquí, no están documentados oficialmente y pueden cambiar en cada release.\nCuando compilas una archivo de Elixir, se crea un archivo con el mismo nombre de tu módulo, pero con la extensión .beam. Este archivo contiene el bytecode de tu programa. Para poder verlo en nuestro editor, necesitamos herramientas especiales. Para VSCode, podemos usar la extensión BEAMdasm.\nAquí podemos ver el ejemplo de lo que genera el programa anterior:\nModule: Elixir.Hello Attributes: [{vsn, [72315C84EFAF57A23F8E5FD7551E9C5D]}] Compilation Info: [{version, 8.2.2}, {options, [no_spawn_compiler_process, from_core, no_core_prepare, no_auto_import]}, {source, /Users/hectorip/Development/elixir/hello_world/hello_world.exs}] //Function Elixir.Hello:__info__/1 label01: func_info Elixir.Hello __info__ 1 label02: select_val X[0] label09 [attributes, label08, compile, label08, deprecated, label07, exports_md5, label06, functions, label05, macros, label07, md5, label08, module, label04, struct, label03] label03: move nil X[0] return label04: move Elixir.Hello X[0] return label05: move [{greet, 0}] X[0] return label06: move 7~�t�jO;_���lS\u0007 X[0] return label07: move nil X[0] return label08: move X[0] X[1] move Elixir.Hello X[0] call_ext_only 2 erlang:get_module_info/2 label09: call_only 1 label17 //Function Elixir.Hello:greet/0 label10: func_info Elixir.Hello greet 0 //line hello_world.exs, 2 label11: move Hello, world! X[0] call_ext_only 1 Elixir.IO:puts/1 //line hello_world.exs, 3 //Function Elixir.Hello:module_info/0 label12: func_info Elixir.Hello module_info 0 label13: move Elixir.Hello X[0] call_ext_only 1 erlang:get_module_info/1 //Function Elixir.Hello:module_info/1 label14: func_info Elixir.Hello module_info 1 label15: move X[0] X[1] move Elixir.Hello X[0] call_ext_only 2 erlang:get_module_info/2 //Function Elixir.Hello:-inlined-__info__/1-/1 label16: func_info Elixir.Hello -inlined-__info__/1- 1 label17: jump label16 int_code_end Como puedes ver después de las etiquetas que tienen nombres como label01, label02, etc., tenemos instrucciones como func_info, select_val, move, return, call_ext_only, call_only, jump, int_code_end, etc. y datos como Elixir.Hello, Hello, world!. Esto es lo que la maquina virtual ya puede ejecutar directamente, o se puede usar para propósitos como optimizaciones si se puede garantizar que la semántica se mantiene.\nEjemplo con JavaScript # También podemos ver el bytecode de JavaScript. Si tienes instalado node en tu computadora puedes correr algo como lo siguiente para ver el bytecode de JavaScript:\nnode --print-bytecode --eval \u0026#34;console.log(\u0026#39;Hello, world!\u0026#39;)\u0026#34; Te dará un motón de código en bytes que es lo que el intérprete de JavaScript ejecuta. Para entender las partes que tiene podemos empezar por aquí: Understanding V8\u0026rsquo;s Bytecode y aquí Node.js Under the Hood #8 - Understanding Bytecodes\nComo puedes, en ambos casos el bytecode no es sencillo, de hecho, pero no está diseñado para que los programadores trabajemos con él.\nResumen # El bytecode es un producto secundario e intermedio de la compilación en algunos lenguajes y entornos de ejecución. En algunos casos es directamente el objeto que la máquina virtual ejecuta y en otros se puede pensar como un caché de la ejecución que se puede usar en las ejecuciones posteriores de un programa para mejorar el rendimiento.\nA veces se puede usar el bytecode con otros propósitos, por ejemplo, para hacer optimizaciones en tiempo de ejecución, que es lo que hacen los compiladores bajo de demanda o JIt\u0026rsquo;s.\nEste pequeño artículo tiene el objetivo de que por lo menos veas físicamente lo que muchas veces se menciona como producto de la compilación o interpretación de un programa, pero que no se explica qué es en la mayoría de los casos.\n","date":"22 enero 2023","externalUrl":null,"permalink":"/2023/01/22/qu%C3%A9-es-el-bytecode/","section":"Posts","summary":"\u003cp\u003eTanto para Java como para otros lenguajes que son interpretados, por ejemplo Python o JavaScript, se genera una representación intermedia como resultado de la ejecución o compilación. A este código le llamamos bytecode.\u003c/p\u003e","title":"¿Qué es el bytecode?","type":"posts"},{"content":"","date":"22 enero 2023","externalUrl":null,"permalink":"/tags/bytecode/","section":"Tags","summary":"","title":"Bytecode","type":"tags"},{"content":"","date":"22 enero 2023","externalUrl":null,"permalink":"/tags/complaci%C3%B3n/","section":"Tags","summary":"","title":"Complación","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/tags/compilaci%C3%B3n/","section":"Tags","summary":"","title":"Compilación","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/tags/compilers/","section":"Tags","summary":"","title":"Compilers","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/tags/jit/","section":"Tags","summary":"","title":"Jit","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/tags/just-in-time/","section":"Tags","summary":"","title":"Just-in-Time","type":"tags"},{"content":"Los lenguajes de programación y los compiladores son de las cosas más interesantes en el desarrollo de software. Hace tiempo ha empezado a sonar más un término: JIT o compilación Just In Time, ya que varios lenguajes lo han integrado a sus entornos de ejecución, aquí la llamaremos \u0026ldquo;compilación bajo demanda\u0026rdquo; (gracias a Manuel Rubio por la sugerencia). Durante el artículo entenderás por qué creemos que esta traducción es adecuada.\nEste tipo de compilación es poco entendida, por eso en este artículo hablaremos de por qué es algo tan usado. Primero empecemos hablando de la compilación en general y después entendamos este tipo especial de ejecución. Pero empecemos desde las bases.\n¿Qué es compilar? # Compilar es traducir de un lenguaje a otro. Lo que entendemos como lenguajes compilados generalmente son lenguajes que se traducen de un lenguaje de programación a un lenguaje de máquina, es decir, a código binario que puede ser ejecutado por un procesador en algunos casos o a código para una máquina virtual (aquí a veces se llama código de bytes o bytecode).\nA veces usamos el término \u0026ldquo;transpilación\u0026rdquo; (transpilation en inglés), que se entiende como una forma de traducir o transformar de un lenguaje entendido por los humanos a otro del mismo nivel. Por ejemplo de TypeScript a JavaScript. Esto no es más que otra forma de compilación. Hablemos de cómo surgió la compilación.\nHistoria de la compilación # En el capítulo 9 del libro \u0026ldquo;Historia de los lenguajes de programación\u0026rdquo; de Manuel Rubio, se nos cuenta cómo la compilación nació. Al principio los programadores escribían todo lo que su programa necesitaba desde cero. Una programadora muy experimentada y que estuvo desde los comienzos de la programación, Grace Hopper, empezó a juntar código que hacía tareas que se repetían vez tras vez y simplemente lo insertaba donde necesitaba esa tarea.\nDespués, se dio cuenta que podía hacer un programa que hiciera lo mismo que ella hacía manualmente, pero que lo hiciera de manera más rápida y eficiente. Así nació el primer compilador\u0026quot; el A-0.\nSe llama compilador (Hopper acuñó el término) y no \u0026ldquo;traductor\u0026rdquo; porque más allá de simplemente pasar de un lenguaje a otro, junta (compila) todas las piezas de código invocadas en el programa original y las pone en el programa resultante. El programa original para el A-0 consistía en códigos numéricos que indicaban la subrutina a usar seguidos de los datos a introducir en cada una.\nEs interesante pensar que cuando Grace tuvo la idea de crear un programa que hiciera esto, muchos se opusieron diciendo que no era posible que una computadora se programara a sí misma y que aunque lo hiciera, los programas nunca iban a ser tan buenos como los que podía hacer un programador humano.\nA partir de ahí, se fueron creando compiladores más avanzados y la comunidad al poco tiempo se dio cuenta de que el ahorro de tiempo era muy conveniente para todos, aunque con una pequeña penalización en el desempeño del programa final.\nCompilación por adelantado # La compilación tradicional, conocida en inglés como \u0026ldquo;ahead of time\u0026rdquo; (AOT), que en español la llamaríamos \u0026ldquo;compilación adelantada\u0026rdquo;, es la que se ha usado desde el principio de la programación. En este tipo compilación, el código fuente se traduce a código final que se ejecutará por un CPU o por una máquina virtual. El código puede ser el código binario o bytecode.\nGran parte de lo que hacen los compiladores actuales hacen a parte de traducir es optimizar el código, con el objetivo de que el programa sea lo más eficiente posible en ejecución.\nCompilación \u0026ldquo;Just in Time\u0026rdquo; (JIT) # La compilación \u0026ldquo;Just in time\u0026rdquo;, que significa literalmente \u0026ldquo;justo a tiempo\u0026rdquo; (en español me gustaría llamarla compilación bajo demanda), más que un proceso de traducción se trata de optimización.\nEsta compilación sucede solamente en lenguajes que usan una representación intermedia antes de que el procesador los ejecute. Esta representación intermedia normalmente es un bytecode. El bytecode puede ser ejecutado por una máquina virtual o intérprete. El compilador JIT transforma este bytecode en código máquina directamente para acelerar su ejecución.\nFuncionamiento de un compilador bajo demanda # Para optimizar la ejecución mientras está sucediendo el compilador JIT tiene que hacer por lo menos tres cosas:\nObservar la ejecución y el código para identificar partes que se beneficiarían de compilar su código a código máquina. Por ejemplo, código que se ejecuta muchas veces o que se lleva la mayor parte del tiempo de ejecución. A esta etapa se le llama profiling.\nCompilar el bytecode en código máquina y optimizarlo.\nComo puede que esta compilación no sea tan buena como el bytecode original, el compilador debe regresar el bytecode original si la ejecución no mejora.\nEjemplo con V8 # El motor de JavaScript V8 creado por Google, es un ejemplo brillante del uso de compilación bajo demanda.\nEn el artículo \u0026ldquo;Qué es un Engine de JavaScript\u0026rdquo; explicamos el funcionamiento con más detalle. Pero en este diagrama puedes ver las partes principales:\n{: .align-center}\nDespués de la lectura del código fuente y la transformación en una estructura que ya puede ser ejecutada (el Abstract Syntax Tree), el código se ejecuta en el intérprete.\nEl intérprete, llamado Ignition genera además el bytecode que más adelante será compilado por el compilador TurboFan en caso de que sea conveniente. TurboFan recibe las métricas de uso del bytecode (recogidas por Ignition), es decir, los resultados del profiling y basado en eso decide qué compilará a código máquina. Después de compilarlo y observar su funcionamiento (si mejoró la velocidad y se mantuvo la estabilidad) del código, V8 decide si lo mantiene o si regresa al bytecode original. Esta es la línea roja que vemos en el diagrama, cuando algo se \u0026ldquo;des-optimiza\u0026rdquo;.\nY esto es básicamente el funcionamiento de un compilador bajo demanda. La observación del código en acción y la mejora en el mismo momento.\nOtros lenguajes que la usan # Las primeras instancias de compilación bajo demanda (también llamada compilación dinámica) se vieron desde los años 60, en Lisp y más adelante con Smalltalk y Self. En este documento puedes ver una historia corta de la compilación bajo demanda y los lenguajes que lo han usado: A Brief History of Just-In-Time\nEl lenguaje que popularizó el término JIT fue Java con su máquina virtual HotSpot creada en Sun Microsystems y ahora poseída por Oracle. Esta máquina virtual se caracterizó por el desempeño que logra. Lars Bak participó en el desaarrollo de HotSpot, V8 y recientemente en el de la máquina virtual de Dart. Como te puedes imaginar, Dart también usa compilación bajo demanda. Lua también tie su compilador JIT. Y finalmente, C#, al ser un competidor directo de Java, tiene usar JIT para ser por lo menos tan rápido como su este.\nLos lenguajes que recientemente han agregado JIT a su máquina virtual o intérprete son:\nRuby con YJIT PHP desde su versión 8: PHP 8.0 Erlang desde su versión 24: Erlang 24 Como puedes ver, tanto lenguajes compilados como interpretados usan JIT. El único requisito es que el lenguaje utilice un código intermedio.\nDesventajas # Como te imaginarás, no todo es miel sobre hojuelas. La compilación bajo demanda tiene algunas desventajas:\nAl ser un proceso de compilación dinámica, abre la puerta a algunas vulnerabilidades de seguridad, por ejemplo el JIT Spraying\nEl compilador JIT compite con el intérprete por el uso de la CPU. Esto puede afectar el rendimiento del programa.\nEl consumo de recursos en general es mayor.\nPuede que la forma en la que está hecha tu programa no se beneficie en absoluto de la compilación bajo demanda, por lo que incluso a veces es posible apagarlos.\nSi estás en un entorno en el que algo de esto sea muy importante, considera si el entorno en el que estás trabajando puede dessactivarse el JIT. V8, por ejemplo, puede funcionar sin JIT: JIT-less V8.\nConclusión # La compilación bajo demanda ha sido un gran avance en el desarrollo de software, y es un trabajo de ingeniería muy interesante.\nPermite que la ejecución de nuestros programas sea más eficiente y rápida. Además, a mi punto de ver, es una maravilla de la ingeniería de software. Si quieres aprender más: puedes visitar el sitio oficial de V8, en el que explican muchas cosas acerca del desarrollo de este sistema pionero en compilación bajo demanda.\nTambién puedes ver como funciona un compilador por adelantado todavía más antiguo y muy interesante: Java HotSpot VM.\n","date":"18 enero 2023","externalUrl":null,"permalink":"/2023/01/18/qu%C3%A9-es-la-compilaci%C3%B3n-just-in-time-jit/","section":"Posts","summary":"\u003cp\u003eLos lenguajes de programación y los compiladores son de las cosas más interesantes en el desarrollo   de software. Hace tiempo ha empezado a sonar más un término: \u003cstrong\u003eJIT\u003c/strong\u003e o compilación \u003cstrong\u003eJust In Time\u003c/strong\u003e, ya que varios lenguajes lo han integrado a sus entornos de ejecución, aquí la llamaremos \u0026ldquo;compilación bajo demanda\u0026rdquo; (gracias a Manuel Rubio por la sugerencia). Durante el artículo entenderás por qué creemos que esta traducción es adecuada.\u003c/p\u003e","title":"Qué es la compilación Just In Time (JIT)","type":"posts"},{"content":"En este post platicaremos acerca de cómo funciona un perceptrón con un ejemplo de código y las técnicas que utiliza para aproximar una función a partir de datos.\nSi no tienes claro lo que es un perceptrón, puedes leer nuestro artículo anterior{:target=\u0026quot;_blank\u0026quot;}. Ahí también explicamos las bases de funcionamiento. En este artículo lo vamos a ilustrar de la manera más sencilla posible.\nEl conjunto de datos # Recuerda que para poder crear un algoritmo de machine learning necesitamos un conjunto de datos, ya que el punto es que este algoritmo aprenda de estos datos.\nLos datos que un perceptrón puede clasificar deben poder ser separados en mínimo dos clases por alguna característica, ya que si representáramos al perceptrón como una función, es un línea recta en un plano de dos variables (o su equivalente dependiendo del espacio y sus dimensiones, lo que en para más de tres dimensiones llamamos un hiperespacio matemáticamente).\nNo es necesario que los datos sólo puedan estar divididos en dos clases, por ejemplo, imagínate un conjunto de datos que representa los dígitos escritos a mano, del 0 al 9 (este es conocido como el MNIST dataset). Cada dígito es una clase, pero un perceptrón nos puede servir para clasificar un solo número, por ejemplo, el 5. El perceptrón serviría para clasificar si un dígito es un 5 o no, lo importante es que el conjunto de datos que representa el 5 sea más o menos separable de los demás dígitos.\nCon esto te puedes empezar a dar cuenta de que el perceptrón es el bloque de construcción más básico de las redes neuronales. Por ejemplo, ¿cómo haríamos para clasificar todos los números del conjunto del que hablamos arriba? Necesitamos un perceptrón por cada número, y tomamos el que más confianza nos devuelva.\nAhora sí veamos qué dataset usaremos nosotros. Ejemplos usando el MNIST o el Iris encontrarás en muchos lados, así que vamos a escoger uno diferente. Este es una alternativa a Iris y se conoce como el Penguin dataset.\nEl conjunto de datos de los pingüinos tiene 344 registros etiquetados, cada uno con máximo 6 características (a parte de la etiqueta). Tiene 3 etiquetas diferentes: Adelie, Chinstrap y Gentoo. Las columnas del dataset son:\nspecies: especie del pingüino, esta es la clase o etiqueta island: isla donde fue visto el pingüino, tiene 3 valores diferentes: Dream, Torgersen, or Biscoe bill_lenth_mm: longitud de la pico del pingüino bill_depth_mm: profundidad de la pico del pingüino flipper_length_mm: longitud de la aleta del pingüino body_mass_g: masa del cuerpo del pingüino sex: sexo del pingüino Tenemos que explorar los datos brevemente para ver qué variables podemos usar para separar. Como este no es el objetivo de este artículo vamos a ver una imagen en la que comparan por pares las variables y seleccionemos las que nos ayuden a separar mejor las clases. Vamos a hacerlo sólamente con dos variables para que el código nos quede más sencillo y se comprenda la idea principal.\nLa siguiente imagen es una gráfica de dos variables: la anchura del pico (bill_depth_mm) y el largo de su aleta (flipper_length_mm). Observa qué bien separa a la clase Gentoo de las otras dos.\n{: .align-center}\nNota: para el entrenamiento de una red neuronal se hace una exploración mucho más profunda de los datos, pero para este ejemplo no es necesario.\nRepaso del funcionamiento básico # El perceptrón es un algoritmo de aprendizaje supervisado, por lo que necesita datos etiquetados, es decir, las características junto con su clase. El trabajo del perceptrón es encontrar los parámetros para una función matemática que defina la frontera de separación entre las clases.\nEsta función matemática es una línea recta en un plano de dos dimensiones, o un plano en un espacio de tres dimensiones, o un hiperplano en un espacio de más de tres dimensiones. Puedes pensar en todos estos términos matemáticos como el equivalente a una linea recta en cualquier espacio.\nEl algoritmo # El perceptron es busca ajustar una función lineal que separa las clases. En este caso separaremos \u0026ldquo;Gentoo\u0026rdquo; de \u0026ldquo;no es un Gentoo\u0026rdquo;. El algoritmos nos dirá \u0026ldquo;1\u0026rdquo; si es un Gentoo y \u0026ldquo;0\u0026rdquo; si no lo es. Una función lieneal tiene la forma:\ny = w1 * x1 + w2 * x2 + b Con un término wn * xn para cada variable de entrada, y un término b para el sesgo. El perceptrón ajusta los valores de w1, w2, y b para que la función lineal se ajuste a los datos.\nPodemos empezar combinando las dos variables que elegimos de la siguiente manera:\ny = w1 * penguins[\u0026#39;bill_depth_mm\u0026#39;] + w2 * penguins[\u0026#39;flipper_length_mm\u0026#39;] + b Nota: En este ejemplo no usaremos numpy o pandas, para hacer la programación lo más tradicional posible. Más adelante nos empezaremos a meter en numpy, pandas y esas cosas que parecen magia negra.\nEsto nos dará un número que tenemos que convertir en un 1 o un 0. Usemos una función sencilla. Todos lo números negativos los convertimos en un 0 y todos los positivos y el 0 en un 1. Esto se puede programar sencillo. Vamos a llamar a esta función paso:\ndef paso(x): if x \u0026lt; 0: return 0 else: return 1 Ahora podemos usar esta función para convertir la salida de la función lineal en un 1 o un 0:\ndef clasificar(x, w1, w2, b): \u0026#34;\u0026#34;\u0026#34;Recibe una fila de datos y devuelve 1 si es Gentoo y 0 si no lo es\u0026#34;\u0026#34;\u0026#34; return paso(w1 * x[\u0026#34;bill_depth_mm\u0026#34;] + w2 * x[\u0026#34;flipper_length_mm\u0026#34;] + b) Nuestra función de clasificación ya está lista. Pero el trabajo del perceptrón es encontrar los valores de los parámetros: w1, w2, y b. Creemos el algoritmo que define estos valores, que llamaremos entrenar. Esta función aprende a base de prueba y error. Para aprender hace lo siguiente:\nClasifica cada dato de entrenamiento Verifica si la etiqueta es correcta (para esto necesitamos las etiquetas de los datos de entrenamiento) Ajusta sus parámetros: cambiar los valores de w1, w2, y b para que la función lineal se ajuste a los datos. Repite el proceso Este proceso puede terminar por dos razones:\nSe alcanza un número máximo de iteraciones Se alcanza un resultado satisfactorio (ej. el número de elementos mal clasificados es menor a un umbral) Para hacerlo sencillo vamos a hacer que el algoritmo se ejecute un número fijo de veces:\ndef entrenar(datos, iteraciones): # inicializamos los parámetros, esto puede ser aleatorio o cero, como lo hacemos aquí w1 = w2 = b = 0 while iteraciones \u0026gt; 0: iteraciones -= 1 for x in datos: etiqueta_real = int(x[\u0026#34;species\u0026#34;] == \u0026#34;Gentoo\u0026#34;) clase = clasificar(x, w1, w2, b) if etiqueta_real == 1 and clase == 0: # Aquí tenemos un Gentoo mal clasificado, tenemos que # aumentar w1 y w2 para que la función lineal se acerque # a la etiqueta real w1 += x[\u0026#34;bill_depth_mm\u0026#34;] w2 += x[\u0026#34;flipper_length_mm\u0026#34;] b += 1 # Valor escogido arbitrariamente elif etiqueta_real == 0 and clase == 1: # Aquí tenemos un NO Gentoo mal clasificado, tenemos que # disminuir w1 y w2 para que la función lineal se acerque # a la etiqueta real w1 -= x[\u0026#34;bill_depth_mm\u0026#34;] w2 -= x[\u0026#34;flipper_length_mm\u0026#34;] b -= 1 # valor escogido arbitrariamente print(\u0026#34;Iteración\u0026#34;, iteraciones, \u0026#34;w1:\u0026#34;, w1, \u0026#34;w2:\u0026#34;, w2, \u0026#34;b:\u0026#34;, b) return w1, w2, b Podríamos decir que esto es básicamente todo el algoritmo del perceptrón. Ahora podemos entrenar nuestro perceptrón con los datos de entrenamiento. Antes le hacemos unas cuantas modificaciones para que sea más fácil de usar:\n# cargar el archivo CSV con los datos de entrenamiento como diccionario, el archivo está en la carpeta data, un nivel arriba with open(\u0026#34;../data/penguins.csv\u0026#34;) as csvfile: data = list(csv.DictReader(csvfile)) # Limpiando los los datos, eliminando los que no tienen bill_depth_mm o flipper_length_mm data = [ row for row in data if row[\u0026#34;bill_depth_mm\u0026#34;] != \u0026#34;NA\u0026#34; and row[\u0026#34;flipper_length_mm\u0026#34;] != \u0026#34;NA\u0026#34; ] for row in data: row[\u0026#34;bill_depth_mm\u0026#34;] = float(row[\u0026#34;bill_depth_mm\u0026#34;]) row[\u0026#34;flipper_length_mm\u0026#34;] = float(row[\u0026#34;flipper_length_mm\u0026#34;]) Estos datos ya está listos para para ser usados. Ahora podemos entrenar el perceptrón:\n# Escogemos las iteraciones arbitrariamente w1, w2, b = entrenar(data, 100) Lo podemos probar con los mismos datos de entrenamiento:\ndef probar(data, w1, w2, b): correctos = 0 incorrectos = 0 for x in data: clase = clasificar(x, w1, w2, b) etiqueta_real = int(x[\u0026#34;species\u0026#34;] == \u0026#34;Gentoo\u0026#34;) if clase == etiqueta_real: correctos += 1 else: incorrectos += 1 print(\u0026#34;\\n\\nResultados:\u0026#34;) print(f\u0026#34;Correctos: {correctos} - {(correctos / len(data)) * 100}%\u0026#34;) print(f\u0026#34;Incorrectos: {incorrectos} - {(incorrectos / len(data)) * 100}%\u0026#34;) probar(data, w1, w2, b) Y el resultado es:\nResultados: Correctos: 219 - 64.03508771929825% Incorrectos: 123 - 35.96491228070175% Parece que nuestro perceptrón no logró ni siquiera aprender bien con los datos de entrenamiento. ¿Qué pasa si aumentamos las iteraciones, digamos a 1000?\nw1, w2, b = entrenar(data, 1000) probar(data, w1, w2, b) El resultado es:\nResultados: Correctos: 342 - 100% Incorrectos: 0 - 0.0% Parece que con las suficientes iteraciones el perceptrón logra aprender a clasificar perfectamente los datos de entrenamiento. Tip: siempre debes dudar de un algoritmo de inteligencia artificial que clasifique perfectamente, eso puede indicar que se sobreajustó a los datos de entrenamiento y cuando encuentre datos no vistos, fallará.\nPara evitarlo, necesitamos probarlo con datos que no ha visto antes. Para esto vamos a dividir los datos en dos grupos, uno para entrenamiento y otro para pruebas:\n# Dividir los datos en dos grupos, uno para entrenamiento y otro para pruebas import random random.shuffle(data) entrenamiento = data[:int(len(data) * 0.8)] pruebas = data[int(len(data) * 0.8):] w1, w2, b = entrenar(entrenamiento, 1000) probar(pruebas, w1, w2, b) El resultado es:\nResultados: Correctos: 69 - 100.0% Incorrectos: 0 - 0.0% Y como vemos, sigue funcionando bien con este dataset sencillo. Esta es le estructura básica de un perceptrón, pero en realidad le faltan muchas partes para que funcione de manera general sin gastar demasiado tiempo de cómputo. Por ejemplo, en este código simplemente sumamos o restamos el valor de las variables a w1 y w2. Estos saltos pueden ser muy bruscos y hacernos saltar fácilmente el valor que necesitamos. Para evitar esto, se usa otro parámetro para la función de entrenamiento llamado \u0026ldquo;ritmo de aprendizaje\u0026rdquo; (learning rate - lr).\nVamos a incluirlo en nuestro código:\ndef entrenar(datos, iteraciones, lr=0.01): # inicializamos los parámetros, esto puede ser aleatorio o cero, como lo hacemos aquí w1 = w2 = b = 0 while iteraciones \u0026gt; 0: iteraciones -= 1 for x in datos: etiqueta_real = int(x[\u0026#34;species\u0026#34;] == \u0026#34;Gentoo\u0026#34;) clase = clasificar(x, w1, w2, b) ## Esta es la revisión de \u0026#34;la verdad\u0026#34;, más adelante la explicamos en la sección \u0026#34;función de pérdida\u0026#34; if etiqueta_real == 1 and clase == 0: # Aquí tenemos un Gentoo mal clasificado, tenemos que # aumentar w1 y w2 para que la función lineal se acerque # a la etiqueta real w1 += x[\u0026#34;bill_depth_mm\u0026#34;] * lr w2 += x[\u0026#34;flipper_length_mm\u0026#34;] * lr b += 1 * lr # Valor escogido arbitrariamente elif etiqueta_real == 0 and clase == 1: # Aquí tenemos un NO Gentoo mal clasificado, tenemos que # disminuir w1 y w2 para que la función lineal se acerque # a la etiqueta real w1 -= x[\u0026#34;bill_depth_mm\u0026#34;] * lr w2 -= x[\u0026#34;flipper_length_mm\u0026#34;] * lr b -= 1 * lr # valor escogido arbitrariamente print(\u0026#34;Iteración\u0026#34;, iteraciones, \u0026#34;w1:\u0026#34;, w1, \u0026#34;w2:\u0026#34;, w2, \u0026#34;b:\u0026#34;, b) return w1, w2, b Y ahora vamos a probarlo de nuevo con 100 iteraciones y el lr default:\nw1, w2, b = entrenar(entrenamiento, 100) probar(pruebas, w1, w2, b) En esta versión podemos ver que con muchas menos iteraciones el perceptrón logra clasificar correctamente los datos de prueba. El resultado es:\nResultados: Correctos: 69 - 100.0% Incorrectos: 0 - 0.0% Función de pérdida # El último detalle de nuestro perceptrón es la forma en la que revisa si se está acercando a \u0026ldquo;la verdad\u0026rdquo;. En este perceptrón simplemente verificamos si la etiqueta está equivocada y elegimos si \u0026ldquo;acercar\u0026rdquo; o \u0026ldquo;alejar\u0026rdquo; la línea del punto en cuestión.\nEsta es una forma no tradicional de hacerlo, pero con lo que te debes quedar es que debe existir una función que te diga qué tan equivocado estás y que te ayude a acercarte a la verdad. Esta función se llama \u0026ldquo;función de pérdida\u0026rdquo; (loss function). En las siguientes versiones del perceptrón vamos a incluir una función de pérdida más sofisticada, \u0026ldquo;de verdad\u0026rdquo;.\nRepaso # En este artículo vimos todas las partes que un perceptrón, la unidad de construcción más básica de una red neuronal. Un perceptrón tiene:\nUna función de predicción. Es la que llamamos clasificar y nos dice si un punto de datos pertenece a una clase o no.\nUna función de entrenamiento. Es la que llamamos entrenar y nos ayuda a ajustar los parámetros que le vamos a pasar a la función de predicción para que nos de un resultado correcto.\nUna función de pérdida. Es la parte en la función entrenar que nos dice si estamos cerca o lejos de \u0026ldquo;la verdad\u0026rdquo;. Esta función es la que vamos a mejorar en las siguientes versiones del perceptrón.\nUna función de activación. Esta es la que llamamos paso y nos ayuda a transformar la salida de la función matemática pura que representa una línea en la salida final de nuestro perceptrón. En nuestro caso necesitábamos 0 o 1.\nConclusión # Este perceptrón funciona, pero no es muy flexible, no se puede usar con otros conjuntos de datos y además con un conjunto de datos más complejo y menos separable probablemente no podría encontrar los parámetros correctos, sin embargo, sigue la arquitectura básica de un perceptrón, que era el punto de este artículo.\nEn un siguiente artículo vamos a integrar herramientas matemáticas más poderosas, y vamos a empezar a ver qué tiene qué ver el álgebra lineal con la inteligencia artificial.\nPuedes ver el código completo en este repositorio.\n","date":"7 enero 2023","externalUrl":null,"permalink":"/2023/01/07/ejercicio-programando-un-perceptr%C3%B3n-con-python/","section":"Posts","summary":"\u003cp\u003eEn este post platicaremos acerca de cómo funciona un perceptrón con un ejemplo de código y las técnicas que utiliza para aproximar una función a partir de datos.\u003c/p\u003e\n\u003cp\u003eSi no tienes claro lo que es un perceptrón, puedes leer nuestro \u003ca\n  href=\"/2021/03/25/intro-a-machine-learning-entendiendo-perceptron.html\"\u003eartículo anterior\u003c/a\u003e{:target=\u0026quot;_blank\u0026quot;}. Ahí también explicamos las bases de funcionamiento. En este artículo lo vamos a ilustrar de la manera más sencilla posible.\u003c/p\u003e","title":"Ejercicio: programando un perceptrón con Python","type":"posts"},{"content":"","date":"30 diciembre 2022","externalUrl":null,"permalink":"/tags/claridad/","section":"Tags","summary":"","title":"Claridad","type":"tags"},{"content":" Hablemos de las cosas que hacen más entendible y claro tu código.\nMuchas de estas ideas están basadas en la plática \u0026ldquo;Clarity\u0026rdquo; de Saša Jurić de la Elixir Conf EU de 2021, de hecho, podríamos considerar este artículo como un análisis y extensión de esa plática.\nCuando trabajamos con bases de código normalmente necesitamos entenderlas. Incluso aunque vayamos a escribir algo nuevo necesitamos entender lo demás para poder integrarlo. Esto lo hacemos mediante la lectura de código.\nLos escritores del código nos transmiten información mediante ese código, lo quieran o no.\nLa forma en la que obtenemos conocimiento del código es leyéndolo.\n¿Qué es la claridad y por qué es mejor que \u0026rsquo;el código limpio'? # La claridad como se define en esta plática, es qué tan bien una pieza de código comunica sus verdaderas intenciones. El código claro puede ser entendido sin mucho esfuerzo por alguien que conoce bien el lenguaje: se entiende tanto el problema como la solución que el autor escogió.\nLa claridad nos hace más eficientes y efectivos. Primero porque obtenemos información más rápido y segundo porque obtenemos la información correcta.\nFinalmente, la claridad le da poder al equipo porque hace que cualquiera pueda tomar el código y trabajar con él, en vez de sólo el autor, como muchos estamos acostumbrados.\nPara conseguir claridad se tiene que invertir tiempo constantemente. Tienes que recordar que el código es una herramienta de comunicación con otros seres humanos, no sólo con la máquina.\nPrácticas que mejoran la claridad # Hablemos de cosas que tú y tu equipo pueden hacer para producir código más claro.\nRevisión de código # Esto es la práctica de un equipo de integrar el código a la rama principal solamente cuando ha sido evaluado por cierto números de miembros del equipo. El foco principal de la revisión debería ser la claridad del código.\nPara facilitar el proceso, tanto el autor como el revisor pueden seguir ciertas reglas para que el resultado sea código más claro y la revisión sea más fácil.\nEl que envía el código puede facilitar el trabajo del revisor de tres maneras:\nEnvía solicitudes de integración pequeñas: siempre es más fácil de entender poco código que mucho. Commits pequeños como unidades de cambio más fáciles de tratar individualmente. Un commit no debería tener cambios en muchos lugares para no hacerlo demasiado difícil de entender. Clarifica tu código lo mejor posible: la historia de los commits debería estar estructurada linealmente. Además debería revisar su código para asegurarse de que está lo más claro posible. El revisor:\nSugerir y mandar mejoras. El revisor debería señalar todos los puntos en los que se le hizo difícil entender el código. También podría mandar los cambios directamente, como un pull request al autor, invirtiendo los papeles temporalmente.\nSincronizar. Es importante tener sesiones si algo no se puede resolver. Estas sesiones de pair programming servirán para clarificar todo aquello que siga siendo confuso.\nPrácticas en el código # Saša sugiere seguir las prácticas de progrmación comunes aplicables al código:\nNombrar variables y funciones de manera explicativa. Seguir los idiomas y patrones de programación aplicables a tu caso. Separación de responsabilidades # Pero además, podemos seguir lo que en español llamamos \u0026ldquo;separación de responsabilidades\u0026rdquo; (en inglés \u0026ldquo;separation of concerns\u0026rdquo;). Esta idea Dijkstra lo mencionó en su artículo On the scientific thougth. Dijkstra se refería a la forma de pensar en los asuntos complejos desde diferentes ángulos para poder \u0026ldquo;ignorar\u0026rdquo; temporalmente los aspectos que no tienen que ver con ese ángulo. Esto permitirá que podamos entender mejor el sistema entero poco a poco.\nEn el código lo podemos aplicar haciendo que nuestro código esté separado en módulos que sólo abarquen un aspecto del problema. Esto es imposible de hacer perfectamente, pero nuestro código debería tender hacia allá lo más posible. Por ejemplo, algo que normalmente se hace muy bien es separar el código que maneja la lógica de los datos de la interfaz. Recuerda: esto es importante porque permitirá al lector solo lidiar con un problema a la vez.\nSi ponemos todos los conceptos posibles de programación en una pieza de código (aquí cito directamente a Saša) \u0026ldquo;¿Quién va a ser capaz de entender algo de eso?\u0026rdquo;\nAdvertencia: Una idea que Saša menciona bastante es la de no seguir arquitecturas o ideas sólo porque un líder de opinión o alguien con autoridad lo dice. Si haces esto puede que la parte más compleja de tu código sea tu arquitectura, lo cuál es un grave error porque el trabajo de la arquitectura deberías ser crear un sistema más claro.\n\u0026ldquo;Consider te actual situation you\u0026rsquo;re dealing with, [..], don\u0026rsquo;t just do something because some thought leader or authority says so, even if that person is me. Just think contextually, think inside of your situation.\u0026rdquo; - Saša Jurić\n\u0026ldquo;Considera tu situación actual, [..], no hagas algo sólo porque un líder de opinión o alguien con autoridad lo dice, incluso si esa persona soy yo. Simplemente piensa contextualmente, piensa en tu situación.\u0026rdquo; - Saša Jurić\nTesting # ¿Para qué creamos tests? Obviamente, para probar. ¿Pero qué queremos probar? Saša afirma que queremos probar el comportamiento del software. Así, las \u0026ldquo;unidades\u0026rdquo; que queremos probar son las unidades de comportamiento y no las unidades de código. Otra recomendación es evitar hacer mocks agresivos, solamente en dónde sea estrictamente necesario para lograr comportamientos repetibles. Esto es porque, el uso de dobles en los tests (como los mocks) complica el código de pruebas, pero también complica el código de producción.\nCuando los tests son demasiado complicados o están ligados a la implementación en vez del al comportamiento externo, vas a tener que dividirte entre arreglar los test o arreglar el código de producción, lo cuál es frustrante y una mala idea para tu productividad en general. Un test debe ser fácil de entender y comunicar exactamente lo que está probando, nada más, nada menos.\nRecomendación: Libro Unit Testing de Vladimir Khorikov. Saša lo recomienda como una muy buena lectura.\nConclusión # Una de las tareas más importantes cuando hacemos código es hacer que comunique claramente el problema que resuelve y cómo lo resuelve. Si hacemos eso, lograremos que nuestro equipo o nosotros mismos podamos continuar con el trabajo y lo mejor: evolucionarlo.\nEn la siguiente imagen verás el resumen de las recomendaciones de Saša Jurić para escribir código más claro:\n.\nPuedes ver la charla completa en YouTube. Manuel Rubio y yo platicamos extensamente sobre ese tema:\nFinalmente, te recomiendo mucho el artículo en el que Manuel Rubio hizo su propio resumen en el blog de Altenwald.\n","date":"30 diciembre 2022","externalUrl":null,"permalink":"/2022/12/30/claridad-de-sa%C5%A1a-juri%C4%87/","section":"Posts","summary":"\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003eHablemos de las cosas que hacen más entendible y claro tu código.\u003c/p\u003e\n\u003cp\u003eMuchas de estas ideas están basadas en la plática \u003ca\n  href=\"https://www.youtube.com/watch?v=6sNmJtoKDCo\"\n    target=\"_blank\"\n  \u003e\u0026ldquo;Clarity\u0026rdquo; de Saša Jurić\u003c/a\u003e de la Elixir Conf EU de 2021, de hecho, podríamos considerar este artículo como un análisis y extensión de esa plática.\u003c/p\u003e","title":"Claridad de  Saša Jurić","type":"posts"},{"content":"","date":"30 diciembre 2022","externalUrl":null,"permalink":"/tags/c%C3%B3digo-claro/","section":"Tags","summary":"","title":"Código-Claro","type":"tags"},{"content":"","date":"30 diciembre 2022","externalUrl":null,"permalink":"/tags/pl%C3%A1ticas/","section":"Tags","summary":"","title":"Pláticas","type":"tags"},{"content":"","date":"26 diciembre 2022","externalUrl":null,"permalink":"/tags/comments/","section":"Tags","summary":"","title":"Comments:","type":"tags"},{"content":"Aunque el principal trabajo de un desarrollador es comunicar sus pensamientos a la computadora a través de instrucciones precisas (el código), ningún trabajo serio o que valga la pena se puede hacer solo. Casi siempre formamos parte de un equipo, puede ser con otros roles o con más desarrolladores. Para trabajar efectivamente, hay que comunicarse lo mejor posible. Russ Olsen tiene una plática llamada Eloquent Explanations en la que nos da consejos sobre cómo comunicarnos claramente, además de que da razones por las que es importante hacerlo.\nEn este artículo resumiremos esta charla con algunas adaptaciones y extensiones.\nLa comunicación: transmisión conocimiento # Lo que nos limita para construir software es conocimiento. Conocimiento sobre el dominio, el negocio o el sistema que estamos construyendo. Por lo tanto, compartir el conocimiento es una de las mejores formas de ayudar al equipo a avanzar. La principal forma de compartirlo es con explicaciones (por eso la charla se llama así). Russ comparte cinco consejos para mejorar nuestras explicaciones, de las que hablaremos ahora.\n1: traza un plan para explicar # Debemos tener un plan o estructura para compartir el conocimiento. Russ propone algunas estructuras, como \u0026ldquo;Zomm In\u0026rdquo;, \u0026ldquo;Zoom Out\u0026rdquo; y \u0026ldquo;simple to complex\u0026rdquo;.\nZoom In y Zoom Out # Empieza en el contexto más amplio (o lo que llamaríamos de más alto nivel, pegado al negocio) y termina en los detalles. Por ejemplo:\nQueremos vender zapatos Por eso estamos construyendo un eCommerce Por eso necesitamos este botón de \u0026ldquo;Pagar\u0026rdquo; Zoom Out es lo mismo, pero en sentido contrario, empiezas en los detalles y terminas en el contexto más amplio. Es importante no empezar por en medio y avanzar para un lado y luego para el otro, ya que esto no sigue un orden lógico que permita a tus oyentes seguir el hilo de la explicación.\nDe lo simple a lo complejo # Empieza explicando lo más básico, sin saltarte nada. Este método puede implicar ocultar información intencionalmente o explicarla en términos inexactos, que cuando llegue el momento se tendrán que aclarar y expandir. Quiero recalcar este punto: a veces es importante, casi imprescindible dar información inexacta con tal de que la explicación no sea demasiado compleja al principio.\nPor ejemplo, cuando explicamos las variables a personas que están entrando en la programación les decimos que son como \u0026ldquo;cajitas\u0026rdquo; que guardan valores, una explicación por demás inexacta, pero que no vale la pena corregir porque si no tendríamos que explicar todo el modelo de organización de memoria de los lenguajes y los entornos de ejecución.\n2: Se ágil: explica, mide ajuste y repite # Para mejorar tus explicaciones, las debes tratar como el desarrollo de software: explica, mide, ajusta y repite. Busca señales sobre si tu explicación está funcionando: las preguntas van cambiando, no te miran raro y no hay un silencio mortal. Estas señales que todos hemos vivido en algún punto de nuestra vida son la medida precisa de si tu explicación está funcionando. Si ves que algo no funciona porque no produce preguntas o hace que todos se queden callados, busca otra forma de explicarlo.\nTambién, las explicaciones y analogías que ves que tienen éxito las puedes ir guardando y puliendo.\n2.5: la maldición del conocimiento # Cuando explicamos algo que conocemos muy bien, puede que nos saltemos información que no tenemos presente que necesitamos sabes, justo por el dominio que tenemos del problema. Tenemos que ser cuidadosos en esto e intentar dar la mayor cantidad de información posible, sobre todo si nuestra audiencia es nueva en el tema.\nA veces parece que lo que estamos diciendo es obvio, pero aquí Russ Olsen menciona una frase muy interesante: \u0026ldquo;nadie en esta sala nació con ese conocimiento codificado en su ADN\u0026rdquo;, esto nos debe recordar que a nosotros también nos tienen que explicar cosas que para otros parecen obvias.\n3: Explicar es un deporte con límite de tiempo # Imagínate que cuando estamos explicando algo estamos en un partido de algún deporte que tiene límite de tiempo estricto. Como tenemos un tiempo muy limitado para explicar lo que queremos antes de perder la atención de la persona, por lo que tenemos que seguir dos estrategias:\ncomprimir la información decir primero lo más importante. Con eso ahorrarás tiempo en la explicación, y si pierdes la atención de la persona, al menos habrás dicho lo más importante.\nLa terminología (palabras especiales de un área del conocimiento) es un obstáculo para los que están empezando, y sólo quitará tiempo y poder a tu explicación, aburriendo o comunicando muy poco en un espacio grande de tiempo. Evítala si tu auditorio no está familiarizado con esta MUY familiarizado con ella.\nHay una buena noticia: puedes re-iniciar el reloj y comprarte más tiempo si logras que las personas a las que les estás explicando tengan pequeñas victorias, entendiendo progresivamente el tema en cuestión. Al mantenerlas ilusionadas con el tema, puedes seguir manteniendo su atención.\n{: .align-center}\n4: Repite para énfasis y para dar contexto # El \u0026ldquo;Don\u0026rsquo;t repeat yourself\u0026rdquo; (No te repitas a ti mismo) es para las máquinas, los humanos sí que necesitamos repetición.\n{: .align-center}\n\u0026ldquo;Las personas prosperan [o crecen] en la redundancia.\u0026rdquo; - Russ Olsen\nPodemos repetir algo para:\nDar énfasis. Si quieres resaltar algo, una de las mejores maneras es repetirlo. Para dar contexto. Puedes repetir algo para recordar a las personas sobre algo que ya se mencionó para darle más conexto a algo que estás a punto de decir. 5: Muéstrate humano # Las explicaciones que causan una reacción emocional en los que escuchan, como las que incluyen humor, las que demuestran sentimientos o conectan en un nivel más humano con las personas son las que dejan las cosas grabadas. Una broma puede a hacer que alguien recuerde lo que explciaste por décadas.\nHazles saber por qué importa lo que estás diciendo, muestra el interés o el amor que tienes por el tema.\nEsto nos deja una conclusión muy importante. Si no te interesa lo que estás explicando, a las personas que te escuchan tampoco tiene por qué interesarles.\nConclusión # Saber explicarnos es esencial para realizar un buen trabajo de equipo, y todos los trabajos serios, grandes y que valen la pena requieren de un equipos si los queremos lograr en un tiempo razonable. Nadie nace sabiéndose explicar, es por eso que debemos trabajar en esto y mejorar con la práctica. Una buena explicación puede cambiar tu compañía, tu equipo o incluso el mundo.\nTe repito que puedes ver la plática aquí: Eloquent Explanations, de nuevo gracias a @russolsen por sus contribuciones a la comunidad y por pláticas tan buenas.\n","date":"26 diciembre 2022","externalUrl":null,"permalink":"/2022/12/26/explicaciones-elocuentes/","section":"Posts","summary":"\u003cp\u003eAunque el principal trabajo de un desarrollador es comunicar sus pensamientos a la computadora a través de instrucciones precisas (el código), ningún trabajo serio o que valga la pena se puede hacer solo. Casi siempre formamos parte de un equipo, puede ser con otros roles o con más desarrolladores. Para trabajar efectivamente, hay que comunicarse lo mejor posible. \u003ca\n  href=\"https://blog.thedojo.mx/2021/07/14/desarrolladores-de-los-que-puedes-aprender-russ-olsen.html\"\n    target=\"_blank\"\n  \u003eRuss Olsen\u003c/a\u003e tiene una plática llamada \u003ca\n  href=\"https://www.youtube.com/watch?v=80EE4mZmp3A\"\n    target=\"_blank\"\n  \u003eEloquent Explanations\u003c/a\u003e en la que nos da consejos sobre cómo comunicarnos claramente, además de que da razones por las que es importante hacerlo.\u003c/p\u003e","title":"Explicaciones elocuentes","type":"posts"},{"content":"","date":"26 diciembre 2022","externalUrl":null,"permalink":"/tags/true/","section":"Tags","summary":"","title":"True","type":"tags"},{"content":"En esta serie de posts vamos a hablar de algunas cosas que harán que tu código de Python sea:\nresistente al paso del tiempo más fácil de entender, de mantener y cambiar que evite errores difíciles de encontrar En este artículo vamos a empezar a hablar de cómo hacer código que sea resistente al paso del tiempo.\nEl tiempo y los cambios # En realidad el puro paso del tiempo no le hace nada a ninguna cosa. A lo que nos referimos con esta expresión es que las cosas cambian con el tiempo. Estos cambios pueden afectar a partes de tu código aunque estas en sí misma no sufran ninguna modificación. Veamos cómo puedes protegerte con algunos tips específicamente para Python.\nSerialización # En algunos casos, es necesario guardar información que es resultado de la operación de un programa, sea como un paso intermedio para poder recuperar el cálculo en caso de fallo (como un punto de revisión) o para que otros procesos lo tomen.\nSobre todo en procesos que llevan una gran cantidad de cálculo, algunos programadores están acostumbrados a usar el módulo pickle de Python para guardar información en un archivo. Este módulo es muy útil para guardar objetos de Python en un archivo, pero presenta algunas características inconvenientes:\nEs inseguro, ya que permite ejecutar código arbitrario al cargar un archivo (hay que truquearlo, pero es posible). Es inestable, ya que permitirá crear una versión de un objeto que no sea compatible con la versión actual del código. Aunque la seguridad es muy importante, el punto que queremos tratar ahorita es la inestabilidad. Por ejemplo, si alguna clase de tu código evoluciona, agregando nuevos atributos, el archivo que guardaste y que ahora puedes cargar, creará una versión del objeto sin las características y las guardas que le hayas puesto a la nueva versión. Esto va a causar problemas no detectables hasta que el código que carga el archivo se ejecute.\nAlternativas a Pickle # Siempre que quieras serializar parte de un programa, enfócate en los datos. No en las clases o los objetos. Así, para guardar datos puedes usar cualquier otro formato de serialización que no se meta con el código directo de Python. Algunas opciones son:\nJSON: usa el paquete json para exportar y cargar los datos resultado de las computaciones. Tendrás que convertir tus objetos a diccionarios y listas, pero esto es fácil de hacer y no te afectará cuando cambies tu código.\nProtocol Buffers: es un formato binario definido por Google para acelarar la comunicación entre diferentes servicios. Es más complicado que usar JSON, pero más eficiente si tienes muchos datos.\nMessagePack: usa el paquete msgpack para serializar datos en un formato binario. Es más rápido y también más pequeño que JSON, aunque no es tan fácil de leer.\nTrabajando con fechas # Otra razón por la que tu código puede dar problemas con el paso del tiempo es por un trato incorrecto de las fechas y horas. Cuando una aplicación tiene que recibir datos de horas o fechas de usuarios de diferentes partes del mundo (casi todas las aplicaciones web), es importante asegurarnos de que entendemos bien lo que nos quieren decir y de comunicarnos correctamente con ellos.\nLas zonas horarias son un gran dolor de cabeza para los desarrolladores, pero espero que podamos escribir un artículo más amplio sobre eso en el futuro. Por ahora, vamos a hablar de cómo trabajar con fechas y horas en Python.\nSi no sabes nada de las zonas horarias te recomiendo leer esto: Fundamentos de la zona horaria\nFechas ingenuas vs fechas conscientes de la zona horaria # Esta traducción la siento un poco forzada pero en inglés son naive y timezone aware. (¿Alguien tiene una mejor idea?)\nEn Python, las fechas y horas se representan con objetos de la clase datetime. Esta clase tiene dos subclases: datetime.datetime y datetime.date. Cuando la usas así, directamente sin especificar una zona horaria, estás usando una fecha ingenua. Por ejemplo:\nfrom datetime import datetime fecha = datetime.now() # Esta fecha no incluye ninguna información sobre la zona horaria Aunque esto funciona bien para programas que sólo van a correr en tu computadora y que siempre van a correr nadamás para ti, no es suficiente cuando esta información va a ser compartida o se tiene que guardar para el uso futuro.\nLa forma de usar una fecha consciente de la zona horaria en Python es:\nfrom datetime import datetime, timezone fecha = datetime.now(tz=timezone.utc) # Esta fecha incluye información sobre la zona horaria, en este caso UTC De esta manera nos protegemos para no dar por sentado en qué zona horaria se creo cierto dato o a que zona horaria se refiere cierta fecha. A partir de Python 3.9 tenemos disponible un paquete que se llama zoneinfo que nos permite trabajar con zonas horarias sin tener que instalar nada extra (excepto en Windows donde es probable que necesites los datos de tzdata). Si estás usando Python 3.8 o anterior, puedes instalar el paquete pytz para poder usar zonas horarias o importar desde backports.zoneinfo (también se tiene que instalar). Aquí hay un ejemplo:\nfrom datetime import datetime from zoneinfo import ZoneInfo fecha = datetime.now(tz=ZoneInfo(\u0026#34;America/Mexico_City\u0026#34;)) # Esta fecha incluye información sobre la zona horaria, en este caso la de México # datetime.datetime(2022, 12, 24, 20, 2, 21, 887237, tzinfo=zoneinfo.ZoneInfo(key=\u0026#39;America/Mexico_City\u0026#39;)) Así puedes crear siempre fechas con zonas horarias para que no tengas problemas a la hora de reutilizarla. Ahora hablemos de por qué es recomendable siempre usar la zona horaria UTC.\nEl tiempo universal coordinado (UTC) # UTC son las siglas para Universal Time Coordinated o el Tiempo Universal Coordinado. Este es un estándar para determinar la hora universal. Incluye todos los detalles de cómo obtener el tiempo, la coordinación, cómo tratar los segundos faltantes en el calendario gregoriano, etc. etc. etc. Coordinar el tiempo es un asunto muy complejo.\nUTC, a diferencia de lo que creemos los programadores no es una zona horaria, aunque nosotros lo usemos así. Antes se conocía como GMT (Greenwich Mean Time), pero otros de sus alias son \u0026ldquo;Z time\u0026rdquo; o \u0026ldquo;Zulu time\u0026rdquo;. Puedes leer el estándar, las motivaciones y la historia en este documento de la (BIPM)[]: Coordinated Universal Time.\nAunque UTC es el estándar, GMT pasó a ser el nombre de la zona horaria que no tiene diferencia con el UTC. Ahora ya sabes entonces que lo que los programadores llamamos \u0026ldquo;UTC\u0026rdquo; es en realidad la zona horaria \u0026ldquo;GMT\u0026rdquo;.\n¿A qué viene todo esto? Es recomendado que siempre que tengas que guardar fechas y horas, antes las conviertas en fechas conscientes de la zona en UTC. Al tener esto estandarizado, podrás convertirla sin ningún problema en cualquier zona horaria que el usuario necesite. Además no tendrás problemas para hacer aritmética con fechas y horas.\nTampoco tendrás que preocuparte por problemas con el horarios de verano, ya que UTC no sufre ese cambio.\nConclusión # Hay cosas a las que le tenemos que poner atención y a veces aprender un poco más para que nuestro código soporte el paso del tiempo. En esta serie de artículos seguiremos hablando sobre este tipo de cosas.\nEste artículo estuvo inspirado por dos temas del libro Intuitive Python de David Muller.\n","date":"24 diciembre 2022","externalUrl":null,"permalink":"/2022/12/24/creando-c%C3%B3digo-de-python-robusto-parte-1/","section":"Posts","summary":"\u003cp\u003eEn esta serie de posts vamos a hablar de algunas cosas que harán que tu código de Python sea:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eresistente al paso del tiempo\u003c/li\u003e\n\u003cli\u003emás fácil de entender, de mantener y cambiar\u003c/li\u003e\n\u003cli\u003eque evite errores difíciles de encontrar\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEn este artículo vamos a empezar a hablar de cómo hacer código que sea resistente al paso del tiempo.\u003c/p\u003e","title":"Creando código de Python robusto, Parte 1","type":"posts"},{"content":"","date":"22 diciembre 2022","externalUrl":null,"permalink":"/tags/ciencia/","section":"Tags","summary":"","title":"Ciencia","type":"tags"},{"content":"","date":"22 diciembre 2022","externalUrl":null,"permalink":"/tags/toma-de-notas/","section":"Tags","summary":"","title":"Toma-De-Notas","type":"tags"},{"content":"Como desarrolladores de Software, necesitamos tener sistemas efectivos para aprender. Y aunque no seas desarrollador@ de software, muchas profesiones requieren que se esté aprendiendo constantemente, sea nuevos avances en el estado del arte, nuevas tecnologías, nuevas técnicas, o simplemente aprender nuevas áreas para entrar en \u0026ldquo;pastos más verdes\u0026rdquo;.\nEn este artículo hablaremos de la importancia de tomar buenas notas mientras consumes información, y cómo este sistema te puede ayudar a ti mismo a producir más información y reflexiones, sea para ti mismo, para tu equipo o para el mundo.\nEste artículo está basado en el libro: How to take smart notes1 de Sönke Ahrens, que también está en español: El método Zettelkasten.\n{: .align-center}\nConceptos fundamentales # Antes de empezar a hablar del método y cómo aplicarlo, entendamos por qué Sönke Ahrens y otras personas lo consideran tan efectivo. Los fundamentos de todo están en lo importante que es escribir.\nEscribir es lo único que importa # Aunque consumir información mediante la lectura, las clases, los tutoriales y cosas similares es importante, la forma más efectiva de asimilar información y comprobar que aprendiste es poner en tus propias palabras aquello que estás tratando de aprender. Un ejemplo de esto es \u0026ldquo;técnica de Feynman\u0026rdquo;, que propone poner tus conocimientos sobre el tema que quieres aprender en una hoja de papel (sin copiar de ninguna fuente) y ver en dónde tienes huecos.\nEs por eso que la escritura se propone como un medio superlativamente importante para el aprendizaje, sólo poniendo el pensamiento en medio físico puedes comprobar que aprendiste. Este acto se puede considerar como \u0026ldquo;aprender en papel\u0026rdquo;.\nSönke Ahrens llega a decir en su libro que \u0026ldquo;escribir es lo único que importa\u0026rdquo;. ¿Por qué podríamos llegar a decir algo semejante? El se refiere sobre a todo a los académicos e investigadores, y es que por mucho que piensen y tengan ideas, si no las escriben, no existen. No es posible sacarlas de su cabeza y incluso si lo comunican verbalmente, esto no es permanente (podríamos debatir sobre si hacer grabaciones o videos es equivalente a escribir).\nPero ahora piénsalo en el área de desarrollo de software. El software que no hemos escrito no existe. Y tenemos una capa superior: el software que no tiene especificación y documentación, cuando se va la persona que tiene esas ideas en la mente, es inservible. No se puede mantener o evolucionar a menos que alguien de nuevo adquiera ese conocimiento como si fuera un arqueólogo. Lo mismo pasa con otras áreas del conocimiento, como los procesos empresariales, las políticas, etc. Si no están escritas, no existen.\nLas conexiones son fundamentales # ¿Cuántas veces un amigo de un amigo te ha ayudado con algún problema que tenías? Estas conexiones, que los sociólogos llaman \u0026ldquo;conexiones débiles\u0026rdquo; son un gran recurso cuando necesitamos algo de ayuda. Lo mismo pasa con las ideas, las conexiones débiles entre ideas que parecen no relacionadas es lo que permite la innovación y resolución de problemas de maneras que no nos imaginamos o no eran obvias.\nPero, ¿cómo podemos encontrar estas conexiones no obvias entre ideas? Justo eso para lo que está construido el Zettelkasten.\n¿Qué es el Zettelkasten? # Zettelkasten literalmente significa literalmente \u0026ldquo;caja de notas\u0026rdquo; (en alemán) y el método se llama así porque su creador, Niklas Luhmann, guardaba sus notas en una caja y desde ahí operaba.\nLa propuesta de este método, y por lo que llamó la atención recientemente, es que Niklas fue un sociólogo muy relevante y productivo, que escribió más de 70 libros y 400 artículos académicos. Fue muy influyente, y esta productividad se le atribuye a su método para tomar notas de lo que iba aprendiendo, pensando y encontrando fortuitamente.\nEl método consiste en estos pasos:\nToma notas mientras lees (o consumes información en cualquier formato, ej. viendo videos), no subrayes o escribas en los márgenes. Luhmann lo hacía en hojas de tamaño A6, escribiendo una nota en pocas palabras capturando la idea principal de que quería guardar y la referencia bibliográfica. Nosotros podemos tomar notas temporales en un papel, cuaderno o cualquier lugar que te permita.\nAl final del día, o constantemente, revisa las notas que tomaste con el fin de integrarlas en con las demás notas. La integración tiene que ver con numerar las notas, para que cada una tenga un identificador único. Ahora bien, ¿dónde vas a poner esta nota con respecto a las otras? Vamos a hablar de esto más adelante, pero esto ya empieza a ser tu Zettelkasten.\nRevisa constantemente tu Zettelkasten y reescribe las notas que crees que puedes mejorar o sustituir. También puedes crear nuevos índices.\nCrea un índice de los temas que contiene el Zettelkasten, para poder encontrar los temas más fácilmente cuando los necesites.\nTipos de notas # Para hacer tu Zettelkasten puedes tomar tres tipos diferentes de notas:\nNotas en modo borrador o temporales. En estas notas, normalmente en papel, anotarás todo lo que se te ocurre, llegas a pensar como parte de la reflexión de tu trabajo, las ideas que surgen mientras vas leyendo, etc. El objetivo de estas notas es que no pierdas nada de lo que crees que es importante para tu trabajo o tu vida en general. Estas notas son temporales y más tarde las transformarás en notas permanentes.\nNotas de referencia. Aquí puedes poner citas textuales junto con su referencia bibliográfica o que te permita encontrar de dónde la sacaste. Normalmente estas notas no llevan tus ideas, sino son usadas para apoyar lo que estás poniendo en una nota permanente. Estas notas normalmente están guardadas en un conjunto de notas de referencia separadas del Zettelkasten principal.\nNotas permanentes. Estas son las notas que añadirás a tu cajita, lo que te permitirá avanzar tu pensamiento. Estas notas son ideas completas, concisas y meditadas sobre un tema en específico. Pueden ser una nota temporal transformada o una nota completamente nueva. Para hacer estas notas tienes que reflexionar y poner en palabras el resultado de esos pensamientos. A estas notas le puedes agregar notas de referencias para tener soporte o para expandir sobre el tema más tarde.\nEl libro \u0026ldquo;How to Take Smart Notes\u0026rdquo; menciona otro tipo de notas, llamadas de proyecto, que yo consideraría como las notas permanentes en el sentido de su utilidad, pero que son útiles por menos tiempo porque pertenecen a un proyecto específico.\nOrganizando las notas # La parte más importante del Zettelkasten es la conexión entre las notas, la integración, lo que permite que se generen nuevas ideas y se solidifiquen las que ya existen.\nPara integrar una nota en el Zettelkasten existen varios métodos:\nPuedes buscar una nota relacionada y agregarla como una conexión, detrás de esta (esto es, de manera física). La relación entre las notas puede ser por ejemplo, que una es argumento para apoyar la otra, que es un punto de vista diferente del mismo tema o que de plano la contradice. Esto indicaría que tu pensamiento se está expandiendo y cambiando. Cuando lo haces en versión digital, sólo tienes que agregar una referencia a los temas que quieres conectar.\nPuedes crear una nota que pertenezca a un tema y que tenga referencias a todas las notas relevantes dentro de tu Zettelksten.\nEn ambos casos es muy muy importante que cuando agregues nuevas notas a tu Zettelkasten, revises las notas anteriores para agregar las conexiones pertinentes, eso es fundamental para crear nuevas ideas.\nOtra cosa que el libro menciona que debes hacer es un índice, sin embargo, esto lo podemos obviar si usamos un programa que automáticamente nos de una vista de todas nuestras notas.\nSoftware para hacer tu Zettelkasten # Luhmann hacía su Zettelkasten en papel, pero no tengo duda de que si hubiera tenido a la mano software que se lo facilitara, lo hubiera aprovechado. Algunos programas que puedes usar para hacer tu Zettelkasten son:\nObsidian. Es gratuito (con algunos servicios de paga). Permite tomar notas en formato markdown y la característica más importante es que te permite crear conexiones entre notas, por lo que es muy adecuado para hacer tu Zettelkasten. Puedes descargar Obsidian y ver un video de cómo hacer tu Zettelkasten con él aquí.\nZotero. Este programa se recomienda principalmente para guardar las referencias a los lugares donde encontraste la información. Desde tu Zettelkasten puedes hacer referencia. A las notas de Zotero. Descarga Zotero.\nZettlr.Es gratuito, te permite tomar notas en formato markdown y que tiene una interfaz muy similar a Obsidian. Descargar Zettlr.\nLogseq. Te permite crear notas en Markdown, pero también en Org-mode. Se promociona como una base de conocimiento personal, con la privacidad en mente. Descargar Logseq.\nConclusión # Un cambio que personalmente quiero hacer para medir mi avance, propuesto por el libro mencionado antes, es medir mi productividad por el número de notas que produzco en vez de por el número de páginas que leo. A final de cuentas, mucho de lo que se lee es olvidado si no lo reflexionamos, y lo reflexionado se pierde si no lo escribimos.\nEste sistema, además de aprender mejor, te ayudará a producir más, ya que si quieres crear una pieza sobre un tema, sea el capítulo de un libro, un video o un artículo, basta con echarte un clavado en tu Zettelkasten, ver las notas relevantes, crear un borrador y luego transformarlo y editarlo en el formato final. Claro, no todo será tan lineal, puede que te falten partes que tengas que investigar, pero tendrás un muy buen punto de partida.\nSi eres desarrollador, tener un sistema de administración del conocimiento es esencial para que no eches todo lo que aprendes en saco roto. Pon manos a la obra ya, sea con Zettelkasten o con algún otro sistema. ¿Tienes alguna otra recomendación? ¡Cuéntanos en los comentarios!\nLos enlaces a Amazon son afiliados, si compras algo a través de estos enlaces, yo recibiré una pequeña comisión sin costo adicional para ti.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"22 diciembre 2022","externalUrl":null,"permalink":"/2022/12/22/tomando-notas-efectivamente-zettelkasten/","section":"Posts","summary":"\u003cp\u003eComo desarrolladores de Software, necesitamos tener sistemas efectivos para aprender. Y aunque no seas desarrollador@ de software, muchas profesiones requieren que se esté aprendiendo constantemente, sea nuevos avances en el estado del arte, nuevas tecnologías, nuevas técnicas, o simplemente aprender nuevas áreas para entrar en \u003cstrong\u003e\u0026ldquo;pastos más verdes\u0026rdquo;\u003c/strong\u003e.\u003c/p\u003e","title":"Tomando notas efectivamente: Zettelkasten","type":"posts"},{"content":"","date":"22 diciembre 2022","externalUrl":null,"permalink":"/tags/zettelkasten/","section":"Tags","summary":"","title":"Zettelkasten","type":"tags"},{"content":"En el artículo pasado hablamos de por qué te conviene aprender Rust, un lenguaje moderno, seguro y productivo. Ahora hablemos de cómo empezar, primero veamos los recursos en español y sigamos con recursos en inglés.\nGuía oficial # En la página oficial de Rust puedes encontrar una página que te da muchos recursos para aprender Rust: Aprende Rust. Lo malo es que la mayoría de los recursos a los que refiere están en inglés. Si lo manejas bien no tienes que seguir este artículo y puedes dirigirte a esta página y seguirla.\nSi quieres otros recursos en español, pero además otros tipos de recursos, sigue leyendo.,\nEmpezando en español # De esta sección deberías escoger uno de los recursos que sugerimos. Si no entiendes bien el inglés, los primeros que sugerimos están en español.\nEl recurso más recomendado por todos los que han aprendido Rust es el libro oficial: The Rust Programming Language. El idioma original del libro es inglés y tiene traducciones a diferentes idiomas, entre ellos el español que puedes encontar aquí: El lenguaje de programación Rust. Sin embargo, parece que la traducción tiene bastante tiempo sin avanzar, por lo que la mejor opción es leer la versión en línea en inglés (volvemos al tema de que aprender inglés es una muy buena idea si trabajas en sistemas).\nHay un recurso de Freecodecamp interactivo: Aprende Rust en Replit, con el que podrás hacer los ejercicios interactivamente en Replit.\nOtro curso en línea es el que Microsoft ofrece en Microsoft Learn: Primeros pasos con Rust.\nHay otros recursos que se mencionan en la página oficial de Rust, que no están en español, entre ellos:\nRust by Example. Un curso completamente práctico que te enseña las bases. Rustlings. Un curso práctico que puedes correr en tu propia computadora. Finalmente, una empresa que se llama ferrous systems ha creado recursos para que aprendas Rust basados en su experiencia de muchos proyectos. Puedes ber estos recursos aquí: Ferrous Teaching Material.\nRecursos introductorios en video (de paga) # Encontré dos cursos introductorios en plataformas en español:\nCurso de Introducción a Rust de Código facilito. Este curso es para programadores principiantes, ya que te explica lo básico de Rust con ejemplos sencillos.\nRust básico de Platzi. Tiene exactamente el mismo objetivo que el anterior, ayudar a programadores principiantes a aprender Rust.\nNo recomiendo ninguno de los dos cursos si eres un programador experimentado, ya que sentirás que avanzan demasiado lento, pero si estás empezando, estos dos cursos están bastante bien por las cosas que explican como detalles.\nUn recurso en inglés que parece bastante prometedor si te gustan los cursos en video es Ultimate Rust Crash Course. Tiene bastantes buenas calificacioenes y lo que yo he tomado del curso parece tener un muy buen nivel y avanzar a buen paso.\nAvanzando más allá de lo básico # Casi todos los recursos de los que vamos a hablar ahora están en inglés.\nLibros # Hay dos libros que me llaman especialmente la atención:\nRust for Rustaceans. Es un recurso pensado para programadores experimentados y que ya saben Rust, trata temas avanzados relacionados con el diseño de programas que sean más eficientes y fáciles de mantener.\nFrom Zero to Production in Rust. Es un libro para principiantes en Rust enfocado en el desarrollo web backend.\nCursos en video # La continuación de Ultimate Rust Crash Curse, que se llama Ultimate Rust 2: Intermediate Concepts avanza en conceptos más profundos del lenguaje, impartido por Nathan Stocks (alias CleanCut), también. El curso termina con un proyecto que es un prototipo de un juego en un motor de videojuegos creado por el propio Nathan, llamado Rusty Engine.\nEsto es un conjunto de cursos que componen lo que llamaríamos una especialidad: Become a Rust Professional. La plataforma Educative tiene el modelo de suscripción, por lo que si tienes tiempo, puedes pagar un solo mes y tomar todos los cursos, aunque también puedes comprar cada curso individualmente, conforme vayas avanzando.\nConclusión # Existen un montón de recursos para aprender Rust, sobre todo en inglés, pero también puedes empezar sin ningún problema en español, sobre todo gracias a los esfuerzos que la comunidad y las empresas que lo usan y patrocinan están haciendo para que la mayor cantidad de personas lo puedan aprender.\nEmpieza tan pronto como puedas si está dentro de tus objetivos.\n","date":"18 diciembre 2022","externalUrl":null,"permalink":"/2022/12/18/c%C3%B3mo-aprender-rust-recursos-para-empezar/","section":"Posts","summary":"\u003cp\u003eEn el \u003ca\n  href=\"/2022/12/13/por-que-aprender-rust.html\"\u003eartículo pasado\u003c/a\u003e hablamos\nde por qué te conviene aprender Rust, un lenguaje moderno, seguro y productivo.\nAhora hablemos de cómo empezar, primero veamos los recursos en español y sigamos con recursos en inglés.\u003c/p\u003e","title":"¿Cómo aprender Rust? Recursos para empezar","type":"posts"},{"content":"","date":"18 diciembre 2022","externalUrl":null,"permalink":"/tags/cursos/","section":"Tags","summary":"","title":"Cursos","type":"tags"},{"content":"","date":"18 diciembre 2022","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"Rust se ha establecido como uno de los lenguajes más queridos entre los desarrolladores en los últimos años y desde 2016 está en el número uno, según la encuesta anual de Stack Overflow. Esto no es de extrañar, ya que Rust es un lenguaje que ofrece muchas cosas buenas a aquellos que lo usan.\nEn este artículo vamos a hablar de algunas de sus características, las ventajas de su ecosistema, y por qué te conviene aprenderlo. Además vamos a hablar de cuándo no es tan buena idea.\nHistoria y concepción # No siempre fue así de claro, pero el lenguaje de programación Rust trata acerca de empoderamiento: no importa qué tipo de código estés escribiendo ahora, Rust te habilita para llegar más lejos, para programar con confianza en una variedad de dominios más amplia que la que antes hacías. - Nicholas Matsakis and Aaron Turon\nRust nació en 2006 como un proyecto personal de Graydon Hoare, un empleado de Mozilla en ese entonces, que siempre ha trabajado en lado de los compiladores. Después de mostrárselo a su jefe, a Mozilla le interesó como una alternativa mejor que C y C++ para crear su motor de renderizado web llamado Servo. Y, efectivamente, Servo actualmente estás escrito en Rust.\nIdea detrás de Rust # Según la entrevista que le hicieron a Graydon, en Rust quiso implementar todas las características que le parecían interesantes y amadas de otros lenguajes, pero para un lenguaje dedicado a la creación sistemas, con la teoría de que las concesiones y condiciones que hacen que lenguajes como C y C++ siempre fueran favorecidos, han cambiado desde que nacieron.\nAsí que Rust nació con la seguridad de memoria y la concurrencia en mente, pensando que el internet y la apertura que este provee hace que estas características sean muy importantes. Hablemos de estas características.\nCaracterísticas de Rust # Rust en un lenguaje que quiere reemplazar a C y C++, por lo que necesita características que les compitan y los mejoren, hablemos de tres de ellas con las que lo está intentando.\nRendimiento # C y C++ se distinguen por ser los lenguajes para creación de sistemas más eficientes, y por eso Rust tiene que ser por lo menos tan eficiente como ellos. Rust, en la mayoría de los casos logra equipararse al rendimiento de C y C++.\nAquí puedes ver algunas mediciones de Rust contra C++: Benchmarks Rust vs C++. Y aquí hay otros un poco más entendibles: Rust vs C. La conclusión a la que podemos llegar es que Rust es un contendiente muy serio para C y C++ en cuanto a velocidad y eficiencia.\nLo que tenemos que recordar es que Rust provee características que C y C++, que hacen más fácil y segura la programación, por lo que si es casi tan rápido como estos, más sus características extra, entonces es una gran oferta para los desarrolladores.\nSeguridad de memoria # La seguridad de memoria se refiere a la propiedad de los entornos de ejecución de los programas que te asegura que las referencias a memoria siempre son válidas. Si has programado en C y C++ has experimentado un entorno no seguro en memoria: puedes acceder a registros de memoria que no han sido inicializados y por lo tanto contienen información incierta. Para que la memoria siempre sea segura se necesita que siempre sea alocada por el programa y se del tipo y tamaño correcto.\nUn programa que no es seguro en memoria puede dar bugs aleatorios o fallar aleatoriamente sin explicación alguna. Además también puede ser inseguro respecto a la integridad de tus datos, ya que las fallas en el manejo de memoria pueden ser explotadas de formas creativas por los atacantes para acceder a información sensible.\nUno de los objetivos de diseño en Rust es que sea seguro de memoria, para mi uno de los distintivos más grandes con C y C++.\n¿Cómo logra Rust la seguridad de memoria? Mediante un sistema de verificación estático de prestamos y pertenencia. En artículos futuros explicaremos cómo se logra la seguridad de memoria con este sistema.\nProductividad # Como lo dice la cita del principio, la ventaja principal de Rust es que te permite ser más productivo en diferentes aspectos de la programación.\nRust tiene a cargo, el manejador de paquetes que además te ayuda a crear proyectos, correr las pruebas, realizar reportes diversos sobre tu código, compilar y administrar paquetes, etc.\nCargo te ayudará en formas que lenguajes más antiguos como C y C++ no pueden, no tendrás que crear los scripts de compilación a mano, o instalar un gestor de paquetes, etc.\nAbstracciones sin costo en tiempo de ejecución # Otra de las ventajas que Rust tiene para la productividad son las abstracciones sin costo (zero-cost abstractions en inglés). Una abstracción sin costo se refiera a que puedes usar elementos de más alto nivel (que hacen más cosas por ti) en tus programas sin que esto genere un impacto negativo en el rendimiento del programa. Es decir, Rust genera el mismo código ensamblador sin importar si usas un for para sumar los elementos de un arrglo, si usas la función fold o todavía a más alto nivel la función sum en la que no tienes que hacer nada tú mismo. Sin duda estas abstracciones te pueden ayudar a ser más productivo, y lo mejor es que no tienes que pagar con rendimiento por ellas. Sabemos que las comidas gratis no existen, ¿quién o dónde se paga el costo de estas abstracciones? Es el compilador quien se encarga de que estas formas más fáciles de programar no te cuesten nada en tiempo de ejecución, por lo tanto, te costarán en tiempo de compilación.\nEsto es un tema un poco controversial porque hay quienes dicen que estas no existen, pero yo creo sinceramente que su costo es tan bajo que podemos considerarlo como costo cero, además con las ganancias en productividad que se obtienen, se puede considerar como una ganancia neta.\nRust resuelve puntos dolorosos presentes en muchos otros lenguajes, dando un sólido paso adelante con pocas desventajas - Jake Goulding\nComunidad # La comunidad de Rust es vibrante y cada vez crece más. Rust cada vez se usa en más lugares y más empresas lo respaldan, es como una bola de nieve que se va haciendo cada vez más y más grande. Mi predicción es que la comunidad seguirá creciendo y desarrollando tanto Rust como paquetes y cosas prefabricadas para que sea cada vez más fácil crear software con Rust.\nDesventajas # Rust, como todo, no es una solución mágica que vaya a resolver todos los problemas de la creación de software como si fuera un hechizo mágico. Algunas de las desventajas que le veo son:\nNovedad. Al ser un lenguaje tan nuevo, no hay tantos recursos desarrollados como para C, C++, Java o Python. Probablemente muchas de las cosas que hagas si trabajas en un dominio muy específico, las tendrás que programar desde cero o componer bugs al no haber tantas manos probándolo por mucho tiempo como en otros lenguajes.\nDificultad de aprendizaje. Rust tiene conceptos que no estamos acostumbrados a manejar en otros lenguajes. Simplemente, uno de sus conceptos básicos, el de préstamos y pertenencia, es algo que a muchos programadores nos costará trabajo. El sistema de tipos y la dificultad de que algo compile es algo más que se escucha por ahí respecto a la dificultad de aprender y usar Rust.\nEstá siendo desarrollado muy activamente. Esto puede ser tanto una ventaja como una desventaja, pero sin duda lo es para la estabilidad de tu código. Si algo cambia en una nueva versión del compilador, vas a tener que hacer un gran cambio en tu base de código o quedarte con tu versión atrasada. Por el lado bueno, a tu lenguaje base se le estarán agregando siempre nuevas y mejores funciones.\nFinalmente, puede que no necesites las cosas que te ofrece. El esfuerzo extra que tendrás que poner para hacer que el compilador acepte tus programas puede que valga la pena si el rendimiento, la seguridad en memoria o el acceso a bajo nivel no son algo que distinga a tu software, así que no te dejes llevar el miedo a perderte algo que no necesitas. Si estas haciendo un prototipo que tiene que salir lo más rápido posible, tal vez Rust no sea la mejor elección, por ejemplo.\nConclusión # Rust es un lenguaje de programación moderno que ofrece grandes características para poder desarrollar software de diferentes niveles, desde sistemas a aplicaciones web, e incluso frontend con WebAssembly. Puede que sus características de seguridad, rendimiento y productividad (por lo menos comparado con C++) sean una razón suficiente para que quieras aprenderlo.\nComo desarrollador, también puedes pensar que Rust seguirá creciendo en popularidad y puede que el número de desarrolladores necesitados aumente en los próximos años, por lo que aprenderlo te abriría las posibilidades de encontrar buenos trabajos y bien pagados.\nEn los próximos artículos hablaremos de las herramientas ya desarrolladas para facilitar el trabajo con Rust, es decir, su entorno Open Source y también de recursos para aprender Rust. ¿Qué piensas? ¿Valdrá la pena aprenderlo?\n","date":"13 diciembre 2022","externalUrl":null,"permalink":"/2022/12/13/por-qu%C3%A9-aprender-rust-en-2023/","section":"Posts","summary":"\u003cp\u003eRust se ha establecido como uno de los lenguajes más queridos entre los desarrolladores en los últimos años y desde 2016 está en el número uno, según la encuesta anual de \u003ca\n  href=\"https://insights.stackoverflow.com/survey/2016#technology-most-loved-dreaded-and-wanted\"\n    target=\"_blank\"\n  \u003eStack Overflow\u003c/a\u003e. Esto no es de extrañar, ya que Rust es un lenguaje que ofrece \u003cstrong\u003emuchas cosas buenas\u003c/strong\u003e a aquellos que lo usan.\u003c/p\u003e","title":"¿Por qué aprender Rust en 2023?","type":"posts"},{"content":"","date":"13 diciembre 2022","externalUrl":null,"permalink":"/tags/lenguajes-de-programacion/","section":"Tags","summary":"","title":"Lenguajes-De-Programacion","type":"tags"},{"content":"","date":"3 diciembre 2022","externalUrl":null,"permalink":"/tags/abierto/cerrado/","section":"Tags","summary":"","title":"Abierto/Cerrado","type":"tags"},{"content":"El principio Abierto/Cerrado, originalmente establecido por Bertrand Meyer en 1988 (pero popularizado por Robert Martin{:target=\u0026quot;_blank\u0026quot;}), es para mi uno de los más útiles en el conjunto (tal vez el más útil) de SOLID.\nVamos a analizarlo, ver sus caso de uso y finalmente a establecer sus relaciones con otros principios de diseño de software que te pueden ayudar a crear mejores programas.\nEl principio Abierto/Cerrado # Este principio establece que:\nCualquier módulo de software debería estar abierto para la extensión, pero cerrado para modificación.\nOtra vez nos encontramos con palabras vagas que tenemos que examinar, pero por suerte en este principio es más fácil llegar a una conclusión.\nEn pocas palabras cuando tengas que modificar el comportamiento de un programa, lo último que deberías hacer siempre es modificar el código que ya existe, más bien, debes crear módulos (clases, métodos, funciones, paquetes) que permitan modificar su comportamiento agregando código nuevo.\nNo hay ningún mecanismo casi en ningún lenguaje de programación que te permita \u0026ldquo;cerrar\u0026rdquo; o \u0026ldquo;abrir\u0026rdquo; módulos, así que estas ideas son puramente conceptuales y guías de comportamiento.\nAplicaciones y ejemplos # La forma de ejemplo más clásica de aplicarlo es mediante la preparación de tus módulos o clases para usar polimorfismo. Por ejemplo, imagínate que estás haciendo una aplicación para procesar pagos y quieres cobrar por diferentes medios. Cada uno de estos medios es un \u0026ldquo;método de pago\u0026rdquo;. Si implementas cada uno de estos métodos como dependientes de una clase padre, mediante la herencia, clases abstractas, protocolos o interfaces, tu procesador principal podrá, por ejemplo, llamar al método procesar de cada clase, sin importar el tipo de método de pago que sea o sus detalles de implementación.\nEn el ejemplo anterior, cuando quieras implementar un nuevo método de pago, simplemente creas un nuevo módulo que cumpla con las especificaciones de la clase padre y no tendrás que modificar el código existente. Así solo has añadido código nuevo y has eliminado la probabilidad de afectar cosas que ya existían y funcionaban bien.\nComo puedes ver, los principios de funcionamiento de estas técnicas tienen que ver con dos cosas:\nOcultar información (esconder la mayor cantidad de detalles de implementación de tus módulos, detrás de una interfaz)\nProgramación por contrato, cumplir con una interfaz dada para que otros módulos puedan usarla con seguridad. De esto hablaremos en otro artículo, pero quiero que veas como es un tema que se va a repetir.\nAplicaciones más amplias # Este principio también se puede aplicar a niveles diferentes del sistema, por ejemplo a nivel arquitectónico.\nUn situación en que puedes usar esta estrategia es cuando tienes un módulo que quieres cambiar pero no quieres deshacer o poner en riesgo el funcionamiento de todo el sistema, ya que puede tener consecuencias catastróficas.\nPara aplicarlo, tienes que dejar intacto el módulo de la funcionalidad afectada, mientras lo envuelves con tu nuevo código, usándolo como la interfaz principal cuando te conviene y reemplazándolo poco a poco cuando te sientas seguro.\nComo puedes notar, para poder aplicar esta técnica, los módulos deben ser completamente independientes o no podrías de ninguna manera aislar los cambios que estás intentando hacer. Esto casi siempre se logra con paso de mensajes, como por ejemplo una interfaz RPC, ReST o respetando un contrato (interfaz).\nOtros ideas parecidas # Lo primero que quiero que notes es que este principio tiene mucho que ver con la separación de funciones, la ocultación de información y el respeto a la interfaces.\nEspero que para este momento te empieces a dar cuenta de que todo lo que llamamos \u0026ldquo;principios SOLID\u0026rdquo; tienen en el fondo: Ocultar Información. Esto ha sido ha hablado mucho por David L. Parnas{:target=\u0026quot;_blank\u0026quot;}, y para mi, es gran parte de lo que se requiere para hacer gran software que pueda ser mantenido y funcional mucho tiempo.\nEsta mismo concepto ha sido tratado por otras personas, como Alistair Cockburn con su concepto de \u0026ldquo;Variación protegida\u0026rdquo;{:target=\u0026quot;_blank\u0026quot;}.\nLa idea natural del concepto, puedes entenderla más fácilmente con máquinas reales:\nUna cámara con lentes intercambiables que, cuando requieres una nueva óptica, pones un lente con el mismo conector (interfaz)\nUn carro, que cuando una llanta se poncha se la puedes cambiar, o si requieres para un terreno diferente, puedes ponerle llantas de otro tipo.\nEl punto es darle a tu sistema puntos \u0026ldquo;naturales\u0026rdquo; de extensión, en los que los cambios puedan caber sin hacer grandes cambios en todo el sistema.\nLos límites de la extensión # Es natural que llegue el punto en el que no puedas seguir extendiendo el sistema y tengas que cambiar código que ya está funcionando, nada de lo que estamos diciendo es una ley absoluta o moral que te tengas que sentir mal por no cumplir, recuerda que todo esto es por tu conveniencia, la de tus desarrollos y de tu equipo.\n","date":"3 diciembre 2022","externalUrl":null,"permalink":"/2022/12/03/el-principio-abierto/cerrado-open/closed/","section":"Posts","summary":"\u003cp\u003eEl principio Abierto/Cerrado, originalmente establecido por Bertrand Meyer en 1988 (pero popularizado por \u003ca\n  href=\"https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view?resourcekey=0-FsS837CGML599A_o5D-nAw\"\n    target=\"_blank\"\n  \u003eRobert Martin\u003c/a\u003e{:target=\u0026quot;_blank\u0026quot;}), es para mi uno de los más útiles en el conjunto (tal vez el más útil) de SOLID.\u003c/p\u003e","title":"El principio Abierto/Cerrado (Open/Closed)","type":"posts"},{"content":"","date":"3 diciembre 2022","externalUrl":null,"permalink":"/tags/open/closed/","section":"Tags","summary":"","title":"Open/Closed","type":"tags"},{"content":"En esta serie de artículos vamos a hablar sobre los cinco principios SOLID. Se dice que todo programador que quiera crear código mantenible y \u0026ldquo;limpio\u0026rdquo; debe conocer y usar. La estructura de los artículos llevará la siguiente forma:\nExplicación del principio Ejemplos y contraejemplos para pensar Críticas y alternativas Esta serie de artículos surge debido a que aunque son poco entendidos por la mayoría de los programadores, estos principios se toman como verdades universales que hay que seguir. Si queremos desarrollar buen software, no podemos ir por allí solamente aceptando lo que la mayoría dice que está bien sin entenderlo a fondo y cuestionarlo.\nAsí que esta serie estará enfocada más bien en el lado débil de los principios SOLID y ver si tenemos mejores alternativas, o por lo menos, ver cuando podemos usarlos y cuando no.\nEmpecemos diseccionando el primer principio de los aclamados SOLID: el principio de Responsabilidad Única. Como verás a lo largo de los artículos, estos principios casi siempre se aplican con ejemplos de programación orientada a objetos, por lo que los verás explicados con \u0026ldquo;clases\u0026rdquo; y \u0026ldquo;objetos\u0026rdquo;.\nEl principio de Responsabilidad Única # Este principio se puede enunciar como:\n\u0026ldquo;Una clase debe tener una única razón para ser modificada\u0026rdquo; según en libro Rober Martin.\nOtros lo enuncian como:\nUna clase debe hacer sólo una cosa y hacerla bien.\nEsto es un resumen del principio que nos puede servir para ayudarnos a pensar sobre las responsabilidades que nuestro código tiene, específicamente una clase. Pero, ¿qué es una responsabilidad? Aquí es donde empiezan a entrar los problemas al definir este principio y a tomar pasos prácticos para aplicarlo. Pensemos en algunos ejemplos:\nUna clase que se encarga de transformar un archivo de un formato en otro debería encargarse sólo de esta transformación. ¿En dónde empieza y dónde acaba la responsabilidad de esta clase? ¿Tiene que encargarse de leer y guardar el archivo? ¿Debe existir una clase para guardar el archivo y otra para leerlo?\nUna clase que se encarga de la comunicación con la API, transformando las peticiones del programa interno en peticiones HTTP y transformando las respuestas de la API en objetos y tipos de datos internos. ¿Dónde acaba su responsabilidad?¿Es la encargada de verificar la condición de la red? ¿Se encarga de verificar que los datos sean correctos, o es responsabilidad de otra clase?\nComo puedes ver, el principio, aunque suena simple, deja muchas cosas sin resolver y vagas, por lo que pocos encuentran un manera clara de aplicarlo. A mi me parece que tiene aplicaciones, pero solamente si acotamos más su alcance y definimos algunos límites, incluso cambiando el enfoque del consejo.\nEl problema # El gran problema con este consejo es que la definición de lo que una responsabilidad significa es completamente arbitraria. Todo dependerá de quién esté dividiendo el problema más grande en responsabilidades. Además, esta división puede tener diferentes niveles de granularidad, por lo que una sola responsabilidad a cierto nivel puede significar varias responsabilidades en un nivel más bajo.\nTransformando el principio # ¿Cuál es la esencia del principio? Para mi el corazón de este consejo tiene que ver con controlar la información que una clase maneja. También tiene que ver con el cambio. Finalmente el consejo tiene que ver con la cantidad de información que podemos mantener en nuestra mente en un tiempo específico. Si una pieza de código hace demasiadas cosas, será difícil de entender y por lo tanto propensa a errores y omisiones.\nLa primera cosa de la que vamos a hablar es de la información. La idea de que se encapsule una responsabilidad en un una clase es que si la información que tenemos sobre un problema cambia, se propague por la menor cantidad de código posible en nuestra base, rediciendo el impacto y la posibilidad de crear problemas.\nEntonces, lo primero que tenemos que pensar es si el nivel de granularidad del que se está hablando (clases) es el correcto. Para mi, no se puede establecer un nivel de granularidad tan fijo, sino que dependerá del programador que decida dónde encapsular o esconder la información que esta responsabilidad maneja. Puede que sea un módulo, paquete, clase o función. Hay problemas grandes y pequeños.\nPara aplicar esto, piensa:\n¿Qué procedimientos, información y datos va a manejar esta pieza de código? Si no tienes claro esto, puede que te falte pensar un poco más en problema, e incluso dividirlo mejor. ¿Cómo puedo aislar la información que esta pieza de código maneja, de tal forma que si cambiar, no afecte a todo lo que está fuera de ella? ¿De dónde viene y a dónde va la información que esta pieza de código transforma? ¿Cómo puedo definir exactamente qué hace esta pieza de código? Esta definición junto con la justificación de la decisión debería estar bien documentada. Técnicas para concretar el principio # Divide en problemas (responsabilidades) bien definidas tu problema principal. No hay una forma correcta de hacerlo, estas divisiones siempre serán arbitrarias, así que trata de documentar estas decisiones lo mejor posible. Estas decisiones deben ser fáciles de entender en la medida de lo posible.\nDefine exactamente que hará cada pieza de código que tenga una interfaz. Un módulo, una clase y una función tienen una interfaz, una parte que permite a otras piezas de código usar su funcionalidad interna. La función de esta interfaz es esconder los detalles de implementación permitiendo el uso de la funcionalidad encapsulada. También esto debe estar bien documentado en el lugar adecuado. Documenta lo que hace, no cómo lo hace.\nEstos dos puntos anteriores los puedes aplicar recursivamente a nivel cada vez más bajo, hasta que consideres que el problema es lo suficientemente pequeño como para resolverlo directamente.\nEl último consejo tiene varias partes, por lo que trataremos en un subtítulo aparte.\nEvita las fugas de información # Aunque tengamos completamente claro lo que una clase, módulo o función hace, nuestros detalles de implementación pueden dejar escapar información que no es conveniente que esté fuera de ella.\nPiensa por ejemplo en la clase que se comunica con la API. ¿Qué pasaría si pasaras directamente los errores que la API da hacia las demás partes del código? Si esta parte cambia en el futuro, afectarás a todas estas partes que consumen esos errores.\nPuedes seguir estos consejos para evitar fugas de información:\nDefine estructuras de datos para comunicar información entre clases, módulos y funciones que sean uniformes a todos. Si alguien necesita un formato diferente, sólo lo transformará dentro de sus límites, siempre encargándose de devolver y recibir la información en el formato correcto.\nEvita las dependencias temporales. Siempre que tienes que llamar las mismas funciones, clases o módulos en el mismo orden quiere decir que tienes una dependencia temporal. La información se está escapando en el orden de las llamadas. Piensa si estas piezas de código en realidad debieron ser una sola pieza.\nEvita usar la misma abstracción a diferentes niveles. Imagínate que estás haciendo una aplicación para editar texto. Tienes una clase central que se encarga de mantener el estado del texto. Esta clase tiene la interfaz básica para realizar todas las transformaciones necesarias básicas, pero no le puedes exponer esto al usuario. El usuario necesita comandos como Copiar, Pegar y Cortar. Sería una mala idea usar estas mismas abstracciones en tu clase central, porque encadenaría completamente tu interfaz con tu centro y viceversa. Por eso, la clase que maneja el código debe tener abstracciones más básicas, adecuadas para crear funcionalidades como Copiar, Pegar, Cortar, u otras, si se necesitara.\nTodos estos consejos se tratan de mejor manera en el libro \u0026ldquo;A Philosophy of Software Design\u0026rdquo; de John Ousterhout, pero también me gustaría hacer eco de un consejo de Dan North: Busca crear código simple.\nEsta fue la crítica y aplicación del principio de Responsabilidad Única. En el siguiente artículo veremos el principio de Abierto/Cerrado (Open/Closed Principle).\n","date":"1 diciembre 2022","externalUrl":null,"permalink":"/2022/12/01/an%C3%A1lisis-de-los-principios-solid-principio-de-responsabilidad-%C3%BAnica/","section":"Posts","summary":"\u003cp\u003eEn esta serie de artículos vamos a hablar sobre los cinco \u003cstrong\u003eprincipios SOLID\u003c/strong\u003e. Se dice que todo programador que quiera crear código mantenible y \u003cem\u003e\u0026ldquo;limpio\u0026rdquo;\u003c/em\u003e debe conocer y usar. La estructura de los artículos llevará la siguiente forma:\u003c/p\u003e","title":"Análisis de los principios SOLID: Principio de Responsabilidad Única","type":"posts"},{"content":"Ya hemos hablado en este blog de lo que es un hash e incluso qué hashes puedes usar para guardar tus passwords de manera segura.\nEn este artículo vamos a hablar de uno en específico, el que estamos seguros que deberías usar para cualquier uso futuro en tus programas y sistemas, el que ha sido nombrado como el Secure Hash Algorithm 3 (SHA-3): Keccak.\n¿Qué es Keccak? # Keccak es una familia de funciones, creadas para cubrir la necesidad de un sucesor de la versión 2 del Secure Hash Algorithm, que tiene algunas limitaciones y vulnerabilidades (por ejemplo, el ataque de extensión de longitud).\nEstá basada en una construcción de esponja, y usa internamente una función criptográfica llamada Keccak-f, que se encarga de permutar (cambiar de lugar o mezclar) los bits de la entrada de manera segura.\nDespués de haber ganado la competición para la versión 3 del Secure Hash Algorithm, y por lo tanto ser nombrada SHA-3, ha sido estandarizada en diferentes documentos para diferentes usos. La estandarización implica que ha sido examinada y analizada criptográficamente por organismos internacionales, empresas e individuales para estar seguros de que no tiene deficiencias como función hash criptográfica.\nUn punto interesante es que uno de los diseñadores de esta función, también participó en la creación del actual AES: Joan Daemen, probablmente es un investigador al que le debamos prestar más atención, ya que casi toda nuestra seguridad actual y futura está influida por él.\n¿Qué es una construcción de esponja? # La \u0026ldquo;arquitectura\u0026rdquo; interna de Keccak se distingue de otras funciones hash criptográficas por ser tener una construcción de esponja. SHA-1 y SHA-2 usan una construcción de Merkle–Damgård.\n¿Qué es una construcción de esponja y por qué nos importa como desarrolladores de software?\nUna construcción de esponja usa una función de permutación (en el caso de Keccak esta función se llama keccak-f). Un función de permutación mapea todas las combinaciones posibles de bits en la entrada a todas las combinaciones posibles de esa misma cantidad de bits, intercambiándolas. Por ejemplo, imagina una función que acepta 3 bits y devuelve 4 bits, y que intercambia los bits de la siguiente manera:\n000 --(f)--\u0026gt; 010 001 --(f)--\u0026gt; 100 010 --(f)--\u0026gt; 001 011 --(f)--\u0026gt; 111 100 --(f)--\u0026gt; 000 101 --(f)--\u0026gt; 110 110 --(f)--\u0026gt; 101 111 --(f)--\u0026gt; 011 Observa como ninguna de las combinaciones se repite en ninguno de los dos lados. keccak-f es una permutación de 1600 bits.\nLa construcción de esponja divide los bits de la salida en dos partes: velocidad y capacidad. Esta división arbitraria, en el caso de Keccak depende de la versión que se quiera usar. La parte de la velocidad define cuántas veces se tiene que aplicar la función, ya que mientras más grande sea, más rápido se conseguirá el tamaño deseado. La parte de la capacidad define qué tan segura es la función, mientras más grande sea, más segura es la construcción de esponja (y más pequeña es la parte de velocidad, por lo que la función hash tardará más).\nKeccak empieza este ciclo con un estado inicial de puros ceros. La entrada se divide en bloques del tamaño de la velocidad (si es más pequeña que la velocidad, se aplica un padding). Se aplica un XOR entre cada bloque y el primer bloque de la velocidad, y se le da como entrada a la función de permutación. Esto se hace tantas veces como bloques haya. Esta fue la etapa de absorción.\nFinalmente, para obtener el hash, se \u0026ldquo;exprime\u0026rdquo; la función, siendo el primer bloque del resultado la parte de la velocidad de la última iteración y para obtener los siguientes bloques se aplica la función de permutación sucesivamente hasta obtener la cantidad de bytes requeridos. La siguiente imagen ilustra el proceso (con una permutación de 8 bits y una velocidad de 5 bits):\n{: .align-center } Ejemplo de construcción de esponja con permutación de 5 bits. (Tomado del libro Real World Cryptography de David Wong)\nAhora ya sabes cómo funciona a grandes rasgos Keccak internamente. ¿Por qué nos interesa esto? Las funciones de esponja pueden ser configuradas para que absorban más o menos bits y por lo tanto son bastante flexibles, lo que permite crear funciones configurables y que pueden crear salidas de diferentes tamaños.\nTamaños de Keccak # Keccak ofrece los mismos tamaños de salida que SHA-2. Existen las siguientes versiones:\nSHA-3-224: 224 bits SHA-3-256: 256 bits SHA-3-384: 384 bits SHA-3-512: 512 bits Como siempre, mientras más grande sea la salida, más bits de seguridad ofrece y más difícil es de ser vulnerada.\nUsando Keccak # El siguiente ejemplo muestra cómo usar Keccak como SHA-3-256 en Python (SHA-3 está disponible desde la versión 3.6 de Python):\nfrom hashlib import sha3_256 hash = sha3_256(b\u0026#34;Hello world\u0026#34;).hexdigest() # resultado \u0026#39;369183d3786773cef4e56c7b849e7ef5f742867510b676d6b38f8e38a222d8a2\u0026#39; Aquí hay un ejemplo en Go:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/crypto/sha3\u0026#34; ) func main() { s := \u0026#34;hello world\u0026#34; // Un hash de 256 bits h := sha3.New256() h.Write([]byte(s)) bs := h.Sum(nil) // terminamos la cadena fmt.Println(s) // hello world fmt.Printf(\u0026#34;%x\\n\u0026#34;, bs) // 369183d3786773cef4e56c7b849e7ef5f742867510b676d6b38f8e38a222d8a2 } Aquí hay una implementación de Java:\nimport java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class Main { public static void main(String[] args) { MessageDigest md; try { md = MessageDigest.getInstance(\u0026#34;SHA3-256\u0026#34;); } catch (NoSuchAlgorithmException e) { throw new IllegalArgumentException(e); } byte[] result = md.digest(\u0026#34;Hello world\u0026#34;.getBytes()); System.out.println(Main.bytesToHex(result)); } public static String bytesToHex(byte[] bytes) { StringBuilder sb = new StringBuilder(); for (byte b : bytes) { sb.append(String.format(\u0026#34;%02x\u0026#34;, b)); } return sb.toString(); } } Además, aquí puedes ver ejemplos de cómo usar Keccak (SHA-3) en otros lenguajes:\nSHA-3 en JavaScript o TypeScript SHA-3 en Ruby SHA-3 en Elixir, usando Erlang ¿Por qué usar Keccak? # SHA-3 o Keccak es una función más fuerte, sin vulnerabilidades conocidas, estandarizada y lista para ser usada como reemplazo de SHA-2 en cualquier lado sin grandes cambios. No hay pretexto para no usarla si existe una buena implementación en tu lenguaje.\n","date":"12 octubre 2022","externalUrl":null,"permalink":"/2022/10/12/crea-hashes-resistentes-a-balas-con-keccak-sha-3/","section":"Posts","summary":"\u003cp\u003eYa hemos hablado en este blog de lo que es un \u003ca\n  href=\"/2021/12/02/algoritmos-criptograficos-que-es-un-hash.html\"\u003ehash\u003c/a\u003e e incluso qué hashes puedes usar para guardar tus \u003ca\n  href=\"/2021/12/03/algoritmos-criptograficos-hashes-seguros-para-alamcenar-passwords.html\"\u003epasswords de manera segura\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eEn este artículo vamos a hablar de uno en específico, el que estamos seguros que deberías usar para cualquier uso futuro en tus programas y sistemas, el que ha sido nombrado como el Secure Hash Algorithm 3 (\u003ca\n  href=\"https://www.nist.gov/publications/sha-3-standard-permutation-based-hash-and-extendable-output-functions?pub_id=919061\"\n    target=\"_blank\"\n  \u003eSHA-3\u003c/a\u003e): \u003cstrong\u003eKeccak\u003c/strong\u003e.\u003c/p\u003e","title":"Crea hashes resistentes a balas con Keccak (SHA-3)","type":"posts"},{"content":"","date":"12 octubre 2022","externalUrl":null,"permalink":"/tags/criptografia/","section":"Tags","summary":"","title":"Criptografia","type":"tags"},{"content":"","date":"12 octubre 2022","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":"","date":"12 octubre 2022","externalUrl":null,"permalink":"/tags/keccak/","section":"Tags","summary":"","title":"Keccak","type":"tags"},{"content":"","date":"19 septiembre 2022","externalUrl":null,"permalink":"/tags/mentor/","section":"Tags","summary":"","title":"Mentor","type":"tags"},{"content":" \u0026ldquo;El círculo está completo. Cuando te dejé, yo erá el alumno. Ahora, soy el maestro\u0026rdquo;. - Darth Vader.\nIntentando evitar ser una maestra del mal; en los últimos meses tuve la oportunidad de ser mentora de dos mujeres increíbles.\nEl viaje comenzó con mi participación en un programa de capacitación en mi actual trabajo; la empresa invitó a personas con experiencia Senior para ser mentores de los niveles Junior y Mid. Creé un perfil siguiendo las recomendaciones del equipo en la empresa. La verdad es que al principio tenia algunas limitaciones, como por ejemplo:\n\u0026ldquo;No sé qué compartir.\u0026rdquo; \u0026ldquo;No estoy segura de que mi experiencia sea útil para alguien.\u0026rdquo; \u0026ldquo;Tal vez, no tengo el perfil de una mentora.\u0026rdquo; \u0026ldquo;¿Qué puedo enseñar que no sepan ya?\u0026rdquo; Afortunadamente, se me asignó una excelente Ingeniera de QA. Ella me ayudó a romper esos límites porque desde el principio creamos un sólido vínculo mentor-mentee. Compartir con ella sesiones de mentoría, escuchar sus situaciones, tratar de darle recomendaciones o hablar de mi experiencia fue una oportunidad que disfruté muchísimo.\nCasi al mismo tiempo, una persona de la comunidad tecnológica de mujeres en la que participo me contactó y me pidió que fuera mentora de otra mujer con un perfil diferente, esta vez más similar al mío (Ingeniera Backend), y nuevamente me llegaron mis limitaciones a la mente \u0026ldquo;Oh\u0026hellip; no sé si podré hacerlo.\u0026rdquo;\nPero gracias a Dios acepté y una vez más, construimos un vínculo sólido mentor-mentee y fue una oportunidad muy buena para mí.\nAhi estaba yo apoyando y compartiendo experiencias con dos ingenieras increíbles. Al día de hoy, no me arrepiento de nada; por el contrario, mis dos nuevas amigas me dieron retroalimentación muy positiva sobre mi desempeño como mentora. Además durante este tiempo, una de ellas decidió aceptar una nuevo trabajo y estuve ahi disfrutando del proceso con ella.\n{: .align-center}\n{: .align-center}\n(Fuente de las imágenes: Hercules 1997 Disney película)\nMis primeras mentees son mujeres, y estoy orgullosa de eso, pues hoy día sigo trabajando en equipos de ingeniería donde hay un 10% de presencia femenina. Sin embargo, no limito el compartir mis conocimientos por género; constantemente trato de hacerlo en charlas, artículos o simplemente ofreciendo mi ayuda en el trabajo. Creo que el primer paso para aportar a la comunidad es definitivamente \u0026ldquo;comenzar\u0026rdquo;; no permitas que tus inseguridades te impidan compartir tu conocimiento. Siempre tendremos algo que enseñar.\nMis aprendizajes # Aquí una lista de cosas que aprendí de esta experiencia:\nTodos tenemos inseguridades; ayuda a la persona que estés mentoreando a identificar y manejar las suyas. Cuando nos comparten algo, debemos escuchar activamente, esto implica pedir detalles y así construir un espacio seguro. Ayuda a la persona que estas mentoreando a ser consciente de sus capacidades; que sea capaz de reconocer y comparar su avance. Por lo general, las personas no necesitan conocimientos; ya los tienen o saben dónde conseguirlos. Lo que necesitan es inspiración. Ser abierto y compartir momentos vulnerables de nuestra vida puede ayudar a otros a identificar y atravesar sus momentos difíciles más rápido. La visibilidad puede impulsar una carrera muy rápidamente. Apoya a la persona que estas mentoreando a ser visible en lo que hace en su equipo o trabajo. Una charla informal puede ser más valiosa que una formal. Sin embargo, no pierdas de vista que en las mentorías profesionales, la relación que establecemos, debe mantenerse profesional, los ingenieros no somos psicólogos. Si lo consideras oportuno, puedes redirigirlos con un especialista. Compartir tu experiencia en procesos de entrevista es importante; lo que hayas atravesado puede acelerar el proceso de alguien más. Es muy importante brindar y solicitar retroalimentación constantemente. Todos estamos en continuo crecimiento como profesionales, intercambia información sobre tus y sus áreas de oportunidad. Comparte tus fuentes de conocimiento, libros, publicaciones, podcasts, etc., cualquiera que pueda ser útil, pero recuerda que no debes compartirlo como tarea a completar; si la persona que estas mentoreando tienen la oportunidad, puede usar esos recursos. Hemos sido testigos de cómo en el área de tecnología las oportunidades se multiplican cuando somos capaces de dominar otro idioma, usualmente es el inglés el que nos abre esas puertas. Si tu ya te eres capaz de manejar este idioma y la persona que estas mentoreando no, o aún tiene sus dudas, hacer las sesiones de mentoría en inglés puede ser muy útil. Podría enumerar más cosas aquí. Pero preferí limitarlo a estos puntos porque, al final, somos personas diferentes, y no hay una receta mágica para ser un buen mentor. Solo puedo decirte que si quieres intentarlo, hazlo y hazlo teniendo en mente que estamos en crecimiento constante como profesionales.\n¿Cuál fue mi crecimiento profesional durante esta experiencia? # Identificó lo siguiente.\nAumento en mi confianza. Oportunidad de repasar conocimientos. Práctica en proceso de entrevista. Mejoras en mi comunicación. Aprendí de otras áreas. Aumenté mis contactos en el área. Experimenté sentimientos agradables (diversión, felicidad, me sentí orgullosa de ellas) Aumento en mi disciplina. Por último, pero no menos importante. Quiero agradecer a las personas de las que fui mentora, por todo lo que me enseñaron durante este tiempo; hoy, gracias a ustedes, soy mejor Ingeniera Senior que ayer.\n","date":"19 septiembre 2022","externalUrl":null,"permalink":"/2022/09/19/mi-experiencia-como-mentora/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;El círculo está completo. Cuando te dejé, yo erá el alumno. Ahora, soy el maestro\u0026rdquo;. - \u003cstrong\u003eDarth Vader.\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIntentando evitar ser una maestra del mal; en los últimos meses tuve la oportunidad de ser mentora de dos mujeres increíbles.\u003c/p\u003e","title":"Mi experiencia como Mentora","type":"posts"},{"content":"Era noviembre de 2020, sí 2020, el primer año del caos\u0026hellip; Momento, aqui va más contexto: llevaba 7 años trabajando para un comercio electrónico, era muy apreciada en ese trabajo y lo disfrutaba mucho. Fuimos una de las mejores empresas de comercio electrónico en LATAM. Empecé a trabajar allí cuando era una startup y disfruté participando en su crecimiento. Durante mi último año allí, una gran corporación multinacional de LATAM adquirió la empresa y con esa adquisición llegaron nuevos desafíos.\n¿Qué estaba haciendo en ese entonces? # Estaba trabajando en algo importante, la primera API que desarrolle por mi cuenta y que tendría impacto en los procesos de negocio. Después de desarrollar el MVP, se unieron más desarrolladores al proyecto, y construimos la primera versión de la API (que, hasta donde yo sé, todavía está en uso). El equipo era genial, mi posición era buena y mis opiniones eran respetadas, perode repente, recibí el mensaje de un amigo:\n\u0026ldquo;¡Oye! Estoy trabajando en [\u0026hellip;] y me gustaría referirte a un puesto de ingeniero de software sénior, ¿te interesaría?\u0026rdquo; # Me tomó por sorpresa. Honestamente solía ser una persona que disfrutaba de la estabilidad antes del dinero o los desafíos (jaja), pero estábamos en plena pandemia y comencé a preguntarme:\n\u0026ldquo;Ya tengo 7 años de experiencia con este producto, ¿qué pasaría si cambio de trabajo?\u0026rdquo; \u0026ldquo;¿Es un buen momento para hacer este cambio?\u0026rdquo;\n¡En ese momento me di cuenta de que estaba en una especie de zona de confort! No me malinterpretén, no está mal disfrutar de la comodidad. Lo hice, y fue una etapa maravillosa. Pero en aquel entonces, estaba pensando en nuevos desafíos\u0026hellip;\nLa decisión # Mi amigo me habló de todas las cosas buenas que traería el nuevo puesto. Decidí comenzar el proceso y ¿adivinen qué? ¡Recibí la oferta! Respiré hondo y di un \u0026ldquo;salto de fe\u0026rdquo;. No fue fácil, ¿sabes? Hay ingenieros increíbles que a menudo cambian de trabajo y los admiro por su fuerza y ​​experiencia al hacerlo. Pero, por otro lado, estaba yo, especializándome en el producto de una empresa, siendo buena en mi trabajo y realmente no buscaba cambios hasta ese día.\n¿Qué pasó con mi trabajo anterior? # Bueno, considerando que ya no era la única que trabajaba en la API, escribí la documentación, con algunas propuestas que imaginaba como los próximos pasos en el crecimiento de la API, hablé con mis compañeros de trabajo avisándoles con anticipación de mi partida y dejé la empresa, un empresa que permanece en mi corazón como la que me ayudó a convertirme en la ingeniera que soy actualmente.\n¡El comienzo de una nueva etapa! # No tenía idea de qué es lo que venía, pero la parte difícil ya estaba hecha. La empresa en la que trabajo actualmente es un proveedor global de servicios de tecnología, lo que significa que no estoy necesariamente trabajando en un producto específico. Para una persona como yo, que estuvo 7 años en el mismo lugar, esta fue una muy buena oportunidad. Comenzar el proceso de ser entrevistado, una vez más, obtener nuevas certificaciones y, lo más importante, cambiar a un nuevo lenguaje de programación. Sin duda, este último punto es algo que muchos pueden hacer sin cambiar de trabajo. Sin embargo, en mi opinión, hacer un proyecto paralelo en diferentes tecnologías no es lo mismo que obtener experiencia profesional en esas tecnologías en su trabajo de tiempo completo. En Noviembre 2022 cumpliré 2 años en este trabajo y la verdad es que disfruto mucho de mi puesto actual.\nAsí es como evolucionó mi escritorio en casa durante este tiempo (Dios bendiga el home office):\n¿Por qué escribo este post? # Con los cambios actuales en la industria y la difícil situación de la economía mundial, hay muchas personas que estan cambiando de trabajo. Si eres uno de los afortunados como yo, y decidiste cambiar a un nuevo trabajo porque es una mejor oportunidad para ti, quiero felicitarte, toma esa curva de aprendizaje y no mires atrás. No es fácil, pero cada nuevo logro es un nuevo paso en el desarrollo de tu carrera. Por otro lado, si tuviste que cambiar de trabajo no porque quisieras, sino porque algo sucedió, déjame decirte que los cambios son buenos. Incluso si los sufrimos sin planearlo, definitivamente será difícil, pero ¿qué en la vida no lo es? Solo espero que puedas encontrar un buen lugar para tus próximos desafíos y que tu situación sea lo suficientemente buena para soportar el cambio.\nConclusión # Por último, pero no menos importante, para todos, como ingenieros de software, algunas claves, mantener un perfil profesional actualizado(LinkedIn, GitHub, etc.), estar abierto a nuevas ofertas de trabajo y establecer relaciones con otros profesionales en esta industria tanto como se pueda. Además, no seas egoísta con tus conocimientos y habilidades, estamos en el mismo gremio y es importante que nos apoyemos unos a otros para construir la tecnología que merecemos.\nGracias por leer este pedacito de mi vida. Deseo, de todo corazón, que logres todas tus metas.\n","date":"11 agosto 2022","externalUrl":null,"permalink":"/2022/08/11/est%C3%A1s-cambiando-de-trabajo/","section":"Posts","summary":"\u003cp\u003eEra noviembre de 2020, sí 2020, el primer año del caos\u0026hellip; Momento, aqui va más contexto: llevaba 7 años trabajando para un comercio electrónico, era muy apreciada en ese trabajo y lo disfrutaba mucho. Fuimos una de las mejores empresas de comercio electrónico en LATAM. Empecé a trabajar allí cuando era una startup y disfruté participando en su crecimiento. Durante mi último año allí, una gran corporación multinacional de LATAM adquirió la empresa y con esa adquisición llegaron nuevos desafíos.\u003c/p\u003e","title":"¿Estás cambiando de trabajo?","type":"posts"},{"content":"","date":"11 agosto 2022","externalUrl":null,"permalink":"/tags/trabajo/","section":"Tags","summary":"","title":"Trabajo","type":"tags"},{"content":"","date":"11 junio 2022","externalUrl":null,"permalink":"/tags/programming-languages/","section":"Tags","summary":"","title":"Programming-Languages","type":"tags"},{"content":"¿Te has preguntado cómo nacieron los primeros lenguajes de programación? Manuel Rubio, autor de \u0026lsquo;Historia de los lenguajes de programación\u0026rsquo;, nos habla lo explica de manera cronológica en el primer tomo de esta obra.\nResumen general # El libro habla de manera más o menos cronológica del nacimiento de los primeros lenguajes de programación, desde la época de 1940. La forma en que lo narra te hace comprender claramente por qué eran necesarios y las diferentes tendencias que se dieron.\nEl libro abarca hasta el año 1960, poco antes del nacimiento de Lisp. Hablemos ahora de las fases que el libro cubre a grandes rasgos.\nEl nacimiento de la computación automática # El primer capítulo trata sobe el nacimiento de la computación como la conocemos, cómo Alan Turing, Alonzo Church y John von Neumann definieron lo que conocemos como computable, gracias al \u0026ldquo;Problema de la decisión\u0026rdquo;, definido en los diez problemas del matemático David Hilbert.\nAdemás habla de las contribuciones de John Von Neumann para el diseño y la concreción de las computadoras como medios físicos.\nEl segundo capítulo habla del camino independiente que tuvo Konrad Zuse, en la creación de máquinas automáticas para la computación de problemas lógicos y matemáticos. Habla de cómo hizo la Z1, Z2 y Z3, computadoras mecánicas, cada una mejor que la otra. Además habla de la creación de un lenguaje de programación teórico llamado Plankalkül.\nEstos dos capítulos son muy interesantes porque nos ayudan a comprender cómo la computación automática es algo que estaba muy cerca de ser logrado por la década de 1930, por diferentes mentes y de formas parecidas.\nLos primero lenguajes que corrían en computadoras # Los siguientes capítulos nos van hablando de la progresión de los lenguajes de programación, todos guiados principalmente por dos cosas:\nLa capacidad de la computaras existentes, pero sobre todo, sus límitaciones. La intención de los usuarios de la computadora. No vamos a hablar de cada uno de los capítulos y lenguajes que se mencionan en el libro, pero hablemos de la progresión general que se fue dando y cómo se acercaban cada vez más los lenguajes que conocemos hoy.\nLas primeras computadoras programables requerían que se recablearan, es decir, esta era su forma de entrada de información, sin embargo, se empezaron a crear tablas de instrucciones que ayudaban a programar. Tenemos por ejemplo el ENIAC Short Code.\nTambién, durante esta época empezaron a crearse cosas que damos por sentado, pero que seguramente surgieron naturalmente durante el trabajo del día a día de las primeras programadoras:\nLa subrutina, como una plantilla de código reutilizable a la que sólo se le agregaban los datos en lugares designados para ello. El punto de ruptura, que es una pausa en la ejecución de un programa, para revisar el estado general del sistema y el programa. Después de esto empezaron a nacer los primeros lenguajes ensambladores. Un lenguaje ensamblador es un conjunto de instrucciones apegadas al procesador que lo correrá, que sustituyen las instrucciones en binario y que para pasar a código máquina necesitan una fase de transformación, que los primeros programadores llamaban la fase de \u0026ldquo;ensamblaje\u0026rdquo;. En este sentido, lo que conocemos como lenguajes ensambladores, debieron haberse llamado lenguajes ensamblados.\nEstos lenguajes correspondían a su propia computadora y que por lo tanto, no se podían usar en ningún otro lado. Tenemos como ejemplo (y primer lenguaje ensamblador reconocido) el ARC Assembly de Kathleen Booth. Así surgieron más lenguajes de este estilo, cada uno para su máquina específica hasta la creación de los primeros intérpretes y compiladores.\nEl primer intérprete # ¿Qué nacio primero? Los compiladores o los intérpretes? Pues resulta que lo primero que permitió usar un lenguaje de alto nivel, es decir, algo no relacionado directamente con las instrucciones de específicas de un procesador, fue un intérprete propuesto por John Mauchly en 1949. Este fue llamado primero Brief Code y después Short Code.\nUn intérprete es un programa que transforma un lenguaje de alto nivel en código máquina, es decir, instrucciones para el procesador para el que este intérprete está implementado y además lo ejecuta.\nShort Code fue un lenguaje pensado para representar y resolver expresiones matemáticas. Fue implementado para el BINAC en 1949 y para el UNIVAC I en 1950, por William Schmitt. Aquí empieza la historia de los lenguajes que no están pegados a la arquitectura de un procesador.\nEl primer compilador # Una de las primeras programadoras, Grace Hopper, después haber estado programando de forma arcaica mucho tiempo, comenzó a crear una colección de subrutinas para facilitarse el trabajo. Así que su trabajo se fue convirtiendo en juntar una serie de subrutinas que lograran la tarea en cuestión.\nEl siguiente paso natural, por lo tanto, fue la automatización de este proceso, de juntar o compilar todas estas partes de código en un programa final. Así fue que nació el primer compilador, creado por Grace Hopper, el A-0 para la UNIVAC I.\nDespués de esto siguieron surgiendo compiladores, como el A-1, A-2, MATH-MATIC, ARITH-MATIC, por ejemplo. Estos lenguajes y compiladores surgieron por las diferentes necesidades de las empresas que poseían una computadora y un equipo capaz de desarrollar estos lenguajes.\nFortran I y II # La mayor desventaja de los lenguajes creados en la década de los 50\u0026rsquo;s es que representaban un gran intercambio entre velocidad de programación por velocidad de ejecución. Es por eso que John Backus hizo la propuesta de un lenguaje que fuera fácil de programar, y por lo tanto de enseñar, y que al mismo tiempo no representara una gran diferencia en velocidad de ejecución.\nAsí presentó el informe sobre FORTRAN (FORmula TRANslator), en el que se mencionaban justo estas dos fortalezas: escribir en alto nivel fórmulas matemáticas al mismo tiempo que compilar un programa muy eficiente en ejecución para la computadora IBM 704.\nAquí se empiezan a ver las malas capacidades de estimación de los desarrolladores: John Backus dijo que la implementación primera versión tomaría 6 meses, pero en realidad tomó 2 años y medio, 5 veces más.\nSin embargo, el resultado de FORTRAN como producto fue impecable: a diferencia de los demás compiladores y lenguajes tenía una muy buena documentación que permitió su adopción masiva, convirtiéndose en la mejor arma de IBM para vender más computadoras, y en el estándar en América (sobre todo Estados Unidos) para la industria, debido a que después de implementó para otras computadoras de IBM.\nAlgol 58 # Aunque FORTRAN había tenido mucho éxito como lenguaje en la industria, no había un lenguaje estándar para hacer computación científica, ni en América ni en Europa, por lo que no se podían compartir los resultados ni los programas entre universidades ni instituciones.\nAsí nació la iniciativa de crear un lenguaje estándar para la industria y la academia, que permitiera compartir los resultados entre diferentes grupos de personas. La GAMM (Gesellschaft für angewandte Mathematik und Mechanik [Asociación de Matemáticas Aplicadas y Mecánica]), que es el equivalente a la ACM (Association for Computing Machinery [Asociación de Mecánica Computacional]) se pusieron de acuerdo para crear una especificación de un lenguaje que sirviera este propósito, reuniendo personas con mucha experiencia en la creación de lenguajes y en la programación de compiladores.\nEl resultado de esto fue el International Algebraic Language, después conocido como ALGOL. Este lenguaje tenía las mejores características de los lenguajes modernos de aquella época, sin embargo, tenía un serio problema: sus implementaciones eran inconsistentes, por lo que no pudo cumplir su objetivo de tener una herramienta estandarizada para crear y compartir programas.\nLa creación de esta recomendación, sin embargo, estableció las bases de cooperación entre las asociaciones relacionadas con la computación de Europa y América.\nCOBOL # Hemos estado hablando de lenguajes usados para computación científica y cálculos matemáticos, sea en la academia o en la industria. Grace Hopper, una gran visionaria por lo que podemos ver, se dio cuenta de que los negocios necesitaban ayuda con cosas más mundanas: contaduría, inventarios, etc. De hecho, en retrospectiva, eso es algo que se estaba notando con lenguajes como FLOW-MATIC y AIMACO, especializados en tareas de procesamiento de datos, menos científicos y con instrucciones más adaptadas al mundo de los negocios.\nAsí que Hopper se dio a la tarea de juntar a la gente necesaria para diseñar un lenguaje que cumpliera con estas características y que detuviera la proliferación innecesaria de lenguajes de negocio. Así nació el comité para diseñar COBOL, un lenguaje que cumpliera con las necesidades de las empresas.\nCOBOL, en vez de enfocarse en matemáticas y fórmulas se enfocaría principalmente en palabras en inglés para hacerlo más fácil de programar y aplicar a las necesidades del día a día de los negocios. En el libro de Manuel puedes ver los detalles y los retos a los que tuvo que enfrentarse este comité.\nLa especificación de COBOL se terminó en 1960, pero su implementación se tomó otros años. Para mi, COBOL es el lenguaje que precede a la gran mayoría de los que usamos hoy, como Java, Python, PHP, etc., ya que estos están enfocados en problemas de negocio más que en computación científica o matemática.\nOtros lenguajes # No mencioné un montón de lenguajes, compiladores y computadoras que Manuel toca en libro, por lo que te recomiendo su lectura si quieres una visión más amplia del desarrollo de nuestra industria desde su nacimiento, la evolución de las necesidades y cómo los comercios, la academia y el gobierno se conjuntaron para ir creando lo que se fue necesitando hasta llegar al rico entorno que tenemos hoy.\nAprendizajes # Este libro, más allá de contarte la historia de la programación entre los años 1940-1960, te comunica varias lecciones que puedes aprender si lees entre líneas. A continuación listo mis aprendizajes.\nPerseverancia # La historia de Konrad Zuse me enseña que no siempre es necesario estar con un grupo de personas pensando igual o siquiera que te entiendan para crear algo.\nKonrad persiguió sus intereses con perseverancia y logró cosas muy parecidas a lo que los grupos de principales de desarrollo de la computación lograron años después. Claro, él es una excepción, pero es una muestra de qué tan lejos te pueden llevar tus intereses.\nAcerca de los equipos de trabajo # Para crear algo que vale la pena, como un lenguaje de programación, que es una creación bastante compleja, casi siempre hace falta la cooperación de muchas personas por un periodo sostenido (como ya vimos, hay excepciones). En por lo menos dos de los lenguajes mencionados arriba, se tuvieron que poner de acuerdo múltiples grupos de personas para lograr un objetivo común, como crear un lenguaje que cubriera las necesidades de un grupo amplio de personas e instituciones y evitar problemas estilo la \u0026ldquo;Torre de Babel\u0026rdquo;.\nVender las ideas # Una de las cosas que se menciona en el libro es que \u0026ldquo;la gente es alérgica al cambio\u0026rdquo;. Esto pasó con la idea primeramente de hacer intérpretes y después de los compiladores.\nEs por eso que las personas que tuvieron la idea inicialmente tuvieron que luchar porque otras personas tomaran sis ideas en serio, convencerlas de que valía la pena y poner de acuerdo a un grupo de personas.\nTener la habilidad de vender tus ideas es algo que te ayudará a avanzar en tu carrera y conseguir tus objetivos.\nSiempre habrá celadores # Cuando se presentaban ideas que permitían abrir el campo hacia personas menos educadas que las que ya estaban, o que quitaban barreras para que otros programaran, siempre había personas que se sentían amenazadas y se oponían a esto.\nEsa es una actitud que seguimos viendo hasta hoy. Hay muchos \u0026ldquo;profesionales\u0026rdquo; que desprecias a las personas que no son tan educadas como ellos o que entran en el campo del desarrollo de software sin educación formal.\nPodemos ver en retrospectiva lo equivocados que estaban y podemos entender lo equivocados que están hoy los que tienen la misma actitud.\nConclusión # El primer volumen de \u0026ldquo;Historia de los Lenguajes de Programación\u0026rdquo; es un libro que te puede enseñar mucho sobre tu industria y te puede dejar muchas lecciones. Lo recomiendo mucho a todos los desarrolladores de software que tengan interés en la historia y la filosofía de lo que hacen día a día y creo que debería ser una lectura obligatoria para todos los estudiantes de carreras afines a la computación.\nAquí nos puedes ver platicando con el autor y como bonus tenemos a Camilo Chacón Sartori como invitado, platicando de su libro Mentes Geniales:\nPuedes comprar aquí el libro por sólo 12 Euros: Historia de los lenguajes de programación, Años 1940-1959.\n","date":"11 junio 2022","externalUrl":null,"permalink":"/2022/06/11/resumen-historia-de-los-lenguajes-de-programaci%C3%B3n/","section":"Posts","summary":"\u003cp\u003e¿Te has preguntado cómo nacieron los primeros lenguajes de programación? Manuel Rubio, autor de \u003ca\n  href=\"https://altenwald.com/book/histlangprog\"\n    target=\"_blank\"\n  \u003e\u0026lsquo;Historia de los lenguajes de programación\u0026rsquo;\u003c/a\u003e, nos habla lo explica de manera cronológica en el primer tomo de esta obra.\u003c/p\u003e","title":"Resumen: Historia de los lenguajes de programación","type":"posts"},{"content":"","date":"2 junio 2022","externalUrl":null,"permalink":"/tags/base-de-c%C3%B3digo/","section":"Tags","summary":"","title":"Base-De-Código","type":"tags"},{"content":"","date":"2 junio 2022","externalUrl":null,"permalink":"/tags/consistencia/","section":"Tags","summary":"","title":"Consistencia","type":"tags"},{"content":"Una de las mejores formas de ayudar a que tu código sea fácil de mantener es hacer que el estilo tanto de formateo como de programación en general sea consistente. Analicemos este concepto que se menciona en \u0026ldquo;A Philosophy of Software Design\u0026rdquo;.\n¿Qué es la consistencia en el código? # Básicamente, significa que las que cosas o el código que hace lo mismo luzca y se programen igual y las piezas de código que no hacen los mismo, luzcan y se programen diferente.\nHay varios factores a tomar en cuenta respecto a la consistencia del código, que trataremos en las siguientes sub-secciones.\nNombres # Para empezar, los nombres deben ser consistentes, tanto en estilo como en semántica. Es decir, si decidiste usar camelCase, debes buscar usarlo en todos lados. Muchos guías de estilo y linters incluso lo sugieren un estilo, o es común tener una costumbre dependiendo del lenguaje (por ejemplo en JS y Java se acostumbra mucho el camelCase, mientras que en Python se recomienda usar snake_case).\nEl segundo punto, la semántica tiene que ver con que siempre te refieras a la misma idea con el mismo nombre, por ejemplo, si estás modelando algo que tiene que ver con boletos para un evento, es buena idea nombrar a las variables siempre de la misma forma, como ticket, en vez de nombrarlas ticket, bill, entrance_ticket, etc.\nSi decides usar nombres como i, j o n para numerar cosas o en bloques, asegúrate de que tengan la misma semántica en todos lados, por ejemplo, usa i para el primer índice en un ciclo, y j para un índice interno.\nTener un sistema de nombrado consistente hará que la carga cognitiva que requiere programar en tu base de código disminuya.\nInterfaces # Crear una interfaz (o una clase abstracta, o una estructura, o un protocolo) o cualquier cosa que sirva para definir un contrato para un conjunto de módulos que hagan cosas similares, permitirá que tú código sea más fácil y rápido de entender. Basta con entender una sola de las implementaciones para comprender todas las demás.\nEl ejemplo perfecto son los métodos de pago en un sistema de eCommerce. En vez de inventar cada vez un una nueva interfaz, puedes definir que la interfaz común sea algo como:\nclass PaymentMethod: \u0026#34;\u0026#34;\u0026#34; Defines the interface for all payment methods \u0026#34;\u0026#34;\u0026#34; def charge(self, amount): pass def refund(self, amount): pass def void(self): pass Si tu lenguaje no tiene, puedes documentar y dejar claro para tu equipo cómo deben cumplirse las interfaces y contratos entre los diferentes módulos.\nPatrones de diseño y principios de programación # Muchas soluciones comunes a problemas comunes que encontramos en el desarrollo se han definido claramente y nombrado, para poder ser usadas y entendidas como una receta por muchos programadores.\nA estas soluciones las llamamos patrones de diseño y la familiaridad con ellos, pueden hacer que tú base de código se más fácil de mantener. Usarlos cuando es adecuado, puede ayudarte a darle consistencia a tu código, lo mismo que otro principios de programación, como por ejemplo, inversión de dependencias.\nSólo debes tener en cuenta que para que tu equipo se beneficie de esto, debe conocer estas soluciones, ya que ese es uno de los principales objetivos de los patrones: que los programadores tengan un lenguaje común de soluciones que los ayuden a comunicarse más fácil.\nInvariantes # Una condición que siempre se cumple en tu programa es una invariante. Por ejemplo, muchos los lenguajes funcionales te aseguran que todo es una expresión, por lo que siempre puedes usar cualquier construcción del lenguaje como algo que te devuelve un valor.\nEstablecer invariantes en tu base de código y estilo de programación, ayudará a que el código sea consistente. Por ejemplo, en JQuery se creo la invariante de que todas las funciones que usan un elemento, devuelven este mismo elemento, por lo que puedes encadenar llamadas y siempre funcionará.\nPiensa en cosas que puedas hacer invariantes y ayudarás a que tu código sea más consistente.\nAsegura la consistencia en el código # Hay varias formas de asegurar que tu equipo cree código consistente, no son excluyentes, sino que se ayudan unas a otras.\nLa primera forma, y la más fuerte, es mediante el aseguramiento automático del cumplimiento de las reglas que pueden ser representadas en alguna herramienta. Por ejemplo, los linters, verificadores de complejidad del código, combinados con las herramientas dadas por los sistemas de versionamiento de código (ver git hooks).\nEste conjunto de herramientas podría verificar y obligar que se cumplan las reglas de formateo de código y otras medidas de calidad.\nOtra herramienta es la documentación, y yo diría que es la más importante porque es en la que se define todas las cosas que deberían ser uniformes y trasciende a las personas, estructuras de equipo y herramientas. Es muy importante que (de preferencia) al iniciar el proyecto crees una guía de estilo y sugerencias de uniformidad que ayuden a tu equipo a crear código uniforme. Como te imaginarás, esto es trabajo extra, pero vale la pena.\nFinalmente tienes que promover la consistencia con tu ejemplo y mediante las revisiones de código, si las tienes. Cuando escribas código nuevo, busca la guía de estilo y las convenciones. Si no son explícitas, observa el código para que veas lo que puedes extraer como convención.\nMantén la consistencia # Es muy fácil querer cambiar algo porque encontramos una forma diferente de hacer las cosas que preferimos por gusto o porque es un poquito mejor. En estos casos, tienes que pensar muy bien si vale la pena romper la consistencia de tu base de código por una mejora.\nComo en muchas ocasiones en el código, esto implica un intercambio de valor y como responsable de esta decisión, tienes que evaluar los pros y los contras. Piensa: ¿me va a dar tanta ventaja como para que valga la pena meter esta complejidad extra? ¿vale tanto la pena para que haga replique este cambio en todo los otros lugares en los qu se hace esto?\nConclusión # Mantener la consistencia, en la base de código es algo que vale la pena para reducir el esfuerzo cognitivo que a los desarrolladores les cuesta trabajar en tu código. Esto ayudará a que tu código sea mantenible y sea más probable que tenga una larga vida.\n","date":"2 junio 2022","externalUrl":null,"permalink":"/2022/06/02/consistencia-en-el-c%C3%B3digo/","section":"Posts","summary":"\u003cp\u003eUna de las mejores formas de ayudar a que tu código sea fácil de mantener es hacer que el estilo tanto de formateo como de programación en general sea consistente. Analicemos este concepto que se menciona en \u0026ldquo;A Philosophy of Software Design\u0026rdquo;.\u003c/p\u003e","title":"Consistencia en el código","type":"posts"},{"content":"","date":"2 junio 2022","externalUrl":null,"permalink":"/tags/posd/","section":"Tags","summary":"","title":"Posd","type":"tags"},{"content":"","date":"3 enero 2022","externalUrl":null,"permalink":"/tags/a-mind-for-numbers/","section":"Tags","summary":"","title":"A-Mind-for-Numbers","type":"tags"},{"content":"Desde que comenzamos en la escuela, a muy pocos de nosotros nos han enseñado técnicas para aprender efectivamente, aunque la escuela trata de aprender lo más efectivamente posible.\nEl desarrollo de software es un campo muy amplio en el que tenemos que aprender constantemente, sea por el cambio de las tecnologías, porque tenemos que aprender del área en la que estamos aplicando nuestro conocimiento tecnológico para crear software efectivo o simplemente porque queremos cambiar de área.\nEn este artículo hablaremos sobre algunas de las cosas que el libro \u0026ldquo;A Mind for Numbers\u0026rdquo;1 de Barbara Oakley nos enseña sobre el aprendizaje de temas difíciles, como las matemáticas y las ciencias. Considerando que el desarrollo de software tiene temas difíciles, creemos que es aplicable lo mencionado en este libro.\nPrimero hablemos de las bases de las recomendaciones que da el libro: los modos en los que puede estar tu cerebro, y las partes que ocupa para cada tipo.\nModo enfocado # En este modo, llamado estado de alta atención, tu cerebro está concentrado en una tarea que tienes que lograr, como escribir este artículo, estudiar un tema específico o resolver un algoritmo. Digamos que todas las energías de tu cerebro están destinadas a esta tarea y no divagas en diferentes temas.\nEste modo es muy bueno para terminar o avanzar las tareas del día a día y para evitar errores mientras haces algo importante, pero no es muy bueno para aprovechar el poder natural de tu cerebro, ya que utilizamos las funciones ejecutivas, que nos permiten mantenernos atentos a algo pero nos cuestan mucha energía. La funciones ejecutivas se encuentran situadas principalmente en la corteza prefrontal.\nEl modo enfocado es necesario para aprender, ya que podremos recordar lo que hemos estudiado en este modo, o hacer conexiones conscientes con otras cosas que ya sepamos. En este modo resolvemos problemas de forma secuencial y analítica.\nModo difuso # Oficialmente podemos llamar a este el modo de descanso. Este es el modo en el que estamos cuando no estamos pensando o aplicando nuestra mente a nada específico, digamos que es el estado por defecto del cerebro. Tu foco de atención está brincando de un lugar a otro constantemente. El modo difuso consume menos energía porque no necesitamos controlar la mente para hacerlo. El modo difuso entra en acción cuando estamos haciendo tareas que tenemos completamente dominadas, como caminar, bañarnos, o comer, en ninguna de estas actividades estamos completamente concentrados y nuestra mente está viajando por diferentes lugares.\nEn el modo difuso podemos conectar ideas usando la capacidad del cerebro de hacer conexiones naturalmente, o brincar de un tema a otro sin ningún esfuerzo.\nPodríamos creer que el modo difuso es malo para el estudio, sin embargo, en este modo es cuando nuestro cerebro procesa inconscientemente lo que hemos estudiado de modo consciente y hace que permanezca. Por lo tanto, el modo difuso es esencial para aprender.\nEl modo difuso no utiliza una parte específica del cerebro, sino que se reparte. Al consumir poca energía relativamente y utilizar todo el poder del cerebro, es una herramienta imprescindible para resolver problemas.\nRecuerda que en parte somos máquinas biológicas que necesitan procesos químicos para funcionar y los modos en los que puede estar nuestra mente se complementan para que funcionemos y para que aprendamos efectivamente.\nTécnicas de aprendizaje # Ahora que ya conocemos los dos modos en los que nuestro cerebro puede funcionar, veamos técnicas que nos ayudarán a aprovecharnos de esto para aprender de manera eficiente.\nControla el tiempo que dedicas a estudiar # Nuestro cerebro tiene una capacidad limitada de absorción de información por unidad de tiempo, necesitamos tiempo para procesar las cosas y entender lo que sigue mejor, además de que la repetición a través del tiempo nos ayuda a retener la información por más tiempo. Es por eso que es muy importante controlar cuánto tiempo dedicas a estudiar, cuándo se lo dedicamos y las condiciones físicas y mentales en las que estamos.\nDos técnicas que te pueden ayudar a dedicarle el tiempo correctamente al estudio son:\nProgramar sesiones de estudio de un tema cortas pero constantes. Es mucho mejor dedicar una hora de estudio diaria durante diez d ías, que 10 horas un día al mismo tema. Hacerlo de manera espaciada permitirá a tu cerebro procesar la información durante los periodos en los que está en el modo difuso, además de que mantener el modo enfocado por periodos cortos es más fácil y eficiente que hacerlo durante periodos largos. Esto se conoce como práctica distribuida.\nCambiar constantemente de modos de pensamiento. Cambiar entre el modo enfocado y el modo difuso te ayudará aprender mejor y te mantendrá fresco. Una técnica que puedes aplicar es la técnica pomodoro en la que programas periodos de estudio o trabajo de 25 minutos y un descanso de 5 minutos. Esta técnica no es efectiva para todos por el tiempo que tardan en enfocarse, pero puedes incrementar los periodos de enfoque para que se acomode a tu estilo. El punto es tener una sesión de estudio estructurada y que te permita cambiar de modos de pensamiento para aprovechar todo el poder de tu cerebro.\nEstos dos técnicas le darán a tu cerebro tiempo para usar todo su poder: le darán al modo difuso tiempo para trabajar en problemas difíciles.\nCrea un mapa de lo que aprenderás # Es muy importante que cuando tengas un tema difícil que aprender hagas una sesión de pre-estudio, en el que veas lo que aprenderás. Esto lo puedes hacer mirando el índice si existe, las preguntas que guían el estudio en caso de que haya, leyendo (o viendo, o escuchando) solamente la introducción y conclusión y fijándote en los subtemas, capítulos, negritas, recuadros, etc.\nEsta sesión de pre-estudio te ayudará a organizar tus pensamientos sobre lo que aprenderás, un mapa que tendrá los puntos principales a aprender que después rellanarás estudiando a fondo el tema.\nEvitar la ilusión de aprendizaje # Una parte muy importante de aprender es evitar la sensación falsa de que aprendimos algo sin realmente haberlo aprendido. ¿Cómo podemos evitar esto?\nAuto-exámenes # Una de las formas más efectivas es buscar o fabricar exámenes o cuestionarios de las cosas de las que deberíamos ser conscientes una vez que terminemos de estudiar el tema. Hacer estos exámenes o prácticas sin consultar el material de estudio te ayudará averiguar si realmente has aprendido algo, y si fallas, tendrás puntos en los cuales mejorar.\nEstos auto-exámenes se han mostrado muy eficaces para muchos estudiantes de temas complejos.\nPractica, recorta y repite # Algunas de las cosas que tenemos que aprender consiste en una serie de pasos por ser un problema complejo. Una técnica de aprendizaje es aislar una parte del problema y practicarla hasta que la dominemos en diferentes contextos. Imagina por ejemplo que quieres dominar la configuración de servidores. Lo que más se te dificulta es la configuración de la parte de HTTPS. Entonces, deberías repetir estar parte con diferentes variables y opciones hasta que lo puedas hacer sin dificultad.\nMejora tu memoria # Finalmente hablemos de algo que ha adquirido muy mala fama: la memoria. Debido a que en la escuela nos hacían aprender de memoria cosas que parecen inútiles a lo largo de la vida, hemos demonizado el memorizar cosas. Sin embargo, memorizar es algo imprescindible para la resolución de problemas efectiva y la creatividad. Veamos algunas técnicas que te ayudarán a memorizar de manera más eficiente:\nPalacios de memoria. Esta es una técnica que consiste en aprovechar nuestra capacidad de ubicación espacial para memorizar cosas fácilmente. Puedes investigar más sobre ella y ver si te sirve. Repetición espaciada. Casi todo lo que consumimos lo olvidamos, a menos que se nos repita constantemente. La repetición espaciada consiste en repasar un tema con frecuencia cada vez más grande, para poder retenerlo a largo plazo. Puedes usar herramientas como Anki para automatizar esto. Conclusión # Hemos hablado de los temas que a mi parecer son más aplicables a los desarrolladores. El libro habla de otros temas como la presentación de exámenes, la organización del tiempo, la motivación, etc. Te invito a que le eches un ojo si estás en la escuela y sobre todo si estás en un área de ciencias o físico-matemáticas.\nLink de afiliados de Amazon\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"3 enero 2022","externalUrl":null,"permalink":"/2022/01/03/aprendiendo-desarrollo-efectivamente/","section":"Posts","summary":"\u003cp\u003eDesde que comenzamos en la escuela, a muy pocos de nosotros nos han enseñado técnicas para aprender efectivamente, aunque la escuela trata de aprender lo más efectivamente posible.\u003c/p\u003e\n\u003cp\u003eEl desarrollo de software es un campo muy amplio en el que tenemos que aprender constantemente, sea por el cambio de las tecnologías, porque tenemos que aprender del área en la que estamos aplicando nuestro conocimiento tecnológico para crear software efectivo o simplemente porque queremos cambiar de área.\u003c/p\u003e","title":"Aprendiendo desarrollo efectivamente","type":"posts"},{"content":"","date":"3 enero 2022","externalUrl":null,"permalink":"/tags/barbara-oakley/","section":"Tags","summary":"","title":"Barbara-Oakley","type":"tags"},{"content":"","date":"30 diciembre 2021","externalUrl":null,"permalink":"/tags/aes/","section":"Tags","summary":"","title":"Aes","type":"tags"},{"content":"Ya hemos hablado de los cifrados de bloque, de flujo y de los hashes, ahora hablemos de un híbrido entre ellos que funciona como un hash pero usa una llave como un cifrado. El uso principal de este tipo de algoritmos es la autenticación y verificación de mensajes, pero también pueden ser usados para generar derivados de una llave, por su carácter pseudo-aleatorio.\nEn general este tipo de algoritmos se llaman hashes con llave o Keyed Hashes. Empecemos a hablar del tipo más sencillo y usado: la generación de códigos de autenticación de mensajes.\nMessage Authentication Codes (MACs) # Un código de autenticación de mensajes es una función que recibe un mensaje y una llave (secreta) y devuelve lo que llamamos una etiqueta, que es una cadena de bits de los tamaños comunes en los hashes.\nEn este tipo de algoritmos, si mantenemos la llave secreta, y la compartimos solamente con quien necesitamos verificar la autenticidad del mensaje, podemos comprobar el origen (gracias a que sabemos que la llave está protegida) y que el mensaje está intacto (gracias a que las propiedades del hash).\nUna forma de crear un hash con llave es simplemente poniendo la llave antes o después del mensaje que queremos autenticar y usando un algoritmo de hashing normal, aunque ninguna de las dos formas es muy segura, ya que es vulnerable a ataques de extensión de longitud o se pueden encontrar colisiones si se usa una llave de tamaño variable. Un ejemplo en Python sería el siguiente:\nfrom hashlib import sha3_512 key = b\u0026#39;mi llave super secreta\u0026#39; message = b\u0026#39;mi mensaje que puede o no ser secreto, pero del que me importa el origen y que no haya sido cambiado\u0026#39; tag = sha3_512(key + message).hexdigest() (Afortunadamente, ningún algoritmo de la familia SHA-3 es vulnerable a los ataques de extensión de longitud, por eso lo usamos aquí para el ejemplo)\nA nuestra contraparte le enviamos el mensaje junto con el tag y para verificar la autenticidad del mensaje el receptor debe hacer exactamente la misma operación, por lo que necesita tener previamente la llave. Si el tag resultante es igual, quiere decir que el mensaje es auténtico y no ha sido modificado, reemplazado o viene de alguien que no tiene la llave.\nPara que un MAC sea seguro, debe ser imposible crear un tag que parezca venir de alguien con la llave, sea por falsificarlo directamente o por poder adivinar la llave.\nLos MACs más comunes son los que están basados en hashes, conocidos como HMAC, un término que seguro has visto si has estado desarrollando por algún tiempo.\nCódigos de autenticación de mensajes basados en hashes (HMAC) # Un Hash based Message Authentication Code es un MAC creado a partir de un hash, operando de una manera diferente a simplemente poner antes o después la llave. Los HMACs hacen uso de dos valores adicionales, un padding interno y un padding externo. Los combinan con la llave para crear una etiqueta que no sea vulnerable a los ataques de extensión de longitud.\nLa construcción de HMAC funciona así:\nSe combina la llave con el padding interno mediante la operación XOR. Se hashea la la combinación de la llave y el padding interno junto con el mensaje del que queremos crear la etiqueta (a esto lo llamaremos H1). Se combina la llave con el padding externo mediante la operación XOR. Se hashea la la combinación de la llave y el padding externo junto con H1, el resultado de esto es la etiqueta de autenticación. Sin embargo, se conoce un ataque efectivos contra los HMACs que permiten falsificar tags computando 2^n/2 operaciones en promedio, lo cuál no es cualquier cosa, pero un atacante motivado (y con recursos) podría lograrlo sin problemas si n, el tamanño interno del estado del hash es muy pequeño. Un hash moderno tiene un estado de 512 bits, por lo que un ataque de tamaño de 2^n512/2 = 2^256 es impráctico.\nYa que un HMAC están basado en un algoritmo de hash, cuando se nombra se usa el nombre de este, por ejemplo: HMAC-SHA-256 o HMAC-SHA-3-512.\nCódigos de autenticación de mensajes basados en cifrados de bloque (CMAC) # Ya que los hashes pueden estar basados en cifrados de bloque, una construcción más directa es usar un cifrado de bloque como la base para un MAC. Así nacen lo CMACs, códigos de autenticación de mensajes basados en cifrados de bloque, por ejemplo AES-CMAC. Aunque se siguen usando en algunos protocolos de seguridad, los más MACs más eficientes son los que no se basan en Hashes o cifrados de bloque, sino que tienen un diseño independiente.\nMACs con diseño independiente # Un MAC seguro es más fácil de lograr que un hash completamente funcional y seguro o que un cifrado de bloque con las mismas características, ya que al usar un llave secreta evitan que se pueda atacar tan fácilmente como un hash y al exponer una etiqueta pequeña, revelan menos información que un cifrado de bloque.\nEs por eso que un MAC no requiere todo el poder de un hash ni de un cifrado de bloque. Gracias a esto se han dieseñado algortimos que usan esta ventaja para ser más eficientes. Hablemos de tres ejemplos:\nSipHash: Es una familia de algoritmos optimizada para autenticar mensajes cortos, originalmente diseñada para reemplazar las funciones hash en los diccionarios implmentados como hashtables. Poly1305: Es una función de autenticación de mensajes muy rápida y eficiente, más que cualquiera basada completamente en un algoritmo de bloque o un hash, usada para autenticar paquetes en dispositivos de bajo rendimiento en Android, por ejemplo. Pelican 2.0: Es un MAC basado en AES (Rijndael), pero que no utiliza todo su poder y que funciona de forma eficiente gracias a esto. Sin embargo, este algoritmo no está implementado en ningún lugar importante. Si lo que buscas es eficiencia, manteniendo la seguridad relativa de tus etiquetas de autenticación, este tipo de MACs son los que deberías usar.\nConclusión # Conocer sobre los códigos de autenticación de mensajes es importante para no navegar perdidos entre todas esas siglas que luego vemos en las suites de seguridad de IPSec, TLS, SSL, SSH, HTTPS, etc. Ahora ya sabes lo que significa HMAC-SHA-512, AES-CMAC o Poly1305.\n","date":"30 diciembre 2021","externalUrl":null,"permalink":"/2021/12/30/criptograf%C3%ADa-para-desarrolladores-c%C3%B3digos-de-autenticaci%C3%B3n-de-mensajes/","section":"Posts","summary":"\u003cp\u003eYa hemos hablado de los cifrados de bloque, de flujo y de los hashes, ahora hablemos de un híbrido entre ellos que funciona como un hash pero usa una llave como un cifrado. El uso principal de este tipo de algoritmos es la autenticación y verificación de mensajes, pero también pueden ser usados para generar derivados de una llave, por su carácter pseudo-aleatorio.\u003c/p\u003e","title":"Criptografía para desarrolladores: Códigos de autenticación de mensajes","type":"posts"},{"content":"","date":"30 diciembre 2021","externalUrl":null,"permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"Cryptography","type":"tags"},{"content":"","date":"30 diciembre 2021","externalUrl":null,"permalink":"/tags/hamc/","section":"Tags","summary":"","title":"Hamc","type":"tags"},{"content":"","date":"30 diciembre 2021","externalUrl":null,"permalink":"/tags/mac/","section":"Tags","summary":"","title":"Mac","type":"tags"},{"content":"","date":"30 diciembre 2021","externalUrl":null,"permalink":"/tags/security/","section":"Tags","summary":"","title":"Security","type":"tags"},{"content":"","date":"26 diciembre 2021","externalUrl":null,"permalink":"/tags/conteo/","section":"Tags","summary":"","title":"Conteo","type":"tags"},{"content":"Saber cuánto tiempo ha pasado desde cierto evento en nuestro programa es algo que podemos requerir en algunos casos. Uno de los casos que más he visto es cuando se está midiendo el tiempo que tarda una parte del programa o un evento externo.\nEl tiempo o reloj monótono es un concepto que todo programador debería conocer, para evitar errores y código frágil al medir el tiempo en los programas.\nEl reloj de \u0026ldquo;pared\u0026rdquo; # Lo primero que se nos viene a la cabeza cuando se trata de medir el tiempo entre dos eventos de nuestro programa es usar alguna función de nuestro lenguaje de programación que obtenga la fecha y hora actual. Este reloj o tiempo se llama de \u0026ldquo;tiempo real\u0026rdquo; y algunos programadores le llaman el reloj de pared, porque es como si voltearas a ver un reloj de esos que pones en tu pared para que te de la hora constantemente.\nUn ejemplo de esto en Python sería:\nimport time start = time.time() # hacer algo (lo que queremos medir) end = time.time() diff = end - start print(diff) Esto puede parecer inofensivo, pero tiene una falla que hace a nuestro programa frágil ante eventualidades fuera del sistema. La función time.time() devuelve un número de segundos desde el 1 de Enero de 1970 (esta fecha conocida como el Epoch) como un flotante. Este número siempre será incremental, es decir, no debería devolverte un número menor que una llamada previa. Sin embargo, para calcular ese número de segundos (conocido como el Tiempo Unix), Python se basa en la hora del sistema en el que está corriendo el programa.\n¿Alcanzas a notar por qué esta forma de calcular cuánto tiempo ha pasado desde un evento es frágil? Por ejemplo, imagina que entre una medida de tiempo (en nuestro programa, la variable start) y la siguiente(end), ocurriera un cambio de hora en el sistema. Puede ser que alguien esté jugando con las configuraciones o que por pura casualidad el sistema haya ajustado el tiempo por uno de los segundos de ajuste de nuestro calendario (leap seconds) o que corra durante el cambio de hora por el horario de verano.\nTodas estas circunstancias podrían afectar como mide el tiempo tu programa si usamos el reloj del sistema. Es aquí en donde entra el tiempo o reloj monótono.\nEl tiempo monótono # El reloj monótono es un contador del sistema que sólo avanza hacia adelante, contando a partir de un punto arbitrario en el pasado. Este reloj no tiene conexión con el calendario y el tiempo real del sistema, sino que simplemente sirve para medir el tiempo que ha pasado (siempre en aumento) desde el punto que se eligió.\nAsí, este reloj es confiable para medir el tiempo que pasó entre dos eventos, porque podemos tener la seguridad de que el una llamada posterior a la lectura de este reloj siempre va a devolver algo mayor que la lectura anterior.\nLa manera de usarlo en Python también es mediante el módulo time:\nimport time start = time.monotonic() # hacer algo (lo que queremos medir) end = time.monotonic() diff = end - start print(diff) La función time.monotonic() devuelve el tiempo monótono como un flotante, en segundos. Con estas dos puntos que están conectados al mismo marco de referencia obligatoriamente, hacemos que nuestra medición entre los dos eventos sea confiable. Lo mismo sucedería si quisieras coordinar dos sistemas diferentes: cada uno puede confiar en su reloj monótono sabiendo que el tiempo no saltará hacia atrás de ninguna manera.\nCon vergüenza te comento que la primera vez que escuché de este concepto fue con más de 10 años de carrera, mediante el libro Elixir para Alquimistas de Manuel Rubio, un libro que recomiendo mucho.\nConclusión # Cuando estés midiendo tiempo o coordinando tareas en tu programa, no confíes en las fechas y horas del sistema en el que está corriendo tu programa. Usa el reloj monótono para garantizar que tienes el mismo marco de referencia siempre que hagas una medición de tiempo. Tu lenguaje de programación debería darte acceso a esta medición, sólo investiga o busca en Google: \u0026ldquo;Lenguaje X monotonic time\u0026rdquo;.\n","date":"26 diciembre 2021","externalUrl":null,"permalink":"/2021/12/26/el-tiempo-mon%C3%B3tono/","section":"Posts","summary":"\u003cp\u003eSaber cuánto tiempo ha pasado desde cierto evento en nuestro programa es algo que podemos requerir en algunos casos. Uno de los casos que más he visto es cuando se está midiendo el tiempo que tarda una parte del programa o un evento externo.\u003c/p\u003e","title":"El tiempo monótono","type":"posts"},{"content":"","date":"26 diciembre 2021","externalUrl":null,"permalink":"/tags/mon%C3%B3tono/","section":"Tags","summary":"","title":"Monótono","type":"tags"},{"content":"","date":"26 diciembre 2021","externalUrl":null,"permalink":"/tags/tiempo/","section":"Tags","summary":"","title":"Tiempo","type":"tags"},{"content":"","date":"25 diciembre 2021","externalUrl":null,"permalink":"/tags/%C3%A1lgebra/","section":"Tags","summary":"","title":"Álgebra","type":"tags"},{"content":"¿Quieres entender por qué los algoritmos criptográficos pueden prometer seguridad? Todos están basados en operaciones matemáticas, problemas difíciles de resolver, probabilidad y estadística.\nVeamos un plan de estudios de matemáticas que podrías usar para adquirir las habilidades matemáticas necesarias para entender mejor los algoritmos criptográficos.\nBásico básico # Empecemos por los fundamentos más profundos que debes tener, que hasta pueden parecer obvios. Lo importante es que tengas la seguridad de que los dominas y si no, te proporcionamos algunos recursos para que los repases.\nÁlgebra # Es necesario conocer los procedimientos algebraicos a fondo porque en esto se basa la resolución de problemas de muchas otras áreas. Además la factorización es uno de los problemas más importantes de la criptografía actual, y aquí es donde aprenderás el concepto básico en práctica. Si sientes que te falta aprender un poco, puedes tomar estos cursos:\nÁlgebra 1 - Khan Academy Álgebra 2 - Khan Academy Algebra básica - UNAM Curso de Álgebra en Platzi Probabilidad y estadística # Siempre que hablamos de que un algoritmo es seguro, lo decimos basados en la probabilidad de que alguien pueda encontrar una solución a un problema muy difícil en un número de intentos razonable.\nPor ejemplo: confiamos en que la probabilidad de que alguien rompa un cifrado es cercana a cero, pero realmente esta probabilidad nunca es cero absoluto, sino algo como 1/2^128 por intento, pero alguien motivado podría hacer miles de millones de intentos. Para poder calcular estas probabilidades hay que entender lo básico de probabilidad y estadística.\nLa probabilidad también te ayudará a entender lo que es una distribución de probabilidad, que es muy importante tanto para atacar algoritmos criptográficos como para verificar que las salidas de estos son seguras.\nPuedes aprender un poco de esto en los siguientes cursos:\nProbabilidad y estadística - Khan Academy Estadística y Probabilidad - UNAM Matemáticas discretas # Me atrevería a decir que esta es la rama más importante de matemáticas que debes de conocer como programador y como criptógrafo. La mayoría de los operaciones criptográficas y de algoritmos de programación están basadas en el conocimiento que aprenderás aquí. Ya hemos mencionado que las matemáticas discretas son el estudio de las cosas que se pueden contar, sean finitas o infinitas, a diferencia de las matemáticas continuas que estudian los números reales o cosas que son continuas, incontables y sin divisiones claras.\nA continuación te listamos algunos de los temas que debes dominar o por lo menos conocer bien.\nLógica # La lógica tiene la intención de formalizar el razonamiento de tal manera que lo podamos estudiar, entender y aplicar a otras áreas.\nEn este tema se habla de cosas como tablas de verdad, lógica proposicional, deducción, teorías y lógica de primer orden, etc.\nTeoría de números # La teoría de números trata acerca de los números enteros, sus propiedades, operaciones y relaciones. Esta es la base de varios problemas difíciles que sirven para crear los algoritmos criptográficos modernos. En esta rama se estudia la divisibilidad, los números primos, la aritmética modular y los algoritmos relacionados con estas operaciones.\nSi no vas a estudiar nada más, entender los temas de un curso de teoría de números enfocado en criptografía es suficiente para no sentirte sin rumbo. Estos cursos pueden ayudarte a aprender lo que necesitas:\nNumber Theory for Cryptography Temario con Bibliografía y tareas del curso de Teoría de Números del CIMAT Mathematical foundations of cryptography Yet Another Introductory Number Theory Textbook - Cryptology Emphasis Combinatoria # Esta sub-rama de las matemáticas discretas tiene que ver con el conteo, combinaciones y arreglos de objetos en estructuras discretas (con objetos claramente separados) como los grafos y conjuntos. Normalmente estas estructuras discretas contienen números, pero podrían contener palabras, textos, frases. La combinatoria incluye el conteo de objetos y combinaciones que llevamos a a cabo en probabilidad y estadística: las operaciones de combinación y permutación.\nAlgunos recursos que te ayudarán a aprender combinatoria a fondo se encuentran aquí: Combinatorics and Discrete Mathematics que tiene un conjunto de libros sobre combinatoria con diferentes enfoques.\nCursos de matemáticas discretas generales # Algunos cursos y temarios que puedes tomar son:\nCurso de matemáticas discretas Temario sobre matemáticas discretas para Maestría en Ciencias de la Computación Geometría analítica # Conocer las propiedades matemáticas de los objetos geométricos te ayudará a comprender intuitivamente algunas de los problemas difíciles en los que está basada la criptografía.\nAlgunos cursos que puedes tomar:\nTrigonometría y geometría analítica - UNAM Álgebra lineal # El álgebra lineal tiene que ver con el estudio de ecuaciones lineales (que pueden ser graficadas en el plano cartesiano con una recta), sus soluciones y su tratamiento a través de vectores y matrices.\nMuchas de las técnicas utilizadas en álgebra lineal son ocupadas en criptografía para crear algoritmos seguros que sean imposibles de revertir sin conocer la llave correcta. Un ejemplo es el algoritmo Rijndael, el actual AES.\nAlgunos recursos que te ayudarána a aprender matemáticas discretas son:\nAprendiendo Python con Álgebra Lineal Fundamentos de álgebra lineal Cómo funciona AES (Rijndael) Opcionales # Si quieres avanzar a campos muy adelantados de la criptografía, debes estudias campos aún más específicos de las matemáticas discretas como:\nTeoría de grupos Teoría de grafos Retículas (algo muy importante para la criptografía post-cuántica) Cursos completos # Para finalizar, te quiero presentar recursos que tienen un conjunto completo básico de todas las matemáticas necesarias para entender los algoritmos criptográficos modernos.\nMANUAL DE CRIPTOGRAFÍA: FUNDAMENTOS MATEMÁTICOS DE LA CRIPTOGRAFÍA PARA UN ESTUDIANTE DE GRADO - Tiene apartados para todos los tipos de algoritmos criptográficos usados en la actualidad, explicando su soporte matemático. Si quieres profundizar en algún tema de estos, podrías tomar el curso específico que sugerimos aquí. Especialización en matemáticas discretas en Coursera - Tiene todos los temas relacionados con matemáticas para computación y criptografía divididos en varios cursos, lo puedes tomar de manera gratuita. Mathematical foundations of Cryptography - Tiene todos los temas necesarios para entender la criptografía, incluyendo los temas selectos de todas las matemáticas para ir directo al grano. Esto requerirá que tengas cubierto las matemáticas básicas para no perderte. Temario de maestría en seguridad de la ISICAL - Tiene todos los cursos que alguien debería de tomar para especializarse en ciberseguridad, con temarios completos y bibliografía, lo que te puede servir como una guía si lo que prefieres es aprender de los libros. Bonus: Cryptogaphy, Boolean Functions and related problems\nConclusión # Como podrás observar, hay una gran cantidad de recursos para aprender lo necesario para entender la criptografía a fondo, desde sus bases matemáticas. Puedes usar estas recomendaciones como guía, o ver los temas y buscar tus propios recursos para seguir aprendiendo. Si tienes alguna recomendación no dudes en compartirla con nosotros para poder actualizar nuestra lista y cada vez hacerla mejor.\n","date":"25 diciembre 2021","externalUrl":null,"permalink":"/2021/12/25/matem%C3%A1ticas-para-criptograf%C3%ADa/","section":"Posts","summary":"\u003cp\u003e¿Quieres entender por qué los algoritmos criptográficos pueden \u003cem\u003eprometer\u003c/em\u003e seguridad? Todos están basados en operaciones matemáticas, problemas difíciles de resolver, probabilidad y estadística.\u003c/p\u003e\n\u003cp\u003eVeamos un plan de estudios de matemáticas que podrías usar para adquirir las habilidades matemáticas necesarias para entender mejor los algoritmos criptográficos.\u003c/p\u003e","title":"Matemáticas para criptografía","type":"posts"},{"content":"","date":"15 diciembre 2021","externalUrl":null,"permalink":"/tags/http/","section":"Tags","summary":"","title":"HTTP","type":"tags"},{"content":"HTTP es el estándar más importante de la web actual, porque permite la transmisión de información entre los diferentes actores de la red. Hablemos un poco de su evolución como estándar para servir mejor a los intereses de la industria y de los usuarios y de su estado actual.\nTL;DR | HTTP/3 hará que tus páginas web descarguen mucho más rápido, gracias a que trabaja de forma diferente a bajo nivel. Empieza a aprenderlo porque esto vendrá con nuevos retos para los desarrolladores.\n¿Qué es HTTP? # El Protocolo de Transferencia de Hyper-Texto (Hyper Text Transfer Protocol) es un estándar definido en el RFC 2616 que permite la comunicación entre dos computadoras a nivel de aplicación, es decir, a nivel de software y con contenido relacionado a lo que tu aplicación de red está haciendo.\nEl que sea un protocolo a nivel de aplicación también implica que necesita otros protocolos debajo de él para encargarse de otras partes del proceso de comunicación, como la conexión física, la conexión de software, el transporte de datos y el enrutamiento de la información.\nHTTP es un protocolo con arquitectura cliente-servidor, en el que un cliente hace peticiones (requests) al servidor y el servidor contesta con la información solicitada, a lo que nos referimos como respuesta (response).\nLa parte de hyper-texto nacio por la necesidad de transferir información más rica que el texto plano, es decir, con metadatos, links a otra parte de la información u otros documentos. Al agregar imágenes, videos y otro tipo de información multimedia lo estamos convirtiendo en Hypermedia, información relacionada entre sí que no es puro texto.\nHTTP/1.1 # Este es el estándar que la mayoría de nosotros consideraríamos como \u0026ldquo;HTTP\u0026rdquo;, ha estado en uso por bastante tiempo. La versión 1.0 fue liberada en 1996, pero en 1997 se liberó la versión 1.1, que es lo que la mayoría de los devs que \u0026ldquo;crecimos\u0026rdquo; junto con la web llamaríamos HTTP.\nLas limitaciones técnicas de HTTP/1.1 son lo que han hecho que necesitemos un nuevo estándar, ya que la web actual requiere muchas más descargas que cuando se creó. En 2021 se descargan aproximadamente 1.9 MB en promedio por página, pero esto repartido en múltiples archivos HTML, CSS, JavaScript e imágenes (74 en promedio). Puedes ver más información sobre el tamaño de las páginas web aquí: HTTP Archive - Page Weight\nHTTP 1.1 solamente permite descargar un archivo a la vez, por lo que los navegadores tienen que abrir múltiples conexiones a un mismo servidor, limitadas por los recursos de la computadora. Esto crea un cuello de botella que puede hacer que la experiencia en web no sea óptima.\nPor eso llegó HTTP/2.\nHTTP/2 # En 2015 por fin llegó una especificación más adecuada para la web moderna que HTTP/1.1: HTTP/2.\nHTTP/2 se centra en la multiplexación de conexiones, es decir, permite mantener varias \u0026ldquo;conversaciones\u0026rdquo; con el servidor al mismo tiempo en la misma conexión. Esto permite la descarga de múltiples archivos simultáneamente sin tener que consumir tantos recursos como en HTTP/1.1.\nEl problema con HTTP/2 es que sigue funcionando sobre TCP, que no permite la multiplexación de conexiones, así al intentar la descarga de archivos paralelamente se pueden producir cuellos de botella ya que si se presentan problemas de descarga con un archivo, hay que esperar hasta que llegue el paquete que corrija el error, pudiendo este tardar mucho tiempo por estar en la misma conexión en la que se están descargando otros archivos.\nEsto último causa que HTTP/2 sea insuficiente para las necesidades actuales, e incluso más lento que HTTP/1.1 en muchos casos de uso de la vida real: cuando las conexiones son poco estables. HTTP/2 fue bastante promovido por Google por un tiempo, pero ahora ha sido reemplazado por HTTP/3, que promete ser mucho mejor.\nHTTP/3 # El último borrador del estándar fue publicado en Mayo de 2021, o sea que es muy, muy nuevo, todavía no está en uso ampliamente y el estándar todavía no es el final.\nHTTP/3 es básicamente las mejoras propuestas por HTTP/2 sobre una nueva capa de transporte que no es TCP: QUIC. QUIC está basado en UDP, pero establece la forma de crear canales con control de flujo, cifrado y multiplexación para poder servir mejor a la web moderna.\nQUIC permite usar TLS para establecer los parámetros de cifrado e incluso permite adelantar el intercambio de información antes de negociar completamente los parámetros de cifrado, haciendo un poco más débil el cifrado pero incrementando la velocidad de descarga.\nBenchmarks # HTTP/3 es mucho mucho más rápido que HTTP/1.1 y mucho más confiable y rápido que HTTP/2. En el artículo HTTP/3 is Fast podrás encontrar una comparación del comportamiento de las tres versiones variando diferentes factores, como la confiabilidad y distancia de la conexión.\nConclusiones # Mantenernos actualizados con respecto a las nuevas tecnologías es muy importante para ofrecerles lo mejor a los usuarios de nuestro software, sean desarrolladores o usuarios finales. Si quieres empezar a usar HTTP/3 échale un ojo a tus servidores HTTP, por ejemplo NGINX ya tiene planes para soportarlo completamente, Traefik ya lo soporta de manera experimental, pero parece que Apache no lo hará por ahora.\nTambién si usas algún servicio de servidores administrados AWS, GCP, Azure, DigitalOcean o similar, revisa su documentación para verificar si puedes activarlo. También debes tener en cuenta que no todos los navegadores lo soportan, pero los que lo hagan se beneficiarán enormemente de que lo actives. Puedes revisar la lista de compatibilidad constantemente aquí: Can I Use HTTP/3?.\n","date":"15 diciembre 2021","externalUrl":null,"permalink":"/2021/12/15/http-1.1-http/2-y-http/3/","section":"Posts","summary":"\u003cp\u003eHTTP es el estándar más importante de la web actual, porque permite la transmisión de información entre los diferentes actores de la red. Hablemos un poco de su evolución como estándar para servir mejor a los intereses de la industria y de los usuarios y de su estado actual.\u003c/p\u003e","title":"HTTP 1.1, HTTP/2 y HTTP/3","type":"posts"},{"content":"","date":"15 diciembre 2021","externalUrl":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network","type":"tags"},{"content":"","date":"15 diciembre 2021","externalUrl":null,"permalink":"/tags/web/","section":"Tags","summary":"","title":"Web","type":"tags"},{"content":"","date":"12 diciembre 2021","externalUrl":null,"permalink":"/tags/cifrado/","section":"Tags","summary":"","title":"Cifrado","type":"tags"},{"content":"","date":"12 diciembre 2021","externalUrl":null,"permalink":"/tags/cypher/","section":"Tags","summary":"","title":"Cypher","type":"tags"},{"content":"","date":"12 diciembre 2021","externalUrl":null,"permalink":"/tags/flujo/","section":"Tags","summary":"","title":"Flujo","type":"tags"},{"content":"Ya hablamos de lo que es la criptografía y del tipo de cifrado más fuerte y seguro que existe en la criptografía: los cifrados de bloque.\nAhora hablemos de cómo puedes transformar cadenas de texto plano de tamaño indeterminado en cadenas de texto cifradas del mismo tamaño. Esto se logra con los cifrados de flujo o stream ciphers.\nDefinición de cifrado de flujo # La mejor manera de entenderlos es en contraste con los cifrados de bloque: mientras los cifrados de bloque toman pedazos de contenido de tamaño fijo y los cifran, aplicando diferentes técnicas para abarcar todo el contenido, los cifrados de flujo toman contenido de tamaño arbitrario y lo cifran, bit por bit, devolviéndote un texto cifrado del mismo tamaño.\nSon muy útiles cuando no sabes el tamaño del contenido que vas a cifrar o cuando van ir llegando de manera continua sin que sepas exactamente cuánto y cada cuando, justamente como un flujo de información.\nLos cifrados de flujo se consideraban \u0026ldquo;cifrados de hardware\u0026rdquo; porque eran más ligeros que los de bloque y se podían implementar en menos espacio en un chip, pero ahora tanto los cifrados de bloque como los de flujo son adecuados para implementarse en hardware.\nFuncionamiento # Un cifrado de flujo trabaja generando una cadena de bits pseudo-aleatorios que después combina con el contenido que va a cifrar mediante la operación XOR, también conocida como suma módulo 2. Para descifrar un texto cifrado, algoritmo genera los mismos bits pseudo-aleatorios y los vuelve a combinar, dejando así solamente el texto claro. A esta cadena de bits pseudo-aleatoria se le conoce como el keystream o cadena de bits de clave. En el video \u0026ldquo;XOR de tamaño fijo | Cryptopals Crypto Challenges\u0026rdquo; explicamos por qué el XOR es una operación perfecta para usarse en criptografía y por qué en algunos recursos se la llama \u0026ldquo;suma módulo 2\u0026rdquo;.\nLa parte más importante es entonces el generador del keystream, y que sea capaz de volver a generar los mismos bits pseudo-aleatorios para descifrar.\nUn cifrado de flujo normalmente utiliza una llave y un nonce, un número usado una única vez con esa llave.\nA muy alto nivel, los cifrados de flujo pueden trabajar de dos formas:\nMediante mantener un estado secreto. Después de haber sido inicializados con una llave y un nonce, el algoritmo mantiene un estado interno que se va actualizando en cada nueva llamada. Mediante un contador. Este tipo de algoritmos recibe a parte de la llave y el nonce, un contador que se incrementa en cada llamada, de esta manera no es necesario mantener un estado interno secreto. Ejemplos de cifrados de flujo # Veamos algunos ejemplos de cifrados de flujo, sus características y sus usos, así como qué tan seguros son.\nRC4 # Es el cifrado de software que se usaba para la comunicación entre los routers WI-FI que usaban WEP y tus dispositivos. También se usaba en las comunicaciones TLS. Fue diseñado por el mismo inventor de MD5, Ron Rivest{:target=blank}. Trivia: RC significaba originalmente: \u0026ldquo;Ron\u0026rsquo;s Code\u0026rdquo;. Se conocen ataques contra el cifrado y sobre todo sobre sus implementaciones, pero se sigue usando, así que ten mucho cuidado cuando los dispositivos que usas te ofrezcan configurarlo (como en el caso de los routers con \u0026ldquo;seguridad\u0026rdquo; WEP).\nA5/1 # Fue el cifrado de flujo de hardware de que se usaba para cifrar las comunicaciones inalámbricas 2G. Se encontraron vulnerabilidades en él, al principio de la década de los 2000 y ahora se puede descifrar completamente.\nGrain-128a # Es uno de los cifrados de flujo recomendados por la ´EAM competition, usa una llave 128 bits y un nonce de 96 bits. Está pensado para ser implementado en hardware.\nEs seguro todavía y usado en sistemas de hardware de bajo presupuesto que requieran un cifrado ligero.\nSalsa20 # Es un cifrado de flujo, orientado a software que también fue recomendado por la ´EAM competition. Tiene una implementación sencilla, lo que lo ha hecho popular. Usa una llave, un nonce y un contador para generar el flujo de cifrado.\nAplica una serie de transformaciones en \u0026ldquo;rounds\u0026rdquo; y tiene tres variaciones, dependiendo del nivel de seguridad necesario y la velocidad que deseemos: Salsa20 (20 rounds), Salsa20/12 (12 rounds), Salsa20/8 (8 rounds), siendo el de 8 rounds el que menos seguridad ofrece. Hay un ataque teórico contra Salsa20/8 que reduce su seguridad a 2^251 operaciones, todavía imposible de llevar a la práctica.\nAES-CTR # Este es un cifrado de bloque disfrazado de cifrado de flujo, como diría JP Aumasson, el autor de \u0026ldquo;Serious Cryptography\u0026rdquo;. Es el cifrado AES usado en Counter Mode o modo contador, que ya explicamos en el artículo sobre los cifrados de bloque y sus modos de operación. Cualquier cifrado de bloque que pueda ser usado en modo counter se comportará como un cifrado de flujo.\nLa desventaja de esto es que normalmente queremos que los cifrados de flujo sean ligeros y rápidos y la velocidad de esta implementación dependerá en gran medida del cifrado que se use.\nEvitando errores # Si estás usando un cifrado de flujo, debes evitar en todo momento re-usar el nonce, recuerda que la única razón de existencia del nonce es ser usado una única vez con la misma llave. Esta es la forma más fácil de usar mal los cifrados de flujo, y elimina completamente la seguridad teórica que puedan ofrecer.\nConclusión y aplicaciones # Los cifrados de flujo actualmente son seguros (Salsa20, Grain-128a y AES-CTR) y los puedes usar con confianza siempre que requieras cifrar datos de longitud desconocida o que llega (o se va) con un flujo de información.\nEvita reutilizar el Nonce, el counter y elige una llave segura, lo más aleatoria posible y estarás listo para usarlos en cualquier desarrollo.\n","date":"12 diciembre 2021","externalUrl":null,"permalink":"/2021/12/12/tipos-de-algoritmos-criptogr%C3%A1ficos-cifrados-de-flujo/","section":"Posts","summary":"\u003cp\u003eYa hablamos de \u003ca\n  href=\"/2019/11/12/criptografia-basica-para-programadores-que-es-la-criptografia.html\"\u003elo que es la criptografía\u003c/a\u003e y del tipo de cifrado más fuerte y seguro que existe en la criptografía: \u003ca\n  href=\"/2020/12/03/tipos-de-algoritmos-criptograficos.html\"\u003elos cifrados de bloque\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAhora hablemos de cómo puedes transformar cadenas de texto plano de tamaño indeterminado en cadenas de texto cifradas del mismo tamaño. Esto se logra con los cifrados de \u003cem\u003eflujo\u003c/em\u003e o \u003cstrong\u003estream ciphers\u003c/strong\u003e.\u003c/p\u003e","title":"Tipos de algoritmos criptográficos: cifrados de flujo","type":"posts"},{"content":" “If you are not completely confused by quantum mechanics, you do not understand it.” - Richard Feynman\nLa computación cuántica es una tecnología muy prometedora que lleva décadas en gestación y cada vez la vemos más cerca. Una de las cosas que más llama la atención es la capacidad de cómputo que las computadoras cuánticas pueden tener, en este artículo aclararemos de qué se trata todo esto y cómo se relaciona con la criptografía, uno de los campos más afectados.\nSi no has escuchado mucho sobre la computación cuántica, este video de una presentación dada por Ignacio Cirac nos da una introducción a lo que promete y las bases de funcionamiento.\nAhora veamos a más detalle cómo computa una máquina cuántica y entendamos por qué no toda la criptografía está perdida, aunque tuviéramos una computadora cuántica funcional hoy mismo.\nPrincipios de funcionamiento de una computadora cuántica # Hablemos un poco de los principios físicos y matemáticos que hacen especial a una computadora cuántica.\nSuperposición cuántica # Una computadora cuántica está basada en el principio de superposición cuántica, que establece, en palabras comunes, que una partícula tiene magnitudes físicas (como la posición o el momento) indeterminadas hasta que se realiza una medición sobre ellas. La partícula se comporta como si tuviera todos los estados posibles, algunos con más probabilidad que otros. Una forma fácil en la que se ha mencionado este principio es que \u0026ldquo;puede estar en dos lugares a la vez\u0026rdquo;.\nLo que se escapa de nuestra comprensión común de la física es que esto de tener múltiples estados desaparece cuando lo observamos, se dice que su función de onda colapsa, lo que significa que la partícula \u0026ldquo;se decide\u0026rdquo; por uno de los múltiples estados en los que podía estar. La función de onda es la ecuación que describe todas las \u0026ldquo;probabilidades\u0026rdquo; de cada estado.\nEl ejercicio mental del Gato de Schrödinger te puede ayudar a imaginarlo, pero en este video de Quantum Fracture te ayudará a profundizar más en la complejidad del tema y como no es tan sencillo como \u0026ldquo;puede estar en dos estados a la vez\u0026rdquo;, sino en un número infinito de estados.\nEste artículo te explicará el principio de superposición cuántica sin matemáticas avanzadas: Superposición, una aproximación sin matemáticas avanzadas a la motivación de la mecánica cuántica.\nResumen: Una partícula como un átomo, un electron o un fotón, puede poseer múltiples estados físicos a la vez, con diferentes combinaciones entre todos sus posibles estados, dando lugar a una infinidad de estados posibles. Las probabilidades de cada estado están contenidas en su función de onda, y cuando medimos (miramos) una partícula se define en un estado de todos los posibles.\nAmplitud de onda y Qubits # Cada uno de los estados posibles de una partícula y sus probabilidades están representados en lo que se llama su amplitud. En el caso de la computación cuántica, nos interesa si una partícula representa un cero o un uno. Por esto, un Qubit (un bit cuántico) está representado por una amplitud de onda, que se puede entender parcialmente como la probabilidad de que ese bit sea cero o uno. Un qubit está caracterizado por dos amplitudes: una para el estado cero y otra para el estado uno. Estas amplitudes son números complejos, números que tienen un parte real y una parte imaginaria, como 2 + 3i, por ejemplo.\nUna palabra o conjunto de qubits está representado por 2^n amplitudes, donde n es el número de qubits. Así que en una palabra de 8 bits, tenemos 256 amplitudes de onda. Y aquí está el secreto de por qué la computación cuántica puede ser tan poderosa: con sólo n objetos (qubits), puedes almacenar y procesar 2^n números complejos, mientras que en una computadora clásica necesitarías 2^n espacios de memoria.\nCompuertas cuánticas # Una compuerta cuántica es el equivalente cuántico a las compuertas lógicas clásicas. Son una serie de transformaciones que se le aplican a las amplitudes que caracterizan nuestro conjunto de qubits para obtener los resultados deseados.\nDespués de aplicarle un serie de compuertas cuánticas a los qubits, lo que se conoce como un circuito cuántico, se realiza una medición sobre uno o varios qubits para saber el resultado.\nLas compuertas se comportan como multiplicaciones de matrices y vectores de gran tamaño, que serían imposibles de hacer para computadoras comunes, pero en la computadora cuántica se realizan mediante manipulaciones físicas que equivalen a estas transformaciones de matrices gigantescas.\nNo vamos a entrar en profundidad en este tema, pero si quieres leer más, este artículo te puede servir.\nAceleración cuántica # Gracias a las cualidades de las computadoras cuánticas antes descritas, es posible resolver algunos problemas de la computación mediante nuevos algoritmos cuánticos que reducen el tiempo esperado de ejecución de O(2^n) a O(n^k), siendo k una constante. Es decir: aceleran la resolución de algunos problemas exponencialmente.\nAhora que tenemos los conceptos más básicos de cómo funciona la computación cuántica y por qué puede ejecutar muchos más cálculos, hablemos de algunas amenazas que presenta contra la criptografía.\nEl algoritmo de Shor # Uno de los problemas en los que está basada la criptografía asimétrica actual, es el problema de la factorización de números primos, es decir, encontrar los componentes primos de un número entero. Creemos que encontrar los factores de un número lo suficientemente grande es casi imposible para nuestras computadoras clásicas actuales, incluso las más poderosas.\nEl algoritmo de Shor, propuesto en 1995, traslada el problema de la factorización a otro problema difícil de las ciencias de la computación: encontrar el periodo de una función exponencial. Aquí puedes encontrar una explicación más a profundidad de esta transformación: Period Finding.\nLo importante de esta transformación es lo siguiente: para una computadora cuántica, el problema de encontrar el periodo de una función exponencial no es tan difícil. Una computadora cuántica resuelve este problema con una complejidad de O(log n) aproximadamente, ya que existen circuitos cuánticos que permiten encontrar el periodo de la función exponencial.\nEsto significa que cuando una computadora cuántica tenga los suficientes qubits para representar los números que se usan en la generación de llaves asimétricas, la mayor parte de la criptografía asimétrica actual dejará de ser útil.\nEl algoritmo de Grover # Buscar un elemento que cumpla cierta condición en un conjunto es uno de los problemas que nos ayudarían a romper la criptografía actual. Por ejemplo, imagina que tienes un texto cifrado con AES con una llave de 128 bits. Si quieres romper la seguridad, vas a tener que probar 2^128 llaves en promedio para encontrar la correcta.\nEl algoritmo de Grover permite acelerar esta operación de manera cuadrática, es decir, te tomaría en promedio 2 elevado a la raíz cuadrada de n encontrar el elemento que cumpla con la condición. En el caso del ejemplo anterior te tomaría en promedio 2^(128/2) = 2^64 operaciones.\nLo mismo podría pasar para todos cifrados simétricos (que usan la misma llave para cifrar y descifrar) y hasheados, el ataque consistiría en un estilo de fuerza bruta más inteligente o cuadráticamente más rápida.\nSin embargo, como podrás notar, esto no es un problema tan grande, ya que para mantener el mismo nivel de seguridad que tenemos actualmente bastaría con duplicar el tamaño de las llaves usadas.\nEsto seguirá siendo así mientras no se descubran debilidades en los algoritmos de cifrado simétricos o en las funciones de comprensión de los hashes que usamos.\nCriptografía post-quantum # Debido a las amenazas que presenta la computación cuántica a la criptografía de llave pública gracias al algoritmo de Shor, los criptográfos están manos a la obra diseñando nuevos algoritmos basados en otros principios aún no amenazados por la computación cuántica.\nAlgunos ejemplos que se ven prometedores son:\nEntramados (Lattice Cryptography) Códigos de corrección de errores (Error-correcting codes) Multivariada (Multivariate cryptography) Hashes (Hash-based cryptography) La explicación de cada uno de estos posibles caminos para la criptografía la dejaremos para otro artículo, déjanos un comentario si te interesa alguna en especial.\nConclusión # La criptografía cuántica acelera la capacidad de cómputo, pero además es fundamentalmente diferente de la computación clásica, lo que permite resolver problemas con otros métodos imposibles de alcanzar con la computación actual.\nPero no toda la criptografía actual esta destinada a perderse con el avance de las computadas cuánticas, solamente la criptografía asimétrica y toda aquella basada en la factorización de números primos.\nCiertamente, la seguridad de la criptografía simétrica se ve menguada por el poder de cómputo y los algoritmos cuánticos, pero no lo suficiente para darla por perdida, sino que bastará con fortalecerla con el mismo poder de cómputo cuántico y aumentando el tamaño de las llaves.\nFinalmente, los investigadores ya están trabajando en formas para sustituir lo que se va a romper.\n","date":"11 diciembre 2021","externalUrl":null,"permalink":"/2021/12/11/criptograf%C3%ADa-vs-computaci%C3%B3n-cu%C3%A1ntica/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e“If you are not completely confused by quantum mechanics, you do not understand it.” - Richard Feynman\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLa computación cuántica es una tecnología muy prometedora que lleva \u003cem\u003edécadas\u003c/em\u003e en gestación y cada vez la vemos más cerca. Una de las cosas que más llama la atención es la capacidad de cómputo que las computadoras cuánticas pueden tener, en este artículo aclararemos de qué se trata todo esto y \u003cstrong\u003ecómo se relaciona con la criptografía\u003c/strong\u003e, uno de los campos más afectados.\u003c/p\u003e","title":"Criptografía VS computación cuántica","type":"posts"},{"content":"","date":"11 diciembre 2021","externalUrl":null,"permalink":"/tags/quantum/","section":"Tags","summary":"","title":"Quantum","type":"tags"},{"content":"","date":"10 diciembre 2021","externalUrl":null,"permalink":"/tags/design/","section":"Tags","summary":"","title":"Design","type":"tags"},{"content":"La regla del \u0026lsquo;Cero, Uno o Infinito\u0026rsquo; es una guía para diseñar software que sea más fácil de usar, tanto para otros desarrolladores como para los usuarios finales. La regla en inglés es:\n“Allow none of foo, one of foo, or any number of foo.” - Willem van der Poel\nEsta regla establece que respecto a la existencia de elementos, deberías permitir que no exista ninguno, solamente uno o un número arbitrario (potencialmente infinito, mientras las limitantes ) de estos elementos. La idea principal es que no existan límites arbitrarios impuestos por alguna idea sin explicación.\nAlgunos ejemplos de esta regla, puesta en práctica:\nUna estructura de datos no limita arbitrariamente el grado de anidado que puede tener No existe un normalmente un límite impuesto de recursividad (más allá del dado por el tamaño del stack de ejecución) En las bases de datos relacionales existen tres cardinalidades: 1-1 (permitir una), 1-N (un padre puede tener muchos hijos), N-N (varios artículos pueden pertenecer a la misma categoría y un artículo puede tener varias categorías) Los caracteres especiales básicos de las expresiones regulares son: . (un carácter cualquiera), + (uno o más caracteres), * (cualquier número de caracteres). Y esta regla parece que también existe en la naturaleza:\nLa procreación es ilimitada mientras los recursos sean suficientes (puedes tener N hijos) Tus ancestros directos son uno de cada género (tienes un padre y una madre) Tus ancestros indirectos pueden ser infinitos (tu linea genealógica y los hijos de tus hijos pueden ser infinitos) Cuando tienes un límite de uno y lo abres para dos, ¿entonces por qué no abrirlo para tres? Si aplicamos esta regla recursivamente llegamos infinito En un consejo de administración hay una (1) persona encargada con acceso a la información de un sistema o un equipo (N - infinito) Como conjunto, un vehículo puede transportar N pasajeros, luego limitado por el caso de negocio o modelo específico. Cuando esta lleno puede transportar cero personas más Ahora veamos algunos ejemplos en los que puedes poner límites arbitrarios sin darte cuenta.\nModelando bases da datos # En modelados de bases de datos. Imagínate que tienes que modelar una tipo de usuario en el que te dicen que tienes que guardar diez propiedades arbitrarias. Podrías cometer el error de crear específicamente diez campos para guardar estas propiedades, lo cuál crearía un límite arbitrario en la capacidad de guardar estas propiedades. La mejor forma de modelarlo sería con una relación 1-N, ya que te da la flexibilidad de aumentar o reducir este límite mediante lógica específica para el caso de uso.\nLo mismo podrías pensar en cuanto a asignación de categorías, tags, comentarios, etc.\nModelando software # Veamos algunos ejemplos que te puedes encontrar creando software.\nCTRL-Z # Imagina que tienes que diseñar un editor de texto y estás pensando en agregar la funcionalidad de \u0026ldquo;deshacer\u0026rdquo;. Primeramente piensas que es buena idea solamente permitir que se deshaga la acción inmediata anterior, así que lo implementas como una variable que se está sustituyendo constantemente.\nPero ahora quieres permitir que se deshagan más acciones. ¿Cuál sería tu siguiente límite? El límite natural tendría que ser \u0026ldquo;infinito\u0026rdquo; o \u0026ldquo;hasta el principio del tiempo\u0026rdquo;, ya que cualquier otro límite sería arbitrario y difícil de comprender o justificar. Así que tu implementación cambia de una variable a una pila de acciones que va manteniendo tantas acciones como sea posible.\nModelando una conversaciǿn # Ahora estamos creando un modelo para almacenar y correr una conversación de un chatbot con un usuario. Cada mensaje puede comportarse de tres maneras: darle la oportunidad al usuario de contestar con una respuesta fija, llevar a otro mensaje sin darle oportunidad al usuario de contestar, o terminar la conversación.\nComo puedes observar, esto es un caso perfecto de la regla del \u0026lsquo;Cero, Uno o Infinito\u0026rsquo;. Un mensaje puede tener cero mensajes siguientes, por lo que termina la conversación. Puede tener un solo mensaje siguiente, que es cuando continuamos sin esperar respuesta. O puede tener N mensajes siguientes, uno correspondiente a cada respuesta posible de parte del usuario. Imponer un número limitado de respuestas posibles dentro de tu sistema no una buen idea, ya que limita sin razón alguna la flexibilidad de nuestro sistema.\nCríticas a la regla del \u0026lsquo;Cero, Uno o Infinito\u0026rsquo; # Una de las principales críticas a esta regla es que está dejando fuera el dos, que también es un número muy especial para ciertos casos: muchas cosas en la naturaleza vienen en pares. Los booleanos, prendido/apagado, arriba/abajo, izquierda/derecha.\nEn mi opinión es un número que también se debe considerar, pero solo en caso de que los dos elementos carguen un significado como en los ejemplos anteriores, normalmente son cosas opuestas que se relacionan con un centro, pero incluso, si no se considera un número especial, podemos modelar estos casos siguiendo la regla del \u0026lsquo;Cero, Uno o Infinito\u0026rsquo;: si tomamos como punto de referencia uno de estos valores, el otro es nuestro \u0026ldquo;uno\u0026rdquo; que estamos permitiendo.\nConclusión # Aprender principios de diseño de software te ayudará a crear mejores sistemas que puedan ser usados más fácilmente tanto por otros desarrolladores como por usuario. Espero que este pequeño ejemplo te lleve a aprender otros principios que puedas aplicar en tu trabajo diario. Déjanos un comentario si quieres que lo platiquemos más profundamente o con otros ejemplos.\n","date":"10 diciembre 2021","externalUrl":null,"permalink":"/2021/12/10/la-regla-del-cero-uno-o-infinito/","section":"Posts","summary":"\u003cp\u003eLa regla del \u0026lsquo;Cero, Uno o Infinito\u0026rsquo; es una guía para diseñar software que sea más fácil de usar, tanto para otros desarrolladores como para los usuarios finales. La regla en inglés es:\u003c/p\u003e","title":"La regla del 'Cero, Uno o Infinito'","type":"posts"},{"content":"","date":"10 diciembre 2021","externalUrl":null,"permalink":"/tags/reglas/","section":"Tags","summary":"","title":"Reglas","type":"tags"},{"content":"","date":"10 diciembre 2021","externalUrl":null,"permalink":"/tags/zero-one-infinity/","section":"Tags","summary":"","title":"Zero-One-Infinity","type":"tags"},{"content":"Todos queremos crecer en nuestra carrera de programación y para lograrlo necesitamos adquirir hábitos y técnicas que nos ayudarán a no quedarnos estancados. En este artículo hablaremos de las tres técnicas que me parecen más importantes del wizardzine gratuito \u0026ldquo;So you want to be a wizard\u0026rdquo; de Julia Evans.\nEspero que estas recomendaciones te dejen reflexionando y que termines con ganas de leer el wizardzine completo. Los pongo en el orden que personalmente me parecen más impactantes, pero para ti puede ser diferente, por lo que te recomiendo que lo leas y medites por tu cuenta.\nEscribe un documento de diseño # Una de las cosas más importantes que podemos aprender los desarrolladores es a diseñar software.\nUn documento de diseño es una expresión del diseño de software. Es un escrito que haces ANTES de empezar un desarrollo, en el que detallas varias cosas sobre lo que te estás proponiendo hacer:\nEl objetivo principal Detalles sobre el problema a resolver El diseño a alto nivel de la solución Las partes del sistema que estás afectando Otras consideraciones que hay que tener sobre esa pieza de software Normalmente este diseño y consideraciones iniciales no se mantienen a lo largo del proyecto, pero sirven para empezar con una idea más clara y sin malentendidos. Una de las cosas más importantes que tienes que hacer con un documento de diseño es la retroalimentación que otros miembros del equipo puedan darte. En un artículo futuro de este blog hablaremos más a detalle de esto.\nPero recuerda que si no tienes práctica y, aunque sea un proyecto o cambio muy pequeño, vale la pena dedicarle un tiempo a pensar y escribir sobre lo que planeas hacer.\nComo adquirir experiencia significativa # Es cierto que mediante trabajar en algo por un tiempo en algo lograrás adquirir experiencia, pero esta experiencia está limitada a las actividades que más repitas en ese trabajo y a ese entorno. Por eso no basta con sólo aprender en el trabajo.\nSi quieres tener una experiencia más amplia, algunas prácticas que te pueden servir son:\nEscoge un área que te interese especialmente y estudiala durante un tiempo razonable. Desarrolla tus habilidades en esa área y luego cambia a otra. Lo importante es que tu aprendizaje sea activo, no solamente teórico o lo que te vaya llegando del trabajo. No pienses que es tarde para aprender. Aunque lleves bastante tiempo usando algo, no significa que lo debas saber todo sobre esa tecnología. No pienses: \u0026ldquo;¿Cómo es que no sabes X cosa sobre Y?\u0026rdquo;, sino: \u0026ldquo;Hoy es el día en que aprenderé sobre X y Y\u0026rdquo;. Aprende los conceptos fundamentales, lo que te servirá para construir sobre eso más conocimiento y habilidades. Haz experimentos. En muchas de las áreas del desarrollo, puedes hacer experimentos que no te cuestan nada y pueden ayudarte a entender más profundamente un tema. Lee Libros. Los libros en la mayoría de los casos son un conjunto de conocimientos destilados sobre cierto tema. Leer los capítulos específicos de los temas de tu interés te ayudará a avanzar más rápido. Haz proyectos difíciles. Nada como poner a prueba tus habilidades para ver los hoyos en tu conocimiento como hacer tareas difíciles. Profundiza. Cuando no entiendas algo, busca información más profunda sobre el tema, aprende la historia, las bases y los conceptos más fundamentales. Además puedes acercarte a expertos en el tema a pedirles ayuda para comprender este tema, o recursos que te ayuden a comprenderlo. Finalmente, recuerda que todo esto toma tiempo, no puedes convertirte en un experto en algo de la noche a la mañana, por lo que debes tener paciencia contigo.\nLee código fuente # A veces, los sistemas o herramientas que tenemos que usar no tienen documentación, nadie sabe lo suficiente para ayudarnos o no están disponibles. Es por esto que una de las habilidades más importantes que podemos tener es la de leer y entender el código fuente.\nAlgunas de las cosas que te pueden ayudar son:\nBusca exactamente por la parte que necesitas. Puede ser un error, un mensaje o un módulo específico, usa las herramientas de indexación de texto para llegar ahí, no creas que tienes que leer toda la base. Si el código que tienes que leer es pequeño, intenta darle un recorrida rápida para tener una idea general de lo que sucede y dónde sucede. Haz experimentos con el código, cambiando cosas y viendo lo que sucede, usa un debuggers, agrega tests, introduce bugs intencionalmente. Finalmente, documenta lo que aprendas y encuentres, le puede servir a otros miembros del equipo, de la comunidad o a ti en el futuro. Entender estos sistemas te ayudará aprender de las decisiones de diseño buenas o malas y además te enseñará nuevas técnicas que hubieras tardado más en aprender por otros lados.\nConclusión # Lo que te acercará más a sentirte un mago o maga programando es la práctica enfocada, que puede presentarse de las tres maneras que hablamos aquí, pero hay muchas otras. Recuerda que la constancia es importante, más que la velocidad, pero buscar formas más eficientes de aprender no es malo.\nSi te quedaste con ganas de más consejos de este estilo, descarga \u0026ldquo;So you want to be a Wizard\u0026rdquo; de la página oficial y continúa leyendo, esta vez de manera visual.\nShameless plug: aquí puedes ver nuestra presentación de los wizardzines.\n","date":"9 diciembre 2021","externalUrl":null,"permalink":"/2021/12/09/c%C3%B3mo-convertirte-en-un-mago-programando/","section":"Posts","summary":"\u003cp\u003eTodos queremos crecer en nuestra carrera de programación y para lograrlo necesitamos adquirir hábitos y técnicas que nos ayudarán a no quedarnos estancados. En este artículo hablaremos de las tres técnicas que me parecen más importantes del \u003ca\n  href=\"https://www.youtube.com/watch?v=drPMyDyQG8M\"\n    target=\"_blank\"\n  \u003ewizardzine\u003c/a\u003e gratuito \u003ca\n  href=\"https://wizardzines.com/zines/wizard/\"\n    target=\"_blank\"\n  \u003e\u0026ldquo;So you want to be a wizard\u0026rdquo;\u003c/a\u003e de \u003ca\n  href=\"https://twitter.com/b0rk\"\n    target=\"_blank\"\n  \u003eJulia Evans\u003c/a\u003e.\u003c/p\u003e","title":"Cómo convertirte en un mago programando","type":"posts"},{"content":"","date":"9 diciembre 2021","externalUrl":null,"permalink":"/tags/investigaci%C3%B3n/","section":"Tags","summary":"","title":"Investigación","type":"tags"},{"content":"","date":"9 diciembre 2021","externalUrl":null,"permalink":"/tags/preguntas/","section":"Tags","summary":"","title":"Preguntas","type":"tags"},{"content":"La criptografía es un campo con mucha demanda laboral actualmente porque es importante para diferentes áreas de la informática. En este artículo vamos hablar su importancia y cómo puedes aprenderlo si está dentro de tus intereses.\nLa importancia de la criptografía # En el artículo ¿Qué es la Criptografía? explicamos que es un conjunto de técnicas y conocimiento que busca ocultar la información, derivada de las matemáticas y las ciencias de la computación.\nEl mundo de la computación necesita mantener secretos en muchas áreas, principalmente en cosas relacionadas como la identificación y autenticación de personas y elementos. Además, la criptografía tiene usos laterales, como la verificación de la autenticidad de la información. Cada día hay más valor en nuestras redes informáticas, por lo que cada vez hay más incentivos para robar la información que protegemos mediante la criptografía.\nEn tiempos modernos, debido a lo pesado de procesos de cifrado y hasheado, también se ha estado usando para probar que un elemento de un sistema distribuido hizo muchos cálculos, un concepto llamado prueba de trabajo, usado en Bitcoin.\nComo resumen: está aumentando el número de personas que se requiere para trabajar en criptografía. Se requieren personas que diseñen sistemas que usen los esquemas y algoritmos correctamente, criptográfos que diseñen nuevos algoritmos adecuados para nuestra época y las décadas que siguen, resistentes a el avance del hardware y la computación cuántica, y finalmente, personas que implementen correctamente los algoritmos diseñados por los matemáticos y criptográfos tanto en hardware como en software.\n¿Quieres ser tú una de estas personas? ¿O tal vez quieres aprender un poco más solamente para crear software más seguro? Veamos algunos recursos que te pueden ayudar.\nLibros # Los siguientes libros te enseñarán lo suficiente de criptografía de manera general para que no te confundas con los términos y para tener una idea clara de los puedes y no puedes hacer al usar diferentes esquemas y tipos de algoritmos.\nThe Code Book # Este libro está escrito por un físico que ha escrito varios libros de divulgación. Te cuenta los usos e historia de la criptografía y es una excelente introducción para motivarte a empezar tu camino en criptografía con el mayor interés posible. Puedes ver la presentación del libro aquí: The Code Book\nSerious Cryptography # Escrito por Jean Philippe Aumasson, un criptógrafo renombrado a nivel mundial e inventor de varios algoritmos de cifrado y hasheado modernos, es libro es una guía para los principiantes de criptografía, te enseña conceptos básicos y avanza hasta contarte de criptografía cuántica. Si no vas a leer o estudiar nada más de criptografía este libro es suficiente para no estar en blanco.\nTiene un estilo divertido, desenfadado, con una gran cantidad de ejemplos y la profundidad adecuada para que no pierdas el interés. Página oficial: Serious Cryptography.\n{: .align-center}\nIntroduction to Cryptography # Es una introducción un poco más formal y académica a la criptografía, con el que reforzarás algunos conceptos si ya sabes de criptografía, pero especialmente bueno en el caso de que no tengas ningún conocimiento. Página oficial: Introduction to Cryptography en Springer.\nCryptography Engineering # Este libro está escrito por un equipo de criptográfos de nivel mundial, con varios algoritmos publicados y todavía en uso. Este libro te explica las bases de la criptografía desde un enfoque un poco más rígido que Serious Cryptography. Está enfocado en las decisiones de diseño detrás de los esquemas criptográficos actuales. Propone un plan de 12 semanas que te puede ayudar a tener estructura al estudiar el libro. Puedes ver la presentación de uno de los autores en Cryptography Engineering.\nA Graduate Course in Applied Cryptography # Este curso es la recopilación del curso de criptografía completo de la universidad de Stanford. En mi opinión es el libro más profundo de todos los mencionados aquí en tres temas: cifrado simétrico, asimétrico y esquemas criptográficos. Tiene explicaciones a alto nivel y las demostraciones matemáticas de por qué es seguro. Puedes leerlo de dos formas: lo lees completo con todo y las demostraciones si ya conoces los conceptos básicos o te saltas las demostraciones y los ejercicios para adquirir los conceptos básicos.\nEs completamente gratuito, lo puedes descargar aquí: A Graduate Course in Applied Cryptography.\nRecursos interactivos # En esta sección abarcaremos algunos recursos con más involucramiento que te permitirán poner manos a la obra.\nCryptopals Crypto Challenges # Esta es una colección de ejercicios en los que programarás y atacarás algunos esquemas criptográficos para entenderlos profundamente. Los ejercicios varían bastante en dificultad y debes tener fuertes bases de criptografía (como la provista por los libros sugeridos anteriormente) y de programación para poder realizarlos.\nPuedes verlos aquí: the cryptopals crypto challenges.\nCryptohack # Es una herramienta que te enseñará las bases de la criptografía con ejercicios y retos interactivos. Tiene una comunidad y los incentivos de un juego, que te ayudarán a mantenerte motivado y a aprender más. Pueder visitarla aquí: Cryptohack.\n{: .align-center}\nCursos en video # En esta sección te recomendaremos buscar en las principales plataformas de cursos masivos online, como EDX y Coursera, ya que existen múltiples cursos impartidos por universidades importantes, con un estilo académico. Puedes probar varios estilos de instructor y elegir el que más te guste. Un curso un poco menos académico y con explicaciones bastante buenas es el Curso de Criptografía Aplicada Gratuito de Udacity.\nRecursos en español # Finalmente, veamos algunos recursos en español por si sientes que el inglés no lo dominas lo suficiente para meterte a temas complejos como este.\nCurso de Criptografía Informática Básica para principiantes # En este curso introductorio el instructor te enseñará con ejemplos sencillos los conceptos más básicos de la criptografía y algunos ejemplos con Python. Lo puedes ver en YouTube aquí: Curso de Criptografía Informática Básica para principiantes.\nCurso introductorio a la teoría de números y criptografía # Este es un curso mucho más profundo en las matemáticas que soportan los esquemas criptográficos, con ejemplos explicados paso a paso, para comprender las bases matemáticas, la puedes ver aquí: Curso introductorio a la teoría de números y criptografía.\nCrypt4You # Es un proyecto gratuito creado en 2012 en españa en el que se recorren los principales temas de la criptografía moderna. Debido a la edad del curso, debes ser precavido porque puede que algunas cosas hayan cambiado desde que se creó, por ejemplo, que SHA-1 ya no se considera seguro.\nPresentación oficial: Crypt4You.\nConclusión # En esta pequeña guía incluimos algunos recursos que te pueden ayudar para empezar a rascar la superficie de la criptografía. Estamos trabajando en un temario completo que no sólo te de la introducción, sino que te ayude a llegar a la parte avanzada si así lo deseas. Esperamos tus comentarios si se nos pasó algún recurso.\n","date":"8 diciembre 2021","externalUrl":null,"permalink":"/2021/12/08/recursos-para-aprender-criptograf%C3%ADa-en-2022/","section":"Posts","summary":"\u003cp\u003eLa criptografía es un campo con mucha demanda laboral actualmente porque es importante para diferentes áreas de la informática. En este artículo vamos hablar su importancia y cómo puedes aprenderlo si está dentro de tus intereses.\u003c/p\u003e","title":"Recursos para aprender Criptografía en 2022","type":"posts"},{"content":"","date":"7 diciembre 2021","externalUrl":null,"permalink":"/tags/aleatoriedad/","section":"Tags","summary":"","title":"Aleatoriedad","type":"tags"},{"content":"Muy comúnmente los sistemas informáticos requieren de valores aleatorios para diferentes procesos, por ejemplo, para ordenar las cosas, para seleccionar elementos de un conjunto, para simulaciones, para tomar diferentes caminos en un proceso (como los videojuegos).\nUn lugar en el que los valores aleatorios tienen una importancia especial es en criptografía y en la seguridad informática. De hecho, los números aleatorios están muy relacionados con la generación de valores usables en criptografía como llaves, por ejemplo.\nVeamos cómo se generan y cómo puedes usar correctamente los generadores de números aleatorios, pero antes empecemos a hablar de qué es la aleatoriedad y cómo podemos entenderla intuitivamente.\nAleatoriedad # La aleatoriedad tiene que ver con la probabilidad de obtener cierto valor de un conjunto (universo) de valores posibles. Los valores aleatorios son impredecibles, no puedes asegurar que uno tiene más probabilidades de salir que otro. Ahora conecta los dos conceptos anteriores: para que un valor sea aleatorio debe de ser extraído de un conjunto de valores con la misma probabilidad de aparecer, lo que se conoce como una distribución uniforme.\nEjemplo: una moneda lanzada puede entregar dos valores, cara o cruz (águila o sol en México). Es imposible asegurar que va a salir uno u otro valor, debido a que ambos valores tienen la misma probabilidad de salir. Y muchos procesos físicos se comportan de esta misma manera.\nSi en el universo de valores posibles es más probable que salga cierto valor, entonces empezamos a perder aleatoriedad, imagínate por ejemplo el caso de una moneda o dado cargado.\nLos humanos percibimos un valor como aleatorio si parece poco probable que hayamos obtenido ese valor específicamente, pero no siempre es así.\nLa aleatoriedad se puede medir a través de entropía, que es la cantidad de información disponible en todo el espacio de valores. La entropía es la sumatoria de la probabilidad de aparecer de cada valor multiplicado por su logaritmo base 2, y se mide en bits. Una generador con aleatoriedad perfecta entrega tantos bits de entropía como valores posibles.\nGeneradores de números aleatorios # Los programadores podemos usar la aleatoriedad si tenemos un generador de números aleatorios.\nUn generador de números aleatorios es un programa que te entrega una serie de bits aleatorios, es decir, impredecibles desde el punto de vista externo. Estos bits se pueden usar entonces para crear un número aleatorio.\nHaya generadores de diferentes tipos dependiendo de su fuente de entropía (información impredecible) y de cómo la usen. Hablemos de los diferentes tipos, sus características, y cómo usarlos.\nTrue Random Number Generators # A esta clase de generadores también se le conoce simplemente como generadores de números aleatorios (Random Number Generators o RNG\u0026rsquo;s). Los RNGs toman su fuente de entropía de lugares físicos, dado que el mundo real es impredecible. Miden las variaciones en los semiconductores, la manera en la que mueves el ratón, el teclado, información de los sensores de la computadora, el micrófono, la red y muchas otras cosas. Hay algunos que toman su entropía de procesos cuánticos incluso, conocidos como generadores de números aleatorios cuánticos o QRNGs.\nEstos elementos físicos son fuentes confiables de entropía, pero no podemos confiar en nuestra manera de medirla o \u0026ldquo;capturarla\u0026rdquo;, además de que pueden ser sesgados por un usuario malintencionado o atacante. Además son lentos para generar los bits aleatorios que las aplicaciones pueden requerir.\nEs normal que un RNG se quede sin suficiente entropía para servir a las aplicaciones que lo usan, por lo que terminaría bloqueándola o haciéndola insegura.\nEs por esto que los generadores de números aleatorios a menudo se complementan de los generadores de números pseudo-aleatorios, de los que hablaremos a continuación.\nPseudo-Random Number Generators # Los generadores de números pseudo-aleatorios (PRNGs) son aquellos que no toman su fuente de entropía de lugares físicos, sino que la generan a partir de una semilla o seed. Siempre que reciban la misma semilla generarán la misma secuencia de bits que parece aleatoria, pero en realidad es determinista.\nSi conocemos la semilla y el algoritmo, podríamos predecir la secuencia de bits que resultará en cada llamada. Si la distribución de probabilidad de los bits es uniforme o cerca de uniforme, entonces la secuencia de bits parecerá aleatoria, lo cuál es útil para la mayoría de las aplicaciones.\nLos PRNGs no se quedan sin entropía para seguir sirviendo bits, ya que la generan artificialmente, normalmente con algoritmos matemáticos y piscinas o pools de bits.\nUna forma de crear un PRNG es usando como semilla un RNG, que tome su fuente de lugares físicos y expendiendo esta entropía a un número más grande de bits. Esto lo hace mediante la actualización de un estado interno mediante la recepción de bits verdaderamente aleatorios de un RNG.\nCryptographically Secure Pseudo-Random Number Generators # Los PRNGs critpográficamente seguros requieren dos características extras para ser usados en criptografía:\nDiscreción hacia adelante. En inglés conocida como forward secrecy, se refiere a que es imposible predecir los bits que generará a continuación.\nDiscreción hacia atás. Se refiere a que, dados los bits de un número aleatorio generado, es imposible conocer los bits que le precedieron, que se entregaron en llamadas anteriores.\nCuando hablamos de \u0026ldquo;imposible\u0026rdquo; en términos de criptografía, normalmente nos referimos a que es computacionalmente infactible resolver el problema propuesto. Para que esto sea cierto basta con que no exista un algoritmo de tiempo polinomial que funcione para resolver el problema.\nEn pocas palabras, los PRNGs criptográficos son impredecibles completamente.\nEjemplos # Algunos PRNGs que puedes usar son:\n/dev/urandom de los sistemas UNIX: genera bits aleatorios combinando lecturas del uso del sistema (RNG de hardware) y un generador por software, de manera que haya siempre suficientes bits. Si quieres conocer más a detalle cómo funciona, este artículo te lo explicará: Understanding random number generators and their limitations on Linux.\nMeresenne Twister: genera bits aleatorios con una distribución uniforme, pero no sirve para criptografía porque es predecible. Dada cierta cantidad de bits es posible predecir la secuencia de bits que generará a continuación. Aún así, el MT se comporta mejor que algunos otros PRNGs incluidos en los lenguajes de programación.\nPRNG\u0026rsquo;s en procesadores: Tanto AMD (desde 2015), como Intel (Desde 2013) tienen PRNGs embebidos dentro de los procesadores que pueden ser usados mediante instrucciones específicas (RDRAND y RDSEED).\nFortuna. Es un algoritmo criptográficamente seguro diseñado en 2003, en el que están basadas la generación de números aleatorios de MacOS y iOS.\nCómo usar un PRNG # Si quieres generar números aleatorios para uso general, sin garantía de que sea impredecible, puedes usar un PRNG común implementado en tu lenguage de programación favorito. Generalmente las funciones rand() de Python o mt_rand() de PHP son bastante buenas para esto.\nSin embargo, para generar números aleatorios para criptografía, debes usar un PRNG especializado, generalmente basado en los provistos por el sistema operativo.\nAunque podrías escribir una función que se comunique con el sistema operativo para obtener un flujo de bits aleatorios, tendrías que hacer lo suficiente para asegurarte de que esos bits sean de calidad (con una alta entropía). Es por esto que como desarrollador es mejor usar las implementaciones de la biblioteca estándar de criptografía de tu lenguaje, a menos que tengas requerimientos muy específicos, y sobre todo, sepas cómo verificar que tienes la entropía suficiente.\nConclusión # Conocer cómo funciona un PRNG, a parte de algo interesante, es útil para no usarlos mal. Siempre que requieras números aleatorios para usarlos con relación a la seguridad de la información, deberías usar un PRNG criptográfico. En cualquier otro caso, un PRNG como el Meresenne Twister es suficiente. Además, ahora sabes que los RNGs basados en procesos físicos, a pesar de las garantías de entropía que prometen, no son muy confiables en el sentido de que no siempre están disponibles, pero hay soluciones de hardware especializadas que te pueden ayudar si tienes un problema muy específico.\nFinalmente, la mejor opción para usar un PRNG es confiar en la implementación de la plataforma y lenguaje en el que estés trabajando.\n","date":"7 diciembre 2021","externalUrl":null,"permalink":"/2021/12/07/generadores-de-n%C3%BAmeros-aleatorios-y-su-importancia/","section":"Posts","summary":"\u003cp\u003eMuy comúnmente los sistemas informáticos requieren de valores aleatorios para diferentes procesos, por ejemplo, para ordenar las cosas, para seleccionar elementos de un conjunto, para simulaciones, para tomar diferentes caminos en un proceso (como los videojuegos).\u003c/p\u003e","title":"Generadores de números aleatorios y su importancia","type":"posts"},{"content":"","date":"7 diciembre 2021","externalUrl":null,"permalink":"/tags/prng/","section":"Tags","summary":"","title":"Prng","type":"tags"},{"content":"","date":"7 diciembre 2021","externalUrl":null,"permalink":"/tags/randomness/","section":"Tags","summary":"","title":"Randomness","type":"tags"},{"content":"TypeScript es uno de los lenguajes que más ha sonado en los últimos años. En este artículo vamos a hablar de por qué es una buena idea que lo aprendas y las ventajas que te puede dar.\nAcerca de TypeScript # El propósito de TypeScript es tener un lenguaje adecuado para crear grandes sistemas que compile a JS. En realidad, todo programa válido en JS también es Válido en TypeScript. La principal diferencia que verás en TypeScript con respecto a JS es que este soporta anotaciones e inferencia de tipos de datos y los verifica en tiempo de compilación. Así que si tu programa no pasa la verificación de tipos, ni siquiera podrá llegar a correr. Algunas de las características de TypeScript son:\nAnotaciones de tipos. Puedes especificar el tipo de dato de una variable o función. Inferencia de tipos. No requiere que se especifique el tipo de dato de una variable explicitamente, ya que lo puede inferir por los valores que le asignas. Verificación de tipos. Verifica que tu programa cumpla con los contratos de los tipos de datos. Borrado de tipos. Se refiere a la eliminación de tipos de datos de un programa antes de dejarlo listo para correr pero después de verificarlo. Compilación a una versión específica de JS. Puedes especificar a qué versión de JS se compilará tu programa. Genéricos. Puedes crear funciones que reciban tipos de datos variables. Es por esto que muchos lo ven como un JavaScript tipado. Es cierto que cumplir con los contratos de los tipos es un trabajo extra, pero es una buena idea y un trabajo que vale la pena cuando tienes que hacer un sistema grande. El tipado estático puede protegerte de errores al mismo tiempo que es una capa extra de documentación.\nTypeScript (de aquí en adelante le diremos TS) fue creado por Microsoft y lanzado al público ne 2012 todavía sin una versión estable. Detrás de él está (Anders Hejlsberg)[https://twitter.com/ahejlsberg], también diseñador de C#, y creador de Delphi y Turbo Pascal. En 2021 vamos en la versión 4.5, con muchísimos avances desde su primera versión pública.\n¿Por qué deberías aprender TypeScript? # Ya empezamos a hablar de algunas ventajas en la descripción de lo que es TS. Veamos otras con más detenimiento.\nReduces los errores en producción # undefined is not a function es uno de los errores que más estamos acostumbrados a ver cuando programaos en JS. Este es un error causado por que algo que esperábamos que tuviera una función no la tiene en tiempo de ejecución. Con TypeScript, esto no sucede, ya que te obliga a cumplir con un contrato de tipo de objeto y si no cuenta con cierto atributo, ni siquiera compila. Por ejemplo:\ntype Person = { name: string; age: number; sayHello: () =\u0026gt; string; } const hector: Person = { name: \u0026#39;Héctor\u0026#39;, age: 30 }; Este código te dará un error cuando lo intentes compilar diciendo que el objeto asignado a Héctor no tiene la propiedad sayHello, protegiéndote así de que se te pase algo que creías que estaba bien a producción. Lo mismo sucedería si la propiedad existiera, pero la función tuviera diferentes tipos de entrada y de salida.\nComo todo en la programación, esto es un arma de doble filo, ya que puede reducir el tiempo \u0026ldquo;crudo\u0026rdquo; de desarrollo, es decir, el tiempo que te lleva programar por primera vez algo listo pra probar, pero reducirá el tiempo total de desarrollo sobre todo si tu programa es grande.\nComo punto final, es que probablemente ni siquiera tengas que correr el código para darte cuenta de que está mal, ya que tu editor de código, aprovechándose de la características de TS, te avisará que algo está mal ahí.\nTu editor o IDE puede ser más útil # La información extra que el sistema de inferencia de TS da, o las anotaciones de tipos que tú pones, le dan información al editor que le permite ayudarte de mejor manera, con autocompletados más eficientes, aviso de incumplimiento de contratos en los tipos, etc. Esto contrarresta el tiempo que te llevará extra trabajar con esos tipos.\nLa refactorización será más fácil # Tener una capa de protección en forma de un sistema de tipos es una capa extra de información que evitará que rompas tu código si lo cambias para mejorarlo manteniendo la funcionalidad. Pero además de eso, muchas herramientas ofrecen funciones de refactorización automática que se aprovecharán de esta misma información para hacerla de manera más segura y efectiva.\nDesventajas de TypeScript # Personalmente, y lo digo como alguien que ha trabajado tanto en lenguajes con tipado estático y dinámico, creo que para un programador que ha estado acostumbrado a trabajar con tipado dinámico toda su vida sufrirá un poco cuando lo pongas a trabajar en lenguajes como TypeScript y hay situaciones en las que te metes en un verdadero embrollo tratando de cumplir con el sistema de tipos. Esto puede causar algunos retrasos, pero como lo hemos mencionado a lo largo del artículo, los beneficios de usar TS en un sistema grande superan con creces estas restricciones añadidas.\nOtra desventaja del código de TypeScript es que puede pasar que el código se vea menos legible si se llena de tipos, pero con el tiempo los programadores pueden aprender en dónde vale la pena poner anotaciones de tipos explícitas contra aprovecharse de la inferencia automática de TS.\n¿Quieres aprender TypeScript? # Algunos recursos gratuitos que puedes usar para aprender TS:\nTackling TypeScript del Dr. Alex Rauschmayer The TypeScript Handbook de Microsoft Estos dos recursos están en inglés. Algunos recursos en español:\nCurso práctico desde cero Curso Práctico Rápido desde cero para Iniciantes Una herramienta de pago que recomiendo muchísimo, tanto por su contenido como por su técnica didáctica es Execute Program creada por Gary Bernhardt.\nConclusión # Si quieres continuar con sistemas serios para entornos que solamente ejecuten JS, una de tus mejore opciones es TypeScript. Las restricciones y la información extra que proporciona el sistema de tipos sobre tu código común supercargará tu proceso de desarrollo desde las herramientas de programación como el editor hasta la protección contra errores en tiempo de compilación.\n","date":"6 diciembre 2021","externalUrl":null,"permalink":"/2021/12/06/por-qu%C3%A9-deber%C3%ADas-aprender-typescript/","section":"Posts","summary":"\u003cp\u003eTypeScript es uno de los lenguajes que más ha sonado en los últimos años. En este artículo vamos a hablar de por qué es una buena idea que lo aprendas y las ventajas que te puede dar.\u003c/p\u003e","title":"¿Por qué deberías aprender TypeScript?","type":"posts"},{"content":"","date":"6 diciembre 2021","externalUrl":null,"permalink":"/tags/js/","section":"Tags","summary":"","title":"Js","type":"tags"},{"content":"","date":"6 diciembre 2021","externalUrl":null,"permalink":"/tags/ts/","section":"Tags","summary":"","title":"Ts","type":"tags"},{"content":"","date":"6 diciembre 2021","externalUrl":null,"permalink":"/tags/typescript/","section":"Tags","summary":"","title":"Typescript","type":"tags"},{"content":"","date":"5 diciembre 2021","externalUrl":null,"permalink":"/tags/acoplamiento/","section":"Tags","summary":"","title":"Acoplamiento","type":"tags"},{"content":"","date":"5 diciembre 2021","externalUrl":null,"permalink":"/tags/cohesi%C3%B3n/","section":"Tags","summary":"","title":"Cohesión","type":"tags"},{"content":"Siempre se dice que una buena base de código tiene alta cohesión, pero bajo acoplamiento. ¿Cómo se puede entender esto? ¿Cómo podemos llevar este principio a la práctica?\nEn este artículo vamos a definir cada uno de esos términos de manera sencilla, y con ejemplos de cómo llegar a la aplicación real de estos términos.\nUn poco de historia # Estos dos conceptos y otros relacionados fueron desarrollados por Larry Constantine en la década de los 60\u0026rsquo;s y publicados en los años siguientes, junto con el nacimiento del diseño estructurado de sistemas. Estos conceptos han sido aceptados y han sido objeto de muchos estudios sobre cómo afectan a la calidad del software realmente. Lo que se ha descubierto es que efectivamente, las dependencias infinitas (alto acoplamiento y baja cohesión) crean problemas que son casi imposibles de resolver en las bases de código y es cuando terminamos diciendo: \u0026ldquo;Es más fácil hacerlo de nuevo.\u0026rdquo;\nAhora sí, hablemos de lo que quisiéramos lograr con nuestro software, para no terminar queriéndolo rehacer de nuevo en poco tiempo.\nCohesión # La cohesión de los módulos se refiere al grado en que los componentes de cierto módulo se relacionan entre sí. Es decir, un módulo tiene alta cohesión si todos, o la mayoría de sus componentes trabajan para un mismo objetivo y no para cosas dispares o no relacionadas.\nUna buena cohesión permitirá que el componente utilice menos otros módulos externos, ya que la mayoría de lo que requiere para realizar su trabajo está en el mismo módulo.\nPara lograr esto, normalmente tienes que reducir las tareas de las que el módulo es responsable al menor grado posible, tratando de seguir el principio de responsabilidad única.\nPongamos un ejemplo: imagina que estás creando un chatbot, un programa que, usando las API\u0026rsquo;s de los aplicaciones de comunicación te permite interactuar con tus usuarios en forma de chat, en lugares como WhatsApp, Messenger o Slack. El sistema tiene como requerimiento que la lógica de conversación sea fácil de reemplazar y mantener y que funcione independientemente del canal.\nPara implementar este sistema los rompemos por lo menos en tres módulos: el manejo de usuarios, la lógica de conversación y la conexión son los canales de comunicación.\nUna buena cohesión se refiere a que, por ejemplo, la lógica de conversación y todo lo necesario para decidir cómo conversar con un usuario exista dentro de este mismo módulo. Así, cuando tengas que actualizarla no tienes que tocar todo el sistema o muchas partes del código. Esto mismo aplicaría para los otros módulos, imagínate que tienes que agregar un canal nuevo, por ejemplo, Telegram. Tu módulo de conexión a canales debería tener todo lo necesario para que no tengas que modificar ni el módulo de usuarios, ni el de la lógica de conversación.\nUna forma efectiva de crear módulos cohesivos es mediante agrupar todas las partes que tienen que ver con el mismo tema abstracción o decisión en el mismo módulo1 o clase. Esto casi nunca se puede lograr perfectamente, pero es una buena meta que te ahorrará dolores de cabeza.\nAcoplamiento # El acoplamiento consiste en el grado de dependencia de las diferentes partes de un sistema entre ellas. La pregunta clave para entender el acoplamiento es: ¿Cuánto se necesita saber de un módulo para entender otro módulo?\nMientras más necesites saber de A para entender B, más A relacionados, o acoplados están.\nPor ejemplo, imagina una aplicación de e-commerce, que consiste de un catálogo, un carrito de compras y la parte del pago. Estos tres elementos pueden estar muy acoplados entre sí, en el sentido de que cualquier cambio en el catálogo afecta al carrito de compras y al pago, o al revés. Si puedes cambiar cualquiera de los tres módulos sin tener que tocar los otros, hay un bajo acoplamiento.\nEl acoplamiento ideal sería cero, pero como te imaginarás esto es imposible.\nLos módulos pueden depender entre ellos de diferentes formas, tanto conceptualmente como en implementación. Constantine menciona que los siguientes cuatro factores pueden afectar el grado de acoplamiento de los módulos:\nTipo de conexión entre los módulos. ¿Escriben a las mismas variables globales? ¿Uno usa al otro? ¿Uno es la especialización de otro? Complejidad de la interfaz: ¿Qué tan intrincada es la conexión entre los módulos? Tipo de información que pasa entre la conexión: ¿se pasan grandes estructuras de datos que procesan de manera secuencial? O, ¿un módulo modifica la forma de trabajar de otro? Tiempo en el que sucede la conexión: ¿depende uno de que el otro corra para poder ejecutarse? Tener en cuenta estos factores puede ayudar a reducir el acoplamiento de los módulos.\nRelación entre cohesión y acoplamiento # Constantine menciona que mientras más cohesión tengan los módulos, menos acoplamiento tendrán entre ellos. Esto suena lógico porque mientras más \u0026ldquo;autocontenido\u0026rdquo; sea un módulo (más cohesión) menos va a necesitar de otros para poder funcionar.\n\u0026ldquo;A mayor cohesión de los módulos individuales en el sistema, menor será el acoplamiento\u0026rdquo; - Structured Design by Yourdon and Constantine\nComo podrás ver, no son medidas independientes; están relacionadas en la práctica.\nCómo lograr alta cohesión y bajo acoplamiento # La principal forma de lograr esta buena estructura es dedicando tiempo al diseño del software,prestando especial atención a la forma en la que se modulariza el sistema, es decir, la forma en la que se divide el problemas en otros más pequeños.\nConstantine y Yourdon afirman que la única forma de lograr esto es con práctica, práctica y más práctica.\nConclusiones # El principio de \u0026ldquo;Alta cohesión y bajo acoplamiento\u0026rdquo; sin duda es útil para que nuestro software sea más claro, más fácil de mantener y de cambiar. No hay manera de aprender cómo dividir el sistema en módulos si no es mediante la práctica de diseño e implementación de sistemas reales. Así que, ya sabes, manos a la obra.\nCuando decimos \u0026ldquo;módulo\u0026rdquo; estamos hablando de la forma de tu lenguaje de agrupar funcionalidades, puede ser literalmente un módulo, un paquete, una aplicación etc.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"5 diciembre 2021","externalUrl":null,"permalink":"/2021/12/05/entendiendo-la-cohesi%C3%B3n-y-el-acoplamiento-en-el-software/","section":"Posts","summary":"\u003cp\u003eSiempre se dice que una buena base de código tiene alta \u003cstrong\u003ecohesión\u003c/strong\u003e, pero bajo \u003cstrong\u003eacoplamiento\u003c/strong\u003e. ¿Cómo se puede entender esto? ¿Cómo podemos llevar este principio a la práctica?\u003c/p\u003e\n\u003cp\u003eEn este artículo vamos a definir cada uno de esos términos de manera sencilla, y con ejemplos de cómo llegar a la aplicación real de estos términos.\u003c/p\u003e","title":"Entendiendo la cohesión y el acoplamiento en el software","type":"posts"},{"content":"","date":"4 diciembre 2021","externalUrl":null,"permalink":"/tags/commits/","section":"Tags","summary":"","title":"Commits","type":"tags"},{"content":"Una de las mejores cosas que podemos hacer por nosotros mismos y por nuestro equipo es versionar nuestro código y qué mejor que hacerlo de las mejores formas conocidas hasta el momento.\nEn este artículo hablaremos de dos cosas conectadas: el versionamiento semántico y los \u0026ldquo;commits convencionales\u0026rdquo;.\n¿Por qué es importante? # Organizar y manejar tu código de tal manera que puedas crear diferentes versiones del sistema que estás programando, cambiar entre ellas o regresar una anterior, es un requerimiento de todos los procesos de desarrollo actuales.\nAdemás, presentar tu software a los usuarios finales en versiones iterativamente mejores es una buena práctica que te permitirá liberar más rápido, más seguido y frecuentemente con mejor calidad. Para lograr esto es importante comunicar correctamente lo que está cambiando en cada versión.\nLa herramienta más usada para versionar nuestro código es git, pero no establece ningún lineamiento en la forma en la que liberamos el software para los usuarios finales. Así que veamos primeramente una forma de comunicar nuestros cambios de manera correcta y efectiva y después una forma de hacerlo conectarlo con nuestro proceso de trabajo con git.\nVersionamiento semántico # El versionamiento semántico (Semantic Versioning o SemVer) es una forma de comunicar a nuestros usuarios finales los tipos de cambios introducidos en las nuevas versiones.\nEsto es muy importante porque, como seguramente habrás experimentado, un proyecto de software requiere de muchas dependencias y cuando alguna de ellas no funciona bien, tiene algunos bugs, o no es compatible con lo que ya existía, nos podemos meter en serios problemas. Y mientras más grande es el proyecto, más dependencias necesitarás, lo que agranda el problema.\nLo que SemVer propone es una sintaxis formal que nos permite entender el tipo de cambios introducidos en cada versión. Esta sintaxis constituye un lenguaje formal que puede ser usado para resolver automáticamente problemas de dependencias si se usa correctamente.\nAntes de ver un ejemplo de una versión semántica es importante que aclaremos que esta se usa para software que tiene una interfaz establecida. Esta interfaz formal está completamente documentada para que otros programadores o usuarios finales pueden usar tu software. A esta interfaz le llamaremos API (Application Programming Interface)1 a partir de ahora. Ahora sí, una versión en SemVer se ve así:\n1.0.2 El primer número es la versión mayor, en este caso 1. El segundo número es la versión menor, en este caso 0. El tercer número es la versión del parche, en este caso 2.\nAhora bien, ¿que significa cuando cambian estos números?\nCuando cambia la versión mayor, se introducen cambios que hacen que la API sea incompatible con la versión anterior. Imagínate por ejemplo que se remueve alguna función o módulo que ya no se necesita. También puede ser que aunque no cambie explícitamente el contrato externo, cambie el significado de una operación.\nCuando cambia la versión menor, se han introducido cambios o mejoras que no hacen incompatible a la API con versiones anteriores. Imagínate algo como agregarle nuevos parámetros a una función, pero que soporta valores default para que pueda seguir siendo llamada de la forma anterior. O también puede ser que agregas nuevas partes que no afectan a la forma en la que se usan las antiguas.\nCuando cambia la versión de parche, no se ha introducido cambios externos a la interfaz por diseño, sino que se han arreglado errores que causaban mal funcionamiento.\nDespués de estos tres elementos pueden venir otros detalles, como por ejemplo la versón de prelanzamiento y metadatos de la compilación.\nEn el documento oficial Versionamiento Semántico 2.0 puedes ver más detalles sobre cómo trabajar con él, pero sobre todo notarás lo importante y serio que es que comuniquemos correctamente lo que está pasando con el software que hacemos, sobre todo si otros dependen de él. También podrás ver como las cadenas resultantes de semantic versioning son un lenguaje formal en el que se puede confiar para programar resolución de dependencias, hasta tienen un regex para reconocerlas.\nAhora veamos una herramienta que te ayudará a llevar cuenta del tipo de cambios que se van introduciendo en tu software y base de código.\nCommits convencionales # Los commits convencionales (Conventional Commits) son una forma de estructurar tus mensajes de cada commit para comunicar explícitamente lo que estás cambiando. El objetivo es que 1) puedas saber exactamente lo que el equipo ha cambiado en cada nueva versión o rama y 2) poder automatizar la creación de versiones semánticas y registros de cambios (changelog).\nUn commit convencional tiene la siguiente estructura:\n\u0026lt;tipo de commit\u0026gt; [ámbito (opcional)]: \u0026lt;descripción\u0026gt; [cuerpo (opcional)] [notas finales (opcional)] Los tipos de commit directamente establecidos por la especificación son:\nfix: Se trata de una corrección de un bug. Este tipo de commit se relaciona con una nueva versión de parche. feat: Se trata de una nueva función o módulo. Este tipo de commits se relaciona con una nueva versión menor. BREAKING CHANGE: No es un tipo de commit sino una nota final. Siempre que se incluyan debe generarse una nueva versión mayor en la siguiente liberación. Si se incluye un símbolo de admiración después del tipo de commit como de esta forma feat! significa que este commit introduce un cambio que rompe la compatibilidad con la versión anterior.\nEl ámbito puede referirse a la base de código o módulo al que se aplicó el cambio.\nVeamos algunos ejemplos:\nfeat(core): Ahora podemos usar ARGON2i para cifrar las contraseñas fix!: Removemos la compatibilidad con SHA-1 debido a que no es seguro Se encontró que SHA-1 no es seguro debido a que se pueden fabricar colisiones y por lo tanto hemos removido el soporte en la plataforma feat: Añadimos el soporte de Sal para todas las funciones de hasheo BREAKING CHANGE: Todas las firmas de función ahora requieren el parámetro `salt` Básicamente en esto consisten los commits convencionales y si tu base de código los sigue, podrás usar herramientas para automatizar la creación de versiones semánticas y registros de cambios (changelog), ademas de mejorar drásticamente la información que se encuentra en los repositorios y cuándo sucedieron los cambios.\nPuedes ver la especificación completa, más tipos de commits, ejemplos y las herramientas que te facilitarán la vida en la página oficial en español.\nConclusión # Comunicar correctamente el estado de nuestros sistemas y módulos hacia nuestros usuarios finales es una tarea muy importante para los desarrolladores de software profesionales. Como podrás haber notado, para que esto tenga utilidad, el requisito previo es que exista documentación formal de tu software.\nEspero que estas herramientas te ayuden a crear software que sea más fácil usar, mantener y más disfrutable tanto para ti como para tus usuarios finales.\nAquí puedes ver por qué se llama una API a la interfaz que presenta una pieza de software a otra: API\u0026rsquo;s con Hug\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"4 diciembre 2021","externalUrl":null,"permalink":"/2021/12/04/versiona-mejor-tu-c%C3%B3digo-versionamiento-sem%C3%A1ntico-y-commits-convencionales/","section":"Posts","summary":"\u003cp\u003eUna de las mejores cosas que podemos hacer por nosotros mismos y por nuestro equipo es versionar nuestro código y qué mejor que hacerlo de las mejores formas conocidas hasta el momento.\u003c/p\u003e","title":"Versiona mejor tu código: versionamiento semántico y commits convencionales","type":"posts"},{"content":"","date":"4 diciembre 2021","externalUrl":null,"permalink":"/tags/versionamiento/","section":"Tags","summary":"","title":"Versionamiento","type":"tags"},{"content":"Una práctica común para solucionar la identificación de usuarios es registrarlos con su nombre de usuario y contraseña. Para no almacenar su contraseña directamente, es una costumbre hashearla. Como aprendiste en el artículo anterior, un hash es una función que impide recuperar el valor original ya que simplemente la información se pierde.\nLos hashes seguros hacen casi imposible encontrar una colisión (que dos passwords te devuelvan un mismo hash), por lo que parecerían una buena solución para crear un valor único para cada usuario. Debido a que son deterministas, cuando el usuario te da su password, calculamos el hash de nuevo, lo comparamos con el hash almacenado y verificamos si coinciden. En este caso, el usuario está autenticado.\n¿Pero qué hash puedes usar para hashear un password? Todos hemos escuchado que no se debe usar MD5 para hashear passwords, pero la razón por la que se menciona que esto es un error normalmente no es la correcta. Se argumento que MD5 es un hash que está \u0026ldquo;roto\u0026rdquo;, ya que es posible romper su seguridad con menos esfuerzo computacional del que su tamaño requeriría. Esto es cierto, pero no es la razón principal por la que no deberías usar MD5 para passwords.\nLa verdadera razón por la que nunca debes usar MD5 para esto es que no está diseñado para esa función, y puede ser atacado de manera sencilla y efectiva.\nHablemos de algunos tipos de ataques que pueden sufrir los sistemas de almacenamiento de información que usan un hash seguro normal para hashear sus passwords.\nAtaques de fuerza bruta # Un hash seguro que no presenta vulnerabilidades tiene la característica de que no hay una forma más inteligente de atacarlo que mediante probar todos los valores posibles de entrada. Por ejemplo, si sabemos que un sistema acepta letras y números y la mínima contraseña es de 6 carácteres, tendríamos que probar todas las combinaciones posibles de letras y números a partir de 6 carácteres.\nEso suena a que es mucho, sin embargo, con los hashes seguros no es un problema para los atacantes ya que estos hashes son muy eficientes y están pensados para correr lo más rápido posible.\nAlguien con la suficiente motivación y paciencia podría lanzar un ataque de fuerza bruta con hardware especializado y encontrar un password que coincida con el hash. Esto se puede hacer con hardware común como CPU\u0026rsquo;s y GPU\u0026rsquo;s domésticos, que llegan a procesar cientos de miles de passwords por segundo, o con hardware especializado en hashear (FPGA\u0026rsquo;s y ASIC\u0026rsquo;s).\nHerramientas como hashcat te permiten hacer este tipo de ataques, pero lo más interesante es que debido a que conocemos la naturaleza de la información, podemos dirigir el ataque de manera un poco más inteligente, usando diccionarios de palabras y contraseñas comunes, haciendo todavía más probable romper la seguridad de estos sistemas.\nRepitamos: lo que permite este tipo de ataques son los objetivos de diseño de las funciones hash seguras: que sean rápidas, y eficientes en memoria. Esta es la primera razón por la que nunca debiste usar MD5 es esta. Pero, como podrás deducir, lo mismo aplica para cualquiera de familia SHA (SHA-1, SHA-2, SHA-3 y los que vengan), BLAKE, BLAKE2 y los que vengan. No importa que estas funciones sigan siendo seguras para otros usos.\nAtaques con tablas arcoiris (Rainbow Tables) # Imagínate que eres un atacante que quiere descubrir los passwords de los usuarios de diferentes sitios y sabes que todos usan SHA-256. En vez de hacer una ataque de fuerza bruta cada vez, preparas una tabla con dos columnas: el hash y el password. En la columna de passwords pondrás valores que sabes que pueden servir de passwords a los usuarios.\nEsto que acabamos de describir es una versión sencilla de una Rainbow table, una colección de valores precalculados organizados para que, una vez teniendo el hash, puedas buscar el password correspondiente en la tabla. Se hace un intercambio de procesamiento por memoria. Las Rainbow Tables completas son un poco más complejas que lo que acabamos de describir, puedes leer más sobres ellas en este artículo: Rainbow Tables\nDebido al mal uso de los passwords y de los algoritmos para hasheo seguro, existen rainbow tables para millones de valores de todos los algoritmos. Aunque siguen siendo una amenaza, las Rainbow tables están cayendo en desuso, en favor de otros métodos más modernos y aprovechándose del poder de cómputo actual.\nProtección contra ataques a hasheo de passwords # La forma de protegerse contra valores precalculados y ataques de diccionario es más o menos sencilla: antes de hashear el password, agrega un valor aleatorio extra que puedas recuperar fácilmente y añadir cada vez que verificas el password. Esto se conoce como salting, siendo el valor aleatoria el salt.\nAunque es cierto que esto lo podrías hacer con cualquier algoritmo de hasheo seguro, se queda sin resolver el segundo problema: ¿Cómo nos protegemos contra ataques de fuerza bruta con hardware muy poderoso? Esto sólo se puede resolver de una forma: usando algoritmos que te obliguen a usar mucho procesamiento o mucha memoria, o ambos. Estas deben ser precisamente las metas de diseño de los algoritmos especializados en hasheo de passwords.\nHablemos de algunos de ellos y finalizarmos con el que deberías usar actualmente en 2021.\nHashes seguros para passwords # Como ya lo dijimos, estos hashes deben ayudarte con una cosa principal además de ser seguros criptográficamente: ser costos en proceamiento y/o memoria, lo que se traduce en lentitud.\nPero además, algunos de estos algoritmos te ayudana a \u0026ldquo;salar\u0026rdquo; el password de manera automática, lo que es una ventaja para reducir errores en la implementación de esta práctica.\nEn esta sección hablaremos de los algoritmos, cómo cumplen con estas características y si los puedes seguir usando.\nPBKDF2 # PBKDF2 - Es un acrónimo que significa \u0026ldquo;Password Based Key Derivation Function\u0026rdquo;, versión 2.0 y que básicamente aplica un algoritmo de hasheo seguro a una contraseña repetidas veces. Puedes configurar el número de iteraciones, el algoritmo de hasheo, el tamaño del resultado y te pide el salt para funcionar. Fue usada por varios frameworks de desarrollo web como Django, pero actualmente no se considera segura porque aunque es exigente en cómputo para una computadora normal, es débil contra hardware especializado.\nbcrypt # bcrypt - Es un algoritmo diseñado específicamente con el objetivo de estar preparado para el mejoramiento que el hardware va teniendo, ya que tiene una \u0026ldquo;dificultad\u0026rdquo; configurable. Te provee automáticamente de un salt seguro, por lo que no recaerá en ti la responsabilidad de conseguirlo como en PBKDF2. Está basado en blowfish, otro algoritmo de cifrado que ha permanecido seguro. Bcrypt fue presentado en 1999 y sigue siendo considerado más o menos seguro, su recomendación está en duda ya que es posible atacarlo con hardware especializado y de bajo costo. Este estudio de 2011 explica como se puede atacar con hardware especializado en cómputo paralelo y predijo muy bien que bcrypt no permanecería super seguro por mucho tiempo.\nscrypt # scrypt - Es una función diseñada para cubrir las carencias de PBKDF2 y bcrypt. Es tanto computacionalmente intensiva como pesada en memoria, por lo que no es tan fácil atacarla con hardware especializado. Es un función de muy reciente presentación, Colin Percival la presentó en 2009. Es una secuencia de funciones pesadas en memoria que impide que sea atacada fácilmente con GPU\u0026rsquo;s. FPGA\u0026rsquo;s y ASIC\u0026rsquo;s. Es una función que puedes usar conseguridad todavía ya que no se han encontrado ataques efectivos contra ella. Al igual que bcrypt, sala (usa un salt) automáticamente, lo que le facilita la vida al desarrollador.\nArgon2 # Argon2 - Es la función más avanzada y con mejores garantías para generación de hashes resistentes a ataques con fuerza bruta. Es la ganadora del Password Hashing Competition en 2015. Se dice que Argon2 es el estado del arte en lo que se refiere a hashing de passwords. Tiene tres variaciones principales: Argond2d, Argon2i y Argon2id.\n¿Cuándo usar cada una?\nArgon2d es más rápida pero al mismo tiempo está mejor protegida contra ataques de fuerza bruta de hardware especializado, por la forma en la que usa la memoria, sin embargo, es más vulnerable a ataques side-channel. Es recoemndada cuando tus atacantes no tengan posibilidad de realizar estos ataques, como en servidores de backend y para generación criptomonedas.\nArgon2i es más lenta, más computacionalmente intensiva y resistente contra side-channel attacks, es la recomendada para hashear passwords. Da varias \u0026ldquo;pasadas\u0026rdquo; a los argumentos de entradda, por lo que es más dificil de atacar.\nArgon2id es un híbrido entre estas las dos variaciones anteriores, protegida parcialmente contra ataques side-channel al mismo tiempo que más computacionalmente intensiva que Argon2d. La recomendación es que si estás en incertidumbre uses Argon2d.\nArgon2 permite configurar:\nMemoria usada: mientras más memoria se use, más resistente será el hash y menos vulnerable será a ataques de fuerza bruta.\nNúmero de iteraciones sobre la memororia. Esto lo hace más computacionalmente intensivo, de igual forma haciéndolo más dificil de atacar, haciendo la generación de hashes más lenta.\nGrado de paralelismo. Es el número de hilos que se usan para generar el hash, el tiempo de ejecución variará dependiendo de la configuración.\nTamaño del hash, el salt y el tag. Esto también varía el grado de resistencia de tus hashes.\nEn el artículo \u0026ldquo;Cómo escoger los parámetros de Argon2\u0026rdquo; se describe una forma de escoger los parámetros de Argon2.\nFinalmente, aunque no incluye la generación del salt en el algoritmo mismo, las implementaciones de Argon2 incluyen una función de generación de salt automática para que no tengas que hacerlo tú.\nNota sobre Funciones de Derivación de Llaves (Key Derivation Functions) # Si lees algunas de las especificaciones de los algoritmos de arriba, probablemente te encuentres mucho con el término KDF o Key Derivation Function. ¿Qué es eso? ¿No estábamos hablando de funciones hash?\nLas KDF\u0026rsquo;s son funciones hash usadas para generar un cadena pseudo-aleatoria de bytes, que puede ser usada como una llave para cifrado, basadas en uno o varios valores de entrada. Las KDF\u0026rsquo;s son un caso especializados de las funciones hash y que pueden entregar resultados de tamaño variable y ya que los algoritmos usados aquí admiten varios valores y pueden entregar resultados variables, se consideran funciones de derivación de llaves o KDF\u0026rsquo;s.\nConclusión # Aunque ninguna de las funciones mencionadas aquí es lo que se diría fácil de romper, es recomendable que no uses PBKDF2 o bcrypt si quieres tener un buen margen de seguridad y estar preparado para el futuro y para el mejoramiento de constante del hardaware. Si estas haciendo una aplicación lo más recomendable es que uses por lo menos scrypt, pero idealmente Argon2i, que es más fuerte que scrypt usando los mismos parámetros de esfuerzo. Esto es de esencial importancia sobre todo si estás haciendo un sistema en el que los atacantes puedan tener incentivos y recursos para robar información.\n","date":"3 diciembre 2021","externalUrl":null,"permalink":"/2021/12/03/algoritmos-criptogr%C3%A1ficos-hashes-seguros-para-alamcenar-passwords/","section":"Posts","summary":"\u003cp\u003eUna práctica común para solucionar la identificación de usuarios es registrarlos con su nombre de usuario y contraseña. Para no almacenar su contraseña directamente, es una costumbre \u003cem\u003ehashearla\u003c/em\u003e. Como aprendiste \u003ca\n  href=\"/2021/12/02/algoritmos-criptograficos-que-es-un-hash.html\"\u003een el artículo anterior\u003c/a\u003e, un hash es una función que impide recuperar el valor original ya que simplemente la información se pierde.\u003c/p\u003e","title":"Algoritmos criptográficos: hashes seguros para alamcenar passwords","type":"posts"},{"content":"","date":"3 diciembre 2021","externalUrl":null,"permalink":"/tags/password/","section":"Tags","summary":"","title":"Password","type":"tags"},{"content":"Dentro del mundo del desarrollo se escucha bastante sobre funciones hash y, en realidad, se usan para múltiples cosas. En este artículo vamos a hablar de lo que es una función hash, los diferentes tipos que hay y cómo pueden servirte para desarrollar software.\n¿Qué es un función hash? # La idea y el nombre de un función hash viene de la cocina: hash se traduce literalmente como \u0026ldquo;picadillo\u0026rdquo;, y se usa precisamente porque eso hace una función hash con los datos que le pasemos.\n{:.align-center}\nLas funciones hash reciben una entrada y normalmente te devuelven un valor de tamaño fijo. Estos datos parecen \u0026ldquo;picadillo\u0026rdquo;, es imposible para los humanos distinguir los argumentos que recibió a partir de la salida. Las funciones hash más simples mapean los valores de entrada a un número pequeño, aquí puedes ver algunos ejemplos. Estas funciones las puedes considerar como un mapeo de valores (con posibilidades infinitas) a un conjunto de valores finitos. Por eso, una función hash de esta naturaleza se considera como una relación del valor de entrada con su \u0026ldquo;contenedor\u0026rdquo; o \u0026ldquo;bucket\u0026rdquo; como le dirían en inglés.\nLas funciones hash son como navajas suizas, ya que pueden ser utilizadas para ocultar datos, para crear estructuras de datos llamadas hash tables, para comparar datos, para crear firmas digitales (verificación de integridad) y muchas otras cosas. Tienen muchos usos dentro y fuera de la criptografía.\nExisten diferentes tipos de funciones hash para los diferentes usos, las características que normalmente verás en hashes son:\nEntregan un resultado de tamaño fijo sin importar el tamaño de la entrada Son rápidas relativamente Son deterministas, es decir, siempre que le demos el mismo valor, dará el mismo resultado Es imposible recuperar la entrada original, porque se pierden datos Algo que contaría como una función hash podría ser tan sencilla como obtener el sobrante de una división entera para los números enteros:\ndef hash_simple(x): return x % 10 Esta función cumple con todas las características de las que hablamos arriba, y es una función hash no criptográfica o no segura, es decir, no se puede confiar en ella para proteger información.\nAlgunos ejemplos de funciones hash no criptográficas son:\nSeaHash fnv1a La función hash de Python o de tu lenguaje preferido Ahora hablemos de qué características tiene una función hash criptográfica segura.\nFunciones hash criptográficas # La característica principal de una función hash segura es que su resultado es completamente impredecible, no revela ningún tipo de información sobre la entrada original, tanto para los humanos como para una computadora, es resistente a análisis estadísticos.\nPara asegurarnos de esto, una función hash segura cumple con tres características formales:\nEs resistente a encontrar una preimagen Es resistente a encontrar una segunda preimagen Es resistente a colisiones ¿Qué es eso de las preimágenes? En criptografía se llama preimagen a todos los valores que le podemos dar a una función hash. La imagen es el resultado de aplicar la función hash a una preimagen.\nEsta ilustración lo puede dejar un poco más claro:\n{:.align-center}\nAhora hablemos sobre lo que significa cada punto de la seguridad. El primer punto se refiere a que dada una imagen o un hash, como normalmente le llamamos al resultado de una función hash, es imposible encontrar la entrada original, o algún otro valor que resulte en ese hash. Si este punto no se cumple, los siguientes dos tampoco.\nEl segundo punto, la resistencia a la segunda preimagen, es que dado un valor de entrada (praimagen) y su hash correspondiente (imagen), es imposible encontrar otro valor de entrada que se resulte en el mismo hash, o la misma imagen.\nEl tercer punto, la resistencia a colisiones se refiere a que es cerca de imposible encontrar (o fabricar) dos valores de entrada que den el mismo hash (dos preimágenes que resulten en la misma imagen).\nEn resumen: para un hash seguro es casi imposible encontrar dos valores que den el mismo hash, teniendo ejemplos de hasheado o no, así como encontrar el valor que generó cierto hash.\nAlgunas funciones hash criptográficamente seguras # Las dos funciones hash criptográficas más populares son MD5 y SHA-1. Actualmente (2021) a ambas se les han encontrado vulnerabilidades, sobre todo en el campo de las colisiones, para ambas es posible generar colisiones de manera arbitraria.\n\u0026ldquo;SHA\u0026rdquo; es un acrónimo que significa Algoritmo de Hasheo Seguro (\u0026ldquo;Secure Hash Algorithm\u0026rdquo;) y es un \u0026ldquo;título\u0026rdquo; dado a los algoritmos de hasheo que son seleccionados por la NIST (National Institute of Standards and Technology de Estados Unidos).\nAhora sí hablemos de algunas funciones hash criptográficas todavía consideradas seguras:\nSHA-2. SHA-2 es la familia sucesora de SHA-1, y consiste de 4 funciones hash que difieren en el tamaño de bits de su salida: SHA-224, SHA-256, SHA-384 y SHA-512. Las dos más usadas son SHA-256 y SHA-512. Hasta 2021 no se le han encontrado vulnerabilidades que hagan que sean no recomendadas. La desventaja es que la familia SHA-2 es más lenta que SHA-1.\nSHA-3. SHA-3 es la cuarta versión de SHA y el algoritmo se escogió de un concurso organizado por la NIST en 2007. En 2012 se anunció que el algoritmo seleccionado era Keccak, un algoritmo muy diferente de SHA-1 y SHA-2. Esta familia de algoritmos también define cuatro funciones hash, SHA3-224, SHA3-256, SHA3-384 y SHA3-512. Pero además define 2 algoritmos extra que pueden dar resultados variables. Puedes ver la página del equipo de Keccak en Keccak Team.\nBLAKE2. Es un algoritmo sucesor de BLAKE, uno de los participantes en el concurso por SHA-3. BLAKE2 es mucho más rápido que Keccak, casi igual de seguro, pero más parecido a SHA-2, que es la razón por la que no se eligió a BLAKE como el SHA-3. Es una muy buena opción para usarse en caso de que requieras un función hash segura y que la velocidad sea muy importante, ya que es más rápida incluso que SHA-1.\nComo puedes ver, tenemos para escoger entre las funciones hash todavía consideradas seguras.\n¿Qué función hash usar? # Ahora que tenemos un sucesor de SHA-2, la que deberías usar en la mayoría de tus proyectos es SHA3-256, ya que provee de la suficiente seguridad, está estandarizada y es probable que sea implementada como instrucciones del procesador en el futuro. Si te importa muchísimo la velocidad en tu proyecto ahora mismo, deberías usar BLAKE2, que también es muy popular y está implementada en muchos lenguajes de programación.\n¿Sirven para guardar passwords? # Un error común es pensar que estas funciones pueden servir para guardar passwords de forma segura en nuestras aplicaciones. En el siguiente artículo hablaremos de por qué no sirven para eso y qué otras funciones podrías usar.\n","date":"2 diciembre 2021","externalUrl":null,"permalink":"/2021/12/02/algoritmos-criptogr%C3%A1ficos-qu%C3%A9-es-un-hash/","section":"Posts","summary":"\u003cp\u003eDentro del mundo del desarrollo se escucha bastante sobre \u003cstrong\u003efunciones hash\u003c/strong\u003e y, en realidad, se usan para múltiples cosas. En este artículo vamos a hablar de lo que es una función hash, los diferentes tipos que hay y cómo pueden servirte para desarrollar software.\u003c/p\u003e","title":"Algoritmos criptográficos: ¿Qué es un Hash?","type":"posts"},{"content":"El libro \u0026ldquo;20 Python Libraries You Aren\u0026rsquo;t Using (But Should)\u0026rdquo; de Caleb Hattingh es un lectura corta que recomienda bibliotecas de Python muy útiles que pueden ayudarte a desarrollar software de manera más efectiva y rápida.\n{: .align-center}\nVeamos las 5 que me parece más importante conocer y tú puedes leer el libro para ver el detalle y entender las otras 15.\nEn la biblioteca estándar de Python # Estas bibliotecas no las tendrás que instalar porque vienen con todas las instalaciones normales de Python, pero son poco usadas.\ncollections - Contiene un conjunto de clases y funciones para trabajar con estructuras de datos especializadas en alguna función. Por ejemplo provee de diccionarios que mantienen el orden, listas de doble acceso, tuplas nombradas y hasta un diccionario especializado en contadores. En el canal de YouTube hemos hecho algunos videos sobre estos contenedores, puedes verlas aquí: Python Collections\nsched - Trabaja con tareas programadas de manera sencilla, este módulo nos da la clase scheduler que nos permite programar, encolar y ejecutar tareas entre otras cosas.\nBibliotecas desarrolladas por la comunidad # hug - Es una biblioteca de Python que nos permite crear API\u0026rsquo;s en el sentido general de la palabra. Nos permite crear interfaces de tres tipos: de consola, de módulo y REST. Contiene una serie de utilidades para que puedas exponer tu API de la manera más sencilla posible, documentación automática, aprovechamiento de las sugerencias de tipos de Python, entre muchas otras cosas. Esta es una Biblioteca que realmente recomiendo si quieres crear una API verdaderamente rápido.\narrow - te permite manejar las fechas y tiempos de mejor manera que sólamente con los tipos de datos nativos de Python. Centraliza todas las funciones de fechas y tiempos en vez de estar repartidas en varios módulos, trabaja por default con fechas y horas que incluyen la zona horaria (UTC), soporta el estándar ISO 8601, tiene funciones de \u0026ldquo;humanización\u0026rdquo; de fechas y tiempos, etc.\nboltons - contiene una gran colección de tipos de datos y funciones que los creadores y contribuidores piensan que le hacen falta a la biblioteca estándar de Python. Para Octubre de 2021 tenía 83 tipos de datos y 171 funciones, hablemos de tamaño. Las utilidades que provee son muy variadas, y te pueden ayudar para una gran cantidad de casos. Por ejemplo, tiene utilidades para colecciones, para manejo de caché, trabajo con tipos de datos, utilidades para debuggear, ente muchas otras ayudas.\nConclusión # La verdad es que cada una de las bibliotecas arriba mencionadas debería tener su propio artículo o video, esperamos que podamos extender sobre algunas de ellas en el futuro. Por lo mientras, puedes leer el libro y aprender más sobre las bibliotecas que recomienda, sólo ten en cuenta que algunas pueden estar sin mantenimiento por la edad que tiene el libro. Aquí te dejamos el resumen que hicimos en el canal y con suerte en este link puedes descargar el libro en PDF, aunque es un libro que puedes seguir leyendo en Safari, la biblioteca online de O\u0026rsquo;Reilly o leer gratuito en línea: aquí. Déjanos un comentario si quieres que hagamos el análisis de alguna biblioteca en el futuro.\n","date":"1 diciembre 2021","externalUrl":null,"permalink":"/2021/12/01/20-bibliotecas-de-python-que-deber%C3%ADas-estar-usando/","section":"Posts","summary":"\u003cp\u003eEl libro \u003ca\n  href=\"https://freecomputerbooks.com/20-Python-Libraries%20You-Are-Not-Using-But-Should.html#downloadLinks\"\n    target=\"_blank\"\n  \u003e\u0026ldquo;20 Python Libraries You Aren\u0026rsquo;t Using (But Should)\u0026rdquo;\u003c/a\u003e de \u003ca\n  href=\"https://github.com/cjrh\"\n    target=\"_blank\"\n  \u003eCaleb Hattingh\u003c/a\u003e es un lectura corta que recomienda bibliotecas de Python muy útiles que pueden ayudarte a desarrollar software de manera más efectiva y rápida.\u003c/p\u003e","title":"20 bibliotecas de Python que deberías estar usando","type":"posts"},{"content":"","date":"1 diciembre 2021","externalUrl":null,"permalink":"/tags/bibliotecas/","section":"Tags","summary":"","title":"Bibliotecas","type":"tags"},{"content":"","date":"1 diciembre 2021","externalUrl":null,"permalink":"/tags/books/","section":"Tags","summary":"","title":"Books","type":"tags"},{"content":"","date":"5 octubre 2021","externalUrl":null,"permalink":"/tags/calidad/","section":"Tags","summary":"","title":"Calidad","type":"tags"},{"content":"","date":"5 octubre 2021","externalUrl":null,"permalink":"/tags/est%C3%A1ndares/","section":"Tags","summary":"","title":"Estándares","type":"tags"},{"content":"Los estándares se encuentran constantemente presentes en nuestra vida cotidiana, son importantes para mantener un cierto orden en las cosas. La Ingeniería de Software no es una excepción a la regla, por lo tanto, los estándares de código son un requisito básico para los sistemas de calidad.\nPara las organizaciones de nuestra época, el correcto funcionamiento de sus aplicaciones digitales representa crecimiento. Si eres parte de un equipo que aún no se preocupa por esto, te invitó a seguir leyendo y conocer las ventajas de esta práctica para que asi puedas considerar utilizarla en un futuro.\n¿Qué son los estándares de código? # Los estándares de código son una serie de reglas definidas para un lenguaje de programación, o bien, un estilo de programación específico. El estilo garantiza que todos los ingenieros que contribuyen a un proyecto tengan una forma única de diseñar su código, lo que da como resultado una base de código coherente, asegurando una fácil lectura y mantenimiento.\nEl uso de estándares es muy importante en la calidad de software, sin embargo mantener todos los proyectos cumpliendo a la perfección con esto no es una tarea fácil, requiere un gran esfuerzo y constancia por parte del equipo de desarrollo. Mientras más y más compañías han adoptado estándares, todavía hay aquellas que realizan el desarrollo de sus proyectos sin ellos.\nTrabajando sin estándares de código # Cuando eres parte de un equipo que aún no ha establecido reglas a seguir, es muy común que los desarrolladores escriban código a su modo, dando como resultado un repositorio difícil de entender y por tanto difícil de mantener. La falta de un código organizado se puede transformar en horas y horas buscando un problema antes de estar siquiera cerca de donde podría haberse originado.\nTambien puede propiciar un ambiente de trabajo hostil, en el que ciertos ingenieros escriben código con un estilo propio y otros lo hacen diferente. Al momento de unificar el trabajo hay discusiones para elegir la mejor opción, y al no tener reglas establecidas u oficialmente validadas por todo el equipo, la discusión puede ser mas larga de lo normal, provocando retrasos en la entrega de nuevas implementaciones.\nSiendo realistas al crear un proyecto nuevo nos enfocamos en conseguir que la aplicación funcione como primer meta, esto no es malo, usualmente las aplicaciones de software tienen un fin comercial o economico que debe resolverse en principio, pero una vez se alcanza cierta estabilidad es importante regresar a revisar el producto inicial y considerar refactorizaciones, esto con el fin de tener un futuro más sencillo.\nComo implementar estándares de código en proyectos existentes # \u0026ldquo;Roma no fue construida en un día.\u0026rdquo; la migración debe ser progresiva, no es algo que se consigue de la noche a la mañana, es recomendado adoptar estas practicas en nuevos proyectos y poco a poco ir implementando un nivel adecuado de estándares en los existentes.\nConsidera que en un inicio puede ser difícil para el equipo de ingenieria adaptarse, el contraste entre no tener reglas oficiales establecidas en el proceso de revisión de código vs, el comenzar a tenerlas puede ser un cambio que no todos tomen de forma natural, a algunos les llevara más tiempo que a otros. Para reducir ese tiempo de adaptación es importante dar a conocer a todo el equipo las ventajas principales de esta practica.\nNo todas las compañías utilizan las mismas herramientas en sus desarrollos y es muy complicado que se encuentre un estándar ideal que se adapte a las necesidades especificas, por ello, para que todos esten en el mismo canal, es recomendable establecer un grupo de estándares propios, es decir, crear tu propio repositorio de estándares es un buen comienzo para lograr código de calidad.\nPueden iniciar adoptando estándares oficiales de las herramientas/lenguajes que utilizan. Automatizar ciertos procesos de validaciones del código puede ser de gran ayuda para una integración continua.\nConsideraciones: # Tomar como base estándares oficialmente publicados de las herramientas que se utilizan en cada proyecto.\nPara obtener un código de fácil lectura es necesario poner atención al estilo del mismo; segmentos de código, correcto uso de indentación, longitud de lineas y espacios entre ellas.\nAsignación de nombres en variables, funciones, etc.\nEstablecer límites en complejidad o longitud de funciones.\nY lo más importante, no detenerse en la aplicación de estas reglas. No incrementemos la deuda técnica en nuestros proyectos. Quizá al día de hoy tengas un proyecto muy grande en el que jamás se han aplicado estándares y te parece una pérdida de tiempo comenzar a hacerlo, pero es una inversión que vale la pena para ir construyendo no sólo un producto de calidad, sino también un equipo de ingeniería de calidad. Si la implementación de estos estándares comienza a ser un verdadero dolor de cabeza, es muy recomendable considerar una refactorización completa de tu sistema \u0026ldquo;Divide y vencerás\u0026rdquo; se puede iniciar módulo por módulo.\nVentajas de la implementación de estándares # Detección temprana de fallas: Al buscar cumplir con los estándares que establezcas es más sencillo detectar posibles errores desde la revisión de código, evitando que esos problemas lleguen a producción.\nReducción de la complejidad: El cumplir con las reglas acerca del estilo de código ayuda a construir código más limpio, permitiendo detectar fácilmente oportunidades para simplificar funciones.\nCódigo de fácil lectura: El respetar los estándares en un proyectos le permite a nuevos miembros del equipo acoplarse más fácilmente al ritmo de trabajo y a entender mejor el código de los proyectos existentes.\nCódigo reusable: Contar con segmentos de código que pueden ser consumidos por más de un servicio, gracias al uso de buenas prácticas, hace menos frecuente la repetición de código.\nPrincipios de código limpio recomendados # Es una buena estrategia buscar que todo el equipo de ingenieros esté familiarizado con principios de código limpio, por esto a continuación se enlistan algunos de los principios que te inspirarán a crear estándares para tu equipo. En busca de software de calidad.\nDRY - Don\u0026rsquo;t Repeat Yourself.\nYAGNI - You Aren\u0026rsquo;t Gonna Need It.\nKISS - Keep it Simple, Stupid.\nSOLID\nS - Single-Responsiblity Principle.\nO - Open-Closed Principle.\nL - Liskov Substitution Principle.\nI - Interface Segregation Principle.\nD - Dependency Inversion Principle.\nConclusión # Considera que siempre habrá procesos por mejorar pero es un esfuerzo continuo y podrás seguir trabajando en ello.\nEn mi experiencia trabajando con diversos equipos de ingeniería, he podido ver muy buenos resultados haciendo uso de esta practica, por ejemplo:\nReducciones entre el 40 y 60% en incidencias. Disminución en el número de despliegues de \u0026ldquo;hotfix\u0026rdquo;. Una mejora significativa en la calidad del equipo de desarrollo. Como podemos ver la definición y el uso de estándares proporciona muchos beneficios, en lo personal, disfruto más el trabajo cuando se tiene un enfoque hacia el código de calidad que cuando no hay reglas establecidas, sin embargo eso no se puede lograr sin el trabajo de todos los ingenieros en un equipo, se trata de apuntar todos juntos a un mismo objetivo.\n","date":"5 octubre 2021","externalUrl":null,"permalink":"/2021/10/05/la-importancia-de-los-est%C3%A1ndares-de-c%C3%B3digo/","section":"Posts","summary":"\u003cp\u003eLos estándares se encuentran constantemente presentes en nuestra vida cotidiana, son importantes para mantener un cierto orden en las cosas. La Ingeniería de Software no es una excepción a la regla, por lo tanto, los estándares de código son un requisito básico para los sistemas de calidad.\u003c/p\u003e","title":"La Importancia de los Estándares de Código","type":"posts"},{"content":"","date":"5 octubre 2021","externalUrl":null,"permalink":"/tags/source-code/","section":"Tags","summary":"","title":"Source-Code","type":"tags"},{"content":"Desarrollar software es una de las cosas que están basadas completamente en el conocimiento que tenemos sobre lo que estamos programando.\nLa charla \u0026ldquo;Eloquent Explanations\u0026rdquo; de Russ Olsen. En ella se proponen 5 puntos para darnos a entender cuando compartimos conocimiento con nuestro equipo u otras personas. Aquí te resumo lo que aprendí.\nLa motivación # Primeramente hablemos de la motivación para explicar mejor las cosas: lo que nos limita para construir software es conocimiento. Conocimiento sobre el dominio, el negocio o el sistema. Es por eso que compartirlo es una muy buena forma de ayudar al equipo a avanzar. La principal forma de compartirlo es con explicaciones.\nTómatelo en serio # Debemos tener un plan o una estructura para compartir el conocimiento, lo primero es no sacar tus pensamientos sin estructura. Russ propone algunas estructuras, como las siguientes:\nZoom In: Empieza en el contexto más amplio y termina en los detalles. Por ejemplo: Queremos vender zapatos -\u0026gt; Por eso estamos construyendo un eCommerce -\u0026gt; Por eso necesitamos este botón de \u0026ldquo;Pagar\u0026rdquo;.\nZoom Out: Empieza en el detalle y termina en el contexto más amplio. Por ejemplo: Necesitamos mejorar la retención de esta pantalla -\u0026gt; Porque es fundamental para terminar la compra -\u0026gt; Por que necesitamos acabar con el stock de este trimestre.\nDe los simple a lo complejo: Empieza explicando lo más básico, sin saltarte nada. Este método puede implicar ocultar información intencionalmente o explicarla en términos inexactos, pero que cuando llegue el momento se tendrán que aclarar y expandir.\nExplica el proceso: Este tipo de explicaciones se adapta bien a escenarios en dónde tienes que describir una transformación progresiva. Por ejemplo, cuando hablamos de cómo se transforma una petición web en un respuesta en cualquier framework web.\nLo más importante es encontrar la estructura que más se adapte a tu situación.\nSé Agil # Tus explicaciones debe seguir el mismo ciclo que el desarrollo de software:\nExplica: ejecuta siguiendo el plan que trazaste Mide: tienes que leer a la audiencia y darte cuenta de si tu explicación está funcionando. Busca señales como si las preguntas van cambiando, no te miran raro y no hay un silencio mortal. Ajusta: si tu explicación no está logrando transmitir lo que quieres, cambia de estrategia, simplifica o busca nuevos ejemplos. Repite: vuelve a iniciar el proceso con nuevo conocimiento aplicando lo que aprendiste. Empieza en lo más básico # Esto viene de un aprendizaje del autor de la plática mientras daba una taller en el quería enseñar Ruby on Rails. Había algunas personas en el auditorio que preguntaban una y otra vez lo mismo (señal de que no está funcionando tu explicación), hasta que comprendieron que Ruby es el lenguaje y Rails es el framework, cosa que Russ no había pensado siquiera en explicar.\nCuando explicamos algo que conocemos muy bien, puede que nos saltemos información que no tenemos presente que necesitamos saber, justo por el dominio tan amplio que tenemos del problema. Tenemos que ser cuidadosos en esto e intentar dar la mayor cantidad de información posible, incluso la que pueda ser muy básica.\nA veces parece que lo que estamos diciendo es obvio, pero aquí menciona una frase muy interesante:\n\u0026ldquo;Nadie en esta sala nació con ese conocimiento codificado en su ADN\u0026rdquo; - Russ Olsen (cuando el público se rio de la explicación tan básica que tuvo que dar)\nEsto nos debe recordar que a nosotros también nos tienen que explicar cosas que para otros son obvias.\nHaz cortas tus explicaciones # Explicar es un deporte con límite de tiempo. Tenemos un tiempo limitado para explicar lo que queremos antes de perder la atención de la persona, por lo que comprimir la información y decir primero lo más importante es buena idea.\nUno de los consejos que Russ da es evitar la jerga técnica. La terminología es un obstáculo para los que están empezando, y sólo quitará tiempo a tu explicación, aburriendo o comunicando muy poco en un espacio grande de tiempo, mientras la puedas evitar hazlo.\nUna buena noticia: puedes resetear el reloj y comprarte más tiempo si logras que las personas a las que les estás explicando tengan pequeñas victorias, entendiendo progresivamente el tema en cuestión.\nUsa la repetición # Repite para énfasis y para dar contexto. El \u0026ldquo;Don\u0026rsquo;t repeat yourself\u0026rdquo; es para las máquinas, los humanos necesitamos repetición para entender que algo es importante o para recordar el contexto de algo.\nAsí que usa la repetición para resaltar las ideas más importantes de tu explicación.\nMuéstrate como humano # Muéstrate humano. Las explicaciones que causan una reacción emocional en los que escuchan, como las que incluyen humor, las que demuestran sentimientos o conectan en un nivel humano con las personas son las que dejan las cosas grabadas. Russ cuenta la experiencia de la portada de un libro que lo hizo reír y por eso se ha acordado de él toda la vida.\nHazles saber por qué importa lo que estás diciendo, muestra el interés o el amor que tienes por el tema. Una buena explicación puede cambiar tu compañía, tu equipo o incluso el mundo.\nConclusión # Explicar algo de manera que otros comprendan no es algo sencillo. Necesitas práctica, intención y esfuerzo para lograrlo. Si lo dominas, sin duda serás un componente muy valioso de cualquier equipo en el que participes en el desarrollo de software.\nPuedes ver la charla completa aquí:\n","date":"19 julio 2021","externalUrl":null,"permalink":"/2021/07/19/como-transmitir-conocimiento-en-el-desarrollo-de-software/","section":"Posts","summary":"\u003cp\u003eDesarrollar software es una de las cosas que están basadas completamente en el conocimiento que tenemos sobre lo que estamos programando.\u003c/p\u003e\n\u003cp\u003eLa charla \u003ca\n  href=\"https://www.youtube.com/watch?v=80EE4mZmp3A\"\n    target=\"_blank\"\n  \u003e\u0026ldquo;Eloquent Explanations\u0026rdquo;\u003c/a\u003e de \u003ca\n  href=\"/2021/07/14/desarrolladores-de-los-que-puedes-aprender-russ-olsen.html\"\u003eRuss Olsen\u003c/a\u003e. En ella se proponen 5 puntos para darnos a entender cuando compartimos conocimiento con nuestro equipo u otras personas. Aquí te resumo lo que aprendí.\u003c/p\u003e","title":"Como transmitir conocimiento en el desarrollo de software","type":"posts"},{"content":"","date":"19 julio 2021","externalUrl":null,"permalink":"/tags/desarrollo/","section":"Tags","summary":"","title":"Desarrollo","type":"tags"},{"content":"","date":"19 julio 2021","externalUrl":null,"permalink":"/tags/explicaciones/","section":"Tags","summary":"","title":"Explicaciones","type":"tags"},{"content":"","date":"14 julio 2021","externalUrl":null,"permalink":"/tags/clojure/","section":"Tags","summary":"","title":"Clojure","type":"tags"},{"content":"En este capítulo vamos a Hablar de Russ Olsen, un desarrollador ahora de Clojure, pero bastante reconocido en el mundo de Ruby. Ha escrito varios libros y contribuye activamente a la comunidad mediante podcasts, presentaciones y charlas.\nAcerca de Russ # Russ trabaja como vicepresidente de Cognitec, la empresa que está detrás de Clojure. Ha participado en proyectos que parecen bastante complejos, su Github muestra creación de compiladores, marshalling y otras cosas interesantes.\nSegún la biografía que se encuentra en sitios de conferencias ha trabajado en motores de renderizado 3D, sistemas de consulta de bases de datos y sistema de flujos de trabajo, en pocas palabras, proyectos bastante complejos.\nRuss es el autor de tres libros bastantes respetados:\nEloquent Ruby: acerca de cómo escribir Ruby idiomáticamente. Design Patterns in Ruby: la implementación de los patrones de diseño clásicos en Ruby. Getting Clojure: te enseña a programar en Clojure mientras te explica las ideas detrás de cada una de las caracerísticas del lenguaje, ya que es importante concer la visión detrás del lenguaje. Las ideas de Russ # Russ tiene ideas muy pragmáticas para crear software, con un background de ingeniería mecánica. Vamos a hablar de algunas cosas que podemos aprender de él y aplicar directamente en nuestras carreras y proyectos.\nTransmitir conocimiento es MUY IMPORTANTE para el desarrollo de software. Si no lo compartimos ponemos en riesgo el desarrollo del proyecto en el que estamos participando. Saber explicarlo de manera sencilla es una habilidad que todos debemos adquirir.\nLa programación funcional, como una serie de restricciones, técnicas y habilidades que reorganizan la forma en que escribimos código, es una forma de crear código de mejor calidad y más mantenible.\nTrabajar con otras personas es uno de los aspectos más importantes que tiene el desarrollo de software y saber organizarla y tratar con ellas es imperativo para llevar a los proyectos a buen término.\nCrear cosas que importen y difíciles te inspirará para seguir creando y también a otras personas.\nCharlas y presentaciones # \u0026ldquo;Ve y haz cosas difíciles.\u0026rdquo; - Russ Olsen\nAquí tienes las tres charlas que Russ que pueden aportar a tu conocimiento y motivación para seguir creando software:\nTo the Moon. Si vas a ver una charla de Russ Olsen, tiene que ser esta. Tiene nulo contenido técnico, pero te puede enseñar muchas cosas: cómo dar una charla entretenida, cómo contar una historia, métodos narrativos y cómo mantener enganchada a la audiencia. En ella cuenta las dificultades técnicas que se presentaron en el proyecto del Apollo 11, y como se solucionaron. La lección más importante de la charla es: hacer cosas difíciles como ingenieros de software te ayudará a creer más en ti y a inspirar a otros.\nEloquent Explanations: En esta charla Russ nos habla sobre lo importante que es comunicar claramente varios aspeectos de los sistemas que creamos, con la premisa fundamental de que el conocimiento es lo que nos permite crear el software que necesitamos. En este hilo de Twitter hicimos un resumen.\nFunctional Programming in 40 minutes: Como puedes ver, Russ es un programador bastante versátil. En los últimos años se ha dedicado a programar en Clojure. Esta es una de las charlas que más me ayudó a comprender la programación funcional como idea más allá de las definiciones clásicas y que te dejan híper confundido. Si quieres aprender programación funcional, esta charla te puede ayudar a entenderla para empezar con una buena base.\nTiene varias charlas más que puedes buscar en YouTube, pero estas son las más importantes para mi, y parece que varias de ellas son la mismas que mencionamos aquí pero repetidas.\nRecursos para aprender más # Twitter de Russ. Su Github, tiene cosas interesantes, como la implementación del lenguaje Forth en Python y Clojure, una implementación de Transit (un formato de serialización) en Go y Julia. El blog de Cognitect Este podcast en el que participó: Get Smarter and Make Stuff Conclusión # Una de las cosas que aprender al ver la carrera de Russ es su flexibilidad y adaptabilidad. Russ era un gran nombre en el mundo de Rails y Ruby, pero ahora está en el mundo de Clojure y tiene una de las mejores explicaciones para aprender programación funcional.\nAdemás, el pragmatismo que demuestra en los consejos que da, es algo que podemos aprender a aplicar: resolver el problema es mucho más importante que sonar rimbombantes y asombrar a todos con las palabras tan bonitas que usamos.\nEl último punto que quiero resaltar tiene que ver con la capacidad que tiene de contar historias, explicar progresivamente y dar charlas entretenidas. La comunicación es uno de los aspectos más importantes en el desarrollo de software, y mientras mejores seamos e eso, más podremos avanzar en nuestra carrera.\n","date":"14 julio 2021","externalUrl":null,"permalink":"/2021/07/14/desarrolladores-de-los-que-puedes-aprender-russ-olsen/","section":"Posts","summary":"\u003cp\u003eEn este capítulo vamos a Hablar de \u003ca\n  href=\"http://russolsen.com/\"\n    target=\"_blank\"\n  \u003eRuss Olsen\u003c/a\u003e, un desarrollador ahora de \u003ca\n  href=\"https://clojure.org/\"\n    target=\"_blank\"\n  \u003eClojure\u003c/a\u003e, pero bastante reconocido en el mundo de Ruby. Ha escrito varios libros y contribuye activamente a la comunidad mediante podcasts, presentaciones y charlas.\u003c/p\u003e","title":"Desarrolladores de los que puedes aprender: Russ Olsen","type":"posts"},{"content":"","date":"14 julio 2021","externalUrl":null,"permalink":"/tags/devs/","section":"Tags","summary":"","title":"Devs","type":"tags"},{"content":"","date":"14 julio 2021","externalUrl":null,"permalink":"/tags/ruby/","section":"Tags","summary":"","title":"Ruby","type":"tags"},{"content":"Hay varios desarrolladores de talla internacional de los que puedes aprender mucho, que creemos que no tienen la suficiente exposición, sobre todo en America Latina. Es por eso que estamos creando una serie de artículos y videos en la que resaltaremos la trayectoria, forma de pensar, pláticas y cosas que puedes aprender.\nLas condiciones para que aparezcan aquí son las siguientes:\nAmplia experiencia real desarrollando sistemas Que tengan algún logro notable en el desarrollo de sistemas Comparten sus ideas con la comunidad de forma continua No son unos \u0026ldquo;brilliant jerks\u0026rdquo;, es decir, no usan su experiencia o inteligencia para humillar o desacreditar a otros, y mucho menos su exposición para promover ideas nocivas. El objetivo de esta serie es que aprendamos de las personas que han dedicado su vida a esto y construyamos sobre lo que ellos han hecho en vez de reinventar la rueda cada vez.\nNota: El que los mencionemos aquí no implica que todas sus ideas son correctas o que estemos de acuerdo con todo lo que dicen. Conocer diferentes puntos de vista, sumado a tu experiencia en diferentes contextos te ayudará a tener un criterio adaptado a tu realidad.\nAhora sí, vamos a hablar de Kevlin Henney.\nAcerca de Kevlin Henney # Kevlin Henney es un consultor, escritor, entrenador y presentador de temas relacionados con sistemas, procesos, las personas y el software. Sus escritos, talleres y consultorías siempre tienen que ver con la forma en que desarrollamos y diseñamos software, además de con los procesos y prácticas que llevan al éxito los proyectos de software complejos.\nHa escrito columnas para múltiples revistas dedicadas al desarrollo de software. Es autor o editor de varios libros que son muy recomendados para arquitectos de software y desarrolladores. Algunos ejemplos son:\nPattern-Oriented Software Architecture, Volume 4: A Pattern Language for Distributed Computing 97 Things Every Programmer Should Know - Es una colección de ensayos que Kevlin se encargó de compilar y editar, sobre cómo ser un mejor programador. También está la versión en español: 97 cosas que todo programador debería saber Kevlin se ha presentado en casi todas las conferencias importantes de desarrollo de software europeas y de habla inglesa. Vive en Bristol, Reino Unido y también disfruta de escribir ficción, puedes encontrar en Amazon sus libros de ficción. Además es muy accesible, si lo buscas en Twitter es muy probable que te conteste: Kevlin Henney en Twitter\nUna de las cosas que menciona que más nos gusta es: \u0026ldquo;Si estás de acuerdo con todo lo qu estoy diciendo, no me estás escuchando.\u0026rdquo;.\nAlgunas ideas de Kevlin # \u0026ldquo;Less code == less bugs\u0026rdquo;. - Kevlin Henney\nDe las pláticas y el contenido que hemos consumido de Kevlin, hemos podido derivar algunas de las principales ideas que promueve. Te listamos las tres más importantes y te dejamos descubrir las demás viendo sus charlas o leyendo su contenido.\nLa arquitectura de software requiere entendimiento completo del dominio. Una de las ideas que Kevlin repite vez tras vez es la importancia de entender y definir el problema que estamos tratando de resolver. Se basa en las ideas de otros autores para reforzar esto. Una de las cosas que Kevlin resalta es que debemos conocer los detalles, para poder implementar software correcto con la arquitectura adecuada. El diseño y la arquitectura de software son procesos iterativos e incrementales. Es imposible hacer un diseño completamente correcto y sin errores desde la primera vez. Es por eso que esta es una idea que se repite en sus conferencias vez tras vez. La lección para nosotros: debemos diseñar el software con el conocimiento de que siempre habrá algo que mejorar. El software simple, pequeño y \u0026ldquo;aburrido\u0026rdquo; es más fácil de manejar. Haciendo eco de la frase que pusimos al inicio de esta sección, una de las ideas que Kevlin promueve más es la de minimizar la cantidad de código para lograr algo, así como buscar la simplicidad tanto en funciones como de construcción. Esto último es lo que llamamos aburrido: evitar tanto como podamos tecnologías a las que no estamos acostumbrados o demasiado nuevas y que agreguen dependencias innecesarias. Pláticas # Kevlin tiene decenas de pláticas en YouTube y Vimeo, hablando temas variados, todos relacionados de una forma u otra con el proceso de desarrollo y la calidad del software.\nVamos a mencionar tres de las que nos han parecido las mejores.\nSoftware is Details # Aquí presenta una idea que repite a lo largo de sus presentaciones: la implementación del software requiere un conocimiento lo más profundo y completo que se pueda sobre el problema que se está resolviendo. Da algunos ejemplos en los que se diseñó un sistema sin pensar en los \u0026ldquo;detalles de implementación\u0026rdquo; con resultados catastróficos. Mantener la vista en el sistema entero mientras se toman en cuenta los detalles es una señal de un arquitecto de software efectivo.\nOld is the new new # En esta plática resalta la importancia de conocer y dominar los principios que habilitan a las nuevas tecnologías y herramientas. Las implementaciones tienen una vida corta mientras que los principios se mantienen inalterados.\nIt Depends\u0026hellip; # Crear software depende del conocimiento que tengamos acerca del dominio que estamos tratando. Nuestro conocimiento tiene límites que no podemos sobrepasar (incertidumbre) y es contra eso con lo que debemos tener cuidado, cosas que no están inmediatamente en nuestra visión.\nTiene muchas más pláticas en conferencias que puedes buscar directamente en YouTube. Cada una de sus pláticas es un conjunto de ideas y referencias que es más de lo que se puede absorber en el tiempo en el que lo presenta, por lo que tal vez tengas que verlas varias veces, pero todo ese bagaje vale la pena. Aquí te dejamos una búsqueda que las agrupa: DevTube.\nPreguntas que le hicimos # Además de investigar y aprender sobre las ideas de estos desarrolladores, creamos un cuestionario para hacérselos a todos los desarrolladores de esta serie, para que contesten las preguntas que puedan. Contactaremos directamente a cada uno y le haremos llegar las preguntas, con suerte nos contestaran.\nKevlin fue muy accesible y nos contestó casi todas las preguntas, disfruta las respuestas.\n¿Cómo fue tu camino de aprendizaje? ¿Cómo te hiciste así de bueno? # No se si soy tan bueno, pero mi camino ha sido una mezcla de interés apasionado experimentación, ignorancia, estudio, ¡y suerte! Me introduje en la programación en la adolescencia pero no se me ocurrió hasta que dejé la universidad que el desarrollo de software podría ser una buena elección de trabajo o carrera.\nMientras trabajaba, fui atraído hacia el mundo de los lenguajes, técnicas, paradigmas, diseño, etc., mientras leía un conjunto aleatorio de artículos que incrementaron mi interés y fascinación. Empecé a tratar de comunicar esas ideas a través de artículos, y a relacionarlas con mis experiencias mientras trabajaba con diferentes sistemas y en en diferentes ambientes.\nEsto eventualmente me llevó a dar charlas, cursos y visitar compañías, lo cuál amplió mi campo de visión, retó algunas de mis ideas y mejoró mi habilidad para pensar con los pies en la tierra.\n¿Cuál ha sido tu peor decisión técnica? ¿Qué restricciones la limitaron? # Escogeré un decisión técnica que está segura en el pasado; un cuarto de siglo en el pasado, para ser precisos. Estaba trabajando en un sistema SCADA en el sector energético. Nuestros sistemas estaban embebidos en subestaciones eléctricas y tenían muy poco ancho de banda (sólo unos pocos miles de bits por segundo). Ayudé a definir un protocolo binario compacto y que no requería mucho ancho de banda. Cuando definimos el protocolo, decidimos específicamente no preocuparnos por la seguridad en el protocolo porque, en ese tiempo, no pensamos que alguien sería lo suficientemente tonto para conectar infraestructura sensible, como la red eléctrica, a una red pública, como el Internet.\n¡Resulta que nunca debes subestimar que tan tonta puede ser la gente! Afortunadamente esto fue corregido después con unos cuántos cambios para usar SSL en vez de correr nuestros propios sockets sin protección.\nDicho esto, aunque perdimos una tendencia futura, nos subimos a otras. No sólo corregimos el problema Y2K antes de que la mayoría de las personas siquiera supieran de él; también atendimos el problema del año 2038.1\n¿Cuál es el peor consejo que te han dado? # Las pruebas no son responsabilidad del desarrollador.\n¿Cuál es el mejor consejo que te han dado? # Piensa en el desarrollo de software como la administración de la complejidad.\n¿En tu experiencia, qué tan importante es el lenguaje que seleccionamos para desarrollar nuestro software? ¿Por qué estamos discutiendo aún sobre los lenguajes? # Es importante porque la elección de lenguaje es, normalmente, arquitectural. Si no estás seguro de esto, considera el costo y esfuerzo, las herramientas, las habilidades, etcétera, de lo que tomaría cambiar de lenguaje en una parte o toda tu base de código. Piensa en cuánto de tu sistema saldría afectado, como afectaría al equipo y cómo otros elementos de tu conjunto de herramientas tecnológicas serían impactados. Y más. Lejos de ser un detalle, la elección es mucho más significativa de lo que muchas personas se dan cuenta.\nEl lenguaje, en cualquier presentación, es una forma de expresarnos. El lenguaje también está asociado con la cultura y la comunidad. Por eso peleamos acerca de él. Aunque muchos desarrolladores podrían pensar que están debatiendo racionalmente acerca de su lenguaje y sus méritos técnicos, pero típicamente esto no sucede. Debajo de la apariencia técnica de estas discusiones hay algo más humano y menos racional, algo más social y personal. Y por eso es por lo que continuamos discutiendo sobre los lenguajes.\nClaro, hay diferencias técnicas y puntos objetivos que se pueden argumentar, pero la verdad es que esto no es el centro de las discusiones.\n¿Cuál es la discusión técnica más improductiva que has tenido? # ¡Probablemente sobre un lenguaje de programación!\n¿Qué podrías recomendar a los programadores jóvenes que aún estén buscando su camino? # Observa la historia de la programación, la arquitectura de software, las metodologías de desarrollo, etcétera. El desarrollo de software tiene una historia y la mayoría de las ideas profundas puede ser hallada ahí. La mayoría de las tendencias y elecciones actuales se entienden mejor al entender el pasado, en vez de sólo mirar el presente. El desarrollo de software es más conservador de lo que podrías apreciar, y las nuevas ideas raramente son originales.\n¿Qué ideas debemos superar como comunidad de IT para mejorar? # La idea de que el desarrollo de software es una actividad estríctamente neutral y técnica que no necesita considerar a la gente. La manera en que desarrollamos software y en la que es usado tiene implicaciones éticas. Necesitamos reconocer de mejor manera el espectro de personas que pueden y crean software y las responsabilidad que tienen para con las personas qeu usan el software. El software cambia al mundo; no podemos hacer eso y decir que la manera en que el mundo cambia no es nuestra responsabilidad.\n¿Cuál es el futuro de la programación para los siguientes diez años, en tu opinión? ¿Qué deberíamos aprender para mantenernos productivos? # Los próximos diez van a ser muy parecidos a los diez anteriores. Va a haber nuevos frameworks, nuevas plataformas, nuevos lenguajes de programación, junto con los respectivos cambios en las habilidades. Algunas personas se emocionarán con las nuevas ideas que no son tan nuevas. Algunas personas predecirán la desaparición de los programadores y el software tal como lo conocemos. Lo que es más probable que pase es que el número de programadores va a seguir aumentando y el desarrollo de software va a seguir evolucionando, mayoritariamente en la línea que lleva ahora. El mundo continuará siendo cada vez mas dependiente de los desarrolladores de software.\nRecursos # Para aprender más de las ideas qeu Kevlin enseña, puedes investigar más de él y su trabajo aquí:\nPágina de Kevlin Henney\nWhat to read if you are a programmer\nEntrevista de la serie \u0026ldquo;Heroes of Java\u0026rdquo;\nBlog\nSus presentaciones\nConclusión # Todos los desarrolladores de diferentes niveles podemos aprender mucho de las ideas que Kevlin se ha dedicado a enseñar, mientras lo hace de una manera entretenida, profunda y que va puliendo con el tiempo. Es importante escuchar a personas con experiencia para pode desarrollar el criterio propio y las habilidades y formas de pensar para ser efectivos.\nEl fin del UNIX Timestamp o Y2k38. (Nota de traducción)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"7 julio 2021","externalUrl":null,"permalink":"/2021/07/07/desarrolladores-de-los-que-puedes-aprender-kevlin-henney/","section":"Posts","summary":"\u003cp\u003eHay varios desarrolladores de talla internacional de los que puedes \u003cstrong\u003eaprender mucho\u003c/strong\u003e, que creemos que no tienen la suficiente exposición, sobre todo en America Latina. Es por eso que estamos creando una serie de artículos y videos en la que resaltaremos la trayectoria, forma de pensar, pláticas y cosas que puedes aprender.\u003c/p\u003e","title":"Desarrolladores de los que puedes aprender: Kevlin Henney","type":"posts"},{"content":"","date":"7 julio 2021","externalUrl":null,"permalink":"/tags/developers/","section":"Tags","summary":"","title":"Developers","type":"tags"},{"content":"","date":"22 junio 2021","externalUrl":null,"permalink":"/tags/leyes/","section":"Tags","summary":"","title":"Leyes","type":"tags"},{"content":"Programar es una cosa, desarrollar software algo completamente diferente, sobre todo en un ambiente comercial en el que tienes que tratar con clientes y patrones. En este entorno tienes que entender otras cosas como la forma de colaborar con ellos, los precios y algo muy importante: las leyes.\nEn este artículo vamos a hacer un resumen de las cosas que platicamos con Cynthia Romero y con Conde en la plática \u0026ldquo;Todo lo que debes saber acerca de propiedad intelectual como creador de Software\u0026rdquo;. También Novus hizo un resumen por si lo quieres checar: Tips legales para crear software.\nTL;DR: Es muy importante controlar y conocer los componentes de tu software y mantener un registro para no meterte en problemas.\n¿Qué es la propiedad? # La propiedad es la facultad que se define en el derecho como la capacidad de usar algo, aprovecharse de los frutos o productos de ese algo y la facultad de usar como quieras, incluso deshacerte de ese algo.\nLa propiedad es muy fácil de entender cuando se trata de cosas físicas, pero no tanto cuando se trata de cosas intangibles. La propiedad intelectual se refiere a la aplicación de las facultades antes mencionadas a obras o trabajos que hiciste con tu mente y no con tus manos. Algo que se resaltó en la plática, es que el software y todas las obras intelectuales están protegidas por las leyes desde escribes la primera línea.\n¿Qué es una licencia? # Debido a que somos los dueños de las cosas que creamos, podemos extender facultades como el uso o la distribución sobre nuestras obras. Estas facultades se formalizan mediante una licencia, que es un contrato que establece las condiciones de uso de la obra intelectual.\nLos desarrolladores de software debemos tener bien claro cómo es que queremos sacarle provecho a nuestras obras para establecer el contrato, la licencia adecuada. Para establecer esto, lo normal es consultar con expertos que nos ayuden a tangibilizar la licencia, ya que los términos y procedimientos legales no son fáciles de manejar, y más vale contar con la ayuda de alguien con experiencia.\nUso de software de terceros # Cuando desarrollamos software medianamente usable para casos cotidianos, es muy difícil que seamos nosotros quienes escribamos cada línea que compone el programa. Es por eso que confiamos en bibliotecas y piezas de software. ¿Cómo puedes asegurarte de respetar la propiedad intelectual de otros desarrolladores?\nEl primer punto es que si alguna pieza de software no tiene una licencia explícita, entonces debes asumir que no tienes permiso para usarlo, mucho menos para incluirlo en software comercial o por encargo.\nSi el software que vas a usar tiene una licencia, debes asegurarte que cumples con lo que se establece en ella. Entender esto y asegurarte de que se estás cumpliendo requiere tiempo y esfuerzo, que debes considerar en la estimación del proyecto.\nEl inventario de activos # Muy conectado con el punto anterior existe una cosa que los creadores de software deberíamos tener muy presente: el inventario de activos (bill of materials). Este es un documento que contiene todas las piezas de software que estas usando, junto con las licencias y algún otro detalle sobre la pieza en específico. Esta lista ayudará al momento de asegurarnos que el software no está rompiendo ninguna licencia.\nDependiendo del lenguaje que programes, hay herramientas que te pueden ayudar a verificar esto automáticamente, incluso a listar las licencias que usan, por ejemplo, Node tiene el paquete License Checker y Python tiene PIP Licenses. El que existan estas herramientas de este estilo tal vez te de una idea de lo importante que es tener tu inventario de activos controlado.\nDocumentos legales # Cuando queremos obtener beneficios por el software que comercializamos o exponemos a un público, es muy importante contar con documentos legales que establecen los acuerdos que se asumen con el uso del software. Estos documentos son normalmente:\nLa licencia de uso (para software comercial) Los términos y condiciones de uso (para software de uso público) El aviso de privacidad Crear estos documentos es un asunto serio en el que normalmente se necesita la ayuda de expertos, a menos que sea una aplicación muy sencilla y poco seria.\nSi estás exponiendo el software como OpenSource, entonces puedes usar una licencia prefabricada: OpenSource Licenses, pero también tienes que entenderlas para ver qué es lo que permites con cada una.\nEstos costos los deberías de considerar en el costo final del software.\nConclusión # Como desarrollador de software es importante que conozcas los temas básicos de propiedad intelectual si quieres desarrollar y comercializar software. Puedes ver la charla entera, para que obtengas más detalles aquí:\n","date":"22 junio 2021","externalUrl":null,"permalink":"/2021/06/22/lo-que-debes-saber-sobre-propiedad-intelectual-como-desarrollador-de-software/","section":"Posts","summary":"\u003cp\u003eProgramar es una cosa, desarrollar software algo completamente diferente, sobre todo en un ambiente comercial en el que tienes que tratar con clientes y patrones. En este entorno tienes que entender otras cosas como la forma de colaborar con ellos, los precios y algo muy importante: las leyes.\u003c/p\u003e","title":"Lo que debes saber sobre propiedad intelectual como desarrollador de software","type":"posts"},{"content":"","date":"22 junio 2021","externalUrl":null,"permalink":"/tags/propiedad-intelectual/","section":"Tags","summary":"","title":"Propiedad-Intelectual","type":"tags"},{"content":"Cada quien tiene su forma de aprender. A algunas personas les funcionan mejor formas visuales y no convencionales. En este artículo te vamos a presentar algunos de los recursos que hemos encontrado que explican ideas y temas relacionados con la programación con un formato no convencional.\nTe lo explico con gatitos # Bel Rey, una programadora de Argentina (con la que tenemos una entrevista) crea explicaciones estilo comics usando gatitos para embellecer y hacer divertidas las explicaciones.\nEn este cómic explica una de las motivaciones para hacer este estilo de ilustraciones-explicaciones:\nEntre sus explicaciones puedes encontrar temas como Docker, programación orientada objetos y comandos SQL todo con el estilo simpático y la estética de los gatitos, algunos de ellos enojados.\nPuedes ver su contenido en:\nSu página Instagram Twitter Los apuntes de Majo # Majo Ledesma, mientras estaba estudiando programación empezó a crear notas bastante bonitas y visuales reportando y resumiendo temas diversos como Python, JavaScript, CSS y ahora amasa una gran cantidad de temas y apuntes.\nSe hizo tan famosa que el CEO de Vercel le ofreció poner todo su contenido en línea gratis usando su plataforma.\nEl estilo de los apuntes es como si estuvieras leyendo la libreta de la alumna más aplicada y dedicada del salón para cualquier materia, con ilustraciones que embellecen la nota pero no siempre relacionadas con el tema. Son apuntes completamente hechos a mano en medios físicos y digitalizados.\nPudes obtener los apuntes:\nLos apuntes de Majo Twitter de Majo Wizardzines de Julia Evans (en inglés) # Los wizardzines son explicaciones sobre un tema en formato de cómic con dibujos sencillos e ilustrativos. Lo que resalta de estos cómics es que tratan a veces temas no tan sencillos de manera fácil de entender y para eso se lleva una buena cantidad de espacio, por lo que el artículo se convierte en una \u0026ldquo;revistita\u0026rdquo;.\nJulia vende las revistas que ha hecho en aproximadamente 10 USD, en formato digital con instrucciones para que tú las imprimas. Sin embargo, si no las puedes pagar, Julia ofrece el modelo que yo llamaría \u0026ldquo;paga sólo si puedes\u0026rdquo;: abrió todo su contenido para que lo descargues sin costo, con la confianza de que pagarás si no es un impedimento para ti.\nEn las Wiardzines puedes encontrar los siguientes temas:\n\u0026ldquo;How containers work\u0026rdquo; \u0026ldquo;Hell yes! CSS!\u0026rdquo; \u0026ldquo;Help! I have a manager!\u0026rdquo; Además, tiene un montón de zines gratuitos que tratan temas más pequeños y no están a color.\nSu página tiene una sección llamada \u0026ldquo;questions\u0026rdquo; que te permite estudiar temas en formato de tarjetas con preguntas y respuestas que se revelan. Es una forma bastante buena de entender básicamente los temas de los que trata y al mismo tiempo de estudiar para memorizar algo que creas necesitar.\nPuedes encontrar los wizardzines en:\nPágina de Wizard Zines Twitter de Julia Evans Visual Partner # Carlo Gilmar, siguiendo la tendencia de visual thinking ha creado Visual Partner, la empresa/proyecto alterno en la que comparte sus apuntes visuales de charlas que se dan en meetups y conferencias.\nCarlo ha creado un buen cuerpo de conocimiento de temas muy variados y probablemente puedas encontrar algo que estés aprendiendo en alguno de los lugares en lo que los comparte:\nVisual Partnership Facebook Twitter Su contenido puede servir como resumen y guía para aprender más acerca de cierto tema, ya que no está ordenado por tópicos, ni toca los temas profundamente. Aquí podrás encontrar contenido variado.\nExecute Program (inglés) # El creador de Destroy All Software, Gary Bernhardt creó una plataforma para que aprendieras las siguientes tecnologías de forma no convencional:\nJavaScript Arrays Concurrencia con JavaScript JavaScript moderno (ES2015-2019) Expresiones Regulares SQL TypeScript La dinámica de la plataforma es la siguiente: tú eres el compilador o el intérprete, es decir, la plataforma te da sentencias cada vez más complejas de la tecnología en cuestión y tú predices los resultados.\nPuedes entrar a la plataforma aquí: Execute Program. Te recomiendo su otra plataforma, con videos tradicionales explicando cosas difíciles de desarrollar como compiladores: Destroy all Software. Tienes acceso a ambas plataformas con la suscripción de Execute Program.\nOtras utilidades # Hay otras experiencias no convencionales que puedes para aprender cosas específicas:\nAprende Git branching CSS Diner Flexbox Froggy HTTP Cats Web Skills Si no te acomodas con las formas tradicionales como los libros y los videos, siempre habrá opciones diferentes e interactivas. ¿Tienes alguna otra recomendación? La esperamos en los comentarios.\n","date":"14 junio 2021","externalUrl":null,"permalink":"/2021/06/14/fuentes-no-convencionales-de-aprendizaje/","section":"Posts","summary":"\u003cp\u003eCada quien tiene su forma de aprender. A algunas personas les funcionan mejor formas visuales y no convencionales. En este artículo te vamos a presentar algunos de los recursos que hemos encontrado que explican ideas y temas relacionados con la programación con un formato no convencional.\u003c/p\u003e","title":"Fuentes no convencionales de aprendizaje","type":"posts"},{"content":"","date":"14 junio 2021","externalUrl":null,"permalink":"/tags/recursos/","section":"Tags","summary":"","title":"Recursos","type":"tags"},{"content":"","date":"29 marzo 2021","externalUrl":null,"permalink":"/tags/book/","section":"Tags","summary":"","title":"Book","type":"tags"},{"content":"","date":"29 marzo 2021","externalUrl":null,"permalink":"/tags/courses/","section":"Tags","summary":"","title":"Courses","type":"tags"},{"content":"","date":"29 marzo 2021","externalUrl":null,"permalink":"/tags/learning/","section":"Tags","summary":"","title":"Learning","type":"tags"},{"content":"El diseño de sistemas es un tema recurrente en entrevistas para desarrolladores de software, sobre todo para los niveles que requieren más experiencia, pero más allá de eso, es una habilidad fundamental a dominar si quieres avanzar en tu carrera.\nEs por eso que vamos a empezar a hablar más de ese tema, contando nuestra experiencia, pero al mismo tiempo aprendiendo a diseñar mejor.\nEn este post hablaremos de algunos recursos con los que puedes empezar a aprender.\nLibros # Un libro que se ha recomendado mucho sobre todo en esta época en la que los datos son cada vez más importantes es Designing Data-intensive Applications{:target=\u0026quot;_blank\u0026quot;} que, como su nombre lo dice, te enseña a construir aplicaciones en donde los datos son muy importantes.\nHay un libro que se enfoca justamente en la parte de entrevistas llamado System Design Interview{:target=\u0026quot;_blank\u0026quot;}, con la mayoría de las opiniones como positivas, pero algunas resaltan un punto muy importante: gran parte del contenido se encuentra en las referencias, así que si quieres profundizar tienes que buscarlas. A mi esto me parece positivo porque en vez de intentar abarcar todo y diluirse, este libro puede servir como un índice o una referencia para aprender más.\nFinalmente, te vamos a recordar un libro del que hemos hablado continuamente tanto en nuestros videos como en los posts de este blog: A Philosophy of Software Design{:target=\u0026quot;_blank\u0026quot;} de John Ousterhout. Este es uno de los mejores libros que puedes leer acerca del diseño de software en general, y de las prácticas que llevan a crear software bien diseñado. No habla de diseño de sistemas a gran escala, sino de organización y división modular y cómo deberías aplicarla.\nCursos y videos # Codely, una plataforma de cursos para desarrolladores, tiene un curso de introducción a la arquitectura hexagonal, que es una muy buena base para deseñar sistemas, aquí puedes ver una pequeña prueba: Intro a arquitectura hexagonal{:target=\u0026quot;_blank\u0026quot;} y aquí puedes ver el curso completo: Arquitectura Hexagonal{:target=\u0026quot;_blank\u0026quot;}.\nPrincipios SOLID Aplicados{:target=\u0026quot;_blank\u0026quot;} es otro curso con aplicaciones prácticas que puedes ver para aprender más sobre estos principios que ayudan a crear código y sistemas más mantenibles.\nEn Educative.io tiene un curso llamado Grokking the System Design Interview{:target=\u0026quot;_blank\u0026quot;} que tiene ejemplos de diseño explicados como blogposts, abarcando varias etapas del diseño, desde el primer borrador (back of the envelop) hasta análisis de cuellos de botella junto con diseño detallado.\nY finalmente, tenemos una recomendación Open Source y gratuita: System Design Primer{:target=\u0026quot;_blank\u0026quot;} que contiene incluso tarjetas de Anki{:target=\u0026quot;_blank\u0026quot;} un software para estudio mediante repetición espaciada.\nExtras # Un sitio en el que puedes aprender a diseñar sistemas que requieran mucho cuidado por la afluencia de usuarios que tendrán es High Scalability{:target=\u0026quot;_blank\u0026quot;}. Ahí podrás ver algunos ejemplos reales sobre como crear sistemas web más grandes en contenido, más rápidos y más confiables.\nSi quieres una ruta de aprendizaje completa, Educative.io tiene además la ruta de cursos que te pueden ayudar aprender aspectos teóricos y prácticos: Scalability and System Design for developers{:target=\u0026quot;_blank\u0026quot;}.\nCómo representar el diseño # Después de tener clara la idea de cómo resolver los problemas es buena idea tener un lenguaje visual y una guía par representar y comunicar todas las partes del sistema. Aquí te podemos recomendar el paper Architectural Blueprints–The \u0026ldquo;4+1\u0026rdquo; View Model of Software Architecture{:target=\u0026quot;_blank\u0026quot;} y el estilo creado por Simon Brown: El modelo C4{:target=\u0026quot;_blank\u0026quot;}.\nCualquiera de estos dos modelos tienen las herramientas suficientes para poder visualizar y comunicar tu arquitectura desde diferentes perspectivas y a diferentes niveles.\nConclusión # Aprender diseño de sistemas tiene que ver con estudiar mucho, pero sobre todo con aplicar lo aprendido. En el canal de YouTube tuvimos una plática sobre este tema, tomando de nuestras experiencias, lo puedes ver aquí:\nEn el futuro tendremos más pláticas sobre estos temas, con algunos ejercicios para ver la teoría en acción.\n","date":"29 marzo 2021","externalUrl":null,"permalink":"/2021/03/29/recursos-para-aprender-dise%C3%B1o-de-sistemas/","section":"Posts","summary":"\u003cp\u003eEl diseño de sistemas es un tema recurrente en entrevistas para desarrolladores de software, sobre todo para los niveles que requieren más experiencia, pero más allá de eso, es una habilidad fundamental a dominar si quieres avanzar en tu carrera.\u003c/p\u003e","title":"Recursos para aprender diseño de sistemas","type":"posts"},{"content":"","date":"29 marzo 2021","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System-Design","type":"tags"},{"content":"","date":"25 marzo 2021","externalUrl":null,"permalink":"/tags/aprendizaje-autom%C3%A1tico/","section":"Tags","summary":"","title":"Aprendizaje-Automático","type":"tags"},{"content":"Hablar de aprendizaje automático y los términos que lo rodean, muchas veces intimida a los desarrolladores. En esta serie de posts vamos a intentar explicar los conceptos detrás del aprendizaje automático y llevarlos a la práctica.\nAcerca de los nombres de las cosas # Antes de empezar a hablar de inteligencia artificial, aprendizaje automático, aprendizaje profundo y todas esas cosas, queremos hacer una nota sobre el nombrado en las asuntos de tecnología.\nPrimero, debemos recordar que la tecnología no existe en un entorno aislado, y generalmente no tiene uso por sí misma, sino que la usamos para servir a otras áreas. Es por eso que lo que conoceríamos por un nombre completamente acertado y descriptivo de acuerdo a sus características técnicas se tiene que renombrar para que otras personas no pertenecientes al área de desarrollo de software.\nAsí ha pasado vez tras vez con diferentes tecnologías:\nEl objeto XMLHttpRequest de los navegadores y su uso se nombró como AJAX para que fuera más vendible Una página web avanzada y con más funcionalidades se empezó a llamar Web App Las técnicas relacionadas con aprovechar las nuevas características de los navegadores como el Service Worker, el archivo manifest se juntaron bajo un solo nombre más \u0026ldquo;vendible\u0026rdquo;: Progressive Web Apps Los ejemplos siguen y estoy seguro que en cada área del conocimiento suceden. Este \u0026ldquo;renombramiento\u0026rdquo; permite que la tecnología en cuestión sea más aceptada y difundida, aunque a veces puede llevar a un malentendido por parte del público en general que puede permear a los practicantes.\nEsto es lo que ha pasado con los nombres que nos conciernen en este artículo, le llamamos \u0026ldquo;Inteligencia Artificial\u0026rdquo; a toda una rama de las ciencias de la computación relacionada con imitar lo que entendemos como \u0026ldquo;inteligencia humana\u0026rdquo;, pero las bases formales de esto podrían describirse con otros nombres más familiares para nosotros.\nEste nombre permite que los avances sean aceptados y por lo menos el área de negocio entienda las capacidades de la tecnología, no su funcionamiento.\nCuando comprendas cómo funciona, tal vez veas que las redes neuronales no tienen nada que ver con las redes neuronales, o que en realidad el aprendizaje automático es la aplicación de técnicas matemáticas y de ingeniería para aproximación de funciones, a veces muy complejas.\nAhora bien, eso no tiene nada de malo, sólo debemos aprender a no confundirnos con esos términos. Después de esta pequeña digresión, ahora si vayamos a lo que venimos: aprendamos aplicar estas técnicas.\nPerceptrones # Un perceptrón es un algoritmo que aproxima una función matemática sirve para clasificar su entrada entre dos clases. Un perceptrón puede tomar N entradas y devuelve un \u0026ldquo;Sí\u0026rdquo; o un \u0026ldquo;No\u0026rdquo;.\nSi eres un programador sin experiencia en ML, te puedes imaginar la función del perceptrón básicamente como un \u0026ldquo;IF\u0026rdquo;. Es un clasificador binario que devuelve Verdadero si el objeto en cuestión pertenece al grupo seleccionado, falso en el caso contrario.\nLa diferencia está en cómo se construye esta función, nosotros no le damos reglas programadas al perceptrón para clasificar los objetos de cierta forma, sino que le damos ejemplos etiquetados y el perceptrón aprende: ajusta los parámetros de su función interna para dividir las dos clases lo mejor posible.\nLa fórmula básica para un perceptrón es una sumatoria de todos sus parámetros de entrada multiplicados por un factor llamado peso para cada uno, más una constante llamada sesgo o bias. Al resultado de esta suma se le aplica la función de activación, normalmente la función step que devuelve 0 (equivalente a falso) si la entrada es menor o igual que cero y 1 en cualquier otro caso.\nSi llamamos X a los parámetros de entrada, W a los pesos aquí puedes ver la representación gráfica de un perceptrón:\n{: .align-center}\nY aquí la ecuación matemática que lo representa:\n{: .align-center}\nEntrenamiento # Como te podrás dar cuenta, el funcionamiento de un perceptrón es muy sencillo. Pero lo importante no es su funcionamiento cuando clasifica, sino como aprende a clasificar. Esta fase se llama entrenamiento o training y consiste en encontrar los pesos correctos para cada parámetro de entrada y el sesgo correcto.\nEl entrenamiento de un perceptrón toma un conjunto de ejemplos clasificados o etiquetados y encuentra los peso que pueden clasificar el mayor número de ejemplos correctamente. Este entrenamiento puede ser muy pesado dependiendo del número de entradas y ejemplos.\nEs justo esto lo que hace que diferencia al machine learning de la programación tradicional. Tú programaste el algoritmo para encontrar los parámetros correctos, pero nunca las reglas específicas de clasificación.\nRedes Neuronales # Una red neuronal es un conjunto de perceptrones combinados para poder clasificar en más de dos clases, y para crear funciones de clasificación que van mucho más allá de nuestro nivel de comprensión.\nLas redes neuronales generalmente usan perceptrones con una función de activación diferente, la función sigmoide que transforma cualquier entrada en un valor entre 0 y 1 (como una probabilidad).\nEn el siguiente artículo hablaremos más a detalle sobre eso.\nLas matemáticas necesarias # Para poder entender las bases de funcionamiento de todo lo que acabamos de mencionar, hay que saber trabajar con matemáticas de nivel universitario:\nÁlgebra líneal Análisis o Cálculo Vectorial Ecuaciones diferenciales Probabilidad Estadística Y, claro, todas las matemáticas que soportan estas: álgebra, trigonometría, geometría analítica, etc.\nSi quieres aprender profundamente esta área de la computación y estas técnicas y sientes que no tienes las bases matemáticas necesarias puedes estudiarlas aquí: Khan Academy en Español (gratuito) o Brilliant (de pago).\nSin embargo, y espero no ser linchado por esto, para empezar a aplicar las técnicas de manera práctica no las necesitas. Puedes abrazar la parte pragmática y algorítmica y empezar a usar los paquetes y herramientas de ML.\n","date":"25 marzo 2021","externalUrl":null,"permalink":"/2021/03/25/intro-a-machine-learning-entendiendo-el-perceptr%C3%B3n/","section":"Posts","summary":"\u003cp\u003eHablar de aprendizaje automático y los términos que lo rodean, muchas veces intimida a los desarrolladores. En esta serie de posts vamos a intentar explicar los conceptos detrás del aprendizaje automático y llevarlos a la práctica.\u003c/p\u003e","title":"Intro a Machine Learning: Entendiendo el perceptrón","type":"posts"},{"content":"","date":"25 marzo 2021","externalUrl":null,"permalink":"/tags/ml/","section":"Tags","summary":"","title":"Ml","type":"tags"},{"content":"La programación funcional tiene conceptos muy relacionados con las matemáticas. Aquí te vamos a platicar de sus orígenes y de algunos conceptos matemáticos directamente embebidos en la programación funcional.\nLo primero que tienes que recordar es que las matemáticas no tienen que ver necesariamente con números, sino con el razonamiento y la formalización de este. En este artículo hablamos más de ello: Las matemáticas que necesitas para programar.\nAhora sí, empecemos con lo más fundamental de las matemáticas que soportan la programación funcional, no sin mencionar que podemos afirmar que la programación funcional es una forma de matemáticas.\nCálculo Lambda # El cálculo lambda es una forma de definir todo lo que entendemos como matemáticas y de describir cálculos o cómputo. Es una notación que permite definir todos los elementos necesarios para crear razonamientos formales abstractos.\nEl cálculo lambda fue diseñado por Alonzo Church como una forma de responder a un problema muy profundo de las matemáticas: \u0026quot;¿Es posible encontrar una forma de computación universal que, mediante la representación de problemas y una serie de pasos definido y finitos permita resolverlos?\u0026quot;.\nEsta pregunta fue planteada por David Hilbert y se conoce como el Entscheidungsproblem, o \u0026ldquo;El problema de la decisión\u0026rdquo;. De esta pregunta se deriva toda la computación moderna, ya que para responder estas preguntas Alan Turing diseñó las Máquinas de Turing. Si quieres saber más de esto, el libro La Mente Nueva del Emperador de Roger Penrose lo explica muy bien, junto con muchas otras cosas.\nFunciones # Las funciones o abstracciones son la base del cómputo en el Cálculo Lambda y lo son también en la programación funcional. Puedes pensar en las funciones como en la parte central del cómputo, la que representa las acciones a realizar con la información introducida, que en el Cálculo lambda, siempre será otra función. Así es, no existen los número naturales, y todo se puede representar con funciones. Si quieres un idea más clara de cómo se puede lograr esto la plática de John Huges, Why Functional Programming Matters da algunos ejemplos con Lisp.\nAdemás esta plática en español explica más del Cálculo Lambda: Cálculo Lambda por Jaime Pavlich-Mariscal.\nY aquí hay un libro gratuito que puedes estudiar si quieres adentrarte más en esto: Introduction to Lambda Calculus\nCombinadores # Un combinador es una abstracción o función en el cálculo lambda, que no tiene variables libres o, en su defecto, sólo usa otros combinadores en su definición. Son funciones que sirven para crear cálculos más complejos mediante la mezcla de ellas.\nLas variables libres son las que no se reciben como parámetros. Los combinadores sirven para crear un lenguaje sobre el cálculo lambda y crear abstracciones más fácilmente y han sido el objeto de estudio de varios matemáticos.\nUno de ellos Raymond Smullyan, los enumeró poniéndoles nombres de aves, basados en las letras con las que se les identificaba y en su libro To Mock a Mockingbird los usa para crear algunos acertijos.\nPuedes aprender más de los combinadores con ejemplos en JavaScript en esta plática: Lambda Calculus - Fundamentals of Lambda Calculus \u0026amp; Functional Programming in JavaScript\nAquí hay algunos ejemplos de combinadores en JavaSCript\n// Combinador I, Idiot o función identidad const I = (x) =\u0026gt; x // Combinador K, Kestrel o función constante const K = (x) =\u0026gt; (y) =\u0026gt; x // Combinador S, Starling o función de substitución const S = f =\u0026gt; g =\u0026gt; x =\u0026gt; f (x) (g (x)) Justo de esta rama de la lógica viene el famoso Y combinator, el combinador que permite la recursión. Aquí hay artículo que explica cómo se llega a él, si te quieres ir por el hoyo del conejo: Deriving Y Combinator\nCálculo SKI # Debido a que todas las matemáticas y cosas computables se pueden expresar con los combinadores S, K e I, existe toda una rama llamada Cálculo SKI, en el que estos tres combinadores son los únicos elementos necesarios para expresar todo lo demás.\nTeoría de categorías # La teoría de categorías explora la composición de elementos y la creación de grupos con \u0026ldquo;objetos\u0026rdquo; relacionados entre ellos. Bartosz Mileswsky afirma que la teoría de categorías es muy importante para los programadores porque nos permite entender la composición y esta es la base para construir programas complejos.\nLa teoría de categorías se extiende más allá de la programación funcional, de hecho todos los sistemas de tipos de los lenguajes se comportan como una categoría. Puedes entender más de qué se trata en el libro de Bartosz Mileswsky \u0026ldquo;Category Theory for Programmers\u0026rdquo;.\n¿Y todo esto, a mi qué? # Conocer las bases de la programación funcional te puede dar un índice muy valioso como referencia a temas en los que tienes que profundizar si quieres ser un mejor programador@ funcional y tú lógica en general.\nLa programación funcional y las ideas provenientes de ella están mejorando la forma en que hacemos software, ya que dan permiten un mejor tratamiento de la información que en muchos casos es más fácil de entender que su contraparte imperativa.\nPuedes ver algunas de las características y ventajas de la programación funcional en este artículo y si quiere aprender, compilamos algunos recursos aquí: Los mejores recursos para aprender programación funcional.\n","date":"18 marzo 2021","externalUrl":null,"permalink":"/2021/03/18/las-bases-matem%C3%A1ticas-de-la-programaci%C3%B3n-funcional/","section":"Posts","summary":"\u003cp\u003eLa programación funcional tiene conceptos muy relacionados con las matemáticas. Aquí te vamos a platicar de sus orígenes y de algunos conceptos matemáticos directamente embebidos en la programación funcional.\u003c/p\u003e\n\u003cp\u003eLo primero que tienes que recordar es que las matemáticas no tienen que ver  \u003cem\u003enecesariamente\u003c/em\u003e con números, sino con el razonamiento y la \u003cem\u003eformalización\u003c/em\u003e de este. En este artículo hablamos más de ello: \u003ca\n  href=\"/2019/12/25/las-matematicas-que-debes-saber-para-programar.html\"\u003eLas matemáticas que necesitas para programar\u003c/a\u003e.\u003c/p\u003e","title":"Las bases matemáticas de la programación funcional","type":"posts"},{"content":"","date":"18 marzo 2021","externalUrl":null,"permalink":"/tags/math/","section":"Tags","summary":"","title":"Math","type":"tags"},{"content":"","date":"18 marzo 2021","externalUrl":null,"permalink":"/tags/programaci%C3%B3n-funcional/","section":"Tags","summary":"","title":"Programación-Funcional","type":"tags"},{"content":"Inspirado en el libro \u0026ldquo;Ultralearning\u0026rdquo; de Scott Young, voy hacer un proyecto de aprendizaje de algo que llama mi atención desde hace mucho: Deep Learning y Machine Learning en general. Si no conces el concepto, te invito leer el post aquí: Ultralearning: el arte del aprendizaje profundo.\nEn esta serie documentaremos las diferentes fases. Este primer post trata sobre los recursos que usaré para aprender. Si tienes alguna sugerencia, ¡todas son bienvenidas!\nFase 1: Investigación # La primera fase de un proyecto de Ultra-aprendizaje consiste en hacer una investigación sobre las posibles opciones, recursos, metas y caminos que otros han seguido para aprender lo que quieres, así como definir claramente los límites del proyecto.\nEn este proyecto el objetivo será:\nEntender y aplicar las técnicas básicas Machine Learning, en específico Deep Learning, para poder resolver problemas y aplicarlos en proyectos que lo requieran.\nAlgunos de los programas que podemos usar para aprenderlo son los siguientes:\nNanodegree de Deep Learning en Udacity Especialización en Deep Learning de Coursera Redes neuronales y Deep Learning de Coursera Programming Machine Learning de Pragmatic Programmers Machine Learning with Python: from Linear Models to Deep Learning de EDX CS230 de Stanford STAT 212B de Berkeley (Lecciones: Github) Deep Learning Crash Course en Free Code Camp Decisión # Uno de los consjos de Ultralearning es no gastar mucho tiempo investigando. No sabemos lo que no sabemos y esta incetidumbre nos puede dar parálisis por análisis y no dejar que pasemos a la siguiente etapa.\nEste proyecto estará basado en el Nanodegree de Deep Learning de Udacity por dos razones:\nProbé algunos de sus cursos y la calidad se me hace muy buena y el contenido muy bien desarrollado Puedes allí mismo optar por un certificado, lo que incluye acompañamiento de un mentor y resolución de dudas con la comunidad. esto puede servir muy bien para desatorarme si encuentro algo muy difícil. Paralelamente leeré el libro Programming Machine Learning de Pragmatic Programmers, ya que parece tener justamente el enfoque que necesito: Machine Learning para programadores.\nObjetivo final # Es hora de ponerle un tiempo y un obejetivo más concreto al proyecto: durante los próximos 10 meses (lo que resta de 2021) aprenderé las bases teóricas y prácitcas de machine learning, con el obejetivo de aplicarlo mejor en los proyectos de trabajo y combinarlo con mis habilidades de ingeniería del software y progeamación.\nSobra decir que este plan no está escrito en piedra y se irá modifcando conforme vaya experimentando y aprendiendo más del campo. Por lo mientras, espero que el proyecto y lo que vaya aprendiendo y meta-aprendiendo te sirva, como la compilación de recursos para empezar que pusimos en este post.\n","date":"6 marzo 2021","externalUrl":null,"permalink":"/2021/03/06/ruta-de-aprendizaje-deep-learning/","section":"Posts","summary":"\u003cp\u003eInspirado en el libro \u0026ldquo;Ultralearning\u0026rdquo; de Scott Young, voy hacer un proyecto de aprendizaje de algo que llama mi atención desde hace mucho: Deep Learning y Machine Learning en general. Si no conces el concepto, te invito leer el post aquí: \u003ca\n  href=\"/2019/08/13/lecciones-sobre-el-aprendizaje-de-manos-de-un-experto.html\"\u003eUltralearning: el arte del aprendizaje profundo\u003c/a\u003e.\u003c/p\u003e","title":"Ruta de aprendizaje: Deep Learning","type":"posts"},{"content":"","date":"10 febrero 2021","externalUrl":null,"permalink":"/tags/consejos/","section":"Tags","summary":"","title":"Consejos","type":"tags"},{"content":"","date":"10 febrero 2021","externalUrl":null,"permalink":"/tags/lives/","section":"Tags","summary":"","title":"Lives","type":"tags"},{"content":"","date":"10 febrero 2021","externalUrl":null,"permalink":"/tags/recomendaciones/","section":"Tags","summary":"","title":"Recomendaciones","type":"tags"},{"content":"Aquí te damos un resumen de la plática que tuvimos con Diego De Granda y Pablo Trinidad sobre algunas cosas que hicieron para conseguir buenos trabajos. Esbozaremos algunos de los consejos independientes sin una secuencia definida.\nAprende Inglés # Aunque la razón de existencia de este blog y de The Dojo MX en general es generar contenido en español para ayudar a los hispanohablantes, nunca nos cansaremos (y tampoco nuestros invitados) de darte el mismo consejo: APRENDE INGLÉS. Creemos sinceramente que el idioma no debería ser una limitante para que empieces a aprender lo que sea que te guste, pero especialmente en el área de tecnología, la mayor parte de las personas, trabaja y habla en inglés, por lo que es importantísimo aprenderlo lo mejor que puedas.\nAprende a dar y recibir retroalimentación # En este apartado hablaron de cuatro cosas que la retroalimentación debe tener para poder ser útil:\nDirecta, sin darle tantas vueltas al asunto Accionable, debes dejar a la persona con algo sobre lo que pueda actuar Oportuno, mientras más cercano estés al momento en cuestión, mejor Transparente, tus intenciones son claras Y si eres la persona que toma la retroalimentación, no te ofendas y toma lo bueno.\nThe Pragmatic Programmer # No pudimos platicar tanto de libros, pero uno que no puede faltar casi en ninguna recomendación de libros para programadores es The Pragmatic Programmer un libro sobre las bases que necesitas para ser un programador productivo.\nAprende los fundamentos # Es muy importante que aprendas los fundamentos de lo que haces si quieres atacar problemas difíciles. Para esto, tienes que aplicar consejos de otras partes de este mismo artículo.\nConsejos de Pablo Trinidad para mantenerte empleable # Permanecer presente en el aprendizaje y ser crítico: Tienes que estarte preguntando constantemente: ¿Por qué funciona lo que estoy haciendo? Y puedes aplicar la técnica de preguntar continuamente \u0026ldquo;¿Por qué?\u0026rdquo; hasta llegar al fondo de las cosas. Leer. Estudiar y aprender lo más que puedas, incluso sobre cosas que no sean ténicas. Consejos de Diego de Granda # Resiliencia: Los problemas nunca van a parar, así que tienes que aprender a solucionar problemas sin frustrarte y persistir hasta que llegues a la solución Resolver problemas: mejorar tus capacidades de resolver problemas te ayudará a ser alguien más útil para tu equipo y tu empresa Ser agnóstico: No te cases con una tecnología, diversifica y usa la correcta para el problema en cuestión. Características que necesitarás para trabajar en Google # ¿Qué se necesita para trabajar en Google? Aquí algunas de las ideas que Pablo nos compartió:\nCapacidad de tomar problemas difíciles Liderazgo para ayudar a tu equipo Impacto extendido en diferentes personas y equipos Independencia, no necesitas de un manager que te esté cuidando los pasos Ownership, te adueñas de los problemas y pones todo tu empeño en resolverlos Estar presente, es decir, no pasar por las experiencias sin aprender de ellas Sigue alimentando tu curiosidad # Pablo nos recomendó algunos canales de YouTube para seguir alimentando la curiosidad y aprender cosas de diferentes campos, como matemáticas, ciencia, computación y electrónica.\nThe Cherno Computerphile Numberphile Veritasium Smarter Everyday Eric Weinstein Joe rogan Ben Eater 3Blue1Brown Esto no te hará un mejor programador directamente pero te ayudará a crecer como persona y te ayudará a conseguir mejores oportunidades. Y sí, necesitas inglés para entenderlos.\nConclusión # Hablamos de muchas cosas más, productividad, Google, cómo avanzar en tu carrera, etc. No te pierdas la plática entera aquí:\n","date":"10 febrero 2021","externalUrl":null,"permalink":"/2021/02/10/resumen-qu%C3%A9-hacer-para-conseguir-un-buen-trabajo-como-programador/","section":"Posts","summary":"\u003cp\u003eAquí te damos un resumen de la plática que tuvimos con Diego De Granda y Pablo Trinidad sobre algunas cosas que hicieron para conseguir buenos trabajos. Esbozaremos algunos de los consejos independientes sin una secuencia definida.\u003c/p\u003e","title":"Resumen: Qué hacer para conseguir un buen trabajo como programador","type":"posts"},{"content":"","date":"10 febrero 2021","externalUrl":null,"permalink":"/tags/video/","section":"Tags","summary":"","title":"Video","type":"tags"},{"content":"","date":"1 febrero 2021","externalUrl":null,"permalink":"/tags/data-science/","section":"Tags","summary":"","title":"Data-Science","type":"tags"},{"content":"Creemos firmemente que una de las mejores maneras de educarte como desarrollador es conseguir guía clara.\nUna de las mejores fuentes de conocimiento son los libros escritos por personas expertas en el tema del que quieres aprender, es por eso siempre buscamos personas que nos den consejos sobre los mejores recursos que encuentren.\nEn esta ocasión invitamos a Yesi Days a platicar sobre qué libros nos recomendaría para desarrollarte en data science. Nos recomendó los siguientes:\nHands-on Machine Learning with Scikit-Learn and Tensorflow\nThe Hundred Page Machine Learning\nIntroduction to Machine Learning with Python: A Guide for Data Scientists\nData Science from Scratch: First Principles with Python\nCracking the PM Interview: How to Land a Product Manager Job in Technology (Cracking the Interview \u0026amp; Career)\nBuilding Real-time data pipelines\nData science Path # Yesi también nos contó sobre un guía que creó para ayuddarte a empezar en el camino, la puedes encontrar en:Data Science Path y próximamente estará en español.\nLa charla que tuvimos con ella se extendió sobre muchos temas más, si no te la quieres perder la puedes ver aquí:\n","date":"1 febrero 2021","externalUrl":null,"permalink":"/2021/02/01/libros-que-te-ayudar%C3%A1n-a-aprender-data-science/","section":"Posts","summary":"\u003cp\u003eCreemos firmemente que una de las mejores maneras de educarte como desarrollador es conseguir guía clara.\u003c/p\u003e\n\u003cp\u003eUna de las mejores fuentes de conocimiento son los libros escritos por personas expertas en el tema del que quieres aprender, es por eso siempre buscamos personas que nos den consejos sobre los mejores recursos que encuentren.\u003c/p\u003e","title":"Libros que te ayudarán a aprender Data Science","type":"posts"},{"content":"Cuando hablamos de los comentarios en el código, hay dos escuelas. La primera dice que debes usar los comentarios para clarificar lo que quisiste expresar con tu código, mientras que la segunda dice que deberías evitarlos al máximo y que comentar tu código es un mal necesario que sólo denota tu falta de habilidad para no hacer código lo suficientemente claro.\n¿A cuál de los dos consejos deberías hacerle caso? En este artículo explicaremos por qué creemos que deberías ver los comentarios como una herramienta necesaria, valiosa y muy útil, y cómo usarlos para no caer en el extremo que ha llevado a algunas personas a tener una mala actitud hacia ellos.\nUn sistema sin documentación esta incompleto # Como desarrollador estarás de acuerdo en que un sistema no tiene la calidad suficiente si no cuenta con documentación, es decir, información acerca del sistema que comunique cosas como la razón de existir de ciertos módulos, valores y funciones y cómo usarlos.\nSi, además, tienes que modificar este sistema, será una pesadilla entender todo lo que los programadores anteriores hicieron o intentaron hacer. Si tienes que usar algo sin documentación, es el mismo caso: tienes estudiar el código para saber como funciona.\nAsí que hemos establecido que la documentación es completamente necesaria para crear programas útiles. Ahora bien, ¿dónde ponemos esa documentación? Muchos desarrolladores y equipos no tienen idea de dónde ponerla y crean documentos que dejan después olvidados en una carpeta en la nube y que nadie encuentra después. Pero, ¿no sería más lógico mantener la documentación lo más cerca posible del código? Eso es precisamente lo que los comentarios te permiten hacer.\nPuedes usar los comentarios documentar:\nDecisiones de diseño Explicaciones sobre la existencia, funcionamiento o razón de ser de cierta parte del código Las interfaces y su ejemplo de uso Efectos de usar cierto código Partes inconclusas o que se pueden mejorar (TODO\u0026rsquo;s) Tener esta información muy cerca del código sobre el que está proporcionando información ayudará a que sea fácil de encontrar y además, si se establecen reglas como tratar los comentarios como ciudadanos de primer rango, se mantendrá actualizado y útil.\nTambién es buena idea tener un documento o sitio web especializado en documentación que te ayude a encontrar rápido lo que buscas como Docusaurus o un sitio generado por Sophinx. Puedes utilizar esta misma documentación que escribiste junto al código si usaste el estilo definido por el lenguaje de programación o por las herramientas de generación de documentos.\nLos comentarios te pueden ayudar en el futuro # Incluso aunque no los uses formalmente como documentación, los comentarios estarán ahí para darte información y recordarte lo que hiciste, pero sobre todo por qué lo hiciste.\nRecuerda que la mente humana busca la eficiencia máxima de recursos, por lo que es probable que elimine información que no ocupe inmediatamente y que no recuerdas a menudo, como por qué esa variable tenía el valor 730 y no otro.\nTu yo futuro y tu equipo te agradecerán haber escrito esos comentarios que te informan sobre lo que estabas pensando en el momento que escribiste ese código.\nLos comentarios son una buena herramienta de diseño # John Ousterhout, en \u0026ldquo;A Philosophy of Software Design\u0026rdquo; recomienda empezar con los comentarios antes de programar (de esto hablaremos más adelante). Pero, ¿por qué lo recomienda?\nEscribir en un lenguaje humano cómo funciona algo antes de implementarlo realmente, te da la capacidad de ver si es lógico y suficiente, además te permite ponerte en los zapatos del usuario para notar deficiencias sobre todo en la interfaz. Los comentarios de interfaz es lo primero que deberías crear porque te servirán de guía para avanzar con tu diseño y, sobre todo, que sea lógico y fácil de usar.\nUna buena guía: si no eres capaz de crear un comentario concreto y corto sobre cómo funciona o por qué existe algo, lo más probable es que tengas que re-pensar tu diseño.\nEl lenguaje de programación no es suficiente para expresar todo lo necesario # Todos los lenguajes de programación están pensados para ser un subconjunto del lenguaje humano que elimine las ambigüedades, manteniendo el mayor poder expresivo posible. Esto nos lleva a sus limitantes: es imposible, o por lo menos impráctico, intentar expresar todas las ideas con el código.\nEn la práctica, el tiempo y los recursos para lograr algo son limitados, por lo que a veces es más conveniente y fácil para todos explicar lenguaje humano algo que intentar expresarlo con código, como los puristas afirman.\nNo te sientas mal si tienes que recurrir de vez en cuando a explicar la forma en que funciona algo, siempre y cuando no sea la práctica común.\n¿Cómo usar los comentarios para que sean valiosos? # No todos los comentarios son valiosos, hay algunos que pueden estorbar más de lo que ayudan, por ejemplo, los que no aportan información a lo que es obvio en el código.\nHablemos de algunas formas de aprovecharlos lo mejor posible para que contribuyan positivamente a aumentar la calidad del proyecto.\nEscribe los comentarios primero # Una de las partes más importantes de los comentarios como documentación es que deben ser concretos, cercanos a la realidad y que proporcionen la mayor cantidad de información útil posible.\nPara lograr esto, se tienen que crear lo más cerca que puedas a la creación del código. Pero como todos sabemos que después de escribir y probar (básicamente) el código vamos a sentir que ya está terminado, es buena práctica obligarte a escribirlos antes, justo como propone TDD con las pruebas.\nDe esta manera te asegurarás que tu código esté documentado incluso antes de escribirlo y te servirán como una herramienta de diseño que te ayudará a pensar mejor en la usabilidad de tus módulos y piezas de software.\nCrea comentarios acerca de la interfaz # La interfaz es el medio de uso que tus módulos o funciones presentan para que las demás partes de tu sistema lo usen. Lo primero que deberías documentar y explicar es esta interfaz, para que más personas a parte de ti puedan usar este pedazo de código.\nDebes escribir comentarios claros sobre:\nCómo usar esa pieza de código Por qué existe esa parte del sistema Qué efectos tiene usarla Este tipo de comentarios son los que aportan mayor valor al sistema y si están lo suficientemente completos, con ejemplos y explicaciones claras, son una documentación válida que está en un muy buen lugar: es fácil de encontrar y no se va a perder enterrada entre otros documentes que después nadie va a consultar.\nEvita los comentarios sobre la implementación # Los comentarios sobre la implementación son aquello que describen qué estas haciendo, como por ejemplo, sumar número, abrir un archivo, etc. Estos comentarios normalmente son innecesarios, ya que lo que se está haciendo es obvio si el código es lo suficientemente expresivo y siempre deberíamos buscar que sea así.\nDe hecho, estos son los comentarios que hacen que la gente odie a los comentarios en general, pues en vez de proporcionar información extra son una carga que hay que mantener y pueden confundir si no son actualizados.\nSi realmente sientes que tienes que explicar qué estás haciendo con cierta pieza de código, primero pregúntate si no hay una manera de reescribirlo para que sea obvio. Si no existe o no es práctica esta solución, entonces escribe el comentario de la manera más concisa posible, incluyendo la razón de la existencia de ese código.\nPara hacer esto debes tomar muy en cuenta los recursos del proyecto: no te puedes tardar el triple del tiempo implementando la pieza de código perfecta porque no quieres escribir un comentario que explique cómo funciona.\nConclusión # Escribir comentarios es una de las grandes tareas que los programadores debemos dominar. Los lenguajes de programación y los entornos de programación cada vez le dan más poder a esta parte de los programas y permiten incluso escribir pruebas en ellos, generar documentación automática y listar tareas a partir de ellos.\nSi pones el suficiente esmero en aprender a escribir buenos comentarios y mantenerlos, serán una gran herramienta de diseño y documentación de tu software.\nEste artículo está basado en las ideas del \u0026ldquo;A Philosophy of Software Design de John Ousterhout\u0026rdquo;, en el que se le dedican 4 capítulos al buen uso de los comentarios.\n","date":"30 diciembre 2020","externalUrl":null,"permalink":"/2020/12/30/deber%C3%ADas-comentar-tu-c%C3%B3digo/","section":"Posts","summary":"\u003cp\u003eCuando hablamos de los comentarios en el código, hay dos escuelas. La primera dice que debes usar los comentarios para \u003cstrong\u003eclarificar lo que quisiste expresar con tu código\u003c/strong\u003e, mientras que la segunda dice que deberías \u003cstrong\u003eevitarlos al máximo\u003c/strong\u003e y que comentar tu código es un mal necesario que sólo denota tu falta de habilidad para no hacer código lo suficientemente claro.\u003c/p\u003e","title":"¿Deberías comentar tu código?","type":"posts"},{"content":"Los modelos generativos permiten a una máquina \u0026ldquo;aprender\u0026rdquo; los patrones que existen en los datos con los que son entrenadas y a partir de dicho aprendizaje, son capaces de generar datos similares que en algunos casos pueden ser casi tan \u0026ldquo;reales\u0026rdquo; como los que se utilizaron inicialmente para su entrenamiento.\nMediante este tipo de modelos pueden generarse nuevos datos que tienen distintas aplicaciones, entre ellas, generar datos que otros sistemas de aprendizaje podrán utilizar para su entrenamiento, sin necesidad de que dichos datos existan previamente.\nEn particular, las Redes Neuronales Generativas Adversariales (GAN\u0026rsquo;s) pueden generar nuevas imágenes que se parecen o son similares a las imágenes con las que fueron entrenadas, pero que individualmente son distintas a todas ellas.\nEl funcionamiento de una Red Neuronal Adversarial consiste en la operación simultánea de dos redes neuronales que son \u0026ldquo;adversarias\u0026rdquo;, una de dichas redes es la encargada de generar imágenes y la segunda es la encargada de discriminar aquellas imágenes que no se parecen a lo que constituye una imágen real.\nAlgunos modelos avanzados pueden verse en:\nThis Person Does Not Exist This Waifu Does Not Exist This Furson Does Not Exist Como parte de un proyecto de investigación, utilizamos una red adversarial para generar imágenes de zapatos, dichas redes utilizan, modelos convolucionales para ir entendiendo las imágenes en segmentos cada vez más pequeños hasta tener una definición y similitud suficiente para reemplazar la imagen original.\nLa calidad de los modelos generados se incrementa conforme el número de iteraciones va aumentando, en general, se van almacenando nuevas muestras de las imágenes generadas cada cierto número de iteraciones de tal forma se puede observar si el modelo sigue mejorando, si ya se estancó o si se está degradando, aunque existen algunas métricas que pueden ayudar a identificar el punto óptimo donde puede detenerse el entrenamiento.\nAlgunas de las peculiaridades de estos modelos es que son relativamente sensibles a la uniformidad y el número de imágenes utilizadas, sin embargo, también es cierto que los modelos han ido mejorando y en algunos casos pueden generar imágenes de gran calidad con menos datos de entrenamiento. Por ejemplo, estas imágenes fueron generadas con sólo 500 datos de entrenamiento mediante un Modelo Generador Adversarial Eficiente:\nData Efficient GANs\nUsos de los generadores adversariales # Hablemos de algunos de los usos que pueden tener en la práctica este tipo de redes.\nMejorar la seguridad # Un discriminador optimiza su capacidad para detectar imágenes que no son reales (las que emite el generador), de tal forma que dicho discriminador adquiere la capacidad de identificar imágenes que no son reales y que pueden estar siendo utilizadas para generar identidades falsas en sistemas que por ejemplo requieren fotografías.\nEn el sector salud # La capacidad de detectar anomalías (trabajo del discriminador) puede utilizarse para identificar células o formaciones anómalas (como el cáncer) al ser entrenado mediante imágenes de tejidos u órganos saludables.\nEn el sector de medios digitales # Ya que generadores adversariales pueden utilizarse para generar imágenes que no existían o generar imágenes a partir de un conjunto de imágenes preexistentes, dicha generación puede de igual forma generar modelos en tercera dimensión a partir de imágenes en dos dimensiones o hacer combinaciones de modelos preexistentes.\nEsto puede usarse como material para la producción de contenido visual e incluso animaciones de video o bien como inspiración para que un diseñador genere nuevos personajes.\nAlgunos generadores pueden ayudar a corregir defectos en imágenes, removiendo o completando partes de la imágen que sobraban o que estaban faltantes, o si es el caso, a dar color a imágenes en blanco y negro.\nDe igual forma permiten crear una “interpolación” de imágenes para “regenerarlas” en una mayor resolución. Desde luego la eficacia dependerá de las imágenes utilizadas para su entrenamiento.\nAlgunas de estas aplicaciones pueden “traducir” las imágenes de un dominio a otro, por ejemplo, convirtiendo una imágen satelital en un mapa de niveles o generando fotografías a partir de bosquejos.\nConclusión # Los modelos generativos pueden ser una gran herramienta para diferentes industrias, aprender a usarlos y generarlos te puede ayudar a entrar en un campo que tiene cada vez más alta demanda: el uso de datos para la creación automática de programas (Machine Learning).\n","date":"30 diciembre 2020","externalUrl":null,"permalink":"/2020/12/30/qu%C3%A9-son-los-modelos-generativos/","section":"Posts","summary":"\u003cp\u003eLos modelos generativos permiten a una máquina \u0026ldquo;aprender\u0026rdquo; los patrones que existen en los datos con los que son entrenadas y a partir de dicho aprendizaje, son capaces de \u003cstrong\u003egenerar datos similares\u003c/strong\u003e que en algunos casos pueden ser casi tan \u0026ldquo;reales\u0026rdquo; como los que se utilizaron inicialmente para su entrenamiento.\u003c/p\u003e","title":"¿Qué son los modelos generativos?","type":"posts"},{"content":"","date":"30 diciembre 2020","externalUrl":null,"permalink":"/tags/c%C3%B3digo-mantenible/","section":"Tags","summary":"","title":"Código-Mantenible","type":"tags"},{"content":"","date":"30 diciembre 2020","externalUrl":null,"permalink":"/tags/comentarios/","section":"Tags","summary":"","title":"Comentarios","type":"tags"},{"content":"","date":"30 diciembre 2020","externalUrl":null,"permalink":"/tags/comments/","section":"Tags","summary":"","title":"Comments","type":"tags"},{"content":"","date":"30 diciembre 2020","externalUrl":null,"permalink":"/tags/gans/","section":"Tags","summary":"","title":"Gans","type":"tags"},{"content":"","date":"30 diciembre 2020","externalUrl":null,"permalink":"/tags/mantenibilidad/","section":"Tags","summary":"","title":"Mantenibilidad","type":"tags"},{"content":"","date":"3 diciembre 2020","externalUrl":null,"permalink":"/tags/3-des/","section":"Tags","summary":"","title":"3-Des","type":"tags"},{"content":"","date":"3 diciembre 2020","externalUrl":null,"permalink":"/tags/cryptograf%C3%ADa/","section":"Tags","summary":"","title":"Cryptografía","type":"tags"},{"content":"","date":"3 diciembre 2020","externalUrl":null,"permalink":"/tags/des/","section":"Tags","summary":"","title":"Des","type":"tags"},{"content":"","date":"3 diciembre 2020","externalUrl":null,"permalink":"/tags/serpent/","section":"Tags","summary":"","title":"Serpent","type":"tags"},{"content":"Ya hablamos de lo que es la criptografía, ahora empecemos a hablar de los tipos de algoritmos criptográficos que existen, sus características y sus principales diferencias. En este artículo hablaremos de los cifrados de bloque.\n¿Qué es un cifrado de bloque? # Los cifrados de bloque trabajan sobre un conjunto de bits de tamaño fijo, produciendo un texto cifrado del mismo tamaño. Para cifrar datos de tamaño arbitrario como sucede en la vida real, se utiliza el algoritmo de cifrado de bloque combinado con diferentes técnicas llamadas Modos de Operación.\nAlgunos ejemplos de estos algoritmos de cifrado son el DES (Estadounidense), GOST 28147-89 (Ruso) y el actual AES.\nUn bloque cifrado debe ser permutación pseudo-aleatoria de bits, es decir, un conjunto de bits que sean indistinguibles de bits generados completamente de manera aleatoria. Es como si aventaras un montón de bits y dijeras que esa es la salida de tu algoritmo.\nEsta propiedad evita que un atacante obtenga información sobre el contenido del mensaje que fue cifrado.\nEjemplos de Cifrado de Bloque # Veamos algunos ejemplos de cifrados de bloque y sus características principales. Algunos se usan mientras que otros ya cayeron en el olvido.\nDES y Triple DES # El Data Encryption Standard era el algoritmo que más se usaba en la década de los 90, lo suficientemente seguro para el poder de cómputo de aquel entonces. Usa una llave de 56 bits y bloques de 64 bits. Debido a estas características, el poder de cómputo actual hace que sea demasiado fácil de romper con el suficiente poder computacional (2^56, el tamaño de la llave, no se considera seguro ya), así que su uso está completamente desrecomendado.\nSu sucesor, el Triple DES realiza tres veces el mismo proceso usando tres llaves diferentes, con un tamaño de llave de 168 bits. Esto evita que sea posible romperlo a base de fuerza bruta, pero este proceso provee solamente una seguridad de 112 bits, por lo que se considera ineficiente (usas el cómputo de tres DES para obtener seguridad de una llave del doble de tamaño) y por lo tanto su uso no es recomendado también.\nAES # Debido a las visibles fallas de DES y triple DES, la NIST (National Institute of Standards and Technology de Estados Unidos) quería un algoritmo de cifrado que fuera dado a conocer públicamente y \u0026ldquo;capaz de proteger la información sensible del gobierno por los próximos cien años\u0026rdquo;.\nEl Advanced Encryption Standard (Estándar de cifrado avanzado), es en realidad un subconjunto de los cifrados posibles de otro algoritmo llamado Rijndael y que fue el ganador del concurso que la NIST hizo para seleccionar el nuevo algoritmo de cifrado estándar que sustituiría a DES.\nRijndael fue creado por analistas criptográficos Belgas con objetivos claros: que fuera rápido y simple. Es una familia de cifrados que permiten cifrar bloques en múltiplos de 32 bits, desde 128 hasta 256 bits (128, 160, 192, 224, 256 bits). Las longitudes de llaves posibles son los mismos desde 128 hasta 256 bits.\nAES es Rijndael con bloques de 128 bits y llaves que pueden ser de 128, 192 o 256 bits.\nAES aplica internamente una misma operación múltiples veces dependiendo del tamaño de la llave, y esto le permite se más seguro aumentando el tamaño de la llave. Esto es lo que se conoce como los \u0026ldquo;rounds\u0026rdquo; de AES, usando 10 para llaves de 128 bits, 12 para 192 bits y 14 para 256 bits.\nAES tiene un diseño de operaciones concurrentes, que es fácilmente paralelizable y puede implementarse muy eficientemente en hardware, de hecho los procesadores modernos normalmente lo traen implementado en sus circuitos, es parte del conjunto de instrucciones del procesador.\nLa seguridad de AES según ciertos criptanalistas (por ejemplo, los creadores de Twofish) está completamente rota teóricamente, ya que hay ataques que pueden romper el cifrado de 14 ciclos (los ciclos completos que hace la versión de la llave de 256 bits) con ciertas condiciones, con 2^176 operaciones (lo cuál es un ataque que no se puede llevar a la práctica fácilmente).\nLos ataques mencionados anteriormente no tienen nada de prácticos, es decir, no se pueden llevar a la realidad en entornos normales, por lo que no se piensa por ningún lado que la seguridad de AES está comprometida. Si necesitas un algoritmo de cifrado confiable y rápido, con AES no te puedes equivocar.\nOtros algoritmos # Como finalistas del concurso de la NIST hay otros algoritmos que vale la pena mencionar:\nSerpent. Es un algoritmo de cifrado de bloque que está pensado completamente para ser resistente. Aplicaca una operación repetidamente (rounds) pero a diferencia de AES la aplica 32 veces. Los criptanalistas han logrado romper 12 de esos 32 rounds, por lo que se piensa que tiene bastante espacio de reserva para continuar siendo seguro. La desventaja contra AES es que es 3 veces más lento.\nTwoFish. Este algoritmo tiene una construcción parecida a DES, y aplica su operación básica 16 veces. Los autores del algoritmo mencionan que es casi tan rápido como AES pero ofreciendo más margen de seguridad.\nModos de operación # Un modo de operación es la forma en que se aplica un cifrado de bloque a un texto no cifrado que no es del tamaño exacto del bloque. Existen diferentes técnicas para hacer hacer que un algoritmo que acepta bloques de tamaño fijo acepte bloques arbitrarios. Los más conocidos son:\nElectronic Codebook (ECB). Este modo de operación parte el contenido en bloques del tamaño aceptado (rellenando los bits faltantes para hacer un múltiplo exacto) y manda cada bloque a cifrar de manera independiente. Este modo de operación está completamente prohibido si quieres hacer que tu programa sea seguro, ya que bloques en tu mensaje con el mismo contenido siempre dará el mismo resultado, dando pistas sobre la información subyacente a observadores meticulosos. NO USES POR NINGÚN MOTIVO AES EN ECB.\nCypher Block Chaining (CBC). Este modo de igual manera parte el contenido en bloques del tamaño aceptado, pero en vez de cifrar cada bloque independientemente cifra el resultado de aplicar la operación XOR con el resultado del bloque anterior. De esta manera \u0026ldquo;encadena\u0026rdquo; los bloques haciendo que cada bloque dependa de los anteriores. Para cifrar el primer bloque utiliza un valor inicial generado de manera aleatoria. Para descifrar el valor se tiene que pasar el valor inicial aleatorio junto con el texto cifrado.\nCounter mode (CTR). En este modo de operación no se cifran los bloques de texto sino la combinación de un número de uso único (nonce) y un contador (de ahí su nombre). Después, ese cifrado se combina con un bloque del mensaje. El contador se aumenta en cada bloque del mensaje, mientras que el número de uso único sólo cambia entre cifrados de diferentes mensajes. El modo contador no requiere relleno, ya que la operación XOR se puede realizar con contenido de cualquier tamaño. Este es el modo de operación más rápido y elegante, pero es muy fácil de usar mal ya que la repetición de nonces lo hace vulnerable.\nCompletado de bloques # Los modos de operación ECB y CBC siguen requiriendo bloques del tamaño aceptado por el algoritmo, por lo que deben existir técnicas para completar mensajes que no sean del tamaño de un múltiplo del bloque. Hablaremos de dos:\nRelleno (padding). Esta técnica completa el último bloque del contenido que no alcanza el tamaño requerido con bytes que comunican el número de bytes que se están rellenando. Ejemplo: Si faltan 15 bytes para rellenar el mensaje agrega 15 bytes con el valor 0f, si falta un sólo byte agrega un byte con 01. Esta técnica sólo funciona para mensajes que construído de bytes completos. Puedes ver una especificación aquí: RFC 5652\nRobo de texto cifrado (cyphertext stealing). Esta técnica es un poco más compleja pero más flexible. Consiste básicamente en tomar los bits que falten para el último bloque del texto cifrado anterior y dejar los bits no usados de ese mismo mensaje como el último bloque cifrado. Es un poco más complicado que esto, pero la idea básica aquí está. La NIST menciona tres formas de implementarlo aquí.\n¿Qué algoritmo debería usar? # La respuesta corta: AES con el mayor de tamaño de llave que tus recursos te permitan. Si tienes restricciones más fuertes de seguridad puedes pensar en TwoFish o Serpent, pero debes tener en cuenta que al no ser tan populares como AES puede que sus implementaciones en el lenguaje de programación de tu elección no estén disponibles o tengan vulnerabilidades no conocidas.\n","date":"3 diciembre 2020","externalUrl":null,"permalink":"/2020/12/03/tipos-de-algoritmos-criptogr%C3%A1ficos-cifrados-de-bloque/","section":"Posts","summary":"\u003cp\u003eYa hablamos de lo que es \u003ca\n  href=\"/2019/11/12/criptografia-basica-para-programadores-que-es-la-criptografia.html\"\u003ela criptografía\u003c/a\u003e, ahora empecemos a hablar de los tipos de\nalgoritmos criptográficos que existen, sus características y sus principales diferencias. En este artículo hablaremos de los cifrados de bloque.\u003c/p\u003e","title":"Tipos de algoritmos criptográficos: cifrados de bloque","type":"posts"},{"content":"","date":"19 octubre 2020","externalUrl":null,"permalink":"/tags/deuda-t%C3%A9cnica/","section":"Tags","summary":"","title":"Deuda-Técnica","type":"tags"},{"content":"Tuvimos una plática con Sagrario Meneses sobre la deuda técnica y cómo podemos atacarla. En este artículo te presentamos un pequeño resumen de lo que es y algunas sugerencias sobre su manejo.\n¿Qué es la deuda técnica? # La definición corta de deuda técnica es: todo aquello que hace que el software sea más difícil de producir y desarrollar.\nLa deuda técnica es invisible para los miembros no directamente relacionados con el desarrollo del proyecto; para los que participan en ellos no siempre es fácil de ver.\nEsto incluye algunas cosas concretas como:\nLos valores fijos que pueden cambiar en el futuro y en realidad deberían ser fáciles de cambiar sin tener que modificar el código (hardcoding)\nFalta de información: cuando nadie sabe sobre cómo trabaja cierta parte del sistema o qué hace cierta pieza de código\nFalta de distribución de información y conocimiento: cuando muy pocas personas saben sobre una parte del sistema y se convierten en cuello de botella\nFalta de diseño explícito\nMalas elecciones sobre diseño o tecnologías\nMezcla de diseños y estilos de programación diferente sin guía\nBugs que nadie conoce\nSagrario comparó la deuda técnica con deberle dinero a la mafia: no la puedes negociar, y cuando te supera estás en grandes problemas. Así que más vale que la aprendamos a controlar porque la deuda técnica puede hacer colapsar tu sistema.\nFormas de hacer visible la deuda técnica # Una forma que nos parece súper efectiva para hacer visible (literalmente) la deuda técnica: ponerlo en tablero de control en un espacio, idealmente, físico, que esté a la vista tanto del equipo técnico como del equipo administrativo. Este tablero fosforescente recordará a todos que hay temas importantes para atender antes de que la mafia venga a cobrarte.\nEn el caso de equipos remotos, el sustituto es un tablero de la herramienta de control que uses (Jira, Trello, Asana, Monday) que contenga temas importantes con respecto a las cosas que se pueden mejorar del sistema.\nFinalmente, tus herramientas de desarrollo te pueden dar ideas valiosas de las cosas que tienes que mejorar de tu código:\nTe ayudan a listar las tareas pendientes (TODO\u0026rsquo;s) Te advierten sobre posibles problemas de código Si tienes una guía de estilo configurada, te dan advertencias sobre este punto también. Prácticas para evitarla y dominarla # Para poder reducir la deuda técnica hacen falta dos cosas:\nPruebas, principalmente unitarias. Esto permitirá encontrar los errores más rápidamente, pero además refactorizar sin miedo. Lineamientos estrictos respecto a las acciones en el proyecto. Sagrario lo llamó disciplina, es decir, tener reglas y los procesos necesarios para hacer que estas reglas sean seguidas. Otros temas # También, hablamos de otros temas como el rol de arquitecta de software que tiene en Linio. De esto podemos sacar dos cosas relevantes:\nAunque no se se sentía completamente lista para el puesto, aplicó para obtenerlo, y por eso está en una posición en la que está aprendiendo mucho. Sin miedo al éxito. A veces la ataca el síndrome del impostor, con el que siente que no pertenece allí, pero continua trabajando y estudiando. Mantiene la humildad sabiendo que no por tener el \u0026ldquo;título\u0026rdquo; es todopoderosa y ahora tiene autoridad sobre todos. Conclusión # Disfrutamos mucho la plática con una experimentada desarrolladora de software que ha ido tomando nuevos roles y responsabilidades en la misma empresa, que también se ha ido transformando. Puedes aprender mucho de ella y de las preguntas que se hicieron en vivo:\n","date":"19 octubre 2020","externalUrl":null,"permalink":"/2020/10/19/or%C3%ADgenes-de-la-deuda-t%C3%A9cnica/","section":"Posts","summary":"\u003cp\u003eTuvimos una plática con \u003ca\n  href=\"https://twitter.com/sagmmd\"\n    target=\"_blank\"\n  \u003eSagrario Meneses\u003c/a\u003e sobre la \u003cstrong\u003edeuda técnica\u003c/strong\u003e y cómo podemos atacarla. En este artículo te presentamos un pequeño resumen de lo que es y algunas sugerencias sobre su manejo.\u003c/p\u003e","title":"Orígenes de la deuda técnica","type":"posts"},{"content":"En este artículo veremos algunas de las ideas que George Polya presenta en su libro How to Solve It sobre la resolución de problemas.\nEstas ideas son sacadas del apartado \u0026ldquo;Aforismos y citas\u0026rdquo;, esperemos que pueda ayudar mejorar tus habilidades de resolución de problemas o que te saque del bache si te encuentras en uno.\nCada subtítulo es una frase que consideramos que vale la pena analizar más detalladamente.\nPiensa en el fin antes de que empieces # El tonto mira el principio, pero el sabio mira el final.\nEstas dos frases nos recuerdan que es muy importante:\nEntender completamente el problema a resolver antes de empezar a intentar resolverlo. Tener verdadero interés en el resolver el problema (Polya dice que debemos desear resolver el problema). En el caso de los problemas prácticos, es decir, a los que nos enfrentamos cada día en el desarrollo de software (no matemáticos, ni acertijos), se recalca que incluso hay que definir y aclarar algunas cosas que no se tienen desde el principio. Es necesario aclarar conceptos, investigar, a veces, el verdadero objetivo y muchas veces descomponer el problema en problemas más pequeños y fáciles de resolver.\nLa diligencia es la madre de la buena suerte # Muchas veces, parece que las ideas de resolución de un problema nos llegan como por arte de magia a la cabeza, por buena suerte o gratis. Polya dice que una precondición para tengamos estas buenas ideas es que las debemos merecer.\n¿Cómo nos hacemos \u0026ldquo;merecedores\u0026rdquo; de tener buenas ideas?\nUn roble no cae con la primera estocada\nDebemos persistir en buscar diferentes maneras de resolver el problema, entenderlo completamente como hemos mencionado y aplicar diferentes formas y técnicas de resolución, que hemos visto en otros artículos.\nDebemos hacer lo que podamos si no podemos hacer lo que debemos\nIntentar por diferentes medios incluso después de fallar es una forma de merecer que nos lleguen nuevas ideas.\nUn sabio convierte oportunidades en buena fortuna\nEsta última frase se menciona por lo importante que es NO despreciar ninguna de las ideas que nos vengan a la cabeza, por simple o tonta que parezca. Alguien experimentado en resolver problemas puede que no tenga más ideas en total que alguien no experimentado, pero sabe reconocer mejor ideas prometedoras.\nUn retraso sabio hace la carretera segura # Esta frase nos recuerda la importancia de no apresurarnos a ejecutar un plan que parece perfecto para llegar a una solución. Según la propuesta de Polya para resolver problemas (entendimiento, planeación, ejecución, revisión), la parte más difícil de lograr es el plan, pero la parte en la que más trabajo se lleva es la ejecución de ese plan. Por tu experiencia en desarrollo de software tal vez ya lo sepas.\nPero al encontrar lo que parece un buen plan no conviene ejecutarlo lo más rápido posible sin darle al menos una segunda revisión. Tenemos que recordar que:\nCreemos muy pronto lo que anhelamos\nNuestro juicio puede nublarse si deseamos salir muy rápido de algo y podemos caer en la trampa de creer muy fácilmente en un plan de resolución no tan sólido.\n¿A qué te recuerda esto de pensarlo muy bien antes de comprometerse completamente con una solución? En el desarrollo de software hacer pruebas de concepto, prototipos y simulaciones es una muy buena forma de evaluar un plan de solución antes de comprometer todos los recursos para la creación de esa solución.\nMira alrededor cuando obtengas tu primer hongo o tu primer descubrimiento: crecen en grupos # ¿Te suena? Muchas veces las soluciones a diferentes problemas, o a diferentes partes del problema se encuentran muy cerca entre ellas, o son una variación de la solución, aplicación del resultado o aplicación del método de resolución.\nPregunta Qué, Por qué, Dónde, Cuándo y cómo # Finalmente, esta frase habla de la importancia de hacer el mayor número de preguntas posibles sobre el problema en cuestión, pregunta, pregunta, pregunta hasta que tengas toda la información.\nConclusión # Repasa estas ideas cuando te sientas atorado para resolver algún problema y puede que te ayuden a salir del hoyo. Y sobre todo, lee \u0026ldquo;How to Solve It\u0026rdquo;.\n","date":"4 octubre 2020","externalUrl":null,"permalink":"/2020/10/04/algunas-ideas-sobre-la-resoluci%C3%B3n-de-problemas/","section":"Posts","summary":"\u003cp\u003eEn este artículo veremos algunas de las ideas que George Polya presenta en su libro \u003ca\n  href=\"https://amzn.to/33qfw07\"\n    target=\"_blank\"\n  \u003eHow to Solve It\u003c/a\u003e sobre la resolución de problemas.\u003c/p\u003e\n\u003cp\u003eEstas ideas son sacadas del apartado \u0026ldquo;Aforismos y citas\u0026rdquo;, esperemos que pueda ayudar mejorar tus habilidades de resolución de problemas o que te saque del bache si te encuentras en uno.\u003c/p\u003e","title":"Algunas ideas sobre la resolución de problemas","type":"posts"},{"content":"","date":"4 octubre 2020","externalUrl":null,"permalink":"/tags/heur%C3%ADstica/","section":"Tags","summary":"","title":"Heurística","type":"tags"},{"content":"","date":"4 octubre 2020","externalUrl":null,"permalink":"/tags/how-to-solve-it/","section":"Tags","summary":"","title":"How-to-Solve-It","type":"tags"},{"content":"","date":"4 octubre 2020","externalUrl":null,"permalink":"/tags/polya/","section":"Tags","summary":"","title":"Polya","type":"tags"},{"content":"","date":"4 octubre 2020","externalUrl":null,"permalink":"/tags/problemas/","section":"Tags","summary":"","title":"Problemas","type":"tags"},{"content":"","date":"4 octubre 2020","externalUrl":null,"permalink":"/tags/resoluci%C3%B3n/","section":"Tags","summary":"","title":"Resolución","type":"tags"},{"content":"","date":"20 septiembre 2020","externalUrl":null,"permalink":"/tags/beego/","section":"Tags","summary":"","title":"Beego","type":"tags"},{"content":"Go es uno de los lenguajes modernos más usados. Ya hablamos de por qué deberías aprenderlo.\nAhora hablemos de un caso de uso práctico: úsalo para crear una API HTTP. En este artículo nos enfocaremos en la parte de comunicación HTTP y la generación de respuestas adecuadas.\nLa funcionalidad básica de tu API puede o no adaptarse completamente a Go (no es es tan fácil de escribir como un lenguaje dinámico como Python), pero definitivamente es un lenguaje excelente para crear interfaces de comunicación web, debido a su alto rendimiento y eficiencia.\nPuedes ver algunas de las comparativas en los siguientes artículos:\nComparando el rendimiento de Go, NodeJS y Elixir. TL;DR: Go y Elixir llegan a manejar más de 100k conexiones sin ningún problema, Node empieza con problemas desde 30k y el más eficiente en cómputo y memoria utilizada por mucho es Go.\nComparación de frameworks web ligeros. Este artículo es un poco viejo, pero el resumen es que Gin (un framework web ligero de Go) es el que más peticiones soporta por segundo y con una consistencia excelente.\nHablemos de tres formas de crear una API sobre HTTP para tu próximo proyecto. Pero antes hablemos de una opción simple que no cubre muchos casos pero que se oye recomendada por todo internet.\nLa biblioteca estándar # Cuando hice mi primer proyecto en Go, gran parte de la investigación sobre qué usar para crear un proyecto de una API web apuntaba a los paquetes nativos de Go.\nGo tiene una biblioteca estándar que cubre muchas de las necesidades de un desarrollador moderno. Si has programado en él podrás estar de acuerdo en que se siente como subirte en hombros de gigantes, debido a que las personas que lo diseñaron y construyeron son las mismas personas que sentaron las bases para los sistemas operativos modernos. Imagínate cuánta experiencia tienen.\nEn la biblioteca estándar podemos encontrar un paquete que se llama net/http con el que puedes hacer, un servidor web con direccionamiento de rutas sencillo (la base de tu API) con muy pocas líneas de código. Puedes recibir peticiones HTTP, procesarlas y devolver una respuesta HTTP. El ciclo básico request -\u0026gt; response.\nAquí hay un ejemplo:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) // Implementando rutas HTTP func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.ListenAndServe(\u0026#34;localhost:8080\u0026#34;, nil) // iniciando el servidor } // handler recibe la petición http y la procesa para devolver una respuesta http func handler(response http.ResponseWriter, request *http.Request) { fmt.Fprintf(response, \u0026#34;Hola Go API\u0026#39;s\u0026#34;) // Falta responder JSON } Si tu API es sencilla, expone pocas URLs y sabes que no requerirás mucho en campo de las peticiones HTTP (procesamiento de parámetros, manejo de rutas, etc.) la biblioteca estándar es una solución buena, pero para otros casos se queda un poco corta, ya que tendrías que implementar varias cosas a mano.\nSu uso es sencillo como acabas de ver. Usar un framework web tiene el costo de agregar complejidad a cambio de funcionalidades que no tienes que desarrollar tú. Pero aquí te compartimos un artículo en el que un experto hablá de por qué él prefiere no usar frameworks: Why I Don\u0026rsquo;t Use Go Web Frameworks.\nPor eso te presentamos las opciones más comunes y algunos ejemplos.\nGorilla Web Toolkit # {: .align-center}\nGorilla Toolkit es un conjunto de herramientas para web que, entre otras cosas tiene:\nUn router más completo que el de la biblioteca estándar: Gorilla Mux. Es compatible con el tipo de dato nativo de Go para las peticiones. Además incluye: Ruteadores secundarios, para que organices mejor tu código. Inversión de URL\u0026rsquo;s: te permite generar la URL a partir de un identificador. Matches complejos Middlewares: logging, compresión, recuperación Manejo de sesiones con cookies seguras Implementación de WebSockets y RPC Conversión de valores de entrada en struct de Go Gorilla Toolkit no es un framework, puedes usar cada de sus herramientas por separado, como las vayas necesitando. Así que puede empezar con la librería estándar y agregar lo que necesitas de Gorilla poco a poco.\nGin # {: .align-center}\nGin es un framework web para Go bastante completo que clama ser el más rápido de todos los frameworks web para Go. Ya está en su versión 1, por lo que puedes usarlo con confianza en proyectos serios.\nGin usa httpRouter que tiene funciones parecidas a Gorilla Mux, pero que dice escalar mejor que el de la librería estándar incluso.\nTiene utilidades incluídas para hacer render de XML, JSON, YAML y ProtoBuf, o sea que es perfecto para crear diferentes tipos de API\u0026rsquo;s.\nAdemás, tiene un montón de cosas más que puedes explorar en su documentación, que es muy completa y con muchos ejemplos, por si fuera poco.\nBeego # {: .align-center}\nBeego es un framweork que se especializa en API\u0026rsquo;s RESTful e intenta usar lo mejor posibles las características de Go como las interfaces y las estructuras embebidas. Parece que está hecho en China.\nLas cuatro características que resalta son:\nFácil de usar: es MVC y tiene herramientas incluídas para poder desarrollar más fácilmente. Inteligente: tiene características de ruteo avanzadas junto con monitoreo integrado que te permiten observar el estado de tu API. Modular: su estructura interna está compuesta por varios módulos que te permiten avanzar rápidamente. Alto desempeño Es un framework bastante completo, que cumple con todo lo mínimo necesario para que puedas empezar a desarrollar tu API eficientemente, pero parece que tiene un defecto: al ser hecho en china, la documentación no está pulida completamente y puede que haya poca información en tutoriales y otras páginas.\nEcho # {: .align-center}\nEcho se promociona como el framework web minimalista. Tiene soporte para HTTP/2, ruteo sin uso de memoria dinámica (para mejor desempeño), TLS automático, middlewares flexibles y funciones utilitarias para responder fácilmente las peticiones web en cualquier formato.\nEn algunos benchmarks echo parece ser más rápido que Gin.\nTiene desarrollo bastante activo y la documentación contiene ejemplos suficientes, junto con algunas recetas y para que logres avanzar rápido.\nConclusión # Existen múltiples opciones para crear tu API en Go. Hay para escoger dependiendo de tus gustos y de lo más importante para tu proyecto.\n","date":"20 septiembre 2020","externalUrl":null,"permalink":"/2020/09/20/formas-de-hacer-una-api-con-go/","section":"Posts","summary":"\u003cp\u003eGo es uno de los lenguajes modernos más usados. Ya hablamos de \u003ca\n  href=\"/2019/09/01/por-que-deberias-aprender-go.html\"\u003epor qué deberías aprenderlo\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAhora hablemos de un caso de uso práctico: \u003cstrong\u003eúsalo para crear una API HTTP\u003c/strong\u003e. En este artículo nos enfocaremos en la parte de comunicación HTTP y la generación de respuestas adecuadas.\u003c/p\u003e","title":"Formas de hacer una API con Go","type":"posts"},{"content":"","date":"20 septiembre 2020","externalUrl":null,"permalink":"/tags/gin-go/","section":"Tags","summary":"","title":"Gin-Go","type":"tags"},{"content":"","date":"20 septiembre 2020","externalUrl":null,"permalink":"/tags/go-lang/","section":"Tags","summary":"","title":"Go-Lang","type":"tags"},{"content":"","date":"20 septiembre 2020","externalUrl":null,"permalink":"/tags/gorilla-mux/","section":"Tags","summary":"","title":"Gorilla-Mux","type":"tags"},{"content":"","date":"10 septiembre 2020","externalUrl":null,"permalink":"/tags/devops/","section":"Tags","summary":"","title":"Devops","type":"tags"},{"content":"","date":"10 septiembre 2020","externalUrl":null,"permalink":"/tags/domix/","section":"Tags","summary":"","title":"Domix","type":"tags"},{"content":"","date":"10 septiembre 2020","externalUrl":null,"permalink":"/tags/hype/","section":"Tags","summary":"","title":"Hype","type":"tags"},{"content":"","date":"10 septiembre 2020","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"10 septiembre 2020","externalUrl":null,"permalink":"/tags/live/","section":"Tags","summary":"","title":"Live","type":"tags"},{"content":"Tuvimos una plática con Domingo Suárez(@domix) acerca de diferentes temas que le interesan a los desarrolladores.\nEn este artículo te vamos a dar un resumen.\nCómo nos dejamos influir para adoptar una tecnología # Lo primero de lo que hablamos es de la forma en que muchas veces adoptamos la tecnología: por moda. A veces es porque alguien con autoridad la mencionó o muchos miembros de la comunidad la están usando. A los desarrolladores nos gustan las cosas brillantes.\nGeneralmente esa decisión tiene un costo bastante alto:\nTe metes en cosas de las que no hay la suficiente información disponible Te enfrentas con problemas totalmente desconocidos Gastas recursos que podrías gastar mejor en otro lado. La lección: no tienes que aprender y usar todo lo nuevo que sale. Usa tecnología aburrida: probada por el tiempo, de la que exista mucha información y usada por muchos desarrolladores de los que podrás aprender rápidamente y enfocarte en los verdaderos problemas que diferencian a tu solución.\n¿Qué es DevOps? # Uno de los temas principales que tratamos es la aclaración de lo que de verdad significa el término DevOps.\nDomingo explicó que DevOps es una cultura que intenta mejorar el flujo de trabajo que existe entre el área de desarrollo y la de operación del software (la encargada de ponerlo en manos de los usuarios y monitorearlo). Intenta mejorar los hilos organizacionales.\nNos explicó que el término \u0026ldquo;DevOps\u0026rdquo; originalmente era un hashtag de Twitter para hablar de esta cultura en una conferencia organizada por Patrick Debois.\nDomingo dejó muy claro que DevOps no es un puesto, ni un rol. No lo puedes comprar con una herramienta, sino que es una serie de prácticas y una forma de pensar que tu empresa debe desarrollar.\nPlaticamos a además de que DevOps establece \u0026ldquo;Las 3 vías\u0026rdquo; que son tres procesos o tres formas en las que la información viaja.\nLa primera vía consiste en poner el código en producción lo más rápido posible, con opciones como quitarlo rápidamente si no funciona bien (rollback).\nLa segunda vía es el monitoreo del software en producción, para poder actuar rápidamente. Puede ser para mejorarlo, para corregir fallas y para aprender del verdadero uso que los usuarios finales le dan.\nLa tercer vía es la repetición de estos dos procesos y la ejecución de ejercicios con el objetivo de pulir los procesos y aprender más cosas. Esta vía incluye simulaciones de falla, sesiones de estudio, sesiones de preparación y análisis de fallos, etc.\nMentores y aprendizaje # Un tema repetido desde el principio es que Domingo tuvo un mentor que se llama Humberto. Una persona que sin darse cuenta le ayudó mucho a adoptar hábitos sanos de aprendizaje y le enseñó muchas cosas directamente.\nDe esto salió que en la industria de desarrollo de productos digitales falta en práctica poner más en práctica la mentoría, ya que nos puede ayudar avanzar y puede a crear personas más hábiles.\nLlegamos a una conclusión: la mentoría es una responsabilidad compartida. El mentor tiene la responsabilidad de guíar al aprendiz de la mejor forma, porque puede influir de formas muy poderosas en su vida, pero la responsabilidad de aprovechar bien esa guía y aplicar los consejos es de la persona que está siendo mentoreada.\nEn este punto Alex levantó un punto interesante: en lugares como Silicon Valley, los directivos tienen la idea de que preparar gente dentro de su empresa es beneficioso en general para el ecosistema. Si todos adoptan esa mentalidad, la próxima persona que llegue a tu empresa habrá sido entrenada de la mejor manera, elvando el nivel de la comunidad.\nLe lección: Aceptar o pedir una mentoría te hará crecer y adoptar la idea de que preparar a las personas es beneficioso ayudará a todo el ecosistema.\nCómo avanzar en tu carrera como desarrollador # Conectado con el tema anterior, hablamos un poco de cómo puedes volverte mejor desarrollador, alcanzar un nuevo puesto y obtener un mejor sueldo. La conclusión es:\nTienes que mantenerte siempre aprendiendo nuevas cosas, no sabes lo que puede servirte más adelante.\nNo estudies sólo lo relacionado con tu trabajo actual, estudiar cosas que no tienen nada que ver con lo que haces hoy puede abrirte las puertas a nuevas oportunidades.\nHaz proyectos de las cosas que estás aprendiendo, no sólo leas o veas videos.\nHas cosas que de verdad disfrutes.\nMicroservicios # La mayoría de las empresas no los necesita, porque aunque quieran imitar a Netflix o Google o Amazon o Facebook, no tienes sus mismos problemas.\nAdemás la arquitectura de microservicios tiene retos a los que tal vez no te quieres enfrentar, como las transacciones distribuidas.\n¿Cuándo es buena idea usar microservicios? Domingo dio dos criterios:\nTu base de usuarios es muy grande, los microservicios te ayudarán a escalar mejor. Tu base de código es muy grande. Así la podrás dividir mejor entre tus decenas de programadores. Aprender Java vale la pena # Después, hablamos de qué tanto vale la pena aprender Java en 2020, ya que Domingo es un Java Champion, uno de los pocos de México y de LATAM.\nLa conclusión: Java es un lenguaje que vale la pena aprender, por ser una tecnología probada (aburrida) y con muchas cosas desarrolladas.\nAlgunas de las características que resaltamos de Java:\nLa JVM es una pieza de software magnífica que tiene optimizaciones para ser muy eficiente, para ayudarte aunque tu código no sea tan bueno. Un montón de lenguajes corren sobre la JVM. Si te gusta más otro que Java puedes combinarlos y compartir lo que ya existe en el ecosistema de Java Java como lenguaje ha avanzado mucho, adoptando formas de programar más modernas. Sus características intrínsecas, como su compilador y el tipado estático lo hacen ideal para cierto tipo de problemas en los que tienes que reducir al mínimo los errores en tiempo de ejecución. El consejo de domingo es: Si quieres empezar con Java empieza con algún framework modernos como Micronaut.\nRecomendaciones de libros # The Phoenix Project Site Reliability Engineering Joel on Software Disfrutamos mucho de esta plática y esperamos tenerlo con nosotros de nuevo pronto. La puedes ver aquí:\n","date":"10 septiembre 2020","externalUrl":null,"permalink":"/2020/09/10/no-hagas-hagas-devops-por-convivir/","section":"Posts","summary":"\u003cp\u003eTuvimos una plática con Domingo Suárez(\u003ca\n  href=\"https://twitter.com/domix\"\n    target=\"_blank\"\n  \u003e@domix\u003c/a\u003e) acerca de diferentes temas que le interesan a los desarrolladores.\u003c/p\u003e\n\u003cp\u003eEn este artículo te vamos a dar un resumen.\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003eCómo nos dejamos influir para adoptar una tecnología\n    \u003cdiv id=\"cómo-nos-dejamos-influir-para-adoptar-una-tecnología\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#c%c3%b3mo-nos-dejamos-influir-para-adoptar-una-tecnolog%c3%ada\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003eLo primero de lo que hablamos es de la forma en que muchas veces adoptamos la tecnología: \u003cstrong\u003epor moda\u003c/strong\u003e. A veces es porque alguien con autoridad la mencionó o muchos miembros de la comunidad la están usando. A los desarrolladores nos gustan las cosas \u003cem\u003ebrillantes\u003c/em\u003e.\u003c/p\u003e","title":"No hagas hagas DevOps por convivir","type":"posts"},{"content":"","date":"10 septiembre 2020","externalUrl":null,"permalink":"/tags/youtube/","section":"Tags","summary":"","title":"Youtube","type":"tags"},{"content":"Hemos escuchado muchísimo acerca de los sistemas en capas como Modelo-Vista-Controlador, Modelo-Vista-Template, Modelo-Vista-*, MV-lo-que-sea etc. y eso es porque la mayoría de los sistemas actuales se organiza así: en capas. Además, nuestros módulos se dividen naturalmente en capas con diferentes funciones (como código que usa a otro).\nHablemos de por qué es efectiva esta forma de organización (o patrón de arquitectura) de código, de sus características y cómo podemos aprovecharla para sacar el máximo provecho.\nCaracterísticas de los sistemas en capas # Sabemos que la mejor forma de organización de un proyecto es descomponerlo en partes independientes que oculten información de otras.\nLa comunicación entre las diferentes partes se da por medio de una interfaz. Esta interfaz, es la API del componente, ya que será usada de manera automática por otra parte del programa.\nEn un sistema en capas el conjunto de elementos pertenecientes a una capa sólo se puede comunicar con la capa superior y con la capa inferior.\nSi un sistema tiene 10 capas, cada componente puede comunicarse máximo con 2 capas. En los sistemas más comunes, como el de 3 capas (MVC, MVT, MV*), sólamente la capa intermedia (el controlador, por ejemplo) puede comunicarse con dos capas, mientras que las otras sólo se comunican con la intermedia.\nJohn Ousterhout usa la división en capas para explicar cómo se organiza el software con respecto al usuario final: la capa de \u0026ldquo;hasta arriba\u0026rdquo; es la que interactúa directamente con el usuario y la de \u0026ldquo;hasta abajo\u0026rdquo; es la más alejada del usuario, generalmente el núcleo de tu sistema.\nHablemos ahora de las mejores prácticas según A Philosphy of Software Design.\nDiferente capa, diferente abstracción # El concepto que debes tener más claro para descomponer tu software en capas es que cada capa debe tener sus propias abstracciones. Ousterhout da el ejemplo de un sistema de archivos:\nLa capa que interactúa con el mundo exterior o la más alta, tiene la abstracción de un archivo La siguiente capa tiene la abstracción de bloques de memoria y caché La siguiente capa maneja directamente los bloques en el disco Esta abstracción es efectiva porque cada capa trabaja con abstracciones diferentes y no repiten ninguna entre ellas.\nEsta es la idea básica que debes checar en tus diseños, si notas que una abstracción no cambia de una capa a otra, algo está saliendo mal. ¿Cómo puedes identificarlas?\nFunciones de paso # Estos son funciones que no hacen nada mas que mandar llamar una función de la siguiente capa, normalmente para cumplir con la limitante de comunicación entre capas.\nEsto indica que no hay una división clara de responsabilidad entre clases o módulos. Para resolver este problema tienes que asegurarte de que la interfaz y la funcionalidad de este punto de tu sistema estén en el mismo módulo.\nEvitar este tipo de métodos te evitará complicar la interfaz sin añadir ninguna funcionalidad.\nVariables pasadas # Similar al caso anterior, si tienes una variable que recibes en la llamada de tu módulo y no haces nada con ella mas que pasarla a una capa inferior, estás mezclando las abstracciones entre capas.\nA veces son necesarias, pero el manejarlas crea complejidad. Dependiendo del paradigma y el lenguaje de programación deberías buscar una solución adecuada.\nPor ejemplo, en lenguajes orientados a objetos podrías guardar todos lo valores a los que necesitas constante acceso desde diferentes lugares un una variable de \u0026ldquo;contexto\u0026rdquo; y que generalmente está almacenada en un lugar en el que todas tus funciones puedan acceder. Algunos frameworks usan su variable de settings para poner información necesaria ahí.\nLos siguientes dos consejos tratan más los diferentes niveles de código que capas del sistema.\nEvita lo más que puedas los decoradores # Ousterhout habla en contra del patrón decorador. Este patrón consiste en envolver clases, objetos o funciones con otros, con el fin de extender la funcionalidad. Los decoradores intentan mantener una interfaz muy similar o exactamente igual al elemento original.\nUn ejemplo es la clase de Java BufferedInputStream es un decorador de InputStream, añadiéndole el buffering.\nLos decoradores pueden crear un montón de funciones y variables de pasada y agregar un montón de código de soporte sin de verdad agregar tanta funcionalidad como código.\nAPoSD (el libro) sugiere crear entidades separadas cuando sea posible y evitar el sobreuso de este patrón, a menos que de verdad tenga sentido, por ejemplo: cuando tienes un módulo muy profundo que con un decorador vas a poder reutilizar todo con muy poco código de soporte.\nAbstracciones diferentes entre la interfaz y la implementación # Tu código debería de exponer en su interfaz la abstracción más conveniente para los usuarios de tu módulo, sin importar las abstracciones más convenientes para manejar los datos internamente.\nPor este principio, es muy normal que las abstracciones de la interfaz no sean las mismas interfaces que tu implementación usa.\nUn ejemplo: imagina que estás escribiendo un componente que te permite editar texto. ¿Cuál es la unidad básica con la que el usuario de tu módulo interactuará?\nPuede ser un carácter, una línea, un párrafo. Ya que tu la visualización del texto es en líneas, lo más conveniente para la implementación es una abstracción que represente una línea de texto.\nPero para el usuario de la clase que maneja texto lo más conveniente es una interfaz que use carácteres porque es más fácil de usar, se quita la responsabilidad de manejar las líneas.\nEntonces tu clase queda así: internamente representa el texto como un conjunto de líneas, pero las interfaces lo usan como si fuera un conjunto de caractéres en los que puedes insertar y borrar sin preocuparte por la organización en líneas.\nConclusión # La separación en capas permitirá que tu código esté mejor organizado y que sea más fácil de entender. Tener cuidado con la forma en que las capas se organizan, cómo se dividen responsabilidades y las interfaces que cada capa expone hará mucho más mantenible y entendible tu base de código.\n","date":"1 septiembre 2020","externalUrl":null,"permalink":"/2020/09/01/a-philosophy-of-software-design-organiza-bien-los-sistemas-en-capas/","section":"Posts","summary":"\u003cp\u003eHemos escuchado muchísimo acerca de los sistemas en capas como \u003cem\u003eModelo-Vista-Controlador\u003c/em\u003e, Modelo-Vista-Template, Modelo-Vista-*, \u003cem\u003eMV-lo-que-sea\u003c/em\u003e etc. y eso es porque la mayoría de los sistemas actuales se organiza así: \u003cstrong\u003een capas\u003c/strong\u003e. Además, nuestros módulos se dividen naturalmente en capas con diferentes funciones (como código que usa a otro).\u003c/p\u003e","title":"A Philosophy of Software Design: Organiza bien los sistemas en capas","type":"posts"},{"content":"Traducir texto es una tarea frecuente y que puede realizarse de diferentes maneras, en este artículo queremos explorar algunas de ellas.\nExisten sitios donde la traducción puede hacerse en línea, como en Google Translate, sin embargo, en muchos casos existe un límite en la cantidad de texto que puedes traducir.\nTambién puedes utilizar APIs que pueden ayudarte a hacer dicho trabajo, dichas APIs también tiene límites por traducción.\nUna solución que nos resulta interesante es la traducción utilizando algún modelo de Aprendizaje de Máquina que ya haya sido previamente entrenado. En este artículo podrás explorar estos diferentes métodos y el código que podrías utilizar para llevarlo a cabo, entendiendo las ventajas y desventajas que cada método ofrece.\nHablemos de los diferentes métodos.\nInterfaz gráfica # Google Translate te permite traducir 5,000 palabras a la vez en su interfaz. Si lo vas a hacer pocas veces y los textos no rebasan esa cantidad de palabras, ¿para qué construir algo?\nEsta opción nos recuerda que a veces la mejor solución es que no programemos nada.\nVentajas: Inmediata, fácil de usar y sin costo. Desventajas: Requiere intervención humana cada que se tenga que traducir algo.\nAPI\u0026rsquo;s # Si quieres automatizar las tareas de traducción para integrarlas en un sistema más grande o generar salidas que se queden almacenadas en archivos o bases de datos, una solución es crear un programa que consuma una API de traducción.\nAlgunas opciones son:\nCloud Translation de Google Cloud Platform. Tiene dos niveles de traducción: el básico que soporta el modelo tradicional de traducción y el avanzado que permite customizar los modelos de traducción además de incluir glosarios y otras monerías.\nWatson Language Translator permite traducir una gran cantidad de formatos de texto en muchos lenguajes. La única desventaja es que las API’s de IBM no son las más hermosas y en general sus sitemas de administración fallan bastante.\nOtras. En RapidAPI puedes encontrar una colección actualizada de las alternativas a Google Translation API.\nPara desarrollar esta pieza de software, lo más recomendable sería crear un wrapper alrededor de la API y exponer a las demás partes del programa sólo los métodos para poder realizar la tarea de traducción, abstrayendo completamente los detalles de cómo se realiza. De esta manera podrías cambiar de API fácilmente (implementando las llamadas a la nueva API) sin irrumpir en la mayoría del programa.\nAdemás esta forma de hacerlo también sería compatible con el siguiente método:\nAutoML Translation. Pertenece también a GCP y permite entrenar un modelo mediante el envío de pares de frases para entrenar un modelo que posteriormente puedes usar para hacer traducciones sobre un dominio específico. Es el que más trabajo implicaría de tu parte pero es el que más flexibilidad de tiene. Ventajas # Puedes olvidarte completamente de los detalles de implementación de la traducción, del hosting y mantenimiento de esta parte y probablemente las traducciones son muy precisas, como estamos acostumbrados a las de Google.\nDesventajas # Generalmente esta comodidad viene un costo económico que varía dependiendo del uso. La flexibilidad y capacidad de configuración de las API’s es variada y si no funciona como esperas es muy probable que no puedas hacer nada por mejorar la traducción.\nModelo pre-entrenado de Aprendizaje de Máquina # Los modelos de Aprendizaje Profundo que se han desarrollado de manera importante en los últimos años han sustituido los modelos previos que utilizaban el conocimiento de lingüistas y décadas de investigación estadística.\nUna peculiaridad de un modelo de Aprendizaje Profundo es que logra detectar patrones de uso de los lenguajes y utilizar dichos patrones para realizar la traducción de uno a otro. Dichos patrones no tienen una representación equivalente de una palabra en un idioma a otra en un idioma distinto, sino que combinan los patrones internos de uso de las palabras en un idioma y después aplican los patrones que el otro idioma utilizaría. Eso hace que los traductores que utilizan aprendizaje profundo sean mucho más precisos y que las traducciones sean mucho más naturales, además de que pueden adaptarse a casos de uso específicos que los modelos anteriores no contemplaban. ¿Por qué? Porque podemos entrenarlos utilizando un conjunto de datos de entrenamiento que se enfoquen en un dominio específico del lenguaje (ej. traducción de subtítulos de películas, o traducción de textos técnicos).\nA pesar de ello, uno de los impedimentos más relevantes para su entrenamiento es que hasta hace algunos años, entrenar un modelo requería grandes cantidades de cómputo y memoria, cosa que ha ido cambiando conforme la industria ha ido evolucionando y los principales proveedores de cómputo han puesto a disposición del mundo, plataformas en la nube donde puede adquirirse poder computacional y de procesamiento de manera sencilla (AWS, Google, Microsoft, IBM, Oracle, etc.). De igual forma, las compañías que crean procesadores especializados (NVIDIA, AMD) también han logrado reducir los costos y poner en manos de cada vez más desarrolladores, tarjetas de video con Unidades de Procesamiento Gráfico (GPUs) a precios cada vez más accesibles.\nEl modelo genérico de un sistema de traducción basado en Aprendizaje de Máquina consta de dos piezas principales (cada una de ellas una red neuronal por sí misma):\nUn codificador de secuencias de palabras (que serían oraciones del texto) que aprende a codificar palabras como un arreglo de números que representa el significado de la oración.\nUn decodificador de números, que toma un arreglo de números en general y los transforma en oraciones.\nLa peculiaridad es que en el paso 1 obtenemos ese arreglo de números utilizando el lenguaje de orígen y la decodificación la hacemos hacia el lenguaje destino.\nPara poder capturar los patrones y relaciones que existen entre las palabras en una oración, es necesario que la red neuronal cuente con la capacidad de recordar las palabras dentro de una oración, ya que las relaciones de una palabra cualquiera serán mucho más fuertes con ciertas palabras que con otras, por ejemplo la relación entre “la” y “relación” será mucho más fuerte que “él” y “relación”, no esperaríamos poder encontrar un texto donde “él” y “relación” estén presentes en dicho orden específico.\nEsta capacidad de “recordar” de una red neuronal no existe en una red neuronal tradicional, donde las entradas pasan y son procesadas por todas las capas de la red sin hacer referencia a las palabras que pasaron antes o las palabras que pasaron después, por ello es que estos algoritmos utilizan un tipo de red neuronal llamado recurrente donde la última entrada influye en la siguiente predicción, esto permite a la red neuronal recurrente “aprender” el “significado” de cada palabra dentro de un contexto.\nEn tiempos recientes, se han mejorado los modelos de procesamiento del “significado” de las palabras dentro de un contexto utilizando Transformadores que van incluso más allá del simple contexto de una palabra dentro de una oración, modelando las relaciones cruzadas entre cualquier palabra (previa o posterior) en vez de considerar únicamente el orden.\nEstos modelos requieren mucho más operaciones matemáticas durante su entrenamiento pero los patrones que pueden identificar las hacen mucho más poderosas, aún así los modelos de recurrentes arrojan resultados bastante aceptables.\nExisten casos en particular donde no es necesario entrenar tu propia red neuronal recurrente, ya que es probable que alguien más lo haya hecho ya. Esto puede ahorrarte muchas horas de procesamiento de información y el entrenamiento y validación del proceso de entrenamiento.\nEl proceso que se sigue es:\nObtener un corpus o conjunto de datos sobre el problema que quieres resolver (por ejemplo, textos en el idioma de origen y en el idioma destino. Limpieza y normalización de este corpus que remueva errores o piezas de los textos que sean incompletas o por ejemplo se puede decidir utilizar todas las palabras en minúsculas, separar las oraciones por ciertos símbolos de puntuación, etc. estas decisiones deberán tomarse teniendo en cuenta los objetivos para los cuales utilizaremos nuestro modelo de traducción, no es lo mismo un traductor de textos formateados de manera regular a textos que por ejemplo se vayan a utilizar como subtítulos para películas. Los pasos que normalmente se utilizarán tendrán como mínimo, código para separar las oraciones, y normalizar el texto. Utilizando un modelo de traducción prefabricado # Si quieres experimentar con este tipo de modelos te recomiendo empezar por el uso de un modelo pre-entrenado y dependiendo de los resultados evaluar si es necesario entrenar uno especializado en la tarea que estás buscando resolver.\nAunque hay varios modelos disponibles, te dejo la liga a un framework hecho en C++ y que tiene un número mínimo de dependencias, se llama Marian Neural Machine Translation y como parte de sus peculiaridades es que es eficiente, puede utilizar varios procesadores gráficos para el entrenamiento y soporta el uso de CPU o GPU para la traducción (al poder utilizar sólo CPU hace que el modelo pueda utilizarse en computadoras que no tienen tantos recursos).\nY aquí hay un modelo pre-entrenado que puede utilizarse para traducciones de español a inglés: Spanish to English Translation\nSi tuvieras necesidad de entrenar la red neuronal sería necesario que tuvieras datos paralelos, es decir el mismo texto en los dos idiomas entre los cuales quieres hacer la traducción. Aquí te dejamos la liga a uno de ellos: The open parallel corpus\nVentajas # Puede adaptarse mediante el entrenamiento, a un estilo o tipo específico de textos (textos científicos, técnicos, informales, subtítulos, etc.) Puede utilizarse en modo “offline” sin necesidad de estar conectado a alguna fuente externa de internet. No tiene costos o límites de uso, más que aquellos resultado de operar el modelo una vez entrenado (y de entrenarlo si fuera necesario hacerlo). Desventajas # Entrenarlo requiere una gran cantidad de datos y un proceso de limpieza/normalización que no son técnicamente sencillos. Es probable que no sea sencillo alcanzar el nivel de entrenamiento que las grandes compañías han utilizado para entrenar sus propios modelos (porque seguramente tienen fuentes bastante grandes de datos/procesadores gráficos/etc). Escalarlo para su uso masivo puede ser todo un reto. Las redes neuronales son cajas negras por lo que si se detecta algún error en la traducción normalmente será muy difícil saber en qué parte de los datos de entrenamiento se introdujo el error y por lo tanto será difícil removerlo. En el siguiente artículo te contaremos cómo nos fue con las pruebas.\n","date":"19 julio 2020","externalUrl":null,"permalink":"/2020/07/19/traducci%C3%B3n-autom%C3%A1tica-apis-vs-tu-propio-modelo/","section":"Posts","summary":"\u003cp\u003eTraducir texto es una tarea frecuente y que puede realizarse de diferentes maneras, en este artículo queremos explorar algunas de ellas.\u003c/p\u003e\n\u003cp\u003eExisten sitios donde la traducción puede hacerse en línea, como en \u003ca\n  href=\"https://translate.google.com.mx/?hl=es\"\n    target=\"_blank\"\n  \u003eGoogle Translate\u003c/a\u003e, sin embargo, en muchos casos existe un límite en la cantidad de texto que puedes traducir.\u003c/p\u003e","title":"Traducción automática: API's vs tu propio modelo","type":"posts"},{"content":"","date":"16 julio 2020","externalUrl":null,"permalink":"/tags/bash/","section":"Tags","summary":"","title":"Bash","type":"tags"},{"content":"Con la reciente liberación de MacOS Catalina, Apple anunció que entre alguno de los cambios al sistema operativo, se utilizará a partir de esta versión un nuevo shell que de manera regular se utilizaba en la app Terminal y en otras aplicaciones utilizadas por los desarrolladores para interactuar con la Mac a través de la línea de comandos.\nEl shell que se utilizaba previo a esta versión era Bash (Bourne Again Shell) y el que se utilizará ahora es Zsh.\n¿Qué es un shell? # En resumen, un shell es un programa que permite controlar la computadora a través de comandos de texto, normalmente se trata de interfaces de texto interactivo, donde el usuario podrá ir tecleando comandos para obtener información o ejecutar comandos y obtener resultados a través de la misma interfaz.\nA lo largo de la historia se han creado diferentes shells, cada uno con una serie de comandos que ponen a disposición de los usuarios funcionalidades específicas de sus sistemas operativos. ¿Y porqué estaría alguien interesado en usar un shell y una línea de comandos para controlar una computadora? Para entenderlo hay que viajar un poco en el tiempo.\nHistoria # Inicialmente, controlar una computadora era una tarea difícil, las primeras de ellas se controlaban mediante diferentes dispositivos (interruptores, tarjetas perforadas, etc.) que \u0026ldquo;cargaban\u0026rdquo; en memoria las distintas piezas de información que serían procesados en forma de programas. Este proceso era regularmente tedioso y sujeto a errores.\nEn algunos casos, el primer programa que se cargaba en memoria era un programa que permitía cargar instrucciones adicionales a través de la lectura de datos en las mismas tarjetas perforadas. De igual forma, los resultados de la ejecución normalmente se plasmaban en papel o tarjetas similares a las que se utilizaban para su carga.\nConforme fueron evolucionando los computadores, los programas permitieron el uso de dispositivos de entrada más amigables para el usuario de la computadora, como Teletipos, que permitían enviar comandos desde teclados y terminales remotas al ordenador (remoto en un sentido práctico, quizás de un cuarto a otro). Esta forma de transmitir comandos y obtener resultados era mucho más sencilla que estar cargando información a través de interruptores o tarjetas perforadas.\nLa pregunta natural es: si esto fue la primer evolución hacia un uso más sencillo de las computadoras, ¿por qué se sigue utilizando?\nAunque la evolución de las computadoras ha seguido su curso y la interacción Humano-Computador ha avanzado en diferentes vertientes, por ejemplo, mediante la implementación de interfaces gráficas, el uso de la interfaz de línea de comandos se ha mantenido vigente por diversas razones:\nPor su versatilidad, es posible utilizarlo para resolver distintos tipos de problemas y con distintos tipos de opciones que harían muy difícil su integración completa en una interfaz gráfica.\nPor su poder, al tener acceso a las funciones centrales del sistema operativo, también contempla casos de uso para los cuales las interfaces gráficas no están preparados.\nPermite crear programas que hacen uso de las capacidades nativas y extendidas del sistema operativo y ejecutar dichos programas o scripts en distintas modalidades, por ejemplo, de manera repetitiva a través de trabajos programados (cron jobs) o en conjunto con otros programas (por ejemplo con ambientes de desarrollo integrados). A esto le podemos llamar automatización de tareas.\nEl programa de shell específico (en este caso Bash o Zsh), definen su interfaz con el usuario, no sólo en la manera en la que presentarán la linea de comando sino también en las capacidades y comandos que soportan de manera nativa, en general, podemos encontrar algunas de estas características:\nUna sintaxis que define los comandos y secuencias de comando que el shell \u0026rsquo;entenderá'. Comandos que darán acceso a las \u0026lsquo;operaciones\u0026rsquo; que el shell puede ejecutar . Funciones que permiten agrupar comandos para ejecutar labores más complejas. Parámetros para almacenar valores para su uso durante la ejecución de las funciones y comandos. Expansión que define la forma en la que los parámetros en un comando son aplicados. Flujo y redirección que controla las entradas y salidas de y desde los comandos. Ejecución que define lo que sucede cuando cada comando corre. Scripting que permite ejecutar archivos que contienen una lista de comandos y/o funciones. ¿Porqué razón puede estar cambiando Apple de un shell a otro? # Existen varias posibilidades, la primera de ellas es que aunque Apple utiliza Bash desde OSX Jaguar, no había actualizado Bash desde la versión 3.2 liberada en el 2007, es decir casi el mismo año en el que se liberó el primer iPhone. Es probable que una de las razones por las que esto sucedió fue que Bash cambió su licencia de uso de GNU GPL 2 a una licencia GNU GPLv3, y dicho cambio incluía restricciones que quizás no fueron del todo favorables a Apple.\nAsí que migrar a Zsh es una opción refrescante. La versión que está incluida en Catalina es la 5.7.1 y utiliza una versión de licenciamiento MIT que es menos restrictiva que la GPLv3.\n¿Qué sucederá con Bash, tendré que dejar de usarlo? # No necesariamente, aunque Zsh será el shell por default para todas las nuevas cuentas de usuario creadas en macOS Catalina, si tu hiciste un upgrade del Sistema Operativo, tu cuenta seguirá utilizando por default Bash. Pero siempre tendrás opción de configurar el shell que desees por default de manera voluntaria, incluso a alguno distinto a Zsh o Bash.\nA nivel general, Bash y Zsh tienen un nivel de compatibilidad bastante alto ya que ambos están basados en el aún más antiguo Bourne Shell, de tal forma que la mayoría de los scripts y comandos existentes funcionarán sin ningún cambio en Zsh.\nLa ventaja real de Zsh es la inclusión de funcionalidades que hacen trabajar con él más fácil (funcionalidades no incluidas por default en la versión vieja de Bash), entre algunas de mis funcionalidades favoritas están:\nAuto completado de comandos Auto corrección de comandos Integración con algunos sistemas de uso común para desarrolladores (git) ¿Qué sucederá con mis scripts hechos en Bash? # En general, correrán de igual forma a como lo venían haciendo, sin embargo en casos muy peculiares podrías requerir modificarlos o simplemente agregar #!/bin/bash (shebang) para forzar a que el script utilice el shell de Bash que sigue incluyéndose en MacOS.\nPuedes usar temporalmente uno u otro shell simplemente invocando su nombre en la línea de comandos (zsh o bash).\nEn la Mac, podrás configurar el shell default en las Preferencias del Sistema, en el panel de Usuarios y Grupos, podrás seleccionar la cuenta de un usuario y en las Opciones Avanzadas podrás seleccionar uno de los shells disponibles.\nConclusión y referencias # Dominar tu shell hará que tu trabajo diario sea más sencillo ya que podrás configurar funcionalidades que aumenten tus capacidades como desarrollador y en conjunto con el conocimiento a profundidad de tu interfaz de desarrollo, podrá hacerte mucho más eficiente al momento de administrar y ejecutar comandos que tengan que ver con tus proyectos.\nAlgunos recursos que te ayudarán:\nLa documentación de Zsh Configuración Zsh es mediante Oh My Zsh ¿Donde se configuran las funcionalidades de Zsh? En ~/.zshrc. ¿Cómo saber que shell estoy usando? echo $0 o\necho $SHELL ¿Cómo configurar Zsh como mi shell default? chsh -s /bin/zsh ¿Cómo activar el autocomplete? autoload -U compinit \u0026amp;\u0026amp; compinit ¿Cómo activar la extensión para git? autoload -Uz vcs_info ¿Cómo configurar el cambio de directorio automático? setopt autocd Referencias # Bash academy Discusión en YCombinator Zsh tips 10 trucos de Zsh Zsh Guide Advanced Bash-Scripting Guide Bash by example Libro: From Bash to Zsh ","date":"16 julio 2020","externalUrl":null,"permalink":"/2020/07/16/de-bash-a-zsh/","section":"Posts","summary":"\u003cp\u003eCon la reciente liberación de MacOS Catalina, Apple anunció que entre alguno de los cambios al sistema operativo, se utilizará a partir de esta versión un nuevo \u003cem\u003eshell\u003c/em\u003e que de manera regular se utilizaba en la app Terminal y en otras aplicaciones utilizadas por los desarrolladores para interactuar con la Mac a través de la línea de comandos.\u003c/p\u003e","title":"De Bash a Zsh","type":"posts"},{"content":"","date":"16 julio 2020","externalUrl":null,"permalink":"/tags/shell/","section":"Tags","summary":"","title":"Shell","type":"tags"},{"content":"","date":"16 julio 2020","externalUrl":null,"permalink":"/tags/terminal/","section":"Tags","summary":"","title":"Terminal","type":"tags"},{"content":"","date":"16 julio 2020","externalUrl":null,"permalink":"/tags/zsh/","section":"Tags","summary":"","title":"Zsh","type":"tags"},{"content":"","date":"15 julio 2020","externalUrl":null,"permalink":"/tags/arquitecturaarquitectura_de_software/","section":"Tags","summary":"","title":"Arquitecturaarquitectura_de_software","type":"tags"},{"content":"","date":"15 julio 2020","externalUrl":null,"permalink":"/tags/podcast/","section":"Tags","summary":"","title":"Podcast","type":"tags"},{"content":"Tuvimos una plática con Agustín Ramos acerca de la arquitectura de software y lo que debes aprender para practicarla. Este pequeño artículo incluye nuestro resumen y las recomendaciones de Agustín.\n¿Qué es la arquitectura de software? # La arquitectura del software incluye el diseño del sistema a alto nivel: la descomposición del sistema en módulos, la descripción de las responsabilidades de cada uno y sus relaciones.\nTambién incluye las prácticas y herramientas que permitirán que el proyecto cumpla con los atributos de calidad o requerimientos no funcionales.\nTodo lo anterior está basado en un análisis de las funciones y atributos de calidad del sistema.\nEl proceso # En la plática tocamos 5 etapas del desarrollo de una arquitectura:\nDescubrimiento y definición de los atributos de calidad. Básicamente consiste en entender el problema, escuchar a todos los involucrados en el proyecto y definir los atributos del software que no están directamente relacionados con la funcionalidad, pero que debe de cumplir.\nDiseño del sistema. Generalmente te ayudarás de estilos de arquitectura y patrones de diseño para llegar a los objetivos funcionales y no funcionales.\nValidación del diseño. Mediante la creación de prototipos se puede validar que las asunciones principales acerca del diseño y su relación con los atributos de calidad se cumplen. Esto puede derivar en cambios sobre el diseño que lo mejoren.\nComunicación del diseño. Después de definir la arquitectura es importante comunicar el diseño al equipo mediante un exposición directa y la documentación. Esta documentación debe incluir la mayor información posible sobre la razón de las decisiones y la evolución de la arquitectura.\nSeguimiento del diseño. Esto incluye varias cosas:\nVerificación de que el equipo está siguiendo el diseño. Esto se logra con revisiones constantes con el equipo: programación en parejas y revisión de código. El diseño nunca está está escrito en piedra. Después de las revisiones de código se descubrirán cosas que no están funcionando como se esperaba, por lo que será necesario modificar el diseño y dejar registro de los cambios y las decisiones tomadas. Consejos específicos # Los arquitectos de software deben encontrar la solución más simple posible porque si no va a ser rígida.\nAcerca de la documentación, Agustín recomienda, exponerla al equipo en una junta y hacer un video de esto, que se le pase a cada integrante del equipo. Se puede seguir el marco llamado \u0026ldquo;Arquitectura 4 + 1\u0026rdquo; que se compone de:\nVista de Componentes Vista de Desarrollo Vista de Procesos Vista Física Vista de Casos (Este es el +1) Además, tenemos que mantener una bitácora de los cambios y los factores que los impulsaron, esto puede ser mediante los Architectural Decision Records.\nCómo empezar # Agustín nos recomendó algunos recursos para que empieces a aprender:\nObject Design - Rebecca Wirfs-Brock Software Architecture in Practice Como alternativa al libro anterior se recomienda Technical Report sobre arquitectura del Software Engineering Institute, encontré varios, tienes un ejemplo aquí. Design it! - Micheal Keeling La serie Pattern-orinted Software Architecture Para aprender patrones de diseño se habló de los siguientes libros:\nPatrones de Diseño - Erich Gamma, et Al. The patterns handbook La serie Pattern language of program design (5 libros) Y entre los libros que se mencionan como la fuente de las ideas de patrones y diseño:\nThe nature of order de Christopher Alexander y los otros libros de él como A timeless way of building The art of Scalability El capítulo # De todos modos no te pierdas el capítulo, que estuvo muy bueno:\n","date":"15 julio 2020","externalUrl":null,"permalink":"/2020/07/15/recursos-para-aprender-arquitectura-de-software/","section":"Posts","summary":"\u003cp\u003eTuvimos una plática con \u003ca\n  href=\"https://twitter.com/machinesareus\"\n    target=\"_blank\"\n  \u003eAgustín Ramos\u003c/a\u003e acerca de la arquitectura de software y lo que debes aprender para practicarla. Este pequeño artículo incluye nuestro resumen y las recomendaciones de Agustín.\u003c/p\u003e","title":"Recursos para aprender Arquitectura de Software","type":"posts"},{"content":"","date":"15 julio 2020","externalUrl":null,"permalink":"/tags/thedojomx/","section":"Tags","summary":"","title":"Thedojomx","type":"tags"},{"content":"Todo lo relacionado con el pensamiento computacional (la programación, la inteligencia artificial, las computadoras) ha estado muy presente en la mente de la sociedad, porque vivimos en un mundo en el que cada aspecto de la vida se ha visto influenciado por lo que la computación permite.\nEn varios lugares del mundo se ha pensado que se debe agregar el pensamiento computacional a la educación básica que todos reciben, bajo la promesa de que mejorará en general la capacidad de pensar y resolver problemas.\nHablemos de qué es el pensamiento computacional y cómo te puede ayudar a comprender mejor el mundo creado con la ayuda de las computadoras.\n¿Qué es el pensamiento computacional? # No hay una definición clara, y todo el tiempo está cambiando lo que se entiende por este término, pero podemos dar una definición decente como la habilidad mental y las prácticas que nos permiten diseñar cálculos para que las computadoras realicen un trabajo.\nOtra acepción es la capacidad de entender el mundo como un complejo de procesos de información.\nEstas dos habilidades combinadas pueden ayudarte a resolver muchos problemas y a navegar mejor el mundo moderno.\nPor ejemplo, para tener la capacidad de diseñar algoritmos para las computadoras modernas debes entender las bases del funcionamiento y eso necesariamente te llevará a entender sus limitaciones y fortalezas, lo cuál te llevará a evitar que te engañen fácilmente.\nTener conocimiento de las capacidades además nos hace conscientes de lo que una empresa o gobierno con los suficientes recursos puede lograr en los campo de manipulación y colección de datos, inteligencia artificial, vigilancia, seguridad e influencia sobre los pensamientos colectivos.\nEl pensamiento computacional ha avanzado en por lo menos seis áreas. Veamos lo que estas abarcan.\nMétodos computacionales # Los matemáticos e ingenieros a lo largo de la historia han buscado desarrollar métodos para hacer más eficientes los cálculos y poder calcular más cosas automáticamente. Esto ha permitido que calculemos cosas que en cierto tiempo se creían imposibles.\nGran parte del trabajo que se ha realizado está dedicado a que los cálculos se puedan realizar sin entendimiento e intuición. Es por eso que se han ido desarrollando áreas de las matemáticas que tienen que ver directamente con esto:\nLa lógica El álgebra booleana La teoría de autómatas. Todo esto es con el objetivo de realizar cálculos libres de errores lo más rápidamente posible. Algunas de las tareas principales que los métodos de cómputo incluyen son:\nDescomposición de problemas en problemas más sencillos Distribución de la ejecución de los cálculos en diferentes tiempos y ejecutores Chequeo y corrección de errores Representación de información Máquinas # La computación está casada con un medio que ejecute los cálculos. Estas son las computadoras, que han variado con el paso del tiempo.\nLa principal motivación de buscar máquinas automáticas que realizaran los cálculos es eliminar los problemas inherentes a los cálculos realizados por humanos: son lentos y propensos a errores.\nLos medios en los que se ejecutan los cálculos han ido evolucionando hasta llegar a los microprocesadores que tenemos hoy que pueden realizar una infinidad de cálculos en poco tiempo.\nPara diseñar y trabajar con estas máquinas, se tienen que entender muchos conceptos, que el pensamiento computacional trata:\nRepresentación de información digitalmente y señales eléctricas como códigos binarios Diseño de circuitos Temporización con reloj de los cálculos Control de flujo Loops Memoria digital Espacios de memoria Aislamiento de procesos Tolerancia a fallos Todo esto está casado con el concepto de computadora digital que tenemos hoy (el modelo de von Neumann), pero existen otro tipo de computadoras que no ejecutan cálculos en la misma forma.\nDos ejemplos de esto son las redes neuronales y las computadoras cuánticas, que no necesitan una serie de \u0026ldquo;pasos\u0026rdquo; para resolver los cálculos y tienen un tipo de pensamiento computacional completamente diferente.\nEs en este punto en donde la computación deja de ser un campo específicamente de las matemáticas y la lógica, ya que los cálculos y los procedimientos realizados están estrechamente ligados al medio de ejecución.\nDe este apartado lo último que tenemos que mencionar es que toda la revolución del mundo que vemos hoy causada por las computadoras está causada por la gran velocidad que las computadoras han alcanzado. Sin esto, que es difícil de comprender (ve la cita de abajo), no podríamos ver todo lo que las computadoras han causado hoy.\n154,300,000,000 de operaciones por segundo en el procesador del iPhone 11 Pro.\nEducación de ciencias de la computación # Difundir el conocimiento para crear procedimientos que las computadoras automáticas puedan ejecutar es una de las principales tareas y responsabilidades del pensamiento computacional.\nAl ser una combinación de ingeniería, matemáticas y ciencia la computación nació como un campo nuevo de estudios que tomó tiempo en ser reconocido y abrazado como una ciencia más.\nLas ciencias de la computación han sido entendidas de diferentes formas a lo largo del tiempo:\nComo los fenómenos que rodean a las computadoras Entendiendo la programación como un arte y una ciencia Computación == Automatización Entendimiento del universo como una computadora gigantezca Estas etapas del entendimiento de las ciencias de la computación han modificado la forma en que el pensamiento computacional es entendido.\nIngeniería del Software # El software son los programas que las computadoras digitales modernas ejecutan para realizar los cálculos que les permiten realizar todas las tareas a las que estamos acostumbrados.\nLa construcción de software es una da las tareas más importantes que se relacionan con el pensamiento computacional. Lo más importante de esta área es la entrega confiable de software listo para entornos de la vida real (de producción), que tiene las siguientes características:\nConfiable (no falla constantemente) Usable (cumple con su función, a una velocidad adecuada) Seguro (no causa daños y no se puede robar información) Hacer software con estas características es una tarea súmamente difícil por la complejidad que implica.\nLa ingeniería es \u0026ldquo;la aplicación de las matemáticas y la ciencia a los problemas de las personas\u0026rdquo;. Así, la ingeniería de software busca establecer técnicas y procedimientos para desarrollar software correcto.\nAdemás la ingeniería del software ha buscado desarrollar herramientas que faciliten el desarrollo de software. Es un área muy compleja del pensamiento computacional que está constante evolución y el principal problema de la industria del software actual.\nDiseño de Software # El buen diseño produce un objeto que funciona para las personas en un contexto de necesidades y valores, para producir resultados de calidad y una experiencia satisfactoria. - Terry Winograd\nEl software muchas veces está hecho para interactuar con personas. La tarea del diseñador de software es diseñar programas que resuelvan los problemas de los usuarios.\nEsto tiene que ver con la forma de usarlo, las interfaces que presentará a los usuarios, las funciones, las actualizaciones, la protección de información, los medios de presentación y muchas más tareas relacionadas con crear software que deleite al usuario.\nLa principal diferencia con la ingeniería de software es que mientras la ingeniería está pensada desde el punto de vista del programador, el diseño está pensado desde el punto de vista del usuario.\nEs decir, la ingeniería asegura que el programa funciona como el programador desea, el diseño asegura que el programa hace lo que el usuario necesita.\nCiencia computacional # La ciencia ha sido completamente revolucionada por lo que la computación electrónica automática permite, desde grandes cantidades de cálculos en poco tiempo hasta simulaciones de los procesos naturales.\nDesde que la computación automática existe, ha sido una gran ayuda para llegar a lugares que no se había siquiera podido soñar. Incluso se han creado nuevas ciencias, que son la combinación de una ciencia tradicional con la computación como \u0026ldquo;Biología computacional\u0026rdquo;.\nPero la ciencia computacional requiere su propio tipo de pensamiento computacional, desde los métodos hasta el software creado. No se aplican las misma técnicas ni herramientas que para el software no usado en la ciencia. Es por eso que el uso de la computación en las ciencias he hecho avanzar a la computación.\nOtro aspecto del pensamiento computacional en la ciencia es el uso del conocimiento de los procesos de información para interpretar el mundo natural como una conexión muchos modelos de información. Esto nos revela que la computación ha influido incluso en la manera en la que vemos el mundo.\nConclusión # El pensamiento computacional es mucho más complejo de lo que parece o de los que los medios han entendido (\u0026ldquo;hacer algoritmos\u0026rdquo;).\nEste campo del pensamiento es tan grande que no alcanzaría una vida para cubrirlo en su totalidad, pero podemos tener una idea general de los campos que abarca y si nos gusta, especializarnos en uno de ellos.\nEste artículo está basado en el libro Computational Thinking de Peter J. Denning y Matti Tedre.\n","date":"9 julio 2020","externalUrl":null,"permalink":"/2020/07/09/qu%C3%A9-es-el-pensamiento-computacional/","section":"Posts","summary":"\u003cp\u003eTodo lo relacionado con el \u003cstrong\u003epensamiento computacional\u003c/strong\u003e (la programación, la inteligencia artificial, las computadoras) ha estado muy presente en la mente de la sociedad, porque vivimos en un mundo en el que \u003cem\u003ecada aspecto de la vida\u003c/em\u003e se ha visto influenciado por lo que la computación permite.\u003c/p\u003e","title":"¿Qué es el pensamiento computacional?","type":"posts"},{"content":"","date":"9 julio 2020","externalUrl":null,"permalink":"/tags/computational-thinking/","section":"Tags","summary":"","title":"Computational-Thinking","type":"tags"},{"content":"","date":"9 julio 2020","externalUrl":null,"permalink":"/tags/mit/","section":"Tags","summary":"","title":"Mit","type":"tags"},{"content":"","date":"9 julio 2020","externalUrl":null,"permalink":"/tags/pensamiento-computacional/","section":"Tags","summary":"","title":"Pensamiento-Computacional","type":"tags"},{"content":"Me llamó mucho la atención la salida de Deno v1 esta semana y le quise echar un ojito. Pero desde la explicación que da inicialmente, no entiendo exactamente lo que es y hace:\n\u0026ldquo;Deno is a simple, modern and secure runtime for JavaScript and TypeScript that uses V8 and is built in Rust.\u0026rdquo;\nAquí me surgió la pregunta: ¿Qué es un runtime para JavaScript?\nPero para contestarla, antes tengo que entender qué es V8. La respuesta es: un engine o motor de JavaScript. En este artículo explicaremos qué es y cómo funciona.\nExplicación rápida # Puedes pensar en un engine o motor de JavaScript como en el programa encargado de correr el código de JavaScript. Todos los navegadores tienen uno:\nNavegador Engine Chrome y Opera V8 Firefox SpiderMonkey Safari WebKit JSCore Edge Chakra Este, combinado con el motor web componen la mayor parte de un navegador. Los engines se pueden usar fuera de los navegadores para otras tareas, como en Deno o Node.\nEl motor de JavaScript es quien convierte tu código de JavaScript en código ejecutable por la máquina en la que va a correr.\nTeoría: Compilación contra Interpretación # Para correr un programa en cualquier lenguaje, hay que convertirlo en instrucciones que las computadoras puedan entender. Esto es el código máquina.\nLos lenguajes compilados transforman todo el código antes de ejecutarlo, por lo que pueden hacer optimizaciones generales para que el programa sea más eficiente.\nPara que el programa compile tiene que estar libre de errores. Generalmente esa compilación lleva un poco de tiempo, que va creciendo dependiendo del tamaño y complejidad del programa. Los programas compilados pueden ser más eficientes en ejecución, pero cuesta más empezarlos a correr.\nLos lenguajes interpretados van ejecutando línea por línea, sentencia por sentencia. Por esto mismo no pueden hacer optimizaciones generales, pero es más fácil y rápido para el programador empezar a ejecutarlos. Normalmente tienen un REPL (Read - Eval - Print - Loop) que puede servir para jugar con ellos y hacer pruebas.\nSe pude pensar que es más fácil desarrollar en lenguajes interpretados que compilados, por lo que su desarrollo es más rápido. Pero como los lenguajes compilados pueden hacer optimizaciones generales, son más eficientes.\nLa ejecución de JavaScript # JavaScript nació como lenguaje interpretado, para correr dentro del navegador Netscape. La idea principal de esto es que no necesitara de un paso de compilación previa, entendida como la generación de un producto intermedio que sea ejecutable.\nEl encargado de esta \u0026ldquo;interpretación\u0026rdquo;, es decir, de convertir instrucciones de JavaScript en instrucciones de la computadora es el engine o motor.\nPero los motores modernos de JavaScript están muy optimizados, la ejecución de JS puede a veces compararse con la de lenguajes completamente compilados. Y esto es gracias las optimizaciones de compilación en el momento de la ejecución: just in time o JIT.\nEn resumen: JavaScript dejó de de ser un lenguaje puramente interpretado para convertirse en un lenguaje híbrido, con interpretación y compilado JIT. Se comporta como interpretado cuando un programador lo corre, pero el motor compila el código, produciendo algunas veces un producto intermedio (bytecode) que puede ser optimizado para que las siguientes ejecuciones sean mucho más rápidas.\nLas etapas de un motor de JavaScript # Ls principales etapas son:\nEscaneo. Convierte el texto del código que escribes en tokens. Un token es un bloque de carácteres que tienen un significado sintáctico. Ejemplo: x=33 está compuesto por 3 tokens: Un identificador (x), un operador (=) y un número (33). Puedes irte por el hoyo del conejo si quieres entender como funciona el scanner de V8 aquí: Blazingly fast parsing\nParseo. No encontré la palabra correcta para traducirlo, pero se puede entender como la \u0026rsquo;lectura\u0026rsquo; de un texto que lo transforma en una estructura de datos. Esta fase convierte el conjunto de tokens generados por el scanner en un Árbol de Sintaxis Abstracta (AST - Abstract Sintax Tree). Este árbol representa tu programa sintácticamente y se pasa a la siguiente fase de la compilación.\nInterpretación. En esta fase se toma el AST y se convierte en una primera versión de código que la máquina ya puede ejecutar, sin optimizaciones. Genera además código intermedio (bytecode) que puede ser pasado a la siguiente etapa para optimizarlo. En V8 se llama Ignition\nOptimización. Esta parte es ejecutada por un compilador JIT, que analiza el código, cómo se comporta, los tipos de datos usados para crear una versión más optimizada en código máquina. Si las optimizaciones fallan, el bytecode sigue siendo ejecutado por el intérprete. En V8 se llama TurboFan.\nLas últimas dos etapas son donde el código se ejecuta, una en forma de bytecode interpretado y la otra en forma de código máquina altamente eficiente y optimizado.\nAquí puedes ver un diagrama de la secuencia de operaciones de V8.\nEjecución # Durante la ejecución, el motor de JavaScript debe mantener por lo menos dos cosas:\nLa información de tu programa En qué parte del programa estamos Esto lo hace mediante dos espacios de memoria organizados específicamente para estas tareas:\nEl Heap. Encargado de mantener la información de las variables y todo otro dato ocupado por el programa. El Stack. Encargado de llevar un registro de las llamadas a funciones y contextos de ejecución. Además necesitamos a alguien que libere memoria para que nuestro programa no crezca infinitamente en la memoria y el heap sea fácil de acceder. Esto es el garbage collector o recolector de basura.\nTodo este proceso complejo se explica en mayor profundidad aquí: Visualizing memory management in V8 Engine.\nConclusión # Esto es lo básico que necesitamos entender de lo que hace un motor de JavaScript, el encargado de ejecutar el código. Pero no es suficiente contar con alguien que pueda correr el código, necesitamos además algo que nos proporcione el material para trabajar, ya que los programas en general actúan sobre algo, u obtienen información de algún lado. Esto es el Runtime, que explicaremos en el siguiente artículo.\n","date":"17 mayo 2020","externalUrl":null,"permalink":"/2020/05/17/qu%C3%A9-es-un-engine-de-javascript/","section":"Posts","summary":"\u003cp\u003eMe llamó mucho la atención  la salida de \u003ca\n  href=\"https://deno.land/v1\"\n    target=\"_blank\"\n  \u003eDeno v1 esta semana\u003c/a\u003e y le quise echar un ojito. Pero desde la explicación que da inicialmente, no entiendo \u003cem\u003eexactamente\u003c/em\u003e lo que es y hace:\u003c/p\u003e","title":"¿Qué es un engine de JavaScript?","type":"posts"},{"content":"","date":"17 mayo 2020","externalUrl":null,"permalink":"/tags/chrome/","section":"Tags","summary":"","title":"Chrome","type":"tags"},{"content":"Debido a la emergencia sanitaria mundial, algunas universidades han liberado cursos que además de auditar, puedes cursar para obtener un certificado. Si quieres mejorar un poco tu perfil del LinkedIn aquí te ponemos unos cursos de tecnología que puedes tomar.\nProgramación # Computer Programming For Everyone\nC++ For C Programmers\nCode Yourself! An introduction to Programming\nBuild Your First Android App\n¡A Programar! Una introducción a la programación\nRobótica (para niños)\nComputer Vision Basics\nIA y Machine Learning # Español # IA para todos Inglés # Data Scince Math Skills Machine Learning for Business Professionals Cloud Computing # Cloud Computing Basics Google Cloud Platform Fundamentals for AWS Professionals Getting Started with AWS Machine Learning Introduction to Cloud Identity Industrial IoT on Google Cloud Platform Developing AI Applications on Azure Building Conversational Experiences with Dialogflow AWS Computer Vision: Getting Started with GluonCV Matemáticas # Español # Estadística y probabilidad (UNAM)\nEl Cálculo - Modelo Lineal\nEl Cálculo - Modelo Cuadrático\nEl Cálculo - Modelo Cúbico\nEl Cálculo - Otros Modelos\nInglés # Introduction to Matlab Data Scince Math Skills Pre-Calculus Introduction to Calculus Diseño # Design: Creation of Artifacts in Society The Language of Design: Form and Meaning Otros temas # Español # Pensamiento Sistémico\nMindshift: Transforma tu mente para superar obstáculos en el aprendizaje y descubrir tu potencial oculto\nART of the MOOC: Arte Público y Pedagogía\nFundamentos de la Escritura\nDesarrollo rápido de productos innovadores para mercados emergentes\nCómo hablar bien en público\nInglés # Teamwork Skills: Communicating Effectively in Groups\nIntroduction to personal branding\nThink Again I\nMarketing Analytics\nIntroduction to Skills Management\nHow to Write and Publish a Scientific Paper\nExploring Emerging Technologies for Lifelong Learning and Success\nMAking Architecture\nPuedes ver una lista actualizada de los cursos aquí: Free Learning Due to Coronavirus. Es emocionante ver todo lo que se puede aprender si uno puede ponerle el tiempo necesario.\n","date":"16 mayo 2020","externalUrl":null,"permalink":"/2020/05/16/cursos-certificados-gratuitos/","section":"Posts","summary":"\u003cp\u003eDebido a la emergencia sanitaria mundial, algunas universidades han liberado cursos\nque además de auditar, puedes cursar para obtener un \u003cstrong\u003ecertificado\u003c/strong\u003e. Si quieres mejorar un poco tu perfil del LinkedIn aquí te ponemos unos cursos de tecnología que puedes tomar.\u003c/p\u003e","title":"Cursos certificados gratuitos","type":"posts"},{"content":"","date":"16 mayo 2020","externalUrl":null,"permalink":"/tags/mooc/","section":"Tags","summary":"","title":"Mooc","type":"tags"},{"content":"Hace tiempo dimos un curso de ES6 o ES2015. Hicimos una investigación acerca de la historia, la nomenclatura, quién lo creo y porque tanta confusión con los nombres.\nEn este video explicamos eso y más: las características principales que se agregaron y la diferencia entre JavaScript y ECMAScript.\n¿Tienes dudas específicas de JavaScript? Compártelas en los comentarios e intentaremos hacer videos sobre eso.\n","date":"27 abril 2020","externalUrl":null,"permalink":"/2020/04/27/entendiendo-es6/","section":"Posts","summary":"\u003cp\u003eHace tiempo dimos un curso de ES6 o ES2015. Hicimos una investigación acerca de la historia, la nomenclatura, quién lo creo y porque tanta confusión con los nombres.\u003c/p\u003e\n\u003cp\u003eEn este video explicamos eso y más: las características principales que se agregaron y la diferencia entre JavaScript y ECMAScript.\u003c/p\u003e","title":"Entendiendo ES6","type":"posts"},{"content":"","date":"27 abril 2020","externalUrl":null,"permalink":"/tags/es6/","section":"Tags","summary":"","title":"Es6","type":"tags"},{"content":"","date":"27 abril 2020","externalUrl":null,"permalink":"/tags/videos/","section":"Tags","summary":"","title":"Videos","type":"tags"},{"content":"Una burla común hacia los programadores es que todo lo queremos hacer demasiado general. Nos piden una funcionalidad y en ese momento empezamos a pensar en todos los casos en los que podría ser usado en el universo.\nHay muchos consejos en contra de escribir código que abarque muchos casos. En este artículo vamos a hablar de las ventajas y desventajas de módulos de propósito general, es decir, vamos a hablar en contra de la sabiduría popular.\nPero además hablaremos del equilibrio y cómo lograrlo.\nEspecificidad de un módulo # Puedes pensar en la especialización de un módulo (o del código en general) como en continuo que va desde algo que se puede utilizar en muchos muchos casos (las bibliotecas estándar) hasta código que sólo sirve para un uso muy acotado y es muy difícil de cambiar.\nUn módulo específico está dedicado a cumplir una sola función en el sistema y sólo se puede usar para eso. Si los pensáramos como conectores para un dispositivo, como un celular, podrías decir que es la conexión especial que Nokia, Apple o Sony Ericsson se inventaron en su tiempo para cargar.\nUn módulo de propósito general se puede usar para varios casos con poca modificación, o creando un módulo más específico a partir de él. En el mismo ejemplo de los dispositivos electrónicos puede compararse al estándar USB que sirve para múltiples cosas y puede ser usado en muchos aparatos diferentes.\nMódulos específicos # El caso más extremo del código específico es el que llamamos hardcoding. Es tan específico que sirve sólo para una instancia muy pequeña de un problema y no es fácil de modificar en producción.\nSe entiende como hardcoding a poner directamente en el código un valor fijo que pudiera variar en el futuro: configuración de IP\u0026rsquo;s, conexión a bases de datos, nombres de usuario, etc. Y es uno de los casos extremos de programación táctica. Por lo tanto, y esto todos lo sabemos, es una muy mala práctica para crear código mantenible e incluso para la practicidad en el desarrollo.\nEl siguiente nivel de especificidad y con el que casi todos nos quedamos contentos es cuando creamos un módulo (una clase, por ejemplo), para una función específica de nuestro sistema y que sólo puede usarse ahí.\nUsemos como ejemplo un programa para registrar publicaciones impresas como libros, revistas, periódicos, panfletos, etc. Una manera de diseñarlo es creando en el módulo una función para cada tipo de publicación:\ndef registrar_libro(...): pass def registrar_revista(...): pass ... def registrar_panfleto(...): pass Esto nos llevaría a tener una interfaz muy amplia y generalmente funciones o módulos poco profundos. Además, si agregamos un nuevo tipo de publicación se tendría que crear una nueva función para atenderlo.\nMódulos de propósito general # Un módulo de propósito general puede tener, casi siempre, una interfaz más sencilla que un módulo de propósito específico. Siguiendo con el ejemplo de los libros, en vez de crear una función para cada uno de los tipos de publicación se podría crear una general:\ndef registrar_publicacion(...): pass def registrar_tipo_de_publicacion(...): pass Esto permitiría tener una interfaz más sencilla con aplicaciones más amplias, con más usos.\nEl ejemplo mencionado por A Philosophy of Software Design es el de un editor de texto con interfaz gráfica. La clase encargada de almacenar el texto en memoria deber tener las capacidades para modificarlo.\nPiensa en las operaciones que los editores de texto dan: insertar texto, borrar texto hacia adelante, borrar texto hacia atrás, seleccionar, copiar, pegar. Ousterhout menciona que implementar una función específica para cada una de estas operaciones crea complejidad no necesaria. Un diseño más general permite hacer tres operaciones: insertar texto, borrar texto y mover el cursor. Todas las operaciones se pueden lograr con estas otras tres, teniendo una interfaz más sencilla.\nEste debería ser nuestro objetivo: crear interfaces sencillas que hagan mucho por nosotros.\n¿Por qué hacer módulos de propósito general? # El principal motivo que A Philosophy of Software Design menciona es que los módulos de propósito general son más profundos es decir, encierran más funcionalidad con una interfaz pequeña.\nHacerlo contribuye a que tu código esconda más información y por lo tanto su uso sea más simple.\nAdemás los módulos demasiado específicos crean acoplamiento en el sistema que no es sano: los usuarios del módulo tienen que adaptarse a una interfaz mu específica.\nLos módulos de propósito general te pueden quitar trabajo en el futuro, al requerir menos modificación y poder reutilizar su código para crear nuevas funcionalidades, como en el caso extremo de las bibliotecas estándar.\nY por último una interfaz demasiado específica puede filtrar información no necesaria.\nEquilibrio # La clave para elegir qué tan específico es tu módulo es la forma en la que lo vas a utilizar: tu pieza de código tiene que ser tan general como puedas sin que dificulte demasiado su uso actual.\nTienes que evaluar qué tanto desvía del uso específico inmediato el que modifiques la interfaz para crear algo que pueda ser reutilizado.\nConclusión # Crear módulos de \u0026ldquo;no tan específicos\u0026rdquo; puede ayudarte a:\nOcultar mejor la información. Crear interfaces más concisas. Reutilizar mejor el código. Tienes que buscar el equilibrio entre crear un módulo tan específico que sólo uses una vez, contra un módulo que cubra todos los casos del mundo. El equilibrio está en un módulo que no sea difícil de utilizar para tu problema a la mano pero que puede ser (o este siendo) utilizado en varios lugares y de varias formas si es el caso.\nTu \u0026ldquo;yo\u0026rdquo; del futuro te agradecerá si logras encontrar el equilibrio, porque podrás crear funcionalidades más rápido, acelerar: una característica de la programación estratégica.\nEn el próximo artículo hablaremos de los sistemas en capas y cómo aprovechar sus particularidades para crear diseños que dominen la complejidad.\n","date":"2 abril 2020","externalUrl":null,"permalink":"/2020/04/02/a-philosophy-of-software-design-crea-m%C3%B3dulos-de-prop%C3%B3sito-general/","section":"Posts","summary":"\u003cp\u003eUna burla común hacia los programadores es que todo lo queremos hacer \u003cem\u003edemasiado general\u003c/em\u003e. Nos piden una funcionalidad y en ese momento empezamos a pensar en todos los casos en los que podría ser usado en el universo.\u003c/p\u003e","title":"A Philosophy of Software Design: Crea módulos de propósito general","type":"posts"},{"content":"","date":"2 abril 2020","externalUrl":null,"permalink":"/tags/class/","section":"Tags","summary":"","title":"Class","type":"tags"},{"content":"","date":"2 abril 2020","externalUrl":null,"permalink":"/tags/generalizaci%C3%B3n/","section":"Tags","summary":"","title":"Generalización","type":"tags"},{"content":"","date":"2 abril 2020","externalUrl":null,"permalink":"/tags/module/","section":"Tags","summary":"","title":"Module","type":"tags"},{"content":"En los artículos anteriores hemos estado hablando de cómo evitar la complejidad mediante ocultar información.\nEn este daremos algunas recomendaciones más y hablaremos de cómo no llevar este principio al extremo.\nHablemos primero de consejos que te ayudarán a mantener oculta la información que debe de estarlo.\nExponer lo menos posible estructuras de datos # Un error común cuando creamos un módulo es exponer las estructuras de datos internas hacia otros módulos. Esto hace el código que usa tu módulo sea dependiente de detalles de implementación que no le conciernen y, como hemos repetido hasta el cansancio, que una decisión de diseño se vea reflejada en varios lugares.\nTransforma las estructuras de datos internas en estructuras de uso general que no dependan de la implementación de tu módulo. Por ejemplo, si estás haciendo una conexión con una API de la que extraes información para otros lados del sistema, comunica esa información en una estructura de datos diseñada para tu sistema no dependiente de la API.\nEjemplo. Imagina un módulo de comunicación con diferentes API\u0026rsquo;s de mensajería como WhatsApp, Messenger, etc. Cada una las API\u0026rsquo;s avisa de la entrada de un nuevo mensaje con sus datos específicos y en su formato. Para que to módulo encapsule la mayo cantidad de decisiones de diseño posible debería crear una estructura de mensajes que los demás módulos recibieran independientemente del medio por el que llegó el mensaje. Lo mismo para responder: la función encargada de la respuesta debería recibir siempre los mismos datos independientemente del mensajero que se esté usando.\nDefaults útiles # Tal vez este punto merezca su propio artículo pero tratemos de resumirlo.\nLa idea de crear un módulo es, a parte de ocultar complejidad, crear un pieza de código que pueda ser reutilizable. Como la operación no es siempre exactamente igual, a veces hay que incluir parámetros que permitan modificar el comportamiento del módulo. Los parámetros pueden llegar a revelar detalles de implementación, así que es conveniente saber diseñarlos, primero para no contaminar la interfaz y segundo para mantener la interfaz fácil de usar.\nJohn Ousterhout habla como ejemplo de lo mal diseñada que está la interfaz de la clase FileInputStream de Java, que no es capaz de realizar una lectura con buffer sin que le pases una clase que lo hace explícitamente. La lectura de un archivo con un buffer es normal, generalmente no quieres leer un archivo sin tener el buffer disponible. Entonces el default de esta clase debería ser la lectura con buffer, sin que se lo tengas que pedir explícitamente.\nLos módulos deberían hacer lo normal o lo correcto siempre que sea posible, sin que se tenga que pedir explícitamente. Es decir, tus módulos deberían estar diseñados para hacer el caso más común muy fácil de usar.\nLas mejores funciones son las que obtienes sin siquiera saber que existen. - John Ousterhout\nUn ejemplo de buen diseño son los lenguajes modernos con la codificación de las cadenas: son utf-8 por default, ya que es \u0026rsquo;lo correcto\u0026rsquo; y lo común.\nOtro ejemplo son las funciones split (separar una cadena) y join (juntar los elementos de un array o lista en una cadena) de Python, Elixir y otros lenguajes: si no le pasas el carácter que usarán para dividir o pegar, lo harán por la cadena vacía, facilitando un caso de uso muy común.\nPodemos aprender de estos buenos diseños para crear los propios. Por ejemplo, imagina que tienes un módulo que usa la fecha y hora para registrar algo. El caso común es que registres algo en el momento inmediato que sucedió. Un buen default sería que el módulo automáticamente registrara la hora actual sin esperarla del usuario, pero dando la opción de modificarla en caso de que se necesite. Un programa que hace esto es Git, registra automáticamente un commit con la hora en que lo hiciste pero tiene la opción de que la especifiques o modifiques.\nAisla dentro de las clases y paquetes # Cuando trabajas con clases, es buena idea crear métodos independientes (privados en caso de ser posible), que oculten información del resto de la clase. Piensa en esto como en aplicar los principios anteriores a nivel de clase. Además las variables de clase o de instancia deberían ser usadas en el menor número de lugares posible.\nSi estás usando un lenguaje funcional o procedural, aplica este principio al nivel de tus paquetes (y definitivamente evita variables globales lo más que puedas).\nFinalmente hablemos de cómo llevar todo esto demasiado lejos.\nLa clase dios # En artículos pasados hablamos un poco de que es mejor crear clases grandes que encapsulen decisiones de diseño completas en vez de dividir esas decisiones de diseño. Pero si no tenemos cuidado, esto nos puede llevar a crear lo que algunos conoce como \u0026rsquo;the God Class\u0026rsquo; o la clase dios.\nEsta infame clase es la que en muchos sistemas se ha creado para mantener la mayoría de la información y operación, es decir, es una clase que lo sabe y lo puede todo. Crearla romería el propósito de ocultar información: pasarías la mayor parte del tiempo trabajando en esta clase, que por lo general sería muy complicada, teniendo tantas cosas que hacer. Así que evítala a toda costa.\nOcultar información que sí se usa afuera # Sería un error grave de diseño hacer inaccesible (en lenguajes que lo permiten), o difícil de encontrar, información que se usa afuera de tu módulo. Un ejemplo que da A Philosophy of Software Design es en el caso de parámetros de configuración que afecten el rendimiento de una pieza de software y que sea absolutamente necesario conocer para operar bien (podría ser el método de conexión en una red, por ejemplo).\nEn el ejemplo de las API\u0026rsquo;s de mensajería del que hablamos arriba, piensa por ejemplo que la parte del código encargada de generar un mensaje necesita saber de dónde viene el mensaje para generar un mensaje adecuado al medio (si viene de SMS hará un mensaje mejor de 100 carácteres, por ejemplo).\nO algo a lo que la mayoría de los lenguajes de programación nos obligan: especificar el modo de apertura de u archivo.\nSin embargo, tu trabajo como diseñador de software consiste en minimizar la información que se necesita fuera del módulo, para que sea lo más fácil de usar dentro de los límites.\nConclusión # Este y los artículos anteriores quieren dejar claro algo: el trabajo principal de un módulo es ocultar información. Hay varias formas de lograrlo y detalles a los cuáles ponerles atención. Hacerlo creará código que sea más fácil de entender y mantener.\nEn el próximo artículo hablaremos de por qué es mejor crear módulos de propósito general.\n","date":"18 marzo 2020","externalUrl":null,"permalink":"/2020/03/18/a-philosophy-of-software-design-recomendaciones-de-dise%C3%B1o-modular/","section":"Posts","summary":"\u003cp\u003eEn los artículos anteriores hemos estado hablando de cómo evitar la complejidad mediante ocultar información.\u003c/p\u003e\n\u003cp\u003eEn este daremos algunas recomendaciones más y hablaremos de cómo no llevar este principio al extremo.\u003c/p\u003e","title":"A Philosophy of Software Design: Recomendaciones de diseño modular","type":"posts"},{"content":"","date":"18 marzo 2020","externalUrl":null,"permalink":"/tags/complexity/","section":"Tags","summary":"","title":"Complexity","type":"tags"},{"content":"","date":"18 marzo 2020","externalUrl":null,"permalink":"/tags/defaults/","section":"Tags","summary":"","title":"Defaults","type":"tags"},{"content":"","date":"18 marzo 2020","externalUrl":null,"permalink":"/tags/interfaces/","section":"Tags","summary":"","title":"Interfaces","type":"tags"},{"content":"","date":"18 marzo 2020","externalUrl":null,"permalink":"/tags/software-design/","section":"Tags","summary":"","title":"Software-Design","type":"tags"},{"content":"En el artículo pasado hablamos de una forma de evitar una fuga de información, que consiste en encapsular una decisión de diseño en un módulo.\nOtra forma de dejar escapar información no relevante para los usuarios de una pieza de software es mediante obligarlos a usarla siempre de la misma forma, con el mismo orden de operaciones reglas de operación implícita. Esto se llama descomposición temporal. Hablemos más de ella.\nQué es la descomposición temporal # En descomposición temporal, la estructura de un sistema corresponde al orden en el tiempo en el que las operaciones ocurrirán. - John Ousterhout\nLa descomposición temporal implica repetir o separar una decisión de diseño por causa del orden en que se usan diferentes partes del sistema.\nEjemplos # John Ousterhout menciona un ejercicio que puso a sus alumnos en el que tenían que crear un programa implementando el protocolo HTTP.\nAlgunos equipos crearon una clase para recibir el mensaje desde la red y otra clase para leerlo, creando así un caso claro de descomposición temporal: como las operaciones sucedían en diferentes momentos (primero recibes y luego lees y procesas) los separaron lógicamente en dos clases que se usaban siempre una detrás de otra. La fuga de información se dio porque para recibir un paquete HTTP tienes que leer parte del mensaje y entonces la lógica de lectura del mensaje está en ambas clases.\nOtro ejemplo más o menos obvio es la lectura y escritura de archivos. Si quieres trabajar con archivos, el orden de las operaciones es la siguiente:\nAbrir y leer Operar con información del archivo Escribir el archivo Un diseño que deja escapar información sería tener dos clases diferentes para la parte de escritura y lectura, cada una con código repetido que sabe leer el formato del archivo.\nEjemplo 3: imagina las diferentes situaciones en las que un elemento de datos cambia de estado a través de su ciclo de vida. Puede ser una solicitud de crédito, un reporte, un blogpost, etc.\nEs tentador crear diferentes entidades de datos y clases para representar algún estado en específico, ya que podría hacer que nuestro código fuera un poco más explícito cuando llamamos las clases o métodos.\nPero si no hay operaciones especiales que correspondan a ese estado, o datos únicos para esta etapa, crear un módulo específico implicaría descomposición temporal: estarías dividiendo o duplicando conocimiento a través de diferentes módulos debido al orden en que suceden los eventos.\nComposición de funciones # En los lenguajes funcionales es común usar una serie de funciones aplicadas a una entidad de datos. Por ejemplo en Elixir es común hacer lo siguiente.\n# El operador |\u0026gt; Toma el resultado de la función o valor # de la expresión anterior (o a su izquierda) y lo manda # como primer parámetro a la función a la derecha, parecido # a una redirección de salida de Unix \u0026#34; the dojo \u0026#34; |\u0026gt; String.trim # Limpiar los espacios sobrante a la cadena \u0026#34; the dojo \u0026#34; |\u0026gt; String.split(\u0026#34; \u0026#34;) # Separar la cadena |\u0026gt; Enum.map(\u0026amp;(String.capitalize(\u0026amp;1))) # Poner en mayúsculas cada uno de los elementos |\u0026gt; Enum.join # Volver a juntar la cadena # Resultado: \u0026#34;The Dojo\u0026#34; Este ejemplo es un poco exagerado para la función que realiza: poner un texto con capitalización estilo título, Todas Las Iniciales En Mayúsculas.\nLa idea viene de las matemáticas y se llama \u0026ldquo;composición funcional\u0026rdquo; y como se puede ver es excelente para usar funciones existentes en la creación de procesos más complejos. Una de las virtudes de esta técnica es la reutilización de las funciones.\nSin embargo, queriendo aplicar esta idea, puedes cometer el error modificar tus módulos (en lenguajes funcionales: funciones), para aplicar esta técnica y terminar con funciones que siempre se usen una tras otra, esperando la entrada de la misma función y mandando su resultado siempre a la misma función. Algo así:\n\u0026#34;datos\u0026#34; |\u0026gt; MiModulo.mi_funcion_1 |\u0026gt; MiModulo.mi_funcion_2 |\u0026gt; MiModulo.mi_funcion_3 Esto es un error que yo he cometido y que ha hecho mi código muy difícil de mantener, ya que al cambiar una función de esta cadena tengo que cambiar las demás, haciéndolas no reutilizables.\nSolución a la descomposición temporal # La solución propuesta por A Philosophy of Software Design es muy sencilla: concentra todas las operaciones relacionadas con una decisión de diseño en un módulo.\nSi nada necesita ser conocido fuera de este módulo (ni detalles de la implementación, ni el orden de operación), has logrado un diseño más limpio. Esto puede implicar que la clase se haga más grande, pero es una mejor solución comparada con tener información repartida por todos lados.\nAsí, si la decisión de diseño cambia, sólo tienes que cambiar la implementación y no la interfaz ni mucho menos su uso.\nEn el siguiente artículo veremos finalmente una serie de recomendaciones para evitar las fugas de información y como no llevarlo demasiado lejos.\n","date":"16 marzo 2020","externalUrl":null,"permalink":"/2020/03/16/a-philosophy-of-software-design-descomposici%C3%B3n-temporal/","section":"Posts","summary":"\u003cp\u003eEn el artículo pasado hablamos de una forma de evitar una fuga de información, que consiste en encapsular una decisión de diseño en un módulo.\u003c/p\u003e\n\u003cp\u003eOtra forma de dejar escapar información no relevante para los usuarios de una pieza de software es mediante obligarlos a usarla siempre de la misma forma, con el mismo orden de operaciones reglas de operación implícita. Esto se llama descomposición temporal. Hablemos más de ella.\u003c/p\u003e","title":"A Philosophy of Software Design: Descomposición Temporal","type":"posts"},{"content":"","date":"16 marzo 2020","externalUrl":null,"permalink":"/tags/descomposici%C3%B3n-temporal/","section":"Tags","summary":"","title":"Descomposición-Temporal","type":"tags"},{"content":"","date":"11 marzo 2020","externalUrl":null,"permalink":"/tags/decisiones-t%C3%A9cnicas/","section":"Tags","summary":"","title":"Decisiones-Técnicas","type":"tags"},{"content":"Este artículo está basado en la presentación Choose Boring Technology de Dan McKinley.\nNo hay nada que haga más feliz a un desarrollador que trabajar con el último de los frameworks, lenguaje de programación o herramienta que salió el mes pasado.\nEste problema se incrementa si trabajas en web, específicamente en JavaScript, donde cada semana tenemos un framework nuevo.\nPero hacer esto puede llevar a tu empresa o producto al desastre, como ha pasado muchas veces. Veamos algunas de las razones.\nQué es la tecnología aburrida # Cuando hablamos de tecnología aburrida en este artículo nos referimos a aquello que no es nuevo y brillante como el último framework: cosas que se han usado por mucho tiempo y que a nadie le emocionaría usar porque no es novedoso.\nEjemplos # Tecnología brillante:\nEl último lenguaje de programación para hacer concurrencia (Crystal, Pony o algo así) Aunque tenga tiempo existiendo, la cosa que casi nadie en el mundo usa (como OCaml o Ío) La base de datos, servidor web, etc. en la que no has trabajado antes pero quieres usar para complementar tu stack (\u0026ldquo;Vamos a agregarle CouchDB, creo que puede resolver el problema mejor\u0026rdquo;). No tiene que ser completamente nuevo, puede ser novedoso sólo para ti y tu equipo.\nTecnología aburrida:\nUna modesta instalación de Python, Django y PostgreSQL La instalación común de PHP con Laravel y las tecnologías asociadas Java con Spring El framework y lenguaje con el que trabajas normalmente y tienes más experiencia Con tecnología aburrida no nos referimos a cosas malas, sino a cosas que no son emocionantes por nuevas.\nHablemos ahora de por qué es casi siempre más provechoso escoger \u0026ldquo;tecnología aburrida\u0026rdquo;.\nLa capacidad de innovar es limitada # Piensa que tu empresa o producto tiene una capacidad limitada de resolver problemas, generalmente determinada por el tiempo para salir al mercado (o aprovechar una nueva oportunidad de negocio) y por el dinero disponible. El autor de la presentación facilita pensarlo diciendo que tienes unas cuántas \u0026ldquo;Innovation tokens\u0026rdquo; o monedas de innovación. Mientras más limitantes tengas, como el tiempo o el dinero, menos de monedas de innovación tienes.\nSi quieres resolver un problema de manera novedosa, puede que eso requiera todas tus moneditas, o incluso más. Y generalmente es aquí donde cualquier negocio quiere gastar sus energías. Esto se explica viendo a las empresas como si fueran humanos.\nSi piensas en la innovación como un recurso escaso, empieza a perder sentido también estar en las líneas frontales de innovación en bases de datos. O de paradigmas de programación. El punto no es que esas cosas no puedan funcionar. Claro que pueden funcionar. Pero el software que ha existido por más tiempo tiende a necesitar menos cuidado y atención que el software que acaba de salir. - Dan McKinley\nPirámide de Maslow # Abraham Maslow propuso en los 60\u0026rsquo;s una jerarquía de las necesidades humanas, conocida como la Pirámide de Maslow, en la que se habla de diferentes tipos de necesidades jerarquizadas, desde las fisiológicas hasta las emocionales.\nSu tesis principal es que tienen que cumplirse las de la base de la pirámide (fisiológicas; comer, dormir, respirar) antes de cumplirse las de la punta (moralidad, creatividad, etc).\nLo que explica Maslow acerca la satisfacción de las necesidades tiene lógica: no puedes preocuparte por cosas como si la filosofía de los estoicos es correcta si no tienes lo suficiente para comer hoy, o no has dormido en tres días. O peor aún, no puedes pensar en tu movimiento siguiente si te estás quedando sin aire.\nLo mismo pasa a nivel tecnológico y de supervivencia en las empresas o proyectos: no puedes pensar en formas de beneficiar a tu cliente, de resolver ese problema tan difícil de manera innovadora si te estás pelando con mantener viva en producción una base de datos.\nAsí que desde el punto de vista económico tiene completo sentido: escoger tecnología lo más fácil de entender, en la que tengas experiencia o sea fácil encontrar expertos que te guíen, tiene más lógica que escoger lo más nuevo.\nLa tecnología \u0026lsquo;aburrida\u0026rsquo; es más segura # Existen sólo dos tipos de lenguajes: de los que la gente se queja y los que nadie usa. - Bjarne Stroustrup\nLa tecnología como los lenguajes, librerías, bases de datos y en general software y hardware que lleva mucho tiempo existiendo es más confiable en el sentido de que conocemos sus fallas, sus limitantes y existen personas que nos pueden contar sus usos y malos usos.\nTodos los proyectos de software respetables tienen una lista de errores conocidos, que puedes consultar en su documentación y el tiempo estimado en que se resolverá, si no se resolverá y las formas de darle la vuelta. En pocas palabras ya sabes que esa tecnología apesta y sabes por qué.\nUna tecnología nueva no tiene esto, y las sorpresas que la esperan pueden ser muy grandes y desagradables. Pero aquí entramos en el campo del riesgo y el conocimiento humano.\nCosas que no sabes que no sabes # Todas las cosas que son capaces de ser aprehendidas por la mente humana caen en una de cuatro categorías:\nCosas que no sabes que sabes. Son cosas que sabes inconscientemente, como caminar, respirar, mover tus manos, etc. Puede haber otras menos automáticas, que se pueden descubrir con un poco de razonamiento, como la ortografía de una palabra o gramática. Por ejemplo, sabes conjugar en modo subjuntivo la mayoría de los verbos de tu idioma pero si no has estudiado la gramática del lenguaje tal vez ni siquiera sabes que existía el modo subjuntivo.\nCosas que sabes que sabes. Este es lo que entendemos como \u0026ldquo;conocimiento\u0026rdquo; cuando hablamos de él. Por ejemplo sabes que escribir está dentro de tus habilidades. O sabes que puedes sumar.\nCosas que no sabes que no sabes. Cosas que estás consciente de no saber, como física cuántica o análisis de variable compleja. Mientras más sepas de algo, más probable es que te des cuenta que no sabes otras muchas cosas de ese mismo tema. De ahí la frase: \u0026ldquo;Sólo sé que no sé nada\u0026rdquo;.\nCosas que no sabes que no sabes. Esto es lo que nos pone en riesgo. Aquí caen muchos eventos futuros y la mayor parte del conocimiento disponible está en esta área para cualquier persona. Por ejemplo, no sabemos que no sabemos las causas de un desplome económico. De esto ni siquiera podemos hablar porque no sabemos que existe. Esto es lo que podemos nombrar como incertidumbre.\nLa quinta categoría, que N. N. Taleb describe en su libro Cisne Negro, son las cosas que no podemos saber, como el futuro o las causas de algo en el pasado.\n¿Por qué es importante esto? La cantidad de cosas que sabemos que no sabemos o que fallan de un proyecto \u0026ldquo;aburrido\u0026rdquo; o probado pueden ser muchas, pero sabemos que ahí están y nos podemos proteger contra ellas. Aún hay cosas que no sabemos que no sabemos, la incertidumbre nunca se elimina, pero son menores al tener más experiencia colectiva sobre algo.\nEn las tecnologías de reciente creación hay mucha información que no sabemos que no sabemos. La cantidad de incertidumbre es mucho mayor, incluso con cosas no relacionadas directamente con la tecnología, como el entorno en el que se está creando. ¿Matarán mañana al proyecto?\nReducir la incertidumbre al máximo posible debe ser uno de los objetivos de cualquier buen arquitecto o diseñador de software.\nIntegración # Cuando hablamos de tecnología probada, no sólo nos referimos a componentes individuales sino a conjuntos de tecnologías usados para resolver un problema comúnmente. Piensa en PHP + MySQL + Memcache, Python (Django) + PostgreSQL + Redis.\nUna dificultad extra de usar la tecnología más nueva es que es probable que la tecnología que ya estamos usando no se lleve bien, pero no lo sabremos hasta que la probemos y encontremos las nuevas dificultades.\nSistemas en producción y número de piezas # Mantener algo en producción es difícil y requiere trabajo y planeación. No porque puedas empezar a usar Neo4J en cinco minutos significa que debas usarla en tu próximo proyecto, ya que el número de elementos diferentes que uses en tu sistema está directamente relacionado con la dificultad de mantener tu sistema en producción y estable.\nDeberías buscar resolver el mayor número de problemas con el menor número de tecnologías posible. Hacerlo te evitará crear una maraña de sistemas imposible de entender y mantener.\nEcosistema # Escoger tecnología que ha sido usada por mucho tiempo y que ya no es novedosa, permite que te aproveches de un cuerpo de conocimiento que ya está disponible para que aprendas, un montón de problemas resueltos y compartidos por otros y un ecosistema maduro que te permitirá avanzar en tus problemas específicos más rápido.\nNo hay nada peor cuando estás desarrollando que encontrarte con un problema incomprensible (y una pregunta sin respuestas en Stack Overflow) o con un bug que no ha sido resuelto en tu lenguaje o herramienta. No estoy diciendo que es el fin del mundo, pero seguramente algo que te pudo tomar 10 minutos con la ayuda de otros ahora te costará dos días resolviendo ese obscuro problema.\nDominio de la tecnología # Trabajar con la misma tecnología repetidamente hará que tu conocimiento en esa tecnología se vuelva como andar en bicicleta: pasarás al campo de la competencia inconsciente, la usarás casi como si fuera parte de tu cuerpo y podrás enfocarte más rápido en resolver tus problemas específicos.\nUna desventaja que viene con esto es la famosa frase \u0026ldquo;Aquel con un martillo piensa que todo es un clavo\u0026rdquo;, pero se puede evitar manteniéndote al pendiente de los avances tecnológicos en proyectos de juguete y empapándote de nuevas cosas mediante el estudio continuo, para que no se pierda la frescura de lo que haces.\nDespués de pensar en todo esto, aún hay veces que conviene integrar ya sea una tecnología que no se estaba manteniendo en el proyecto o lo más nuevo.\nCuando integrar nueva tecnología # El caso principal en el que conviene integrar una nueva tecnología tiene que ver con un equilibrio en los costos. La principal pregunta que debes hacer es: ¿facilita mis tareas TANTO esta tecnología que equilibra el trabajo extra que tendré que hacer?\nCon \u0026ldquo;trabajo extra\u0026rdquo; nos referimos a todo lo mencionado en los puntos anteriores, la curva de aprendizaje, la carga añadida de nueva infraestructura, las dificultades no encontradas aún, etc. Puede haber casos en los que una tecnología nueva supere todo esto, dándote una productividad mayor o permitiéndote hacer cosas que son muy muy difíciles de lograr con la tecnología actual.\nConclusión # Es más conveniente tanto para ti como para el negocio que tus golpes de dopamina vengan por el lado de resolver problemas emocionantes útiles para algún cliente y para el negocio, que por andar resolviendo problemas oscuros que nadie le proveen mucho valor (tal vez aprendizaje, pero se puede obtener de otras formas).\nEnfoca tus esfuerzos en cosas útiles para el negocio.\n","date":"11 marzo 2020","externalUrl":null,"permalink":"/2020/03/11/gu%C3%ADa-para-escoger-tu-stack-por-qu%C3%A9-deber%C3%ADas-escoger-tecnolog%C3%ADa-aburrida/","section":"Posts","summary":"\u003cp\u003eEste artículo está basado en la presentación \u003ca\n  href=\"http://boringtechnology.club\"\n    target=\"_blank\"\n  \u003eChoose Boring Technology\u003c/a\u003e de \u003ca\n  href=\"https://mcfunley.com/\"\n    target=\"_blank\"\n  \u003eDan McKinley\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eNo hay nada que haga más feliz a un desarrollador que trabajar con el último de los frameworks, lenguaje de programación o herramienta que salió el mes pasado.\u003c/p\u003e","title":"Guía para escoger tu stack: por qué deberías escoger tecnología aburrida","type":"posts"},{"content":"","date":"11 marzo 2020","externalUrl":null,"permalink":"/tags/infraestructura/","section":"Tags","summary":"","title":"Infraestructura","type":"tags"},{"content":" La idea básica es que cada módulo debería encapsular algunas piezas de conocimiento, que representen decisiones de diseño. - John Ousterhout\nEn el artículo anterior vimos por qué es bueno que los módulos sean profundos, es decir, oculten detalles de implementación y funcionalidades detrás de una interfaz lo más sencilla posible. En este y los siguientes artículos vamos a ver maneras prácticas de lograr esto, basado en ejemplos de \u0026ldquo;A Philosophy of Software Design\u0026rdquo;.\nEn este artículo hablaremos de cómo ocultar información que no es necesaria saber para usar los módulos, ya que complicaría su uso, creando carga cognitiva, uno de los síntomas y consecuencias de la complejidad innecesaria.\nPara saber cómo esconder la información debemos entender por dónde se escapa, prácticas comunes que llevan a un mal diseño y que pueden hacer que nuestro programa sea difícil de entender y mantener.\nFugas de información # Tener fuga de información es revelar información que no deberíamos, porque se rompe el propósito del encapsulamiento en el módulo.\nRecuerda la cita del principio: un módulo tiene que ocultar y mantener decisiones de diseño. Si esta decisión cambia y tienes que modificar varios módulos, tienes una fuga de información. En otras palabras, una fuga de información sucede cuando una decisión de diseño se ve reflejada en varios módulos.\nEjemplo. Piensa en una clase se conecte a una API para obtener información relacionada con los códigos postales. Para todos los usuarios de esta clase, debería ser irrelevante qué API se está usando, si es una API HTTP externa, un archivo gigantesco con todos los datos, una base de datos o lo que sea, mientras la clase cumpla con su trabajo.\nSi al hacer cambios en esta decisión de diseño tienes que cambiar otras cosas a parte de esta clase, tienes algún tipo de fuga de información. ¿Ya pensaste en las formas en las que se puede escapar la información?\nJohn Ousterhout sugiere hacerte la siguiente pregunta:\n¿Cómo puedo reorganizar estas clases para que esta parte del conocimiento general sólo afecte a esta clase?\nVeamos un ejemplo de una fuga de información. Piensa en una aplicación en la que la principal tarea sea obtener el estado del clima y mostrarlo al usuario. Para esto usaremos una API que nos dará los datos y nosotros seremos los encargados de mostrarla.\nUna pieza de información importante para obtener el clima es ala ubicación. Considera que la API actual recibe el nombre de la ciudad para devolver las predicciones meteorológicas.\nVeamos dos diseños:\nEn este escenario hacemos que la inicialización de la clase o cada una de las llamadas a sus métodos para obtener los diferentes valores manden el nombre de la ciudad de los datos que buscamos. Así, si buscamos los datos acerca de México mandamos \u0026ldquo;México\u0026rdquo; como parámetro para obtener la temperatura.\nEn otro escenario decidimos que aunque la API reciba el nombre de la ciudad, nuestra clase recibirá las coordenadas e internamente obtendremos el nombre de la ciudad de esas coordenadas y lo mandaremos a la API. Es probable que para esta transformación usemos otra clase u otro paquete.\n¿Qué diseño te parece correcto?\nEn el diseño 1 estamos revelando información acerca de la implementación de esta API específicamente. ¿Qué pasaría si tenemos que cambiar de API y la próxima necesita las coordenadas en vez de el nombre de la ciudad? Tendríamos que cambiar el diseño en la clase de la API y en los lugares en los que se usa.\nEn el segundo diseño estamos ocultando más detalles detalles de implementación, ya que las coordenadas son una forma más natural de comunicar lugares y es probable que se lo que se obtenga del usuario (por ejemplo, desde su geolocalización por dispositivo). La transformación de las coordenadas en un nombre de ciudad quita carga del usuario de nuestra clase.\n¿Puedes pensar en otros ejemplos? En el libro PoSD vienen algunos.\nEn el próximo artículo hablaremos de otra forma de fugas de información: la descomposición temporal.\n","date":"7 marzo 2020","externalUrl":null,"permalink":"/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003eLa idea básica es que cada módulo debería encapsular algunas piezas de conocimiento, que representen decisiones de diseño. - \u003cstrong\u003eJohn Ousterhout\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eEn \u003ca\n  href=\"https://blog.thedojo.mx/2020/03/02/a-philosophy-of-software-design-los-modulos-deben-ser-profundos.html\"\n    target=\"_blank\"\n  \u003eel artículo anterior\u003c/a\u003e vimos por qué es bueno que los módulos sean profundos, es decir, oculten detalles de implementación y funcionalidades detrás de una interfaz lo más sencilla posible. En este y los siguientes artículos vamos a ver maneras prácticas de lograr esto, basado en ejemplos de \u003ca\n  href=\"https://amzn.to/2H92nwA\"\n    target=\"_blank\"\n  \u003e\u0026ldquo;A Philosophy of Software Design\u0026rdquo;\u003c/a\u003e.\u003c/p\u003e","title":"A Philosophy of Software Design: Ocultar información","type":"posts"},{"content":"","date":"7 marzo 2020","externalUrl":null,"permalink":"/tags/m%C3%B3dulo/","section":"Tags","summary":"","title":"Módulo","type":"tags"},{"content":"Para reducir la complejidad de los programas es importante tener técnicas definidas. La primera que vamos a analizar es la organización y separación de código a alto nivel, es decir separación en módulos.\nPor qué es importante la separación # Antes de empezar a hablar de cómo deberíamos diseñar nuestros módulos hablemos de por qué es importante la separación.\nLa mejor forma de resolver un problema complejo es mediante la descomposición del problema en problemas más sencillos. Estos problemas se resuelven individualmente, idealmente de de manera independiente en un módulo por separado para cada uno. De esta manera podemos hacer software más mantenible y fácil de entender. Incluso se puede dividir mejor el trabajo.\nLa división del problema permite además ocultar información no relevante para el problema en cuestión.\nEsta división del trabajo es diferente dependiendo del paradigma del lenguaje de programación que usemos, así que veamos a qué nos referimos con un módulo.\n¿Qué es un módulo? # Una definición fácil y amplia de \u0026ldquo;módulo\u0026rdquo; dada por \u0026ldquo;A Philosophy of Software Design\u0026rdquo; es: todo aquello que agrupe código, proveyendo separación de funcionalidad, es decir que agrupe comportamiento en detrás de una interfaz.\nUn módulo puede ser una función, una clase, un paquete o cosas similares dependiendo del lenguaje de programación. Un módulo incluso puede ser una API HTTP u otro programa.\nComo resumen: un módulo permite hacer algo mediante una interfaz.\nAhora bien, ¿qué es la interfaz de un módulo?\nInterfaces # Ya hemos hablado sobre lo que es una interfaz, pero para resumir: es el punto en donde un sistema, en este caso específico, un módulo, se encuentra con otro (otro módulo o código que lo usa).\nUn módulo tiene una interfaz que permite a otras partes del sistema usarlo. Usaremos el caso más sencillo, una función. La interfaz de una función es su firma: su nombre, los parámetros que recibe y lo que devuelve.\nVeamos un ejemplo:\narchivo = open(\u0026#34;my_file.md\u0026#34;, \u0026#34;w\u0026#34;) # Devuelve un apuntador a un archivo abierto La interfaz de la función es su nombre open (nos permite identificarla y comunica información sobre lo que hace), el nombre del archivo como primer parámetro y el modo de operación en el segundo.\nDependiendo de la forma de agrupar la interfaz de los módulos varía, pero recuerda esto: la interfaz es la parte visible del módulo hacia otros módulos.\nDiseño de módulos # Aquí entramos en lo importante: los módulos deberían ser lo más profundos posible.\n¿A qué nos referimos con un módulo profundo? Puedes imaginarte un módulo como un rectángulo en el que su interfaz es el largo de la base y su funcionalidad es la altura. Un módulo profundo es aquel que tiene una altura elevada comparada con el largo de la base.\nObserva la siguiente imagen:\nUn módulo profundo tiene una interfaz sencilla o fácil de usar para la mayoría de los casos de uso y provee de mucha funcionalidad, hace mucho por ti.\nUn módulo superficial tiene una interfaz compleja o difícil de usar y provee poca funcionalidad.\nEsto no es absoluto: la relación entre la complejidad de la interfaz es relativa a la funcionalidad que provee, por ejemplo, si un módulo hace muchas cosas por ti, puede que requiera muchos datos. La relación interfaz/funcionalidad debe ser razonable para considerar que el módulo es profundo.\nAbrir archivos en la mayoría de los lenguajes es un ejemplo de una función profunda: con una interfaz muy pequeña (el nombre y el modo), la función se encarga de todos los detalles de implementación de apertura y creación del archivo. No te debes de preocupar por cosas como el sistema de archivos, el guardado físico en el disco, por verificar si hay memoria, etc.\nEn el caso contrario, los getters y setters que se acostumbra usar en algunos lenguajes de programación (Java) son ejemplo de funciones poco profundas, generalmente no hacen algo más que devolver el valor de la propiedad.\nEjemplo: Piensa en un aparato electrónico. En una televisión, sus control remoto te permiten acceder a las funcionalidades de encender el panel de iluminación, captar la señal del canal, decodificarlo y saltar entre diferentes canales, todo sin preocuparte tú por los detalles. Sólo la usas y ya. Mientras más detalles de implementación oculte es más fácil de usar.\nVentajas de los módulos profundos # Encontrar un equilibrio entre la cantidad de código que metes en un módulo y la interfaz que expone tiene varias ventajas:\nEl código se puede re-usar en otras partes del sistema Evitas la acumulación de interfaces, es decir, tener demasiadas interfaces (funciones, clases o módulos) que tienes que aprender a usar y que hacen poco por ti La expansión de cambios (tener que tocar muchos lados del sistema para hacer un cambio relativamente pequeño) Finalmente, recuerda que una de las funciones que proveen los módulos es ocultar la complejidad. ¿Cuántas veces has visto lo que hacen las funciones prefabricadas de tu lenguaje de programación? Es probable que ninguna. Los módulos profundos te permiten ocultar mayor cantidad de información, hace más fácil trabajar con ellos y simplifica el sistema en general.\n","date":"2 marzo 2020","externalUrl":null,"permalink":"/2020/03/02/a-philosophy-of-software-design-los-m%C3%B3dulos-deben-ser-profundos/","section":"Posts","summary":"\u003cp\u003ePara reducir la complejidad de los programas es importante tener técnicas definidas. La primera que vamos a analizar es la organización y separación de código a alto nivel, es decir separación en módulos.\u003c/p\u003e","title":"A Philosophy of Software Design: Los módulos deben ser profundos","type":"posts"},{"content":"","date":"2 marzo 2020","externalUrl":null,"permalink":"/tags/funci%C3%B3n/","section":"Tags","summary":"","title":"Función","type":"tags"},{"content":" \u0026ldquo;Controlar la complejidad es la esencia de la programación\u0026rdquo; - Brian W. Kernighan\nMuchas mentes brillantes dedicadas al desarrollo de software han estado de acuerdo en que el principal problema al crear y mantener programas es el manejo de la complejidad.\nPodemos decir que algo complejo es aquello que está compuesto por muchas piezas relacionadas entre ellas. Ousterhout lo define de manera práctica como todo aquello que hace que el software sea difícil de entender, escribir o mantener.\nLa complejidad es más visible para los lectores que para los escritores [del código]. Si escribes una pieza de código que parece simple para ti, pero otras personas piensan que es compleja, entonces es compleja. - John Ousterhout\nPhilosophy of Software Design habla de tres formas de identificar un programa más complejo de lo que debería ser:\nAmplificación de cambios Carga cognitiva Desconocidos desconocidos Identificar la complejidad es una habilidad crítica para el buen diseño de software, te permitirá crear sistemas más simples y evitará que gastes recursos en desarrollar soluciones que son demasiado complejas.\nAmplificación de cambios # Este síntoma de la complejidad se hace obvio cuando estás haciendo un cambio que debió haber sido sencillo y tienes que tocar 7 archivos, 3 clases y 4 funciones. Se refiere a que una funcionalidad que parece sencilla del programa está repartida en muchos lados y para lograr hacer un cambio hay que tocar muchas partes del sistema.\nEsto se pude dar cuando parámetros o valores que pueden estar centralizados o referenciados se ponen fijos a través de muchos archivos. También cuando código que se podría reutilizar se copia y pega.\nCarga cognitiva # Si tienes que mantener muchas cosas en la cabeza para poder entender el sistema, es complejo. Puede que tengas que entender y aprender muchas cosas acerca del funcionamiento del programa para usarlo bien y no causar un desastre. Cuando algo no tiene una interfaz simple, causa carga cognitiva.\nEl ejemplo son las funciones de lenguajes de programación que nunca aprendemos a usar porque tienen parámetros que aunque siempre son los mismos son requeridos por no tener un default decente. O por ejemplo, aquellas funciones que no recuerdas si cambian los parámetros o devuelven uno nuevo.\nAunque programas más cortos están relacionados con baja carga cognitiva, no siempre es el caso debido a que ese poco código que existe sea difícil de entender.\nDesconocidos desconocidos # ¿Tienes miedo de cambiar algo porque no sabes lo que pueda pasar y no hay ni documentación a la que puedas referirte? En este caso el sistema tiene información que no sabes que no sabes.\nUn desconocido desconocido es aquella información que ni siquiera sabemos que estaba ahí y que no conocíamos, como algunas características del código, parámetros ocultos y comportamientos que no son fáciles de detectar ni están documentados.\n¿Recuerdas la broma que dice: \u0026ldquo;Cuando escribí este código sólo Dios y yo sabíamos lo que hacía, ahora sólo Dios sabe\u0026rdquo;? Muchas veces nos pasa así con el código y es el ejemplo perfecto de los desconocidos desconocidos, sobre todo para otros programadores.\nMedición de la complejidad # Un sistema puede ser complejo independientemente de su tamaño, es decir, hay sistemas no tan grandes que son muy complejos.\nPara determinar la complejidad se puede pensar en la siguiente fórmula.\nEsto lo podríamos explicar como:\nLa complejidad total de un sistema es la sumatoria de la complejidad de cada una de sus partes multiplicada por el tiempo que los desarrolladores pasan en esa parte del código.\nEsta complejidad puede evitar que avances tanto como deberías, pero el primer paso es identificarla como lo viste aquí. En los siguientes artículos hablaremos de técnicas para reducir la complejidad.\n","date":"26 febrero 2020","externalUrl":null,"permalink":"/2020/02/26/a-philosophy-of-software-design-tres-formas-de-identificar-la-complejidad/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;Controlar la complejidad es la esencia de la programación\u0026rdquo; - Brian W. Kernighan\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eMuchas mentes brillantes dedicadas al desarrollo de software han estado de acuerdo en que el principal problema al crear y mantener programas es el manejo de la complejidad.\u003c/p\u003e","title":"A Philosophy of Software Design: Tres formas de identificar la complejidad","type":"posts"},{"content":"","date":"21 febrero 2020","externalUrl":null,"permalink":"/tags/eloquent/","section":"Tags","summary":"","title":"Eloquent","type":"tags"},{"content":" TL;DR: Estamos trabajando en una nueva traducción de Eloquent JavaScript al español, en su tercera edición. La puedes encontrar aquí: Eloquent JavaScript en Español. Está la versión en Eloquent JavaScript en Español en PDF, que actualizamos cada capítulo. Si quieres contribuir puedes ponerte de acuerdo a través de este foro o en GitHub.\nDesde el 2015 intentamos empezar a traducir la 2da edición de Eloquent JavaScript. Puedes ver el post en Medium aquí: Traducción de Eloquent JavaScript al Español.\nPasó el tiempo y tradujimos algunos capítulos, pero luego salió la tercera edición.\nDecidimos esperar a que se terminara para traducirlo completo, y hemos empezado de nuevo con los esfuerzos de traducción. Esta vez hemos empezados basados en la traducción de Luis Rodríguez quien tradujo los primeros 12 capítulos pero no pudimos contactar para ponernos de acuerdo.\nLa primera etapa de la traducción consiste en una revisión rápida de los capítulos ya traducidos, la segunda en completar los capítulos que faltan y la tercera en una revisión profunda de los 12 primeros capítulos.\nPuedes ver la página oficial del libro aquí: Eloquent JavaScript ES. Puedes leer el libro en línea o descargarlo en PDF, próximamente en EPUB y Mobi. También estamos trabajando en una portada exclusiva para la versión en español.\n¿Por qué lo hacemos?\nLa importancia del contenido en tu idioma nativo # Es cierto que si quieres ser un buen desarrollador de software tienes que aprender inglés. Si quieres ganar un mejor sueldo por poder trabajar para equipos remotos también es un requisito.\nPero es aceptado que se aprende mucho mejor en la lengua materna, así que si confías en que lo que tienes que estudiar es una buena traducción, no deberías dudar en estudiar en la lengua con la que creciste y que mejor conoces, el idioma de tus pensamientos.\nOtras veces, hay personas que no tienen otra opción y principalmente por ellas que se está realizando esta traducción. No debería sumarse la barrera del lenguaje a la carga de aprender a programar que ya es fuerte.\nEste es, esperamos, el primero de varios libros que queremos traducir al español.\nContribuciones # Si dominas el inglés (sobre todo técnico) y tienes buena ortografía, necesitamos tu ayuda para traducción. También necesitamos revisores, personas que lean el contenido y hagan comentarios (o Pull Requests) sobre frases poco claras, errores de ortografía o gramática. Si tienes habilidades de diseño gráfico necesitamos ayuda para traducir las ilustraciones.\nFinalmente, en el futuro habilitaremos algún medio para contribuciones monetarias, para acelerar la traducción mediante la contratación de traductores y diseñadores profesionales.\nNo dudes en ponerte en contacto en GitHub o a través de este artículo, en los comentarios.\n","date":"21 febrero 2020","externalUrl":null,"permalink":"/2020/02/21/eloquent-javascript-en-espa%C3%B1ol/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003eTL;DR: Estamos trabajando en una nueva traducción de Eloquent JavaScript al español, en su tercera edición. La puedes encontrar aquí: \u003ca\n  href=\"https://eloquentjs-es.thedojo.mx/\"\n    target=\"_blank\"\n  \u003eEloquent JavaScript en Español\u003c/a\u003e. Está la versión en \u003ca\n  href=\"https://eloquentjs-es.thedojo.mx/Eloquent_JavaScript.pdf\"\n    target=\"_blank\"\n  \u003eEloquent JavaScript en Español en PDF\u003c/a\u003e, que actualizamos cada capítulo. Si quieres contribuir puedes ponerte de acuerdo a través de este foro o en GitHub.\u003c/p\u003e","title":"Eloquent JavaScript en Español","type":"posts"},{"content":"","date":"21 febrero 2020","externalUrl":null,"permalink":"/tags/eloquent-javascript-pdf/","section":"Tags","summary":"","title":"Eloquent-Javascript-Pdf","type":"tags"},{"content":"","date":"21 febrero 2020","externalUrl":null,"permalink":"/tags/eloquent-js/","section":"Tags","summary":"","title":"Eloquent-Js","type":"tags"},{"content":"","date":"21 febrero 2020","externalUrl":null,"permalink":"/tags/eloquentjs-espa%C3%B1ol/","section":"Tags","summary":"","title":"Eloquentjs-Español","type":"tags"},{"content":"Cuando desarrollas software tienes dos actitudes para escoger: desarrollas de forma rápida y sucia (desarrollo táctico) o de forma ordenada, planeada y pensando en el futuro. Cada uno de estos tipos de desarrollo o filosofías de desarrollo tiene ventajas y desventajas. Pero veamos a más detalle de qué trata cada uno.\nDesarrollo táctico # Está caracterizado por la alta velocidad inicial con la que empiezas a desarrollar y crear las funciones de tu programa. Con esta actitud, tu principal objetivo es tener código que funcione. Con esta forma de trabajo no gastas mucho tiempo buscando el mejor diseño para tu programa sino que te enfocas en terminar lo más rápido posible. Tu vista está en el corto plazo.\nCon tal de terminar con la tarea lo más pronto posible, no importa si agregas algo de complejidad al sistema.\nEste tipo de desarrollo es alentado por los negocios que quieren que su código o programa esté tan pronto como sea posible sin importar el costo. ¿Tiene uso este código y esta forma de pensar? Por supuesto: cuando se quiere construir un producto muy muy rápido y se tiene conciencia de que será desechable.\nPero otra cosa que te puede llevar a desarrollar de esta manera es la falta de planeación: estimar en mucho menos tiempo una tarea o malgastar el tiempo que tenías disponible.\nEl desarrollo táctico produce programas que con el tiempo se van haciendo más y más difíciles de mantener, hasta que es tan impráctico que parece más fácil volver a hacerlo. La velocidad de desarrollo se va reduciendo.\nUna vez que empiezas a programar un sistema de esta forma, es muy difícil cambiar. Y lo más triste es que la mayoría de las organizaciones y programadores prefieren este método.\nAlgunos ejemplos de desarrollo táctico:\nHard-coding de parámetros que deberían ser configurables Duplicación innecesaria Abstracciones deficientes o complicadas en extremo Código difícil de entender Manejo de excepciones deficiente(envolver todo en un try/catch, no manejar excepciones) Desarrollo Estratégico # Este tipo de desarrollo se caracteriza por poner atención en el diseño y la calidad del código. Lo más importante no es directamente terminar la tarea pendiente, sino también hacerlo de manera que facilite las tareas futuras y mantenga la complejidad bajo control. La tarea principal es crear un muy buen diseño.\nPara el desarrollo estratégico código que funciona no es suficiente. En vez de introducir partes que hagan más complejo el código, buscas mejorar aunque sea una pequeña parte del código cada que trabajas en él.\nEsto no quiere decir que harás todo el diseño por adelantado, sino que se va a ir creando un buen diseño de las partes que se vayan necesitando.\nEs tener una actitud de inversión en la base de código.\nEsta actitud te hará ir más lento al principio, pero con el tiempo el equipo acelerará y podrá crear nuevas funciones muy rápido.\nEjemplos de prácticas desarrollo estratégico:\nProbar varias implementaciones hasta encontrar la más limpia Documentar y comentar el código Limpiar y mejorar el código cada que sea posible (cada que lo toques) Crear pruebas unitarias Revisión de código La siguiente imagen ilustra cómo se comporta el avance total en las dos formas de programar:\nComo se puede ver, el desarrollo estratégico tarda más en entregar resultados, pero vale la pena si es un proyecto importante con un tiempo de vida esperado largo. Puedes pensarlo como la diferencia entre construir una choza o construcción sin ningún tipo de diseño contra una casa bien diseñada y con buenos materiales, como en la historia de los tres cochinitos. ¿Cuál aguantará más?\nMuchas veces aquí está la diferencia entre si algo \u0026ldquo;escala\u0026rdquo; o \u0026ldquo;no escala\u0026rdquo;, no en la tecnología elegida. Es obvio que a una choza no le puedes construir un segundo piso.\nPero no seamos puristas y pensemos que si no es de la forma estratégica no vale la pena, la pregunta es: ¿Qué tipo de desarrollo conviene para tu proyecto según su tiempo de vida?\nEste y los siguientes artículos están basados en el libro \u0026ldquo;A Philosophy of Software Design\u0026rdquo; de John K. Ousterhout.\n","date":"11 febrero 2020","externalUrl":null,"permalink":"/2020/02/11/a-philosophy-of-software-design-desarrollo-t%C3%A1ctico-vs-estrat%C3%A9gico/","section":"Posts","summary":"\u003cp\u003eCuando desarrollas software tienes dos actitudes para escoger: desarrollas de forma rápida y sucia (desarrollo táctico) o de forma ordenada, planeada y pensando en el futuro. Cada uno de estos tipos de desarrollo o filosofías de desarrollo tiene ventajas y desventajas. Pero veamos a más detalle de qué trata cada uno.\u003c/p\u003e","title":"A Philosophy of Software Design: Desarrollo Táctico vs Estratégico","type":"posts"},{"content":"","date":"11 febrero 2020","externalUrl":null,"permalink":"/tags/a-philosophy-of-software-design/","section":"Tags","summary":"","title":"A-Philosophy-of-Software-Design","type":"tags"},{"content":"DevOps es un término de recientemente creación (2013) que representa un cultura de trabajo enfocada en resolver los problemas que han sido persistentes en la entrega y servicio en el área de productos tecnológicos.\nEn este artículo platicaremos qué significa y sus fundamentos.\nAdelanto: DevOps no es un rol, una palabra mágica y mucho menos automatización de servidores.\n¿Por qué importa? # En las eras económicas anteriores, los negocios creaban valor moviendo átomos. Ahora crean valor moviendo bits. - Jeffrey Snover\nAhora todas las empresas son empresas de tecnología. Las que no aprovechan la tecnología ya están siendo superadas por las que sí lo hacen. Y las que lo hacen mal en su momento serán superadas por las que usan mejor la tecnología.\nCada industria y compañía que no traiga el software al corazón de su negocio será cambiada radicalmente sin previo aviso. - Jeffrey Immelt\nAsí que es importante que las empresas aprendan a manejar lo mejor posible la tecnología y a crear valor o aumentar el valor que producen mediante ella.\nLos problemas # Si has trabajado en desarrollo de software, infraestructura o en el área de IT de alguna empresa tal vez no necesito contarte esto. Todo lo relacionado con productos digitales está plagado de proyectos no cumplidos en tiempo, nunca terminados, pasados de presupuesto, atención a clientes internos extremadamente deficiente, etc.\nNo conforme con eso hay millones de historias de terror de cómo los negocios no se interesan en lo mínimo por mejorar estas áreas, sólo exigiendo cada vez más cosas y poniendo fechas irrazonables.\nOtras historias cuentan los actos heróicos que las personas que trabajamos en estas áreas hemos tenido que hacer para cumplir con los compromisos adquiridos: trabajar toda la noche por varios días seguidos, cambios de último momentos, largas horas en despliegues y re-establecimiento de servicios, etc. O se descubre que el sistema no cumple con los requerimientos legales de protección información y ahora hay que trabajar horas extras para cumplirlo.\nY por último la vista del lado de la operación del negocio: cada que se va a poner en producción un cambio, un nuevo producto o se va a actualizar algo todos temen que algo catastrófico pase con cierta razón. Ha pasado que, por culpa de estos cambios, los sistemas que soportan la operación diaria se caen por horas haciendo perder al negocio clientes, dinero y reputación.\nTodos estos problemas son lo que DevOps ataca con 3 principios o \u0026ldquo;tres caminos\u0026rdquo;. Pero para habilitar esto, se necesita algo de la organización.\nTodos los involucrados trabajan para lo mismo # Sobre todo en empresas grandes, donde es más común dividir en departamentos debido a la gran cantidad de trabajo disponible, es normal que cada departamento busque sólo sus propios intereses y cumplir con sus métricas de desempeño sin poner en primer lugar lo más importante: la producción de valor para el negocio en general.\nAsí que la primera precondición para que se pueda alcanzar verdadera productividad es que los involucrados comprendan que todos trabajan con el fin de crear cosas de valor para que el negocio siga funcionando y pueda hacerlo cada vez mejor. Esto implica eliminar la burocracia, las guerras entre departamentos y la reducción de trabajo que sólo se hace por demostrar que se tiene algo que hacer como tristemente ha estado marcado por este estigma el departamento de Seguridad de la Información o su equivalente.\nSi la actividad qu se está haciendo no contribuye de alguna forma a crear valor para el negocio debería ser eliminada.\nEsta condición por sí misma es difícil de cumplir y sin ella no es posible lograr las demás. ¿Quiénes son los encargados poner las condiciones para que se cumpla? La dirección. La dirección de la empresa tiene la responsabilidad de elegir personas razonables, buenas en sus campos y dispuestas a cooperar para que la empresa o el proyecto progresen más allá de su ego. Repito, sin esto lo demás es imposible o inútil.\nUna vez cumplida la precondición de cooperación con personas dispuestas y hábiles, podemos hablar de los tres caminos.\nEl primer camino: Flujo # {:align-center}\nEl primer principio de DevOps establece que debe haber un flujo constante de valor en el área de tecnología de información o de sistemas, como lo quieras llamar. Algo de valor es todo aquello que permite al negocio seguir operando o incrementar los beneficios que obtiene de las operaciones.\nEl objetivo principal es minimizar el tiempo que tarda una característica/producto/servicio en entregarse desde que solicita hasta que empieza a cumplir con su función.\nDebido a que el desarrollo de software es una actividad poco predecible, DevOps se enfoca en la parte de la cadena de entrega de valor que va desde que el área de desarrollo termina algo hasta que es puesto en manos de los usuarios finales. Pero no le interesa sólo eso, ya que las personas encargadas del desarrollo deben seguir ciertas prácticas para facilitar el resto del camino.\nAcelerar esta entrega beneficia en gran manera a la forma en que se desarrolla software de calidad.\nSi estás en una empresa pequeña o en una startup puede que seas tú mismo el que desarrolle y tenga que mantener los programas en operación (producción). Así que reducir la fricción entre estas dos actividades te beneficiará aún más.\n¿Qué prácticas permiten lograrlo?\nHacer el trabajo visible. La mayoría del trabajo que realizamos al hacer productos digitales es muy difícil de estimar, tanto en dificultad como en cantidad. Es por eso que debe haber una manera física de ver el trabajo, como lo habría en un fábrica que realiza productos físicos: si una estación de trabajo tiene demasiado material inmediatamente se notará.\nReducir y limitar el trabajo en progreso. Mientras más actividades sin terminar existan, más difícil es administrarlas y notar todo el trabajo pendiente. Tener pocas actividades en progreso permite calcular mejor cuánto tardará en terminarse un nuevo requerimiento y atender los errores más rápidamente. Siguiendo con el ejemplo de la fábrica física: existe un límite físico para el material que puede esperar en una estación de trabajo.\nEstablecer procesos. Cada uno de los cambios o actividades solicitadas debe pasar por un proceso de revisión que determine si provee valor para el negocio en caso de completarse. Esto implica mantener en algún lado el registro de las tareas solicitadas y su estado actual.\nReducir el tamaño del lote trabajo. Cuando vamos a entregar algo generalmente agrupamos varias piezas de trabajo para \u0026ldquo;entregarlas más eficientemente\u0026rdquo;. Pero en realidad mientras más pequeño sea este lote de trabajo (idealmente de una tarea) mejor se hace la entrega.\nIdentificar y mejorar las limitantes. En todo proceso de trabajo hay puntos que hacen que toda la cadena de entrega de valor sea más lenta. Estos puntos son las limitantes. Para mejorar toda la cadena primero hay que identificarlos y después mejorar su eficiencia para mejorar todo el proceso de producción de valor.\nEliminar características no necesarias. Mientras más grande sea el producto más difícil será de manejar. Por lo tanto, si alguna característica no aporta valor al usuario final, necesariamente está restando valor a la compañía entera.\nAlgo que notar de las prácticas de DevOps es que muchas están extraídas de los movimientos de Lean Manufacturing. Existen otra prácticas, pero personalmente considero que estas son las esenciales.\nEl segundo camino: Retroalimentación rápida # {:align-center}\nEl segundo camino por el que el valor fluye en las organizaciones que implementan DevOps es de regreso: debe existir un flujo de información desde los sistemas en producción hacia los equipos que están desarrollando los productos y los demás equipos relacionados con esta tarea.\nEsto permite que los problemas sean resueltos según se van encontrando, primeramente. En segundo lugar habilita un flujo de retroalimentación rápido que permitirá crear mejores productos más rápido.\nLean Manufactruing recomienda que la línea de producción no debe continuar si hay algún problema con una sola de las estaciones de trabajo. Lo mismo debería pasar en los equipos de desarrollo y operaciones. Si un problema no puede ser resuelto por los encargados de ello, todo el equipo debería juntarse a resolver el problema hasta que terminen. Lo sé, esto suena contra-intuitivo y poco productivo, pero la experiencia de las fábricas japonesas demuestra que es mucho mejor resolver un problema inmediatamente en vez de dejarlo avanzar en la cadena de producción, para evitar retrabajo.\nEl tercer camino: Cultura de aprendizaje y experimentación # Después de implementar el camino hacia el cliente y de regreso, DevOps establece que se tiene que crear un cultura de aprendizaje que permita mediante ciclos de retroalimentación mejorar la forma general en la que se trabaja.\nLa siguiente imagen completa los tres caminos de DevOps:\n{:align-center}\nLa empresa debe asegurarse de que los equipos de trabajo están mejorando constantemente mediante el aprendizaje continuo.\nEsto puede lograrse mediante varias prácticas:\nExperimentación, por ejemplo pruebas A/B Introducción de fallas intencionalmente (chaos engineering) Mediciones cada vez más precisas mediante software especializado Agendar tiempo para actividades dedicadas a mejorar el equipo como Improvement Katas Este paso depende de que los dos anteriores se hayan logrado, ya que requieren de tiempo y energías, que no se tendrán si no se tiene una forma confiable de liberar el producto y de monitorear para saber que no está pasando.\nConclusión # Estos pilares fundamentales de DevOps nos pueden ayudar entender las bases de la cultura, pero ponerlos en práctica no es fácil. El libro Devops Handbook explica qué otra prácticas se deben seguir y da consejos prácticos que permiten lograrlo.\nPerfeccionar estas prácticas es algo que nunca se termina y lleva tiempo ver los resultados. Así que ¿qué esperas para empezar?\nCon este pequeño artículo esperamos que quede claro que DevOps no es un rol en la empresa.\n","date":"16 enero 2020","externalUrl":null,"permalink":"/2020/01/16/qu%C3%A9-es-devops/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003eDevOps\u003c/strong\u003e es un término de recientemente creación (2013) que representa un cultura de trabajo enfocada en resolver los problemas que han sido persistentes en la entrega y servicio en el área de productos tecnológicos.\u003c/p\u003e","title":"¿Qué es DevOps?","type":"posts"},{"content":"","date":"16 enero 2020","externalUrl":null,"permalink":"/tags/culture/","section":"Tags","summary":"","title":"Culture","type":"tags"},{"content":"","date":"16 enero 2020","externalUrl":null,"permalink":"/tags/servers/","section":"Tags","summary":"","title":"Servers","type":"tags"},{"content":"","date":"29 diciembre 2019","externalUrl":null,"permalink":"/tags/aprender/","section":"Tags","summary":"","title":"Aprender","type":"tags"},{"content":"","date":"29 diciembre 2019","externalUrl":null,"permalink":"/tags/programar/","section":"Tags","summary":"","title":"Programar","type":"tags"},{"content":"¿Quieres aprender a programar y no sabes por dónde empezar?\nEn este artículo te daremos algunos recursos que puedes seguir para aprender a programar desde lo más básico hasta tener un conocimiento razonable de programación con el que podrías empezar a trabajar.\nMotívate # Es importante conocer las bases, pero para eso antes hay que tener motivación y mantenerla. Así que empecemos por algo que te mostrará el poder de la programación y de lo que puedes hacer con un poco de conocimiento.\nEl curso de programación web de CourseIt es un muy buen punto en dónde empezar, el profesor Juani Gallo explica de manera concisa y sencilla lo que es la programación y terminarás creando una página de internet con HTML y CSS: Introducción al desarrollo web.\nPuedes empezar con la creación de una página de internet. Si buscas \u0026ldquo;Crear página web desde cero\u0026rdquo; vas a encontrar un montón de opciones, pero aquí tienes una Creando una página.\nTambién existe el curso para aprender programar de Platzi, que comienza desde los básico y con algunos ejemplos te enseña lo que se puede lograr con la programación.\nAhora sí, las bases # El legendario CS50 de Harvard te ayudará a entender las bases de las ciencias de la computación, afortunadamente ya está con subtítulos en español y es completamente gratuito. Si quieres obtener un certificado puedes pagar por él en la plataforma de cursos edX. Este curso te dará bases sólidas para poder más adelante programar lo que quieras. Aprenderás varios lenguajes: Python, C++, HTML y CSS, entre otros. Es un curso que no puedes perder si quieres ser un autodidacta de la programación.\nSi prefieres contenido con audio en español, este, y los que le siguen te puede ayudar: Curso de introducción a Python I.\nCon estos es suficiente, aunque si quieres reforzar aún más y aprender otro lenguaje te recomiendo el siguiente curso de de Uniwebsidad: Introducción a JavaScript. Este curso es bastante viejo, pero la manera de explicar del autor, la sencillez y la forma en la que avanza te hará comprender muchas cosas que te servirán para el futuro.\nCrea algo real # Es hora de aplicar y extender el conocimiento que has adquirido hasta ahora. La mejor manera es hacer algo que tenga utilidad práctica aplicable a un problema que tú o alguien cercano vea directamente.\nLa mejor manera de hacerlo es crear una descripción del problema que tienes, hacer una lista de las cosas que necesitas que haga y empezar a programarlo, investigando en el camino cualquier cosa que no sepas hacer. Para este punto es probable que ya seas hábil con los mejores amigos de aprendizaje del desarrollador: Google, Stack Overflow y YouTube.\nSi siente que aún no tienes lo suficiente aquí te dejo algunos ejemplos de cursos creando aplicaciones aunque sea pequeñas completas:\nUsando Flask y MySQL para hacer una aplicación Creando aplicaciones Multi-tenant con Django. Este curso no es gratis pero es bastante accesible. Has una especialización # El desarrollo de sistemas es un campo muy grande. Aunque está muy bien saber las bases y aunque sea un poco de diferentes campos (podríamos decir que es esencial), lograrás lo mejor en tu carrera si te especializas en algo:\nFrontend si disfrutas de las cosas visuales y tienes paciencia para luchar contra los distintos navegadores. Trabajarás con HTML, CSS y sobre todo JavaScript y sus millones de librerías. Desarrollador de aplicaciones móviles. Es un caso parecido al de frontend, tienes que crear las interfaces con las que los clientes van a interactuar, pero tu programa será instalado en un celular y tendrás que programarlo en Swift o Kotlin, teniendo consideraciones diferentes. Backend: si prefieres manejar datos, crear los sistemas que mantienen la información y los medios de comunicación (generalmente API\u0026rsquo;s) con clientes consumidores y productores de información. Elegir el lenguaje es difícil porque hay muchos, pero los más usados son Python, JavaScript, PHP, Java y C#. Administrador de infraestructura. Tendrás que aprender a manejar los servidores y a instalar y configurar las aplicaciones que permiten que los programas corran allí. Harás programas para automatizar varios de los pasos. Podrías programar en Bash, Go, Python, entre otros. Ingeniero de datos. Aprenderás a manejar programas relacionados con la captura, tratamiento y almacenamiento de grandes cantidades de datos. Sólo mencioné algunas áreas pero hay varias más y combinaciones entre ellas.\nSi quieres empezar a buscar por donde te recomiendo que busques cursos en las siguientes plataformas:\nUdacity Coursera edX Estas tres plataformas tienen cursos gratuitos en español (por lo menos subtitulados) casi sobre cualquier cosa que quieras aprender, incluído los mencionados. No te olvides de YouTube.\nAprende inglés # Si tu deseo es poder programar o desarrollar software profesionalmente, una de las cosas que tienes que hacer sí o sí es por lo menos aprender a leer inglés. Esto te ayudará a cubrir el 83.5% (número inventado) de las situaciones para aprender más. Muy probablemente si sabes leer en inglés sabrás escribirlo a un grado razonable para programar en inglés, es decir, crear los comentarios, los nombres y otros textos requeridos en inglés, ya que hará tu código de más fácil acceso a un mayor número de personas.\nUna vez dominado esto se te abre la puerta al 80% de recursos de aprendizaje de internet. Y las posibilidades son ilimitadas.\nObliga a alguien a ser tu mentor # Esto suena un poco raro, pero claro que lo puedes hacer y es de las maneras más eficaces de aprender. Lo mejor de todo es que no necesitas ni siquiera que tue mentor esté vivo. Hacer a alguien tu mentor significa aprender de él y muchas personas nos han preparado el camino para que los tomemos como mentores: mediante sus libros. Busca ejemplos de personas como las que quisieras ser e inspírate en sus escritos, charlas, conferencias, entrevistas, podcasts y todo contenido que produzca para ver como puedes recorrer un camino parecido al de esa persona.\nNotas finales # Lo que acabas de aprender después de terminar esto son sólo las bases. Igual que muchas otras carreras, en ésta tienes que poder seguir aprendiendo constantemente. El desarrollo de software, sin embargo, se caracteriza por ciclos más cortos aún, en los que las habilidades se quedan obsoletas en mucho menos tiempo así que debes afinar tus habilidades de aprendizaje.\nUna de las mejores maneras de solidificar tu conocimiento después de practicarlo, es enseñándolo a otros. No te quedes con lo aprendiste y devuelve algo a la comunidad: enseña siempre que puedas mediante conferencias, videos o artículos en un blog. De esto es algo de lo que no te arrepentirás.\n","date":"29 diciembre 2019","externalUrl":null,"permalink":"/2019/12/29/recursos-gratutitos-para-aprender-a-programar-desde-cero/","section":"Posts","summary":"\u003cp\u003e¿Quieres aprender a programar y no sabes por dónde empezar?\u003c/p\u003e\n\u003cp\u003eEn este artículo te daremos algunos recursos que puedes seguir para aprender a programar desde lo más básico hasta tener un conocimiento razonable de programación con el que podrías empezar a trabajar.\u003c/p\u003e","title":"Recursos gratutitos para aprender a programar desde cero","type":"posts"},{"content":"","date":"29 diciembre 2019","externalUrl":null,"permalink":"/tags/recursos-aprendizaje/","section":"Tags","summary":"","title":"Recursos-Aprendizaje","type":"tags"},{"content":"Cuando se habla de matemáticas muchas personas prefieren cambiar de tema.\nPero las matemáticas son la base de muchas otras ciencias incluida la computación. Podríamos considerar las ciencias de la computación como una rama de las matemáticas, pero que ha evolucionado todavía más allá de ellas.\nPara programar con eficacia no necesitas saber muchas matemáticas, con el entendimiento básico es suficiente. En este artículo hablaremos de aquello que debes dominar.\nSi ya programas, ya usas matemáticas. Saber más te ayudará a programar mejor, pero para eso necesitamos saber qué matemáticas necesitas. Antes, hagamos un esfuerzo por entender qué son las matemáticas.\n¿Qué son las matemáticas? # Definir las matemáticas es difícil. Según lo que (de manera muy irresponsable) nos han enseñado en la escuela, las matemáticas son el tratamiento de los números. Eso está muy lejos de la realidad, y ya te habrás dado cuenta si has avanzado lo suficiente en esta área del conocimiento.\nEs cierto, las matemáticas más elementales se pueden reducir a números, pero no es su centro, el espíritu de su estudio.\nAlgunas definiciones que encontré útiles:\nLas matemáticas son la manera que tenemos de elevar a la categoría de un arte nuestros esfuerzos cognoscitivos. - Fausto Ongay\nOngay también menciona que la etimología de la palabra matemáticas tiene que ver con conocer o saber. Así, en cierta medida las matemáticas se pueden pensar como la ciencia de la certidumbre. Es decir, de saber algo con certeza y poder verificarlo.\nLa matemática, como una expresión de la mente humana, refleja la voluntad activa, la razón contemplativa, y el deseo de la perfección. Sus elementos básicos son: lógica e intuición, análisis y construcción, generalidad y particularidad. - Richard Courant\nEn esta definición más abstracta se mencionan los elementos usados para lograr su cometido: lógica, intuición, análisis, construcción (o síntesis), generalidad (inducción), particularidad (deducción). Ya hablamos un poco de esto en los artículos acerca de las idea de George Polya.\nSi quieres adentrarte en esto el libro ¿Qué son las matemáticas? habla de ello a fondo.\nPero no estamos aquí para filosofar acerca de las matemáticas. Lo único que quiero quede claro con esto es que las matemáticas no tienen que ver con sólo con números, sino con el razonamiento, certidumbre y resolución de problemas.\nMatemáticas Básicas # Empecemos hablando brevemente de las matemáticas que debes conocer como programador y como ser humano funcional.\nOperaciones básicas # Saber operar con números en la vida cotidiana es una habilidad que todos necesitamos. Pero más importante aún es entender el significado de estas operaciones:\n¿Qué significa una multiplicación? ¿Qué significa una división? ¿Qué significado tiene el elevar un número a una potencia? Entender esto te ayudará a resolver problemas que es la actividad principal que se realiza cuando programas. Todo lo demás está alrededor de esto.\nProbabilidad y estadística # Tener las nociones de estas áreas es una de las herramientas más útiles a la hora de resolver problemas y sobre todo atacarlos prácticamente. Varias de las áreas de la ciencia de la computación basan sus resultados y procesos en estas dos áreas.\nUn ejemplo es la criptografía: los algoritmos de cifrado como AES trabajan con una llave que es usada para cifrar y descifrar el mensaje. Asignar el tamaño de la llave depende totalmente de la probabilidad de que un atacante sea capaz de adivinar la llave en un número de intentos razonable.\nAhora imagina que la llave tiene 128 bits de longitud. Aquí entra otro par de conceptos importantes para la computación.\nCombinaciones y permutaciones # ¿Cuál es el número de llaves diferentes que se pueden generar con 128 bits? La respuesta es: 2^128 (2 elevado a la potencia 128). ¿Cómo llegamos a esa respuesta? Esto se conoce como conteo en matemáticas y las bases son la permutación y la combinación de elementos. En este caso es la permutación de 2 elementos que permiten repetición en 128 lugares.\n¿Qué probabilidad hay de que alguien encuentre esa llave por suerte en el primer intento?\nLa respuesta es 1/2^128. Tan cerca de cero para ser considerada prácticamente imposible de adivinar incluso en un número de intentos razonable.\nLa criptografía y varias áreas están llenas de probabilidad y estadística (como el aprendizaje automático y el análisis de datos, aunque más avanzadas).\nSi sientes que necesitas un recordatorio aquí hay un curso que enseña desde lo más básico: Conteo, combinaciones y permutaciones en Khan Academy. Este también es un curso que enseña probabilidad y estadística desde cero.\nLógica (Matemáticas discretas) # Las matemáticas discretas son una de las áreas más abstractas de las matemáticas cuando las vemos en papel pero en realidad tratamos con ellas a diario. Podemos definir las matemáticas discretas como el estudio de las cosas que se pueden contar, sean finitas o infinitas.\nLa lógica es uno de los campos de estudio de las matemáticas discretas. Se enfoca en estudiar el razonamiento y sobre todo si el razonamiento es correcto.\nPara lograr esto la lógica se vale del estudio de las proposiciones (o afirmaciones) y sus relaciones. Una proposición es un enunciado que dice algo que puede ser verdadero o falso. En matemáticas se dice que tiene un valor de verdad.\nDos proposiciones se pueden relacionar mediante un conector (en electrónica: compuertas lógicas, en programación son operadores booleanos). Los conectores más conocidos son el or (o) y el and(y).\nEsto da origen a demostraciones tanto matemáticas como prácticas. En el desarrollo de sistemas se pueden usar para demostrar que tu algoritmo o solución es correcto, es decir, va a funcionar con los datos de entrada propuestos que cumplan con los valores de verdad.\n¿Son absolutamente necesarias para programar? Las demostraciones no, pero serán útiles si quieres crear demostraciones de que un algoritmo funciona sin tener que crear miles de ejemplos que convenzan a alguien. Lo que sí es necesario entender es el funcionamiento de los conectores lógicos, no hay programa que se escape de ellos.\nConjuntos # El estudio de los conjuntos es una parte de las matemáticas discretas que se enfoca en estudiar elementos (objetos) que se agrupan por alguna característica en común. Los conjuntos son de gran utilidad para resolver muchos problemas matemáticos y la criptografía actual esta fuertemente basada en algunos problemas que tienen que ver con el cálculo de ciertos conjuntos.\n¿Me sirve para trabajar en el día a día? Para cierto tipo de problemas es más cómodo trabajar con conjuntos que con los tipos de datos comunes de colecciones a los que estamos acostumbrados los programadores. Tratar tu colección (lista, tupla, etc.) como un conjunto matemático te permitirá efectuar operaciones como la intersección de conjuntos (elementos en común), la unión (todos los elementos únicos encontrados en dos o más conjuntos). Si el lenguaje de programación tiene este tipo de dato te va a dar un buen empujón.\nPor cierto, el resultado de las consultas en SQL (lenguaje de manejo de datos para la mayoría de las bases de datos) se comportan como conjuntos matemáticos.\n¿Quieres aprender matemáticas discretas? Aquí tienes un pequeño curso: Curso de matemáticas discretas.\nEso es todo lo que necesitas para programar básicamente. Mientras mejor seas en estos campos, mejor podrás aprovecharlos para programar mejor o para entender mejor los programas de otros.\nSistemas numéricos # Los sistemas numéricos son un tipo de conjuntos que se conforman de todas las cifras que pueden formarse con una cantidad determinada de símbolos que representan los números. El número de símbolos le da nombre al sistema: si hay dos símbolos (0, 1) es binario, si hay tres (0, 1, 2), ternario, etc.\nPara programar es muy conveniente que entiendas básicamente cómo se define un sistema numérico y que conozcas por lo menos cuatro:\nDecimal. Incluye los símbolos que conocemos como dígitos (0, 1, 2,.., 9). Su base es el 10. Binario. Es el sistema numérico con el que los microprocesadores pueden trabajar. Por eso es importante conocerlos. Sólo se pueden usar dos valores: 0 y 1. Su base es el 2. Hexadecimal. Se usa por conveniencia para representar números binarios de manera abreviada, por su compatibilidad entre bases (16 = 2^4). Su base es el 16 y los símbolos o valores extra que incluye a parte de los dígitos comunes son las letras de la A a la F. Octal. Su base es el 8 y también se usa para abreviar números decimales. Usa los dígitos del 0 al 7. El sistema decimal lo usamos en la vida diaria. Con entender básicamente el binario y hexadecimal estarás bien.\nMatemáticas avanzadas y especificas # En muchas áreas de la programación se usan matemáticas más avanzadas, sobre todo en áreas que están sonando mucho recientemente: análisis de datos e inteligencia artificial. Si quieres entender a fondo estas y otras áreas del desarrollo de sistemas, es conveniente tener un conocimiento amplio en algunas de las siguientes áreas:\nProbabilidad y estadística avanzada. Saber acerca de variables aleatorias, distribuciones de probabilidad, análisis Bayesiano, etc. Esto te permitirá analizar datos tanto exploratoria como predictivamente. Álgebra lineal. El álgebra y la resolución de ecuaciones que representan líneas en el plano cartesiano. Esto te ayudará a tratar con conjuntos de datos. Muchas de los resultados de los algoritmos de Machine Learning son ecuaciones lineales. Ecuaciones diferenciales. Esto es la resolución de sistemas de ecuaciones y sus derivadas. Esto tiene aplicaciones en todo lo que tenga que ver con cambios respecto a alguna variable, como el tiempo. Hablé de los campos finales pero para entender esto debes tener conocimiento previo:\nGeometría Analítica Álgebra Trigonometría Cálculo Integral y diferencial Cálculo Vectorial Por suerte, para los campos de los que habla arriba no tienes que saber todo esto, a menos que quieras ser el desarrollador de los algoritmos originales. Generalmente somos usuarios de bibliotecas creadas por genios que ya hacen lo que necesitamos.\nNo te preocupes # Saber matemáticas avanzadas no es necesario para ser ser un programador exitoso si tu campo de desarrollo no lo necesita dentro de su dominio. Por supuesto que aprender cosas así de difíciles te hará más hábil para resolver problemas, tal como saber física o química avanzada te harían más hábil.\nFuera de las matemáticas básicas y un control decente e intuitivo de la lógica, no es necesario que seas Terence Tao, a menos que el campo en el que estés trabajando esté directamente relacionado con eso, tal como tendrías que saber lo suficiente de finanzas si estuvieras haciendo una app financiera o de administración de empresas si estuvieras haciendo una aplicación o plataforma para este campo.\nAquí hay un video curso en el que se explican más ampliamente lo que algunos llaman \u0026ldquo;matemáticas para programadores\u0026rdquo;.\n","date":"25 diciembre 2019","externalUrl":null,"permalink":"/2019/12/25/las-matem%C3%A1ticas-que-debes-saber-para-programar/","section":"Posts","summary":"\u003cp\u003eCuando se habla de \u003cstrong\u003ematemáticas\u003c/strong\u003e muchas personas prefieren cambiar de tema.\u003c/p\u003e\n\u003cp\u003ePero las matemáticas son la base de muchas otras ciencias incluida la computación. Podríamos considerar las ciencias de la computación como \u003cstrong\u003euna rama de las matemáticas\u003c/strong\u003e, pero que ha evolucionado todavía más allá de ellas.\u003c/p\u003e","title":"Las matemáticas que debes saber para programar","type":"posts"},{"content":"","date":"20 diciembre 2019","externalUrl":null,"permalink":"/tags/asciidoc/","section":"Tags","summary":"","title":"Asciidoc","type":"tags"},{"content":"Parte del trabajo de un desarrollador es crear documentos con un formato fácil de entender y agradable a la vista, para crear documentación, registrar decisiones, escribir manuales, etc. La forma común de hacerlos es un procesador de textos como Word o Google Docs, pero generalmente batallamos sobre todo con el formateo y embellecimiento de documento.\nEn este artículo te platicaré de tres alternativas que pueden hacer tu vida más fácil: Markdown, reStructuredText, AsciiDoc.\nTodos estos lenguajes pueden producir múltiples formatos de salida: HTML, PDF, Word, entre otros. Y lo mejor es que estas salidas son personalizables.\nMarkdown # Es el formato de marcado de texto simple más conocido por ser el usado en muchos lados (GitHub, por ejemplo) para darle un poco de formato semántico al texto.\nPuedes crear los estilos de texto más comunes directamente:\nnegritas cursivas enlaces Imágenes: También permite crear listas no numeradas, como la anterior, numeradas, tablas (con las sintaxis extendidas pero no con la definición original) y una serie de títulos de diferente jerarquía equivalentes a los headers de HTML (h1, h2\u0026hellip; h6).\nDe hecho, esta entrada está escrita con Markdown. Markdown es tan popular que existen aplicaciones completamente dedicadas a él como MacDown, Focused y Typora. Además, diferentes empresas han creado sus propios dialectos o adaptaciones para que sea más fácil de usar en su caso específico.\nSi aún no lo sabes usar, vale la pena que le eches un ojo: Guía de Markdown en español. Tardarás unos minutos en aprender lo básico que es muy útil para el 80% de los casos en los que lo ocuparas.\nMarkdown es muy bueno para crear documentos individuales pero, ¿qué pasa si el texto que quieres escribir es más extenso? Tal vez el texto está compuesto por muchas partes, como un libro o una documentación extensa. Hay quienes dicen que no deberías usar Markdown para crear tu documentación.\nLas siguientes herramientas están mejor que preparadas que Markdown para eso, permiten crear cuerpos de textos más extensos.\nreStructuredText # Este formato de texto es adecuado para crear cuerpos de texto más complejos que con Markdown. Tienes las mismas capacidades de formateo de texto que con Markdown: negritas, cursivas, cabeceras, links, imágenes, listas, tablas, etc.\nPero reStructuredText provee más opciones para formatear el texto, ya que fue creado para hacer documentos técnicos además de documentos de carácter general.\nreStructuredText parece ser parte de docutils originalmente, creado como una revisión de se StructuredText y Setext.\nSus herramientas te permitirán crear texto marcado con mejor semántica que Markdown, más estandarizado (RST no tiene \u0026lsquo;sabores\u0026rsquo; o dialectos) y con herramientas adaptadas a la documentación de código. Entre otras cosas RST provee:\nMás formatos de listas: Listas de definición Listas de parámetros Numeración de listas arbitrariamente Bloques de texto pre-formateado (para código) Bloques de documentación de pruebas Citas Notas a pie de página Directivas, una manera de extender el lenguaje con construcciones propias Hyperlinks con diferentes destinos: externos, internos, etc. Esta última característica permite crear documentos interconectados que son muy útiles para textos amplios.\nRST es el formato default de Sphinx una herramienta de documentación de código creada en Python que te puede ayudar a crear documentación muy bonita.\nAquí hay una introducción a RST en inglés: A reStructuredText Primer.\nAsciiDoc # Incluso el software más brillante es inútil sin buena documentación. - Documentación de AsciiDoc\nAsciiDoc fue creado para hacer tan fácil como escribir un email la escritura de cualquier tipo de documento, sea este un artículo, un texto en prosa, un libro o documentación técnica.\nEl creador asegura que una de las causas de que se nos haga tan difícil escribir está relacionada con que los editores de texto nos distraen con cosas como el formateo o paja que no es necesaria. AsciiDoc se enfoca en que puedas escribir sin preocuparte por el formato, dando una sintaxis natural, fluída y que no estorba, mientras te permite preparar el texto para crear formatos de salida hermosos.\nUsa AsciiDoc para marcado de documentos. De verdad. En verdad es legible, fácil de procesar y mucho más flexible que XML. - Linus Torvalds\nAl igual que Markdown y RST, AsciiDoc provee de medios básicos para dar formato al texto. Pero AsciiDoc es el que más herramientas de los tres platicados aquí tiene. Además de ofrecet todo lo de las dos herrmientas anteriores tiene:\nMás formatos de párrafo: párrafos de introducción y pre-formateados fáciles. Secciones prediseñadas: cuadros de aviso, de notas, etc. Estilos de lista parecidos a los de RST. Formateo y sintaxis de código con notas, como la siguiente: Barras laterales Macros Generación de tablas desde CSV Videos Muchas muchas cosas más\u0026hellip; Sin duda AsciiDoc es el más completo de los formatos que hemos visto en este artículo. Aquí hay una introducción en inglés y aquí un libro en español. AsciiDoc es tan completo que varios autores de libros lo han escogido para crear sus escritos.\n¿Cuál uso, entonces? # Mi conclusión personal es la siguiente:\nSi tienes que hacer un documento pequeño, sin mucho formato y en el que la velocidad de entrega es lo más importante usa Markdown, ya que su popularidad te permitirá entregar el documento en el menor tiempo posible. Por ejemplo, en GitHub subes un archivo \u0026ldquo;*.md\u0026rdquo; y automáticamente lo muestra formateado.\n¿Tienes que hacer documentación de código que posiblemente deba ir en línea o al lado del código? reStructuredText está especializado en eso y con sus herramientas y entonrno te facilitará la vida.\nPara todo lo demás, usa AsciiDoc. Una vez que lo sabes usar y combinado con AsciiDoctor (su procesador) y Pandoc (un transformador de formatos) puedes crear cosas muy complejas muy rápidamente.\nConclusión # Si eres como los programadores clásicos, odias usar Word, Docs o lo que sea por el problema que es formatear mientras escribes y amas la simplicidad del texto plano ayudado con herramientas que te permiten crear mejores cosas.\nEstos lenguajes de marcado de texto te dan lo mejor de los dos mundos. Requieren un poco más de trabajo para empezar que los editores \u0026ldquo;lo que ves es lo que obtienes\u0026rdquo;, pero la productividad que te dan después paga con creces.\n¿Qué opinas? ¿Vale la pena aprenderlos?\n","date":"20 diciembre 2019","externalUrl":null,"permalink":"/2019/12/20/formatos-de-marcado-de-texto-que-deber%C3%ADas-aprender/","section":"Posts","summary":"\u003cp\u003eParte del trabajo de un desarrollador es crear documentos con un formato fácil de entender y agradable a la vista, para crear documentación, registrar decisiones, escribir manuales, etc. La forma común de hacerlos es un procesador de textos como Word o Google Docs, pero generalmente batallamos sobre todo con el formateo y embellecimiento de documento.\u003c/p\u003e","title":"Formatos de marcado de texto que deberías aprender","type":"posts"},{"content":"","date":"20 diciembre 2019","externalUrl":null,"permalink":"/tags/latex/","section":"Tags","summary":"","title":"Latex","type":"tags"},{"content":"","date":"20 diciembre 2019","externalUrl":null,"permalink":"/tags/markdown/","section":"Tags","summary":"","title":"Markdown","type":"tags"},{"content":"","date":"20 diciembre 2019","externalUrl":null,"permalink":"/tags/restructured-text/","section":"Tags","summary":"","title":"Restructured-Text","type":"tags"},{"content":"Este es el tercer artículo acerca del libro \u0026ldquo;How to Solve It\u0026rdquo; de George Polya. Puedes ver los dos artículos anteriores aquí:\nTécnicas para resolver problemas Heurística Con este artículo cerraremos con las ideas que George Polya desarrolló para resolver problemas.\nDeducción # Tratar de resolver problemas por deducción significa aplicar principios o conocimiento general a un caso específico. Por ejemplo para un problema práctico en el que tenemos encontrar la longitud de un cable tensor para una antena, sabemos que podemos aplicar el teorema de Pitágoras.\nAlgunos ejemplos para los programadores:\nEncontrar el elemento más grande o más pequeño en una lista. (Una forma de resolverlo es ordenar los elementos). Revisar que un elemento no está repetido en una colección de elementos. (Indexado) Asegurarse de que las operaciones son atendidas en el orden en que se solicitaron en un entorno con múltiples ejecutores. (Colas) Lo difícil de la deducción es encontrar qué principios, teoremas o formas de resolución de problemas aplican para el problema que tenemos que resolver. Para esto nos pueden ayudar las técnicas platicadas en los artículos anteriores: ¿He resuelto un problema similar? ¿Qué técnica fue usada? ¿Qué principios sirvieron para la resolución de ese problema? Y, a mi parecer la más útil: ¿puedo usar el resultado o el proceso de resolución de un otro problema?\nDeducción en el desarrollo de Software # Imagínate un problema que te trae un cliente, como sigue: tienen un proceso que necesita recorrer una lista muy grande de clientes por la noche y tienen algunos errores intermitentes, a veces termina, a veces no y cuándo no termina hay que investigar quién no pudo ser procesado y aplicar el proceso individualmente.\nSi has tenido experiencia en procesos parecidos y te has enfrentado con problemas similares, seguro que empezaste a pensar en soluciones. Eso es deducción, aunque las reglas no estén formalmente establecidas en tu mente.\n¿Cómo usamos la deducción entonces? Conociendo soluciones o diseño de solución a problemas que se repiten y que podemos aplicar directamente o combinar para resolver el problema actual.\n¿Te suena? Esto es algo que se repite vez tras vez: tener las bases de las ciencias de la computación, conocer diferentes algoritmos, estructuras de datos, tipos de datos abstractos, patrones de diseño, principios de diseño de software te ayudará a resolver los problemas de manera eficaz.\nAsí que la lección es clara: intenta ampliar tus conocimientos básicos para que puedas hacerte más hábil resolviendo problemas.\nTener un registro palpable de tus aprendizajes como una serie de notas te permitirá repasarlos y consultarlos cuando los necesites.\nInducción # La inducción es el proceso de descubrir leyes generales mediante la observación y combinación de casos particulares. - George Polya\nLa inducción es uno de los mecanismos de resolución de problemas más difíciles de llevar a la práctica. Funciona en forma inversa a la deducción:\nConsiste en partir de observaciones específicas (ejemplos y contra-ejemplos) y llevarlas a generalizaciones que puedan ser aplicadas en otros casos o que apliquen en muchas otras situaciones situaciones.\nPolya deja claro una cosa: aunque en las ciencias físicas y naturales la inducción es completamente válida y natural, y generar conocimiento sólamente basado en esto es aceptable, pero en las matemáticas debes poder tener demostraciones de que lo que propones es cierto.\nInducción matemática # Polya habla de otro tipo de inducción de la que opina que no debería llamarse así, y que comparte muy poco con el proceso que acabamos de describir y puede llegar a confundir a la gente: la inducción matemática. Este tipo de inducción se refiere al método que los matemáticos emplean para demostrar que cierta aserción es un teorema o no.\nSi has estudiado inducción matemática no la confundas.\nInducción en el desarrollo de software # El desarrollo de software no es un área que viva aislada de las demás áreas y seguro te has encontrado con este tipo problemas si ya llevas tiempo desarrollando: las personas que requieren el software llevan ejemplos de problemas que regularmente tienen que resolver, en vez de la explicación completa y las reglas completamente establecidas.\nNuestros clientes, en general, no se han dado a la tarea de establecer las reglas por las que algo funciona de la manera en que lo hace, ni las excepciones, ni los casos únicos. Es nuestra tarea casi siempre descubrir las reglas que subyacen a la operación del negocio de los clientes. Para esto tenemos que aplicar la inducción.\nEste paso es completamente necesario para desarrollar software, ya que son estas reglas las que ponemos en los programas, las probamos con los tests y lo que hace valioso al software.\nAsí que tenemos que ser lo más hábiles que nuestras circunstancias lo permitan haciendo inducción. ¿Cómo podemos mejorar?\nDesarrollando tus capacidades de Inducción # Polya da varios de consejos para aplicar la inducción, veamos algunos pasos.\nLas tres herramientas de la inducción # Primero entendamos cómo funciona el proceso de inducción. La inducción usa tres procesos para poder llegar a sus descubrimientos:\nGeneralización. Tomas un ejemplo e intentas quitarle las cosas que lo hacen único para crear una regla general. Analogía. La generalización está basada en analogías: la aplicación de los mismos principios observados a otros casos. Especialización. Aplicas tus descubrimientos a casos particulares y descubres casos especiales que hacen que tengas que ajustar Ahora vemos los pasos que podrías seguir para llevar a cabo tu proceso.\nReunir ejemplos y ocurrencias # Primero, tienes que juntar o generar ejemplos del fenómeno o evento que estás resolviendo. En el caso de un sistema tendrías que solicitarle al cliente la mayor cantidad de situaciones que tenga disponibles.\n\u0026ldquo;Generar\u0026rdquo; ejemplos ciertamente es algo difícil, porque al no conocer las reglas puede que te equivoques varias veces. Justamente es un proceso de prueba y error.\nHacer hipótesis # Después de observar los ejemplos y tratar de descubrir un patrón entre ellos, establece explícitamente una hipótesis: un supuesto plausible que explique la relación entre los ejemplos y que permita generar otros.\nComprobar o refutar la hipótesis # Después de tener una hipótesis, ahora tienes un \u0026ldquo;problema para probar\u0026rdquo;, como les llama Polya. Intenta demostrar que la hipótesis es cierta. Polya afirma que en la matemáticas no existe autoridad que una demostración rigurosa, pero en nuestra área, el desarrollo de software, a menudo es impráctico tener dicha demostración, así que podrías comprobar con más ejemplos (o ejemplos sintéticos) que tu hipótesis o propuesta se mantiene cierta en todos los casos conocidos.\nSi logras comprobarla, puedes avanzar a lo siguiente. Si encuentras un caso que no esté cubierto por tu hipótesis actual puedes ajustarla. Lo mejor de este proceso es que es cíclico: no hay un límite de veces que lo puedes aplicar hasta que tengas \u0026ldquo;las regla0s\u0026rdquo; lo suficientemente claras.\nSi lo piensas, se parece mucho al método científico que nos enseñaron cuando nos hablaban de ciencia: observación -\u0026gt; hipótesis -\u0026gt; experimento -\u0026gt; conclusiones.\nConclusión # La inducción y la deducción son dos procesos que aplicamos normalmente, sin saberlo, en nuestra resolución diaria de problemas. Identificarlos y formalizar su estructura nos puede ayudar a ser mejor en ellos. No pierdas la oportunidad de aprender y ampliar tus capacidades de resolución de problemas.\nAdemás, la información que encontrarás en \u0026ldquo;How To Solve It\u0026rdquo; te ayudará a ser mejor resolviendo problemas, por lo que tu capacidad como desarrollador de software se verá potenciada: es nuestra principal tarea.\n","date":"14 diciembre 2019","externalUrl":null,"permalink":"/2019/12/14/inducci%C3%B3n-y-deducci%C3%B3n-para-desarrolladores-de-software/","section":"Posts","summary":"\u003cp\u003eEste es el tercer artículo acerca del libro \u003ca\n  href=\"https://amzn.to/2P8HJA8\"\n    target=\"_blank\"\n  \u003e\u0026ldquo;How to Solve It\u0026rdquo;\u003c/a\u003e de George Polya. Puedes ver los dos artículos anteriores aquí:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\n  href=\"/2019/09/27/tecnicas-para-resolver-problemas.html\"\u003eTécnicas para resolver problemas\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\n  href=\"/2019/10/03/el-arte-de-resolver-problemas-la-heuristica.html\"\u003eHeurística\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCon este artículo cerraremos con las ideas que George Polya desarrolló para resolver problemas.\u003c/p\u003e","title":"Inducción y Deducción para desarrolladores de software","type":"posts"},{"content":"","date":"14 diciembre 2019","externalUrl":null,"permalink":"/tags/problem-solving/","section":"Tags","summary":"","title":"Problem-Solving","type":"tags"},{"content":"Es muy común escuchar de \u0026ldquo;encriptación\u0026rdquo; (la palabra correcta en español es cifrado), llaves, algoritmos criptográficos y cosas parecidas, sobre todo con el surgimiento de Bitcoin y Blockchain.\nUno de los temas menos tratados por programadores de software común (para usuarios y sistemas que no impliquen el uso de seguridad a medida), es el correcto uso de los algoritmos criptográficos y muchas veces ni siquiera conocemos lo suficiente de ellos, sino que confiamos en lo que las herramientas pre-establecen (que gran parte de las veces fue diseñado por expertos y eso está bien).\nPero un poco de conocimiento sobre criptografía no te hará daño, sobre todo si programas sistemas que necesiten seguridad (todos), y sí puede evitarte errores fatales.\nEsta serie de artículos tratará de todo lo que un programador debe saber acerca de la aplicación correcta de algoritmos criptográficos a sus desarrollos, y un poco de su funcionamiento interno.\nEmpecemos por lo más básico. ¿Qué es exactamente la criptografía?\nDefinición de Criptografía # La criptografía moderna se puede considerar una rama de las matemáticas (otra vez) y la computación enfocada en encontrar y crear formas de convertir información clara y con algún significado en información imposible de entender por entidades que no cuenten con la autorización para hacerlo, aunque la tengan en su poder.\nLa palabra quiere decir literalmente \u0026ldquo;escritura oculta\u0026rdquo;. Y también se puede definir el campo como el encargado de encontrar algoritmos o procedimientos que permitan ocultar mensajes que sólo puedan ser descifrados por aquellos que tengan la llave.\nLa criptografía implica esconder información explícitamente (los atacantes pueden saber que esa información está oculta e incluso hasta tener los mensajes ocultos en su poder), de manera que quien tenga la información correcta (que les concede la autorización) pueda obtener la información original desde los datos ininteligibles.\nEste proceso de ocultar la información se llama cifrado (también se usa encriptado, como un barbarismo), mientras que el proceso de recuperar la información se llama descifrado (o desencriptado 🙄).\nLos procesos de cifrado modernos requieren generalmente una llave o conjunto de llaves, para realizar los procesos de cifrado y descifrado.\nLa criptografía es la base de todos los mecanismos de seguridad informática modernos, y a menudo se usa una conbinación de ellos para proteger un sistema.\nUso en el software actual # Los algoritmos criptográficos se usan en todos lados en los sistemas modernos. Son los algoritmos que permiten que la información viaje segura en internet (usando HTTPS, que se basa en TLS/SSL), por ejemplo. Algunos otros casos en los que son usados:\nEn la protección de la información que viaja en las redes inalámbricas, sean WiFi o Celulares (3G, 4G, 5G).\nAlmacenamiento de datos sensibles como passwords (mediante hash) e información personal (cifrados con password).\nProtección de archivos.\nCifrado de datos en reposo (al estar almacenados en los discos duros) de los datos para evitar su robo en caso de robo físico o de dispositivos virtuales.\nTarjetas de crédito y seguridad bancaria en general.\nEstos son tan sólo algunos ejemplos de los lugares en los que la criptografía juega un papel muy importante.\nEsteganografía # La esteganografía es la técnica, relacionada con la criptografía, de hacer la información invisible, generalmente ocultándola dentro de otro tipo de información.\nCon técnicas criptográficas comunes el que un atacante tenga disponible la información cifrada no hace necesariamente que nuestra información quede expuesta, a menos que el algoritmo criptográfico sea débil y el atacante tenga suficientes recursos para romperlo. En muchos casos incluso suponemos que los atacantes tienen acceso a esta información, como en el caso de la comunicación en internet en la que en cualquier parte de la red puede haber alguien interceptando nuestra información.\nLas técnicas esteganográficas buscan \u0026ldquo;desaparecer\u0026rdquo; completamente la información, hacerla invisible a través de ocultarla dentro de otros tipos de mensajes. En la antigüedad, por ejemplo en un libro que parecía hablar de magia, se ocultó un tratado acerca de criptografía y esteganografía, que sólo fue revelado hasta que se encontró la llave correcta.\nCon la llegada de los medios digitales, en la que todo puede ser representado por medio de bits, en realidad se puede ocultar información de cualquier tipo en cualquier otro tipo de mensajes, pero también se siguen usando medios físicos para ocultar información. Un ejemplo son los micro-puntos de algunas impresiones de manuscritos o información sensible repartido a personas de confianza que permiten identificar cada una de las copias entregadas a diferentes personas.\nAunque la esteganografía y la criptografía son técnicas relacionadas, la más importante actualmente es la criptografía por su uso en la mayoría de los sistemas informáticos de la actualidad.\n¿Por qué deberías aprender criptografía? # Ya mencionamos lo importante que es en los sistemas actuales. La mayoría de los lenguajes de programación, los desarrollos open source, como los frameworks web, muchas librerías, plataformas como servicio, etc. tienen funciones de seguridad y criptográficas incluídas.\nPero no es suficiente con ser usuario de estas cosas, ya que hasta los mecanismos y algoritmos mejor diseñados se pueden ser mal usados y hechos inseguros por la mala utilización.\nConocer temas como los siguientes te permitirá elevar la calidad de tus desarrollos:\n¿Qué determina la seguridad de un algoritmo criptográfico? ¿Por qué es importante tener una llave de un tamaño correcto? ¿Qué algoritmo debo escoger para esta característica que tengo que desarrollar? ¿Cuáles son las principales características y diferencias de los algoritmos más usados? ¿Qué algoritmos nunca más debería usar? Conclusión # En este artículo sólo hemos tocado la definición de criptografía y hemos mencionado por qué es importante. En los siguientes empezaremos a hablar de las bases que nos permitirán comprender cómo funciona la criptografía y qué mecanismos son los que permiten que brinde seguridad mediante ocultar la información.\nEn el próximo artículo hablaremos de la base de todos los sistemas criptográficos. Los números (pseudo)aleatorios y sus generadores.\n","date":"12 noviembre 2019","externalUrl":null,"permalink":"/2019/11/12/criptograf%C3%ADa-b%C3%A1sica-para-programadores-qu%C3%A9-es-la-criptograf%C3%ADa/","section":"Posts","summary":"\u003cp\u003eEs muy común escuchar de \u0026ldquo;encriptación\u0026rdquo; (la palabra correcta en español es \u003cem\u003ecifrado\u003c/em\u003e), llaves, algoritmos criptográficos y cosas parecidas, sobre todo con el surgimiento de Bitcoin y Blockchain.\u003c/p\u003e\n\u003cp\u003eUno de los temas menos tratados por programadores de software común (para usuarios y sistemas que no impliquen el uso de seguridad a medida), es el correcto uso de los algoritmos criptográficos y muchas veces ni siquiera conocemos lo suficiente de ellos, sino que confiamos en lo que las herramientas pre-establecen (que gran parte de las veces fue diseñado por expertos y eso está bien).\u003c/p\u003e","title":"Criptografía básica para programadores: ¿Qué es la criptografía?","type":"posts"},{"content":"","date":"12 noviembre 2019","externalUrl":null,"permalink":"/tags/esteganograf%C3%ADa/","section":"Tags","summary":"","title":"Esteganografía","type":"tags"},{"content":"","date":"12 noviembre 2019","externalUrl":null,"permalink":"/tags/seguridad/","section":"Tags","summary":"","title":"Seguridad","type":"tags"},{"content":"","date":"27 octubre 2019","externalUrl":null,"permalink":"/tags/categories/","section":"Tags","summary":"","title":"Categories:","type":"tags"},{"content":"La tercera característica que Thomas R. Fielding (Roy Fielding a partir de ahora) establece para los sistemas REST es la capacidad de que su información sea cacheable. Veamos lo que esto significa y por qué es una característica importante. Empecemos por definir el caché.\n¿Qué es el caché? # Originalmente el caché se refiere a un tipo especial de memoria muy rápida en los procesadores, que guarda temporalmente información que tiene gran probabilidad de volver a ser utilizada dentro de poco tiempo (en los procesadores hablamos de nano-segundos).\nAl evitar que el procesador vuelva a consultar la RAM (muy lenta en comparación con la memoria caché), las operaciones se realizan a mucha mayor velocidad.\nLa memoria caché de los procesadores tiene una gran desventaja: es muy muy pequeña. Esto presenta retos:\n¿Qué guardo aquí para maximizar la eficacia de este espacio de almacenamiento? ¿Cómo decido cuándo borrar o sobre-escribir la información que tengo aquí? ¿Qué pasa si la información original cambia mientras estoy ocupando los datos guardados en la memoria caché? Hablaremos más adelante de estas preguntas en nuestro propio contexto, pero hay técnicas para poder contestarlas con cierta eficacia, que los procesadores han logrado implementar.\nAsí que puedes pensar en el caché como en una memoria que es más rápida (aunque más limitada). Se utiliza con el objetivo de hacer un sistema más rápido y a veces más eficiente.\nCaché en los sistemas REST # Esta característica se basa en las dos que ya hablamos: servicios sin estado y arquitectura cliente-servidor.\nLo que se define como \u0026ldquo;cacheabilidad\u0026rdquo; en los sistemas REST es la capacidad de estos sistemas para etiquetar de alguna forma las respuestas para que otros mecanismos intermedios funcionen como un caché.\nAsí el sistema puede atender más peticiones, en menos tiempo, con menos recursos (comparado con un sistema sin caché).\nEstos sistemas o mecanismos intermedios (existen entre el cliente y el servidor) deben ser por lo general transparentes para los desarrolladores, no deben afectar la manera en que los servicios se consumen.\nEn sistemas web que usan HTTP para comunicarse el sistema de \u0026ldquo;etiquetado\u0026rdquo; que permite que una respuesta sea cacheada son las cabeceras. Estas permiten a los diferentes actores en el proceso de comunicación (servidor local, proxy, proxy reverso, navegador o cliente final, entre otros), saber quién debería cachear la información y por cuánto tiempo o cómo decidir si deben renovar la información. Las cabeceras HTTP comúnmente usadas para esto son:\nExpires: especifica hasta cuándo se puede considerar fresca o válida la información. Cache-control: Es usado para especificar directivas de caché que deben ser respetadas por todos lo puntos por los que pasa la información. Puedes ver los posibles valores y su especifacación aquí: Cache-Control Header Vary: es usada para indicar qué otras cabeceras se deben tomar en cuenta para decidir si el servidor puede reutilizar una respuesta o no. Etag: identifica a una respueste de manera única, puede usarse para pedir una respuesta nueva de un mismo endpoint, y en combinación con la cabecera If-None-Match Existen otras cabeceras usadas para lograr un control correcto del caché como If-Modified-Since.\nVentajas del caché # El caché se establece como una de las características de REST porque proporciona ventajas para el uso y la escalabilidad de los sistemas. Veamos algunas de ellas.\nAumenta la percepción de velocidad # Al guardar las respuestas que es más probable que vuelvan a salir, un sistema REST puede contestar una gran cantidad de sus peticiones a la velocidad que el caché lo permita, es decir, muy rápido.\nConsumo de recursos reducido # El uso caché se parece mucho a una técnica de programación llamada dynamic programming que consiste en guardar temporalmente los resultados de operaciones costosas en tiempo. Esto permite que nos ahorremos el procesamiento de muchas respuestas que no se necesitan de nuevo porque están almacendas. Además se reduce el ancho de banda consumido porque muchas peticiones ni siquiera tienen que llegar al servidor.\nSistemas más fáciles de escalar # Los sistemas que usan caché son capaces de aguantar más peticiones simultáneas por la razón que vimos anteriormente: se reduce el consumo de recursos. Además, si se require crecer el sistema se deben poner menos recursos. Para algunos sistemas, el caché es lo único que tiene que crecer cuando se requiere atender a más usuarios simultáneos.\nRetos de cachear # Toda solución tecnológica implica ventajas y desventajas. Entonces ¿qué desventajas o retos implica usar un sistema de caché?\nFrescura # Sólo hay dos cosas difíciles en Ciencias de Computación: invalidación de caché y nombrar cosas. - Phil Karlton\nEl reto más grande e importante de tener un sistema de caché es lograr un equilibrio entre mantener la información el mayor tiempo posible y tener información correcta y actualizada. Si se almacena en caché por demasiado tiempo algo, esta información se vuelve vieja y por lo tanto puede estar desactualizada. Por el otro lado si se guarda por muy poco tiempo puede llevar a que los sistemas de caché se sub-utilicen y provean pocos beneficios.\nDiseño del sistema # Designar qué partes del sistema pueden ser cacheables y asignar los etiquetados de las respuestas correctamente puede aumentar la complejidad del sistema en general.\nInconsistencia # El uso de caché puede llevar a inconsistencias de información entre diferentes clientes por periodos de tiempo de diferente duración. Esto es en parte consecuencia de la dificultad de mantener el caché fresco, pero además tiene que ver con la manera en que los clientes piden la información. Si tus clientes no pueden soportar la mínima variación en la información porque tendría consecuencias graves, es mejor no cachear.\nConclusión # El caché es una parte olvidada de los sistemas REST, el constraint menos mencionado. Pero es importante que les permite funcionar mejor cuando tenemos bastante carga. Mantenerlo funcionando bien es un reto, pero los sistemas que quieren ser escalables y resistentes deben implementar alguna forma de cachear.\nRoy Fielding menciona que es importante porque cualquier sistema expuesto a clientes desconocidos tiene el peligro de recibir una gran cantidad de carga súbitamente, y si tu servicio no está preparado o es fácil de escalar, fallarás.\nSi quieres leer un artículo más completo con otras referencias sobre el caché en REST y en HTTP te recomiendo REST better: HTTP Cache, en inglés.\nEn el siguiente artículo veremos la cuarta restricción de los sistemas REST: la interfaz uniforme, la más amplia de las restricciones, pero una de las más útiles.\n","date":"27 octubre 2019","externalUrl":null,"permalink":"/2019/10/27/entendiendo-rest-servicios-cacheables/","section":"Posts","summary":"\u003cp\u003eLa tercera característica que \u003ca\n  href=\"https://twitter.com/fielding\"\n    target=\"_blank\"\n  \u003eThomas R. Fielding\u003c/a\u003e (Roy Fielding a partir de ahora) establece para los sistemas \u003cstrong\u003eREST\u003c/strong\u003e es la capacidad de que su información sea cacheable. Veamos lo que esto significa y por qué es una característica importante. Empecemos por definir el caché.\u003c/p\u003e","title":"Entendiendo REST: Servicios cacheables","type":"posts"},{"content":" La heurística habla del comportamiento humano frente a los problemas. - George Polya\nEn un artículo anterior analizamos la estructura básica de un problema y la estructura de resolución que George Polya propone para intentar resolverlos.\nPolya analiza a fondo la estructura del proceso de resolución de problemas. Aquí hablaremos de la heurística, de la que escribió en \u0026ldquo;How to solve it\u0026rdquo;{:target=\u0026quot;_blank\u0026quot;}, un compendio que pensó originalmente como un análisis de esta.\nDefinición # La palabra heurística viene de una raíz griega que transmite la idea de descubrimiento o invención. La heurística históricamente ha estado relacionada con estudiar los medios por los que se descubre o inventa algo. Su campo de estudio abarca la lógica, la psicología y la filosofía, pero no se puede acotar a ninguna de las tres áreas.\nPolya estudia y define la heurística moderna como el arte de resolver problemas, porque en eso consiste el proceso: descubrir una solución(en los problemas en los que hay que encontrar algo) o inventar algo (en los problemas en los que hay que crear una demostración).\nPodemos echar mano de lo que nos enseña al atacar problemas muy difíciles de los que no tenemos la mínima idea de cómo resolver o no podemos idear un plan confiable para resolverlos (recuerda que crear un plan es el punto medular de la resolución de un problema).\nHeurística moderna # La heurística actualmente busca entender el proceso de resolución de problemas, pero particularmente las operaciones mentales relacionadas con ese proceso.\nLa experiencia en la resolución de problemas u observar a otros resolver problemas debe ser la base de la heurística. - G. Polya\nSe busca encontrar patrones y propiedades comunes en una gran variedad de problemas, por lo que se puede decir que la heurística tiende a la generalidad, estudia procedimientos que son independientes del dominio del problema. Polya habla de múltiples métodos y procedimientos para avanzar en la resolución de un problema complicado.\nAnalicemos algunos de ellos:\nVariación del problema. ¿Puedo variar por lo menos temporalmente alguna de las partes del problema? ¿Puedo cambiar los datos, las condiciones o la solución?\nDescomposición y recombinación. Esta operación mental implica entender y separar las partes esenciales de un problema y tratar de re-crearlo con un nuevo entendimiento o crear un problema ligeramente diferente.\nRegresar a las definiciones. Comprender los términos usados en cada parte del problema a veces implicará que busquemos lo que algo significa desde sus raíces. Esto nos puede ayudar a entender mejor el problema así como a introducir elementos auxiliares que ayuden en la resolución.\nGeneralización, especialización y analogías. Estas tres operaciones son una forma de variar un problema. ¿Puedo hacer el problema más amplio, para resolver un caso más general y después aplicar los resultados o el método a mi problema original? ¿Existe un problema similar al que estoy resolviendo que pueda resolver más fácilmente?\nNotación adecuada. Una vez entendido el problema, sobre todo para problemas matemáticos, es muy importante introducir notación que nos pueda ayudar a trabajar sobre el problema. Para los problemas matemáticos y en ciencias en general, ya existen estas notaciones estándar. Para nuestros problemas tenemos que inventar una que la mayoría de los implicados puede entender y usar.\nSuponer, pero comprobar las suposiciones. Para avanzar en la resolución de un problema muchas veces hay que dar cosas por supuesto, como en el caso de las comprobaciones por reducción al absurdo. Polya afirma que no está mal suponer cosas temporalmente mientras más adelante encontremos una forma de comprobar o rechazar esas suposiciones.\nTrabajar en reversa. Muchas veces sabemos como luce la solución, o tenemos que comprobar que una solución supuesta es correcta. Trabajar en reversa significa avanzar de la solución hasta nuestro estado actual, trabajando paso por paso hasta poder encontrar la cadena de transformaciones necesarias para conectar esos estados.\nAspectos psicológicos: determinación, esperanza y éxito. Al principio mencionamos que la heurística es también trataba con aspectos psicológicos. Polya afirma que sería un error considerar que los problemas son ejercicios puramente intelectuales. En el proceso de resolución influye mucho los sentimientos y emocionses. Los tres puntos mencionados aquí son muy importantes para la resolución de un problema. Primero, debemos desear resolver el problema, esto es la determinación. Segundo, debemos creer que somos capaces de resolver el problema y que este tiene solución. Y tercero, en lo relacionado con problemas intelectuales es muy difícil perseverar si no se experimenta una razonable dosis de éxito de vez en cuando. Para esto es necesario aplicar algunas de las técnicas mencionadas arriba.\nComo puedes ver, la heurística es práctica. Además la heurística aplicada a la enseñanza y a la puede tener efectos positivos, ya que ayuda a las personas a aprender a pensar mejor.\nRazonamiento Heurístico # Aplicar las técnicas antes mencionadas tiene un efecto en la forma de resolver los problemas: en algunos de los pasos de la solución aceptamos soluciones supuestas, incompletas, relacionadas vagamente con el problema o parcialmente erróneas con tal de avanzar en la solución y el entendimiento del problema y de generar nuevas ideas/éxitos para mantener y aumentar la motivación.\nEsto no quiere decir que la heurística acepte soluciones erróneas, estos pasos son temporales, y las soluciones finales deben ser comprobadas con el mayor rigor posible.\nAlgoritmos heurísticos # Ahora hablemos de aprovechar estas ideas para la programación, con una clase de algoritmos conocidos como algoritmos heurísticos.\nUn algoritmo heurístico en vez de garantizar siempre la mejor solución en cada paso del programa, acepta soluciones parciales o suficientemente buenas. Este tipo de algoritmos funciona muy bien en casos donde hay demasiadas soluciones posibles como para probarlas todas (fuerza bruta) o muchas de ellas (como los algoritmos de backtracking) y no hay ningún algoritmo establecido conocido que resuleva el problema o se haya demostrado que esta solución es imposible.\nLa principal diferencia a tener en cuenta cuando hablamos o tratamos con este tipo de algoritmos es que no garantizan la respuesta correcta o la respuesta óptima, aunque en algunos casos son la mejor forma de lograrlo. Fuera de la programación, la heurística nos ayuda a llegar a la respuesta correcta aceptando temporalmente soluciones intermedias no óptimas, semi-erróneas o incompletas, pero con soluciones finales *que se pueden verificar como correctas rigurosamente. No es así con los algoritmos heurísticos en la programación, y he aquí por lo que el nombre puede confundirnos.\nConclusión # La heurística es un campo de estudio valioso sobre todo para la vida moderna y para el desarrollo de software porque puede ayudarnos a estructurar nuestros esfuerzos en la resolución de los problemas que nos enfrentamos.\nEn el siguiente y último artículo de la serie analizaremos más técnicas usadas en la resolución de problemas de las que Polya habla en el libro \u0026ldquo;How to Solve It\u0026rdquo;.\n","date":"3 octubre 2019","externalUrl":null,"permalink":"/2019/10/03/el-arte-de-resolver-problemas-la-heur%C3%ADstica/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003eLa heurística habla del \u003cstrong\u003ecomportamiento humano\u003c/strong\u003e frente a los problemas. - George Polya\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eEn un \u003ca\n  href=\"/2019/09/27/tecnicas-para-resolver-problemas.html\"\u003eartículo anterior\u003c/a\u003e analizamos la estructura básica de un problema y la estructura de resolución que George Polya propone para intentar resolverlos.\u003c/p\u003e","title":"El arte de resolver problemas: la heurística","type":"posts"},{"content":"","date":"3 octubre 2019","externalUrl":null,"permalink":"/tags/heuristics/","section":"Tags","summary":"","title":"Heuristics","type":"tags"},{"content":"","date":"3 octubre 2019","externalUrl":null,"permalink":"/tags/how_to_solve_it/","section":"Tags","summary":"","title":"How_to_solve_it","type":"tags"},{"content":"","date":"27 septiembre 2019","externalUrl":null,"permalink":"/tags/maths/","section":"Tags","summary":"","title":"Maths","type":"tags"},{"content":"Todos los desarrolladores nos hemos encontrado con problemas que nos dejan perplejos y que no tenemos idea de por dónde empezar a resolver.\nGeorge Polya fue uno de los matemáticos más prolíficos del Siglo XX, un matemático de primera clase (de esos que descubren e inventan cosas, y para algunos, el matemático más influyente del siglo) pero que, a diferencia de muchos otros, mantenía un interés por la educación y la enseñanza de las matemáticas, algo muy peculiar.\nEscribió varios libros, entre ellos está \u0026ldquo;How to solve it\u0026rdquo; un tratado de 4 partes en el que explica de manera muy detallada cómo resolver problemas matemáticos principalmente, pero también cómo aplicar este conocimiento a otras áreas de la vida.\nLas técnicas explicadas por Polya te pueden ayudar a desarrollar tus capacidades de resolución de problemas.\nEmpecemos por hablar de la estructura los problemas de los que Polya habla en su libro.\nEstructura de un problema # Polya enseña que un problema tiene tres partes:\nLos datos. Es la información que tenemos disponible para resolver el problema. Las condiciones. Describen la relación que existe entre los datos y la solución, pero también la forma, los límites y características de la solución buscada. La incógnita o lo desconocido. Es la información que buscamos y que cumple con las condiciones del problema. Es muy importante conocer la composición de un problema para poder aplicar las técnicas descritas en el libro. Cualquier problema matemático debería cumplir con estas características, pero no todos los problemas de la vida real cumplen con esta estructura tal y como la necesitamos; por esta razón deberíamos desarrollar la capacidad de entender los problemas que se nos presentan y estructurarlos lo mejor posible según esta definición para facilitarnos la vida posteriormente.\nPara resolver un problema deberías ser capaz de contestar las siguientes preguntas:\n¿Qué estoy buscando? -\u0026gt; ¿Cuál es la incógnita? ¿Qué datos tengo disponibles? -\u0026gt; ¿Son suficientes los datos que tengo para resolver el problema? ¿Qué condiciones tiene que cumplir la incógnita? -\u0026gt; ¿Es posible cumplir con esta condición? ¿Qué relación hay entre los datos y la incógnita? Esta estructura sienta las bases para lo que viene. Ahora hablemos de de los tipos de problemas de los que Polya hace distinción.\nTipos de problemas # Polya hace la distinción entre dos tipos diferentes de problemas que hay que tratar de resolver de manera ligeramente diferente aunque la estructura sea la misma.\n1. Problemas para encontrar # Estos son los problemas básicos que nos ponían en la escuela primaria: \u0026ldquo;Hallar el área de un terreno cuadrado de 10m por lado\u0026rdquo;, \u0026ldquo;Encuentra la diámetro de una circunferencia con un perímetro de 12cm\u0026rdquo;.\nEn este tipo de problemas hay que encontrar un resultado, que puede ser numérico o no. Estos son los problemas con los que nos encontramos mayormente en áreas del conocimiento muy exploradas.\nComo programadores podríamos tener estos ejemplos de este tipo de problemas:\n¿Qué complejidad tiene este algoritmo que acabo de programar? ¿A cuántos usuarios simultáneos podré atender con este servidor con 4GB de RAM? ¿Cuánto tiempo va a tardar en subir mi millón de archivos si lo vuelvo paralelo? ¿Cuánto va a tardar si no lo paralelizo? Varios de estos problemas suenan demasiado simples porque ya los tenemos bien trabajados a base de repetición. Pero otros que no tienen una respuesta numérica pueden ser un poco más complicados:\n¿Qué base de datos debería usar para servir notificaciones en tiempo real? ¿Qué lenguaje de programación debo usar para un sistema que estará emebebido en un millón de dispositivos electrónicos mandando notificaciones críticas cada segundo? ¿Qué sistema de comunicación puedo usar entre dos dispositivos que no cuentan con una conexión confiable a internet? En los ejemplos anteriores encontrar una solución concreta a las preguntas planteadas permite avanzar.\n2. Problemas para demostrar # \u0026ldquo;Demuestre que la línea de mayor longitud que toca dos puntos de una circunferencia pasa por el centro del círculo\u0026rdquo;.\nEsto es un ejemplo de un problema para demostrar. Estos implican la comprobación o refutación de una aserción (hipótesis) enunciada en el problema. Estos problemas generalmente nos los ponían en la preparatoria o universidad, por su naturaleza son un poco más difíciles en general.\nPara un desarrollador podríamos poner problemas para demostrar como:\n\u0026ldquo;Demuestra que es imposible un bloqueo mutuo entre procesos con el algoritmo usado actualmente\u0026rdquo;. \u0026ldquo;¿Cómo sabemos que evitamos todas las condiciones de carrera en el sistema actual?\u0026rdquo; \u0026ldquo;Comprueba que el máximo tiempo que puede tardar el sistema en responder es menor que X.\u0026rdquo; Estos problemas requieren soluciones más generales y abstractas en general. Espero que con estos ejemplos haya quedado clara la diferencia entre los diferentes tipos de problemas.\nProblemas matemáticos, acertijos y problemas de la vida real # Polya habla en sus libro sobre todo de un tipo específico de problemas: los problemas matemáticos.\nUn problema matemático bien definido cuenta con:\nDatos suficientes para resolución No tiene datos sobrantes Condiciones no contradictorias o imposibles de cumplir Por extensión, los acertijos cumplen con las mismas características, y se dan algunos de ejemplos de ellos en el libro. Pero los problemas de la vida real son muy diferentes, ya que estos pueden no cumplir con las características completas de un problema bien definido. Así que uno de los pasos previos para resolver un problema de la vida real es intentar definir lo mejor posible el problema por resolver y completarlo en caso de que falte algo.\nCómo empezar a resolver un problema # Polya plantea cuatro etapas de resolución de un problema:\nEntendimiento Planeación Ejecución Retrospectiva Hablemos de cada una, para entender claramente cómo podemos mejorar nuestras posibilidades de resolución de un problema.\nEntendimiento # Es tonto contestar una pregunta que no entiendes. Es triste trabajar por un fin que no deseas. - G. Polya\nEl entendimiento del problema consiste primero en asegurarnos de que entendemos el planteamiento verbal del problema, si no tenemos ni siquiera un planteamiento verbal, debemos empezar por crearlo.\nPara decir que comprendemos el problema, tenemos que conocer los datos que se dan, las condiciones a satisfacer y la incógnita o lo que hay que demostrar.\nEsta parte puede llevar gran parte del tiempo total dedicado al problema, ya que es el fundamento de los próximos pasos, sin la que no se puede continuar.\nPlaneación # El siguiente paso es trazar un plan para atacar el problema. El plan consiste en saber que transformaciones, derivaciones y combinaciones tenemos que hacer con los datos para llegar a la solución esperada.\nEsta es la parte más difícil, ya que implica conocimiento profundo del problema. Para Polya, concebir un plan es el mayor logro en la resolución de un problema. Cuando lo concebimos parece que tenemos una \u0026ldquo;idea brillante\u0026rdquo;.\nPero es casi imposible tener una idea brillante cuando sabemos muy poco del tema. Las buenas ideas están basadas en conocimiento y experiencia previa. Por eso conviene preguntarse: ¿Conozco o resuelto un problema relacionado o similar?. Hablaremos de otras preguntas que nos pueden ayudar a concebir un plan más adelante.\nEjecución # Es hora de llevar a cabo los pasos establecidos en la planeación. En esta etapa hay que ejecutar cada uno de los pasos que establecimos en la planeación de ejecución del problema. Polya dice que aquí es donde hay que ser rigurosos con lo que hacemos, verificando que lo que hacemos tenga sentido y sea estrictamente correcto. ¿Puedes comprobar en cada paso que es correcto lo que estás haciendo?\nRetrospectiva # En este paso hay que examinar el resultado. ¿Puedes probar que el resultado final es correcto? Además podemos ver si podemos hacer algo diferente, si nuestro resultado cumple con todo lo esperado y si podemos encontrar o derivar el resultado de alguna otra forma ahora que ya sabemos cuál es.\nEste paso también sirve para verificar si el resultado o el método que usamos para resolverlo nos puede ayudar con algún otro problema que tengamos que resolver.\nLas preguntas de Polya # Polya estableció una serie de preguntas que pueden guiarte en la solución de un problema, muy relacionadas con los pasos de los que acabamos de hablar. Estas preguntas las repite vez tras vez en el libro y en verdad son iluminadoras si estás atorado en algún problema que no puedes resolver. A continuación las listamos.\n¿He resuelto un problema relacionado? ¿Conozco un problema que se aproxime? ¿Estoy usando todos los datos? ¿Puedo cambiar algo del problema para hacerlo más fácil? ¿Puedo cambiar los datos? ¿Puedo cambiar las condiciones? ¿Puedo cambiar la incógnita? Para recordar # Para resolver un problema:\nAsegúrate de entender el problema completamente: qué datos tienes, qué relación hay entre los datos y la incógnita y lo que tienes que encontrar. Planea cómo vas a atacar el problema Si estás detenido en la resolución de un problema puedes: Variar los datos, las condiciones o el resultado esperado. Pensar en otros problemas que se le parezcan: puedes usar el método que usaste para resolverlos o el resultado. Aceptar soluciones parciales, parcialmente erróneas o asumidas. Genera nuevas ideas y re-evalúa el problema y el plan a la luz de cada nuevo paso. Aprovecha cualquier idea aunque suene disparatada. En el siguiente post hablaremos de 5 cosas más de las que Polya habla en su libro: heurística, inducción, deducción, análisis y síntesis.\n","date":"27 septiembre 2019","externalUrl":null,"permalink":"/2019/09/27/t%C3%A9cnicas-para-resolver-problemas/","section":"Posts","summary":"\u003cp\u003eTodos los desarrolladores nos hemos encontrado con problemas que nos dejan perplejos y que no tenemos idea de por dónde empezar a resolver.\u003c/p\u003e\n\u003cp\u003eGeorge Polya fue uno de los matemáticos más prolíficos del Siglo XX, un matemático de primera clase (de esos que descubren e inventan cosas, y para algunos, \u003cstrong\u003eel matemático más influyente del siglo\u003c/strong\u003e) pero que, a diferencia de muchos otros, mantenía un interés por la educación y la enseñanza de las matemáticas, algo muy peculiar.\u003c/p\u003e","title":"Técnicas para resolver problemas","type":"posts"},{"content":" Go es eficiente, escalable y productivo. - Rob Pike\nGo es un lenguaje popular por los rumores que hay acerca de él, como que es el lenguaje que va a matar a C, o que es muy muy rápido y poderoso. En este artículo vamos a hablar de qué cosas son ciertas y en qué casos te conviene aprender Go.\nEmpecemos hablando de cómo y por qué nació.\nHistoria de Go # Go fue diseñado por Google para resolver sus problemas, y Google tiene grandes problemas. - Rob Pike\nGo fue creado dentro de Google por un grupo de desarrolladores de software y científicos de la computación MUY experimentados. Las tres personas que lo iniciaron a pensar y diseñar en 2007 fueron Robert Griesemer, Rob Pike y Ken Thompson (sí, el co-creador de UNIX, grep y muchas cosas más). De ese tamaño son las personas que lo diseñaron, y así se siente el lenguaje cuando lo usas.\nDespués de una serie de correos y discusiones sobre el diseño, empezaron a trabajar en él y lo presentaron como proyecto Open Source en 2009, a partir de ahí muchas personas tanto de dentro como de fuera de Google han contribuido a su desarrollo.\nCaracterísticas de Go # Go fue concebido pensando en los problemas que los diseñadores veían en los sistemas de Google: su proceso de desarrollo estaba entorpecido por las herramientas que usaban.\nSegún Rob Pike, todo era demasiado lento: demasiado lento de compilar, demasiado lento de construir, demasiado lento de pensar. Cuando decimos que el tiempo de compilación era demasiado largo nos referimos a que podía llegar a tomar varias horas para compilar un sistema.\nTambién había una \u0026ldquo;explosión de complejidad\u0026rdquo;. Así que Go fue pensado para ser simple, de una \u0026ldquo;simplicidad radical\u0026rdquo;. Por lo tanto, carece de características que otros lenguajes sí tienen, pero hacen que los programas sean complejos.\nLa simplicidad es la clave del buen software. - The Go Programming Language\nAnalicemos las características de Go, un lenguaje pensado para trabajar en sistemas muy grandes de manera simple.\nProcedural, con flexibilidad para orientación a objetos # El paradigma principal de Go es el procedural se parece mucho a C en este aspecto. Sus principales medios de organización son las funciones y los paquetes, aunque permite crear un tipo débil de organización muy parecida a los objetos mediante structs.\nAquí puedes ver un \u0026lsquo;Hello world\u0026rsquo;:\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Printf(\u0026#34;¡Hola Go!\\n\u0026#34;) } Tipado estático y fuerte # Go es un lenguaje fuertemente tipado, lo cuál significa varias cosas:\nLa declaración de variables implica el tipo de valor que estará asociado a esta instancia del nombre, por lo que no puede usarse para guardar otro tipo de valor. En Go no necesariamente se tiene que decir explícitamente el tipo de valor a usarse, puede ser inferido: miNombre := \u0026#34;Héctor\u0026#34; // La variable es un string Esto es verificado en tiempo de compilación, por lo que podrás estar tranquilo de que Go no te dejará correr programas usando variables como lo que no son.\nNo existe la conversión o forzamiento de tipos automática e implícita, como en JS, que intenta realizar la operación aunque los tipos de valor usados no tengan sentido en la operación. En Go, si intentas hacer una operación con tipos no compatibles el programa puede no compilar o fallar en tiempo de ejecución. Rápida compilación # Pensado para sistemas muy grandes, justo como los desarrollados en Google, Go se toma en serio el tiempo de complicación y es muy rápido al compilar los programas, a diferencia de Java, C o C++. Esto está apoyado por tres pilares:\nLas dependencias están puestas al principio de cada archivo, por lo que no hay que buscar en todo el programa por dependencias perdidas. Las dependencias no forman ciclos, por lo que pueden organizarse para que sean compiladas independientemente, incluso de manera paralela. El programa objeto compilado de cada paquete exporta información útil para sus dependencias que puede ser usada sin tener que leer todo el paquete. Manejo de dependencias y paquetes # Go tiene en su biblioteca estándar más de 100 paquetes y la comunidad de Go cada vez contribuye más paquetes. Go viene con la herramienta para la línea de comandos go que es fácil de usar para manejar proyectos creados con Go. La herramienta go nos ayuda a administrar nuestras dependencias: descargarlas, limpiarlas e instalarlas.\nManejo de memoria # Go tiene manejo automático de memoria, lo que quiere decir que tal como en Java o Python, no tienes que preocuparte de liberar la memoria manualmente. Sin embargo, esta característica lo hace poco práctico para sistemas que requieran tratamiento de datos en tiempo real demasiado fuerte y preciso.\nConcurrencia # A esta característica decidimos dedicarle un poco más de espacio. Debido a que el mundo de la computación ha cambiado desde que se escribieron los primeros programas, en los que se contaba con sólo un procesador, el equipo de Go le dio gran importancia a la capacidad de crear programas con un muy buen diseño concurrente. Eventualmente estos programas podrían correr en paralelo aprovechando los sistemas de computación que existen actualmente, con múltiples procesadores.\nGo permite crear procesos concurrente de manera muy sencilla:\ngo myFunc() Eso es todo. Go ejecutará la función myFunc de manera concurrente (se ejecuta de manera independiente al programa principal o a otras funciones concurrentes). Esto es una goroutine.\nGo soporta dos modelos de concurrencia:\nComunicación de procesos secuenciales (Communicating Sequential Processes - CSP), en la que cada proceso tiene sus propias variables, y se transfieren información entre ellos mediante mensajes. En el caso de Go es a través de canales.\nMulti-hilo con memoria compartida. En este tipo de concurrencia todos los procesos escriben sobre el mismo espacio de memoria, es decir, comparten variables, pero debe haber algúna forma de coordinación entre ellos para que no choquen ni se bloqueen mutuamente al tomar un recurso.\nLa concurrencia es uno de los puntos más fuertes de Go.\nVentajas de Go sobre otros lenguajes # Hablemos de en qué casos son buenos para usar Go.\nEficiencia al correr # Go no corre sobre ninguna máquina virtual. Crea ejecutables para los sistemas operativos a los que apunta, que contienen todo lo necesario para poder ejecutarse sin necesidad de tener algo instalado allí. Al ser compilado, Go es mucho más eficiente para correr que otros lenguajes interpretados, como JS, Python o Ruby. Consume menos memoria y su velocidad se acerca a la de C.\nLegibilidad # Go fue pensado para ser simple. Sus estructuras, su sintaxis y su filosofía lo hacen fácil de leer y de aprender. Es cierto que no es tan legible como Python o Ruby, por ejemplo, pero es mucho más legible que otros lenguajes con características similares como C++ o Java.\nUsable # Una de las promesas de Go desde el principio era poder hacer mucho con poco. Y es algo que cumple completamente. Su librería estándar está diseñada y construida por verdaderos titanes de la ingeniería del software, practicantes de esto por más tiempo que la vida de muchos de los que leerán este artículo. El siguiente ejemplo es un servidor web con una ruta, sin usar ningún framework o biblioteca extra, sino la pura biblioteca estándar de Go.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, HelloServer) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } func HelloServer(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello, %s!\u0026#34;, r.URL.Path[1:]) // te saluda de regreso } Desventajas # Sistema de tipos # Esta no es una desventaja como tal de Go, sino una creada por el ecosistema de desarrollo actual: al haber tantos lenguajes que hacen manejo de valores y tipos de dato automáticamente, al programar en cualquier lenguaje tipado, incluyendo Go, muchos sienten que están desperdiciando su tiempo.\nRelativamente joven # Go tiene a penas 10 años de haber salido a la luz, 12 desde que se empezó a diseñar. El tiempo de vida de un lenguaje influye en su usabilidad y la conveniencia de varias formas:\nLa comunidad que ha desarrollado Las herramientas disponibles Los errores encontrados Experiencias de otros desarrolladores con diferentes tipos y tamaños de sistemas Considera esto si tienes que hacer un proyecto grande.\nProyectos que lo usan # Muchos proyectos importantes del mundo de la infraestructura, orquestación de servidores, contenedores, bases de datos y herramientas para programadores lo usan. Algunos ejemplos:\nDocker Kubernetes Terraform y Vault (casi todos las herramientas de HashiCorp) InfluxDB Caddy Esto te debería dar una idea de la importancia de Go en el ecosistema de desarrollo. Grandes proyectos lo usan, grandes empresas lo usan.\nGo vs Rust # ¿Cuál de los dos lenguajes va a lograr efectivamente reemplazar a C, con características más modernas y como un lenguaje más adaptado a las necesidades actuales?\nEsto es pura opinión: Rust es un mejor candidato para reemplazar a C por sus características de manejo de memoria. Pero Rust no es un lenguaje tan fácil de aprender o empezar com Go.\nEn Go puedes hacer muchas cosas que haces con C razonablemente bien, sin tanta complicación y sin tener que manejar la memoria manualmente o semi-manualmente. La prueba está en todos los proyectos que manejan cosas de bajo nivel.\nMás adelante tendremos un artículo de por qué deberías aprender Rust.\nConclusión # Go es un lenguaje relevante en 2019, 10 años después de haber nacido y lo seguirá siendo por muchos años, sobre todo por los proyectos ya desarrollados en él y las características de las que hablamos en este artículo. Aprenderlo te dará una herramienta más para desarrollar programas que valgan la pena y cumplan con lo esperado.\nPero como Shane Parrish dice: Go es \u0026ldquo;simple pero no fácil\u0026rdquo;. Es sencillo empezar a programar con él, pero dominar sus conceptos requiere estudio y esfuerzo.\nGo se siente como una herencia de gente muy sabia haciendo un lenguaje para hacer cosas grandes. No te arrepentirás de aprenderlo.\n","date":"1 septiembre 2019","externalUrl":null,"permalink":"/2019/09/01/por-qu%C3%A9-deber%C3%ADas-aprender-go/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003eGo es \u003cstrong\u003eeficiente, escalable y productivo\u003c/strong\u003e. - \u003cem\u003eRob Pike\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eGo es un lenguaje popular por los rumores que hay acerca de él, como que es el lenguaje que va a matar a C, o que es muy muy rápido y poderoso. En este artículo vamos a hablar de qué cosas son ciertas y en qué casos te conviene aprender Go.\u003c/p\u003e","title":"¿Por qué deberías aprender Go?","type":"posts"},{"content":"","date":"1 septiembre 2019","externalUrl":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang","type":"tags"},{"content":"","date":"13 agosto 2019","externalUrl":null,"permalink":"/tags/lectura/","section":"Tags","summary":"","title":"Lectura","type":"tags"},{"content":"","date":"13 agosto 2019","externalUrl":null,"permalink":"/tags/rese%C3%B1as/","section":"Tags","summary":"","title":"Reseñas","type":"tags"},{"content":" ¿En qué te convertirías si aprendieras todo lo que deseas?\n¿Cuántas cosas están en tu lista de aprendizaje? Todos tenemos una lista larga de temas, habilidades y curiosidades por aprender. Pero tenemos una cantidad igual de grande de obstáculos para lograrlo: la falta de acceso a recursos de aprendizaje, la falta de tiempo, falta de motivación, dificultad en estructura, entre muchas otras cosas.\nScott Young el autor de Ultralearning fue muy amable al proporcionarme una copia de revisión antes de que saliera el libro que ya está a la venta, y en este artículo quiero sintetizar las principales técnicas que enseña para que puedas lograr aprender mejor.\nPero primero, ¿quién es Scott Young y por qué deberíamos escucharlo? Se hizo famoso por estudiar el temario completo (o casi completo) del MIT para Computer Science que normalmente se cursa en 4 años en sólo 1. Este proyecto ocupaba todo su tiempo, un montón de concentración y técnicas para aprender. Aquí es donde empezó a desarrollar el concepto que presenta en el libro (me tomaré la libertad de traducirlo): Ultra-aprendizaje. A partir de ahí ha aprendido muchas más cosas con el mismo estilo agresivo de aprendizaje y ha ayudado a otros a hacer lo mismo.\nUn proyecto de ultra-aprendizaje se define como un periodo de concentración intensa que permite aprender de manera acelerada y profunda el tema que hayas elegido. Para realizar estos proyectos, Scott propone nueve principios, tomando como base lo que aprendió de otras personas que han realizado proyectos similares a los de él pero también los estudios más recientes sobre el tema.\nEste libro te servirá tanto si eres tú el que desea aprender como si quieres enseñarle a otras personas. Veamos los nueve principios necesarios para realizar tu propio proyecto de ultra-aprendizaje.\n1: Meta-aprendizaje # Podemos pensar en este principio como la etapa de planeación. Tienes que investigar cómo esto que quieres aprender lo han aprendido otras personas, qué ruta de aprendizaje han seguido, cuáles eran sus conocimientos previos, cuánto tiempo les tomó, etc. Para esto puedes investigar en internet o incluso conseguir una entrevista con una persona que tenga los conocimientos que tú quieres.Todo lo que puedas obtener de esta información es útil.\nTambién tienes que buscar y entender la estructura del tema que quieres aprender, los subtemas principales, cuáles son buenos recursos para aprender. Si encontraste un experto que te ayudara ya tienes cubierto gran parte de esto.\nEs entonces que tienes que reunir todos los recursos posibles de aprendizaje y trazar un plan, un mapa de aprendizaje. En este periodo decidirás cuánto tiempo vas a dedicarle al proyecto y hasta dónde llegarás. Muy importante porque un poco de investigación te puede ahorrar mucho tiempo de ejecución. Este principio te invita a reducir al máximo posible lo que no sabes que no sabes sobre el tema.\n2: Enfoque # Este principio establece que para poder aprender efectivamente antes tenemos que agudizar nuestra capacidad de concentrarnos en un tema.\nEl enfoque puede trabajarse en tres momentos diferentes:\nEmpezar a enfocarse en algo Mantener el enfoque Mejorar la calidad de nuestra concentración Muchos autores coinciden en que la calidad y capacidad par concentrarse es uno de las claves para poder progresar en cualquier cosa, no sólo en el aprendizaje.\nEn el libro se dan sugerencias prácticas para poder mejorar en las tres etapas de enfoque.\n3: Aprendizaje directo # Aquel que puede ir a la fuente no va sólo por la jarra.\nEs bueno aprender cosas leyendo, pero es mucho mejor aprenderlas aplicando lo que leemos, practicando directamente. Si quieres aprender a programar tienes que crear programas reales que funcionen. Si quieres aprender un idioma tienes que hablar o comunicarte con otras personas en ese idioma. Haciendo esto aprenderás mucho más rápido de lo que harías sólamente leyendo libros que relaten la experiencia de otros, o usando Duolingo.\nPracticar la habilidad directamente o poner en acción el conocimiento hará que este sea más profundo, útil y que lo recuerdes mejor.\nEste principio es muy importante y muchos de nosotros lo hemos vivido en nuestra experiencia escolar: nada de lo que no es enseñaron es aplicable en el mundo real porque las habilidades necesarias para realizar el trabajo de verdad son muy diferentes a lo que se ve en los libros. Aunque el conocimiento adquirido puede servir como base, la práctica hace al maestro.\n4: Ensayo # Esta parte es una de las que a las personas en general menos le gusta: practicar o ensayar partes de la habilidad que sean difíciles, laboriosas o aburridas.\nMuchas veces nuestras habilidades están topadas o detenidas por cierta parte del proceso, como si fuera un embudo deteniendo el flujo de líquido. Para acabar con esto hay que practicar en la parte más incómoda de la habilidad.\nEsto incluye que descompongas la habilidad en diferentes sub-procesos que puedan ejecutarse individualmente y practicar cada uno por separado hasta que lo domines de manera razonable, uno tras otro, cada de los sub-procesos hasta terminarlos todos. Después hay que practicar de nuevo el proceso completo y medir nuestro desempeño.\nEsto es conveniente porque al trabajar sobre una parte específica del proceso completo puedes liberar recursos mentales para mejorar de manera más profunda y significativa en esa parte de la habilidad.\n5: Recuperación de la información # El principio de \u0026ldquo;retrieval\u0026rdquo; consiste en intentar poner en práctica y ver si de verdad entendiste lo que acabas de aprender mediante pruebas reales, por ejemplo: usar las palabras de un nuevo idioma en conversación, contestar preguntas de un examen o usar una nueva técnica aprendida para programar.\nEsto ayudará a que recuerdes mejor lo aprendido y a que no te quedes con la sensación de que has aprendido algo cuando no es la realidad. Poner a prueba tu conocimiento es la mejor manera de saber que sí existe y de qué calidad es.\nEste principio pone de relieve algo: es mucho más incómodo \u0026ldquo;probarse\u0026rdquo; a uno mismo mediante imponerse algún obstáculo, es una fuente de cansancio e incomodidad mental, lo cuál nos puede dejar con la sensación de que no estamos aprendiendo o avanzando mucho. Pero estudios sobre esto demuestran que aunque sólo leer puede dejar la sensación de que entendimos y aprendimos mucho, la forma más efectiva de aprender es poner a prueba el conocimiento y la sensación de aprendizaje no está directamente ligada a cuánto aprendimos de verdad.\n6: Retroalimentación # Una forma importante de mejorar y aprender es tener a alguien o algo que te ayude a encontrar lo que está fallando en tu desempeño del tema de lo que estés aprendiendo.\nEl ejemplo que Scott usa de una persona que aprendió a hablar en público como su proyecto de ultra-aprendizaje y que recibía retroalimentación de un mentor que le decía exactamente dónde fallaba. Al atacar estos puntos que una persona con más experiencia le marcaba pudo llegar a ser un orador de clase mundial en muy poco tiempo.\nA nadie nos gusta escuchar nuestras fallas, pero es una parte muy importante de aprender de manera efectiva.\nPero no todo tipo de retroalimentación es útil. Cuando esta información es sobre alguna cualidad personal o sobre tu persona directamente, en general es más perjudicial que benéfico, puede llevarte hasta a abandonar la habilidad que estabas intentando aprender.\nMuy probablemente todos hemos experimentado este tipo de comentarios: \u0026ldquo;Eres muy inteligente\u0026rdquo;, \u0026ldquo;No eres bueno para esto\u0026rdquo;, \u0026ldquo;Mejor dedícate a otra cosa\u0026rdquo;. Este tipo de comentarios no aportan nada relevante y atacan o inflan el ego de la persona.\nPara que la retroalimentación sea útil debe proveer información que guíe las siguientes etapas de aprendizaje. Para lograr esto debe ser muy específico y si es posible decirte cómo mejorar en ese aspecto.\n7: Retención # No deberíamos echar agua en una bote con fugas. De igual manera, no vale la pena que leas y aprendas muchas cosas que después no podrás recordar porque las olvidaste rápidamente.\nEn este principio Scott explica que tenemos que aprender y reconocer por qué olvidamos y atacar esas causas específicas.\n¿Cómo hacer para no olvidar el valioso conocimiento que con tanto trabajo ganamos?\nScott propone varios métodos:\nRepetición espaciada. Es un método que consiste en repasar la información un poco de tiempo después de haberla estudiado o aprendido por primera vez y repetir el proceso con cada vez más tiempo de espacio.\nAutomatización. Cuando aprendemos algo a tal grado que podamos decir que tenemos automatizada la habilidad (como andar en bicicleta), es muy poco probable que lo olvidemos.\nSobre-aprendizaje. Practicar más allá de lo que es requerido para volverse bueno en algo o competente hará que las cosas sean mucho más difíciles de olvidar. Esto se puede hacer practicando hasta el cansancio una actividad clave o aprendiendo algo más difícil que construya sobre la actividad principal, por ejemplo: aprender y practicar cálculo diferencial hará que sobre-aprendas álgebra.\nMnemónicos. Estas es un técnica que consiste en crear imágenes vívidas o palabras relacionadas con lo que estemos buscando aprender para poder recordarlo. Los mejores memoristas del mundo aplican esta técnica para poder recordar grandes cantidades de información en poco tiempo.\nPoder retener información es uno de los requisitos para que tu proyecto de ultra-aprendizaje valga la pena.\n8: Intuición # La intuición es el producto una gran cantidad de experiencia acumulada. Para verdaderamente entender algo tenemos que desarrollar nuestra intuición en el tema. ¿Qué podemos hacer para desarrollarla?\nEn esta sección del libro se habla de cómo personas como Richard Feynman parecen hacer magia al resolver problemas de física y de matemáticas. La principal característica de Feynman usada para resolver los problemas es su capacidad de identificar los principios que están en juego, además de la gran cantidad de información almacenada obtenida de otros problemas resueltos con anterioridad.\n¿Cómo puedes desarrollar una intuición similar?\nResolver problemas difíciles. Muchas veces huímos de los problemas que nos parecen demasiado difíciles para nosotros, pero resolver problemas que rebasen nuestra habilidad puede darnos un entendimiento muy profundo del tema tratado.\nComprueba la información para entenderla. No te quedes sólamente con la explicación del libro, sino trata de demostrar que lo que estás aprendiendo es cierto.\nUsa ejemplos concretos. Cuando trates con conceptos o temas abstractos, desde el principio establece un ejemplo al que le puedas ir aplicando los puntos que se van explicando. Esta concreción permitirá desarrollar un mejor entendimiento del tema.\nNo te engañes a ti mismo. Cuando te falta conocimiento sobre un tema, generalmente también te falta conocimiento para saber qué tan hábil eres. Esto quiere decir que el que no tengas dudas sobre un tema significa que lo sabes todo, sino más bien que sabes muy poco. Hacer muchas preguntas es una manera de hacerle frente a este problema, aunque parezcan tontas.\nUna forma muy efectiva de desarrollar un entendimiento real: la técnica de Feynman. Esta consiste en intentar explicar el problema, solución o concepto de la manera más clara posible como para alguien que nunca ha visto nada relacionado con el tema.\n9: Experimentación # El verdadero conocimiento no se queda en llegar al punto en que otros te dijeron que debías llegar sino en ir más allá.\nAdemás, mientras más aprendas de algo menos guía podrás recibir ya que hay menos personas y recursos en ese nivel, por lo que es algo requerido aprender a experimentar con maneras de generar conocimiento.\nPara experimentar en tu aprendizaje y resultados puedes intentar tres cosas:\nVariar los recursos de aprendizaje. Experimentar la técnica de aprendizaje. Experimentar con tu estilo de trabajo y aprendizaje. Experimentar te permitirá convertirte en verdadero experto en el tema que estés queriendo dominar.\nConclusión # Completar un proyecto de este tamaño te demuestra que tienes la habilidad de mejorarte y de sacarle buen provecho a tu vida. Te da la confianza de que puedes lograr cosas ambiciosas.\nEsta es una de las frases más inspiradoras del libro y creo que te da buenos motivos para empezar a pensar en tus propio proyecto de ultra-aprendizaje, además de los beneficios asociados al tema mismo que quieras aprender:\n¿Te ayudará a conseguir un mejor trabajo o puesto? ¿Podrás ser más útil a tu familia, comunidad o amigos? ¿Disfrutarás más de tu tiempo libre o tendrás más a consecuencia de esto? Sin duda todas estas razones son suficientes para intentarlo por lo menos.\n\u0026ldquo;Hacer cosas difíciles, sobre todo cosas que tienen que ver con aprender, puede hacer crecer el concepto que tienes de ti mismo\u0026rdquo;.\nEsto a su vez, tendrá efectos en otros campos de tu vida.\n¿Quién te podrías volver?\n¡A aprender!\nPuedes comprar el libro en Amazon.\n","date":"13 agosto 2019","externalUrl":null,"permalink":"/2019/08/13/ultralearning-el-arte-del-aprendizaje-profundo/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e¿En qué te convertirías si aprendieras todo lo que deseas?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e¿Cuántas cosas están en tu lista de aprendizaje?\u003c/strong\u003e Todos tenemos una lista larga de temas, habilidades y curiosidades por aprender. Pero tenemos una cantidad igual de grande de obstáculos para lograrlo: la falta de acceso a recursos de aprendizaje, la falta de tiempo, falta de motivación, dificultad en estructura, entre muchas otras cosas.\u003c/p\u003e","title":"Ultralearning: el arte del aprendizaje profundo","type":"posts"},{"content":"Hemos venido hablando de las características que componen a un sistema REST. En el último artículo hablamos de la arquitectura cliente-servidor. Esta es la primera característica fundamental de un sistema REST. Ahora pasemos a la siguiente característica-limitante que Thomas Fielding establece para los sistemas REST: conexión sin estado.\n¿Qué es el estado de un sistema? # El estado de una aplicación son todos los datos que usa para operar en un momento determinado.\nComo ejemplo podemos pensar en una aplicación de ventas en línea. El estado de esta aplicación, para un usuario específico son sus datos de identificación, su bolsa de compras y los productos que ha estado viendo o que tiene en su lista de deseos, así como datos que no son identificables directamente desde la interfaz de usuario como los tokens de sesión, su historial de visita de las páginas y productos (piensa en Amazon) y los productos que ha comprado anteriormente en esta página.\nTodos estos datos necesarios para operar tanto a nivel interno como para la interfaz de usuario son el estado de la aplicación para este usuario. Puedes entender el estado como el contexto de una aplicación. Todas las aplicaciones y programas usables tienen uno. Entonces, ¿a qué nos referimos con conexiones sin estado?\nConexión sin estado # Dando por supuesto que estamos trabajando en un sistema con arquitectura de red cliente-servidor, las dos partes comparten la información (el estado) necesaria para realizar las operaciones. La pregunta es: ¿en qué lado mantengo esta información durante la operación? Damos por supuesto que el almacenamiento de información a largo plazo está localizado en algún lado del servidor. Pero en el momento de la operación, ¿quién mantiene estos datos memoria operativa?\nEn el ejemplo del que hablamos: ¿quién mantiene en memoria la bolsa de compras del usuario, el cliente (el navegador web) o el servidor? Cualquiera de los dos podría llevarlo a cabo. Veamos los dos casos, empecemos por una conexión que \u0026ldquo;recuerda\u0026rdquo; el estado.\nImagínate la siguiente conversación:\nCliente(C): Vamos a empezar a trabajar con el usuario hectorip Servidor(S): De acuerdo C: Dame su bolsa de compras S: Tiene estos 5 artículos guardados C: Comprar todos los artículos de su bolsa S: Ok, serán $500 C: el cliente quiere pagar S: le he cobrado todo lo de su bolsa El tipo de conversación que acabamos de ver sería una conexión con estado: cada uno de los mensajes depende del mensaje anterior para poder entender de qué estábamos hablando. Intenta leerla de regreso y lo notarás.\nAhora veamos cómo sería un conversación que no recuerda los mensajes anteriores:\nC: Dame la bolsa de compra de hectorip S: hectorip tiene estos 5 artículos en su bolsa C: hectorip quiere comprar todos los artículos de su bolsa S: Ok, serán $500 por todos los artículos de la bolsa de compra C: hectorip quiere realizar un pago por $500 por los artículos en su bolsa de compras S: He cobrado $500 a hectorip por el pedido de los artículos en su bolsa de compras Si revisamos la conversación anterior, podemos entender cada mensaje leído individualmente, sin necesitar el contexto completo de la conversación.\nLa primera conversación (conexión con estado) tiene algunas ventajas claras:\nLos mensajes son más cortos La conversación es más fluída Se transfiere menos información de un lado a otro Pero también tiene desventajas. ¿Qué pasa si esta conversación se interrumpe y se intenta retomar? Hay que empezar la conversación desde cero. ¿Qué pasa si el servidor, por algún error olvida de lo que estábamos hablando? Hay que reiniciar la conversación. ¿Qué pasa si quiero continuar la compra en otro servidor? Hay que reiniciar la conversación con el nuevo servidor.\nCaracterísticas de conexión sin estado # Hablemos de las características de una conexión sin estado.\nLa primera característica es que no necesitamos que la conexión a nivel de sesión de red sea persistente, es decir, que se mantenga un canal de comunicación abierto que pueda mantener en memoria la información de los procesos actuales.\nSegundo, no podemos (ni debemos) asumir que el servidor mantendrá los datos del cliente automáticamente por medio de reconocer al cliente. En cada una de las peticiones que se hacen al servidor, deben venir todos los datos necesarios para que el servidor mantenga realice la operación, no se puede confiar en que las peticiones anteriores transfirieron esa información y no es necesario repetirla.\nHasta ahora parece que esto presenta más problemas que ventajas. Revisemos por qué alguien querría trabajar con un sistema así.\nVentajas de mantener el servidor sin estado # Replicación de servidores. Al no tener que mantener el estado o conexiones persistentes con una instancia del servidor, una conexión sin estado puede permitir que la petición sea atendida por cualquier instancia del código del servidor que tenga el mismo código que las peticiones anteriores, ya que toda la información necesaria para atender esas peticiones estará incluida.\nEscalabilidad. Esto es una consecuencia inmediata de la ventaja anterior: poder replicar los servidores permite distribuir la carga entre muchas computadoras y aplicar técnicas de balanceo para poder atender a muchos más clientes de lo que se podría en un sistema que requiera mantener estados.\nServicios más sencillos. Quitarle la responsabilidad de mantener el contexto de las operaciones actuales a los servicios hace que su código sea más sencillo y por lo tanto más mantenible.\nMenos carga en los servidores. Al no tener que mantener conexiones persistentes, ni tener que mantener procesos o memoria relacionada con los clientes con los que está operando, se reduce la carga en memoria operativa de los servidores (teóricamente). Esto también implica que el servidor ni siquiera tiene que estar corriendo mientras no esté activamente respondiendo una petición (como las funciones lambda).\nLa siguiente imagen ilustra una técnica común para atender a muchos clientes.\nDesventajas # Complejidad de las peticiones. La complejidad de las peticiones aumenta al necesitar mantener en el cliente toda la información necesaria para reconstruir el estado en cada petición en un servidor desde cero. Por lo tanto, la complejidad de los clientes aumenta. y el tamaño de las peticiones se incrementa.\nMayor carga en la red. Como las peticiones son más complejas y generalmente contienen más información para poder recuperar el contexto efectivamente, el viaje de información en la red es mayor en tamaño.\nConexiones que mantienen estado # En los últimos años la mayoría de las conexiones que se levantan en programas creados con la arquitectura cliente-servidor son creados con conexiones que no mantienen el estado. Sin embargo, también se puede mantener una conexión con estado en la arquitectura cliente-servidor. Hay varias formas de lograr esto, pero la principal característica es que debe haber una manera de relacionar al cliente que está solicitando los servicios con el servidor que está atendiéndolo, por lo general la manera de hacerlo es con conexiones persistentes que se mantienen abiertas mientras el proceso de uso de los servicios dura.\nEsto viene con sus propios retos, pero tecnologías actuales como Elixir, Phoenix y los WebSockets hacen el camino más fácil. En otro post hablaremos de cómo podemos aprovechar esta arquitectura y en qué casos nos conviene.\nConclusión # La segunda característica definida de los sistemas REST es importante porque permite que los servicios sean más confiables, disponibles y flexibles en tamaño (escalables). Como cada decisión que se toma en el desarrollo, esta viene con sus propias desventajas: al hacer más complejas las peticiones, la base de código es más difícil de mantener en general (del lado del cliente), pero permite características importantes en los sistemas que tienen que atender a una gran cantidad de clientes.\nEn el siguiente artículo hablaremos de la tercera característica de los sistemas REST: la capacidad de ser cachear información.\n","date":"3 agosto 2019","externalUrl":null,"permalink":"/2019/08/03/entendiendo-rest-conexi%C3%B3n-sin-estado/","section":"Posts","summary":"\u003cp\u003eHemos venido hablando de las características que componen a un sistema REST. En el último artículo \u003ca\n  href=\"/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html\"\u003ehablamos de la arquitectura cliente-servidor\u003c/a\u003e. Esta es la primera característica fundamental de un sistema REST. Ahora pasemos a la siguiente característica-limitante que Thomas Fielding establece para los sistemas REST: \u003cstrong\u003econexión sin estado\u003c/strong\u003e.\u003c/p\u003e","title":"Entendiendo REST: conexión sin estado","type":"posts"},{"content":"","date":"3 agosto 2019","externalUrl":null,"permalink":"/tags/rest/","section":"Tags","summary":"","title":"REST","type":"tags"},{"content":"","date":"3 agosto 2019","externalUrl":null,"permalink":"/tags/stateless/","section":"Tags","summary":"","title":"Stateless","type":"tags"},{"content":"","date":"3 agosto 2019","externalUrl":null,"permalink":"/tags/thomas-fielding/","section":"Tags","summary":"","title":"Thomas-Fielding","type":"tags"},{"content":"","date":"4 julio 2019","externalUrl":null,"permalink":"/tags/cliente-servidor/","section":"Tags","summary":"","title":"Cliente-Servidor","type":"tags"},{"content":" El propósito de construir software no es crear una topología de interacciones específicas, o usar un tipo particular de componente; es crear un sistema que cumpla y exceda las necesidades de la aplicación. - Thomas Fielding\nYa hablamos de las motivaciones detrás del estilo arquitectural REST{:taget=blank}. Ahora empecemos con la primera de sus características o restricciones, que la empieza a definir: la arquitectura cliente-servidor.\n¿Qué es la arquitectura cliente-servidor? # Esta arquitectura de aplicación divide un sistema en dos componentes:\nCliente: Es un programa o proceso que solicita un servicio y usa la información provista para sus propios objetivos.\nServidor: Programa o proceso que ofrece un conjunto de servicios y espera por peticiones para ejecutar o dar estos servicios.\nLa principal característica de la arquitectura cliente-servidor es que logra una separación de responsabilidades clara.\nEn palabras de Gregory R. Andrews{:target=blank}, el cliente es un proceso desencadenante mientras que el servidor es un proceso reactivo. Es decir el servidor no puede envíar datos o empezar procesos que un cliente no le ha solicitado.\nLa arquitectura básica de un sistema cliente-servidor es esta:\nVeamos sus ventajas y desventajas.\nVentajas # Hablemos de los beneficios que trae usar la arquitectura cliente-servidor.\nSeparación clara de responsabilidades # La funcionalidad del sistema se divide en dos partes (por lo menos), como el nombre lo indica en parte de dar los servicios (generalmente de datos) y la parte de atender al usuario (humanos o programa) final.\nEl cliente y el servidor tienen funciones completamente distintas y cada uno puede cambiar por su lado sin afectar al otro, a esto le podemos llamar \u0026ldquo;evolución independiente\u0026rdquo;.\nEl ejemplo que tenemos es el del navegador y las páginas que visitamos normalmente en internet. Mientras sigan cumpliendo con el protocolo establecido de comunicación (HTTP) van a poder seguir comunicándose y transfiriendo información, sin interferir la manera en que estén implementados sus procesos internos.\nDivisión de complejidad # La misma división de la que hablamos en el punto anterior permite dividir la complejidad en dos partes por lo que cada una por su lado es más fácil de entender y desarrollar que el sistema completo.\nPor lo tanto, se sigue el mismo principio que se usa para desarrollar software complejo en general: divide y vencerás. Esto permite que podamos dividir el trabajo limpiamente en diferentes etapas de desarrollo o entre diferentes equipos, que lo único que requieren es una interfaz de comunicación clara.\nEsto no quiere decir que la complejidad general se reduzca. De esto hablaremos en las desventajas.\nMúltiples versiones y reusabilidad # La implementación de la interfaz de comunicación es el único requisito indispensable para que un sistema cliente-servidor pueda seguir funcionando. Esto permite que un servidor pueda tener un número indefinido de clientes diferentes que puedan consumir su interfaz y viceversa. En el caso de REST implementar el servidor con la API permite crear tantos clientes como se necesite:\npágina web aplicación móvil sistema embebido SDK para servidores Sólo para ilustrar:\nTener N versiones de los clientes o poder crear una sin tener que volver a a replicar la funcionalidad del servidor ha hecho que las API\u0026rsquo;s se vuelvan sumamente populares.\nSimplificación de escalamiento # Poder tener separado el servidor permite que podamos escalarlo de forma independiente dependiendo del número de clientes a los que va a atender. Si necesitamos dar un servicio a escala mundial podemos replicar nuestros servidores (usando las arquitecturas adecuadas para esto) sin afectar a los clientes y sin que ellos se enteren y por lo tanto tengan que hacer algún cambio.\nDesventajas # Todo en la vida viene con desventajas asociadas y generalmente directamente proporcionales a sus ventajas. Y otra vez: intercambiamos valor entre diferentes partes de la aplicación. Analicemos algunas de estos intercambios que hacemos al aplicar la arquitectura cliente-servidor.\nComplejidad general aumentada # Cuando dividimos la aplicación y funciones completas en dos partes, aunque la complejidad de cada parte es menos que la general, la complejidad general aumenta porque hay que agregar elementos al sistema:\nInterfaces de comunicación entre cliente y servidor Mantenimiento o forma de recuperación del estado general de la aplicación Protocolos de comunicación de red cuando es el caso Centralización de la información # El servidor es el responsable de almacenar la información y procesarla para darle servicio a los diferentes clientes que los soliciten, lo cual, aunque hace más fácil su administración, representa la desventaja de tener la información centralizada en el sistema que actúa como servidor. Si este sistema se corrompe de alguna forma, los clientes necesitan otras fuentes de información para eliminar este problema.\nCombinar cliente-servidor con otra arquitecturas ayuda a mitigar esta falla. Por ejemplo, se puede implementar el patrón de replicación de repositorio en el lado de los proveedores de servicio.\nPero, un momento, ¿acaso no es cliente-servidor la única arquitectura que existe para sistemas web o sistemas distribuidos?\nOtras arquitecturas # La arquitectura para aplicaciones distribuidas más escuchada es la cliente-servidor, pero no es ni de lejos la única. Analicemos otras dos arquitecturas comunes y dónde se usan. Si quieres ver la lista completa que Fielding analiza puedes revisar la sección 2 de su tesis doctoral.\nPeer to Peer # En este estilo está compuesta por nodos equivalentes, es decir, que tiene la misma función (aunque pueden tener diferente información) y que se distribuyen la carga que soporta el sistema entero según las capacidades de cada uno y a veces se proporcionan servicios entre ellos. Un mismo nodo puede cambiar entre funciones o roles en la red dependiendo de la demanda.\nEn esta arquitectura no hay por definición un nodo más importante que otro y si alguno de toda la red falla, puede ser sustituido por otro si tiene la información replicada.\nLas redes de torrents, el blockchain y programas como Ares o LimeWire funcionaban de esta forma.\nUna red peer-to-peer puede lucir así:\nLas redes peer-to-peer son una de las mejores formas de crear sistemas distribuidos resistentes y descentralizados, es decir, que no concentran la información en un sólo punto que se vuelve el más delicado e importante de todos.\nPipe and Filter # En este patrón, la información pasa por una series de \u0026ldquo;filtros\u0026rdquo; o nodos que la procesan y van dejando la información en un nuevo estado o con nuevas propiedades y que pasan la información al siguiente nodo. Este patrón es el que siguen los pipelines de datos normalmente, en el que la información que es producida por una fuente externa es procesada a través de una serie de pasos, que pueden incluir la recolección, limpieza, almacenamiento, etc.\nConclusión # Los estilos arquitectónicos el diseño de un sistema deben adecuarse a las necesidades de ese sistema, no al revés. - Thomas Fielding\n¿A qué necesidades nos adaptamos?\nA la necesidad de tener una separación clara entre las funciones de datos y procesos de negocio y las interfaces de usuario: sean usuarios finales humanos u otros programas que consumen información.\nLa arquitectura cliente-servidor permite simplificar el trabajo del lado del servidor al no tener que preocuparse por todas las distintas situaciones en las que sus datos o procesos van a ser usados.\nEsto nos lleva a que sus procesos sean reutilizables por todos los clientes que sepan comunicarse con el servidor (léase: usar su interfaz). A su vez los clientes son más fáciles de crear por no tener en ellos mismos toda la lógica del negocio y poder enfocarse en las funcionalidades de la entidad al que le van servir.\nY por último, esta separación permite que el servidor sea fácil de escalar al nivel del servicio requerido.\nPara los propósitos de REST la arquitectura Cliente-servidor es muy adecuada. Sus beneficios superan sus desventajas para este caso de uso particular.\n","date":"4 julio 2019","externalUrl":null,"permalink":"/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003eEl propósito de construir software no es crear una topología de interacciones específicas, o usar un tipo particular de componente; es crear un sistema que cumpla y exceda las necesidades de la aplicación. - Thomas Fielding\u003c/p\u003e","title":"Entendiendo REST: Arquitectura cliente-servidor","type":"posts"},{"content":"","date":"22 junio 2019","externalUrl":null,"permalink":"/tags/machine/","section":"Tags","summary":"","title":"[Machine","type":"tags"},{"content":"¿Quieres aprender análisis de datos y ya eres programador? Los siguientes libros pueden ser de gran ayuda. Este post está basado en un artículo inglés que encontramos, pero con los recursos que recomienda actualizados y algunos otros de nuestra cosecha.\nCasi todos están en inglés pero incluímos unos cuántos en español y, en los que nos fue posible, tienes descarga directa.\n0. R en español # Empecemos por los pocos recursos en español. Encontré dos libros enfocados en aprender R (ojo: sin profundizar en el análisis de datos) en español.\nR para principiantes de Juan Bosco Mendoza # R para principiantes pretende ser un material introductorio al lenguaje de programación R, dirigído a personas que nunca han usado R o ningún otro lenguaje de programación, ni tiene conocimiento previo de probabilidad y estadística.\nEs un libro que te lleva de la mano desde la instalación hasta la exploración visual de los datos, mediante el uso de la gráficas generadas por R, de manos de un practicante asiduo del lenguaje.\nLée R para principiantes aquí.{:target=\u0026quot;_blank\u0026quot;}\nR para principiantes de Emmanuel Paradis, traducido por Jorge A. Ahumada. # Es una introducción al lenguaje R explicando un poco los detalles de funcionamiento para poder sentar las bases de uso avanzado, para principiantes en programación. Toca algunas nociones muy básicas de estadística para proporcionar ejemplos.\nPuedes descargarlo aquí.{:target=\u0026quot;_blank\u0026quot;}.\n1. Think Stats, Segunda Edición # The thesis of this book is that data combined with practical methods can answer questions and guide decisions under uncertainty.\nEste libro enseña estadística básica con Python y el proceso de análisis de exploración y análisis de datos básico, con un enfoque en los programas más que en las matemáticas.\nLee Think Stats, segunda edición.{:target=\u0026quot;_blank\u0026quot;}\nExtra: La editorial tiene todos sus libros para leer en formatos digitales gratuitos. Una oportunidad que no puedes perderte, sólo que su sitio no es fácil de navegar así que visita la página de inicio{:target=\u0026quot;_blank\u0026quot;}\n2. Bayesian Methods for Hackers # Este libro explica cómo aplicar métodos de inferencia bayesiana para programadores que no tienen tanto conocimiento de estadística y matemáticas, enfocados en el lado de la programación.\nDescarga el libro aquí{:target=\u0026quot;_blank\u0026quot;}\n3. Undestarding Machine Learning: From Theory to Algorithms # Este libro Shai Shalev-Shwartz y Shai Ben-David nos enseñan los fundamentos de machine learning y cómo transformar estos principios en algoritmos usables.\nEste libro incluye un análisis de la complejidad computacional implicada.\nDescarga Undestarding Machine Learning aquí{:target=\u0026quot;_blank\u0026quot;}\n4. The Elements of Statistical Learning # \u0026ldquo;Estamos inundados de información pero secos de conocimiento\u0026rdquo; - Rutherford D. Roger\nEsta frase que abre el libro explica la necesidad de entender y aplicar correctamente métodos estadísticos de análisis de datos para entender bien el mundo, dada la explosión de información que estamos viendo gracias a la digitalización de todas las industrias y de las ciencias.\nEl libro se enfoca en los métodos de análisis y sus fundamentos conceptuales en vez de en los detalles matemáticos.\nDescarga The Elements of Statistical Learning{:target=\u0026quot;_blank\u0026quot;}\n5. An Introduction to Statistical Learning # Está dirigido a personas que no estudiaron algo relacionado con matemáticas (como la mayoría de los programadores), para introducirlos a al aprendizaje estadístico práctico, inspirado por el libro del punto 4.\nEste libro es adecuado para personas sin preparación ni en estadística ni en ciencia de la computación. Usa R para aprender los conceptos.\nDescarga An Introduction to Statistical Learning{:target=\u0026quot;_blank\u0026quot;}\n6. Foundations of Data Science # Este libro intenta enseñar los fundamentos de análisis de datos desde una perspectiva computacional, para darles a los lectores un fundamento para los siguientes 40 años de la era de la computación, argumentando que la primera época, la enfocada en compiladores, algoritmos y lenguajes ha pasado y que ahora el foco debería estar en el análisis y procesamiento de datos.\nEmpieza estableciendo las bases matemáticas y el entendimiento necesario de los conceptos estadísticos para luego avanzar a la aplicación de estos.\nPuedes descargarlo aquí.{:target=\u0026quot;_blank\u0026quot;}\n7. A Programmer\u0026rsquo;s Guide to Data Mining # Es una guía práctica para minería de datos y sistema de recomendación, con la técnica de aprender haciendo, con ejercicions en Python. Es libro menos serio (en sentido de seriedad formal) de los que hemos visto hasta ahorita, tiene memes, bromas e imágines divertidas.\nPuedes descargar el libro aquí{:target=\u0026quot;_blank\u0026quot;}\n8. Mining of Massive Datasets # Este libro está basado en el curso CS246 de Stanford del mismo nombre. Está enfocado en la minería de datos en grandes cantidades, es decir que no puedan ser mantenidos en la memoria principal.\n\u0026ldquo;Data mining is about applying algorithms to data, rather than using data to “train” a machine-learning engine of some sort.\u0026rdquo;\nEn enfoque es en e los algoritmos que podemos aplicarle a los datos para obtener información relevante.\nPuedes descargar la segunda edición y ver el beta de la tercera edición.\n9. Deep Learning # Es un recurso introductorio al campo de machine learning específicamente enfocado en deep learning. Es un buen recurso para programadores que no tienen preparación en estadística porque la primera parte del libro está enfocada en dar las bases matemáticas para comprender los algoritmos y técnicas de deep learning.\nPuedes comprar el libro o leerlo directamente desde su página de forma gratuita.\n10. Machine Learning Yearning # Está escrito por Andrew Ng uno de los fundadores de Coursera y un gigante de la inteligencia artificial. Su enfoque principal es enseñarte cómo organizar un proyecto de Machine Learning, cómo hacer que los algoritmos funcionen y den resultados.\nTe pide suscripción con correo electrónico para que recibir una copia del borrador gratuita. Puedes registrarte aquí{:target=\u0026quot;_blank\u0026quot;}.\n11. Los libros OpenIntro # OpenIntro es una iniciativa para proveer recursos de aprendizaje de alta calidad a un precio razonable.\nProvee todos sus recursos de manera gratuita para descarga. Puedes visitarlos aquí.\n12. Los libros de Roger D. Peng y sus colegas # Roger D. Peng es un profesor de bioestadística la Escuela John Hopkins Bloomberg de Salud Pública. Tiene varios cursos en Coursera sobre análisis de datos, y también lo podemos considerar uno de los grandes contribuidores a la educación sobre análisis de datos.\nHa escito numerosos libros sobre análisis de datos y manejo de proyectos de análisis de datos. Su especialidad es R.\nPuedes ver el índice de sus libros aquí, casi todos ellos gratuitos, aunque puedes continuir monetariamente si gustas.\nConclusión # Si sabes inglés, hay más material del que podríamos leer decentemente en un buen tiempo sin tener que gastar un solo peso directamente en esta información. ¿Por qué no aprovecharla?\nCuéntanos si ya leíste uno de ellos y qué te pareció.\n","date":"22 junio 2019","externalUrl":null,"permalink":"/2019/06/22/libros-gratuitos-para-aprender-an%C3%A1lisis-de-datos/","section":"Posts","summary":"\u003cp\u003e¿Quieres aprender análisis de datos y ya eres programador? Los siguientes libros pueden ser de gran ayuda. Este post está basado en \u003ca\n  href=\"http://bit.ly/2RjPiol\"\n    target=\"_blank\"\n  \u003eun artículo inglés que encontramos\u003c/a\u003e, pero con los recursos que recomienda actualizados y algunos otros de nuestra cosecha.\u003c/p\u003e","title":"Libros gratuitos para aprender análisis de datos","type":"posts"},{"content":"","date":"22 junio 2019","externalUrl":null,"permalink":"/tags/r/","section":"Tags","summary":"","title":"R]","type":"tags"},{"content":"","date":"15 junio 2019","externalUrl":null,"permalink":"/tags/api/","section":"Tags","summary":"","title":"Api","type":"tags"},{"content":"En el artículo anterior de la serie hablamos un poco de lo que es una API REST. En este artículo empezaremos a ver qué es REST y por qué surgió.\nAntes de empezar con lo nuestro, hablemos de lo que NO es una API REST.\nEsto no es REST # Actualmente, muchos desarrolladores (yo me contaba entre ellos), llaman API REST a cualquier servicio Web que corra sobre HTTP, sirva recursos (objetos o elementos que representan un objeto) o cosas parecidas y use JSON como lenguaje de transferencia de datos. De estas cosas, sólo la parte de servir recursos (en realidad representaciones de recursos) tiene que ver con una API REST. El estilo arquitectural REST no obliga el uso de HTTP y mucho menos de JSON.\nDada esta tendencia de llamar API REST a cualquier cosa que funcione sobre HTTP, debemos estar de acuerdo en que la mayoría de las API\u0026rsquo;s ni siquiera intenta ser REST. Algunas son RPC (Remote Procedure Call) sobre HTTP simplemente. Otro mal uso que he escuchado es que cualquier cosa que sirva JSON es llamada API REST, pero como ya dijimos el estilo arquitectural REST ni siquiera fuerza el uso de JSON (y no todas las API\u0026rsquo;s que sirven XML son SOAP).\nCon esto no queremos decir que el que un servicio no sea REST lo haga malo o de mala calidad, de hecho, muchas veces (la mayoría) no se necesita cumplir con las características de REST y con cumplir con algunas de las características o principios de diseño de REST es suficiente.\nEn artículos posteriores vamos a hablar de las seis características que sí definen una arquitectura REST, las vamos a cambiar un poco del orden tradicional que se explica en la mayoría de los tutoriales (y seguiremos el de la tesis original) para que tenga más sentido la forma en que las explicamos.\nLas características de las que hablaremos son en cierto modo restricciones (constraints, como lo dice la tesis original): una cosa es definida por las cosas que no puede o no debe hacer.\nArquitectura # Cuando hablamos de REST (REpresentational State Transfer) estamos hablando se un estilo de arquitectura.\nLa definición del estilo de arquitectura REST la hizo Thomas Fielding en su tesis doctoral, que puedes descargar y leer completa aquí, en ella explica lo que lo llevó a definirla y diseñarla tal como es.\nFielding hace la distinción entre tres conceptos que parecerían lo mismo a simple vista.\nEstilo de arquitectura o estilo arquitectural: Es un conjunto de restricciones que limitan cómo los elementos de una arquitectura (componentes del software, conectores y datos) pueden interactuar entre sí y las características que deben tener. En la arquitectura de espacios físicos podemos pensar en los estilos más amplios que a veces escuchamos mencionados: Barroco, Moderno, Post-moderno. En la arquitectura de software, REST cae en esta categoría.\nDiseño arquitectural: Es la aplicación de un estilo de arquitectura. Podemos pensar en esto como las guías que definen cómo una arquitectura se implementará. El diseño arquitectural en los edificios podría pensarse en la aplicación de las reglas del diseño arquitectural a un tipo de edificio específico tu catedral o castillo 🤔.\nArquitectura: Fielding la define como una abstracción del estado de un sistema en un momento determinado. La arquitectura es la concreción de un diseño arquitectural. En el ejemplo de los edificios puedes pensar en esto como en los planos de la catedral barroca.\nHablando de arquitectura Simon Brown, que es actualmente una da las grandes mentes en el campo de la arquitectura de software, la define como la todo lo relacionado con el diseño de un sistema de software, desde la estructura del código hasta cómo funciona a alto nivel, pasando por cómo el software es puesto en producción. Es responsabilidad de la arquitectura definir las siguientes características y funciones del sistema:\nTareas que abarquen todo el sistema: Logging, manejo de errores, etc. Seguridad Rendimiento Escalabilidad Disponibilidad Auditorías y cumplimiento de regulaciones Limitaciones del entorno Interoperatividad e integración con otros sistemas Consistencia de soluciones a través de toda la base de código Evaluación de cumplimiento de los entregables Como podemos ver, la arquitectura de software tiene muchas cosas de preocuparse. Pues bueno, el estilo de arquitectura ayuda a resolver varias de estas preocupaciones predefiniendo algunas cosas la estructura y el comportamiento del sistema mediante las características y limitaciones que establece.\n¿Qué de estas cosas ataca REST? Hablemos de ellas.\nCosas que REST intenta resolver # Todo este embrollo de arquitectura-diseño-estilos fue definido con un fin en mente: estudiar los estilos y las características de las arquitecturas para poder llegar a la resolución de los problemas concretos que los sistemas tienen.\nLas cosas que REST intenta ayudar a resolver concretamente son las siguientes.\nRendimiento # Una de las principales cosas que este estilo de arquitectura quiere atacar es el rendimiento de las aplicaciones. El rendimiento se refiere tanto a la capacidad real como percibida de cumplir con lo que se espera de un sistema de software en términos de velocidad de respuesta.\nEsto implica que tanto la aplicación como la red (recordemos que siempre estamos hablando de aplicaciones web) debe responder en un tiempo razonable.\nVarias de las restricciones y características que REST establece están relacionadas directamente con este punto.\nFacilidad de Modificación # Fielding elabora esto como uno de los puntos más grandes que las arquitecturas deben atender. A final de cuentas un sistema no se puede quedar estático, y facilitar el trabajo para nosotros mismos en el futuro o para otras personas debería ser una prioridad.\nLos cinco puntos que Fielding considera que definen la facilidad de modifición son:\nFacilidad de evolución. Es la capacidad que tiene un sistema de que sus componentes cambien sin afectar directamente negativamente a los demás y por lo tanto el estado general del sistema.\nExtensibilidad. Es la capacidad de agregar funcionalidades o capacidades a un sistema.\nFacilidad de personalización. Es la capacidad de un elemento de poder adaptarse temporalmente para dar un servicio que no siempre da, sin afectar negativamente el sistema en general.\nFacilidad de configuración. Se refiere a poder cambiar la configuración o modificar un sistema en producción mediante configuraciones, es decir, sin cambios en el código.\nFacilidad de reutilización. Se puede explicar como la capacidad de los componentes de un sistema de ser usados sin modificaciones en otros sistemas.\nVisibilidad # La visibilidad es la capacidad de monitorear un componente del sistema e incluso mediar la interacción entre dos componentes. Este tipo específico de visibilidad (recientemente llamado observabilidad), puede mejorar el sistema de muchas maneras como mediante cachés, capas intermedias para mejorar la escalabilidad, monitoreo activo y la seguridad al observar la comunicación de los componentes y actuar, tal como un firewall lo hace.\nPortabilidad # Uno de los puntos que se necesita resolver de algunas aplicaciones, es que la solución pueda correr en diferentes entornos. A esto se refiere la portabilidad para Fielding, que un sistema pueda correr sin cambios en diferentes instalaciones y sin grandes cambios.\nEscalabilidad # ¿Cuántos usuarios al mismo tiempo puede soportar tu aplicación? ¿Qué pasa si de repente llegan diez veces más usuarios de los que esperabas? La respuesta a estas preguntas está directamente relacionada con la escalabilidad de la aplicación.\nFielding la define como la capacidad de los componentes de soportar un número grande de interacciones, que se ve impactada no sólo por la cantidad sino por la frecuencia de interacciones.\nSimplicidad # Un buen desarrollo debe ser tan simple como sea posible. Si se añade complejidad extra a la innata del problema en cuestión será más difícil de mantener.\nEstas cuestiones y cosas importantes acerca de todas las aplicaciones son lo que llevó a Fielding a definir REST y a agregar las características/restricciones que puso.\nFielding resume tres características en lo que el llama simplicidad:\nComplejidad. Es la cantidad de componentes interconectados. Mientras menos sea, mejor. Facilidad de comprensión. ¿Qué tan preparado está el sistema para poder ser entendido fácilmente? Verificabilidad. ¿Se puede verificar que la solución y los datos que entrega el sistema sean correctos? Conclusión # Todas estas características y necesidades de un sistema de software de fácil mantenimiento son las que llevaron a la creación de el estilo arquitectural REST. Sirven para entender por qué definió las 6 restricciones que un sistema REST debe cumplir, pero algo interesante que se menciona a través de su tesis es que cada una de las decisiones es un intercambio de valor que hay que sopesar.\n¿Por qué deberías elegir REST?\nEl estilo arquitectural REST te ayuda a resolver problemas que pueden empezar a dar dolores de cabeza desde el principio, al dar una guía de cómo debería comportarse tu aplicación para cumplir con las cualidades mencionadas arriba.\nNo debemos olvidar que toda selección es necesariamente un intercambio de valor. Se pierde algo por ganar otra cosa. La pregunta que siempre hay que tener en mente es:\n¿Qué me conviene más en este caso?\nEn el siguiente artículo analizaremos la primera restricción de REST: la arquitectura cliente-servidor.\n","date":"15 junio 2019","externalUrl":null,"permalink":"/2019/06/15/entendiendo-rest.-el-estilo-de-arquitectura./","section":"Posts","summary":"\u003cp\u003eEn el \u003ca\n  href=\"/2019/05/06/diseno-y-desarrollo-de-una-api-desde-cero.html\"\u003eartículo anterior de la serie\u003c/a\u003e hablamos un poco de lo que es una API REST. En este artículo empezaremos a ver qué es REST y por qué surgió.\u003c/p\u003e\n\u003cp\u003eAntes de empezar con lo nuestro, hablemos de lo que NO es una API REST.\u003c/p\u003e","title":"Entendiendo REST. El estilo de Arquitectura.","type":"posts"},{"content":"","date":"15 junio 2019","externalUrl":null,"permalink":"/tags/restful/","section":"Tags","summary":"","title":"Restful","type":"tags"},{"content":" TL;DR # ¿Por qué deberías considerar aprender Elixir? La respuesta fácil la encuentras en el siguiente gráfica y la plática de la que salió:\n{: .align-center}\nEste registro visual salió de esta plática:\nAgradecemos a @loreniuxmr por la plática y a @alebricio por el registro visual, así como a Hack Tabasco por la organización.\n¿Todavía no te convences? # Entonces hablemos más profundamente. Elixir es un lenguaje de programación reciente (creado cerca de 2012), pero que está haciendo mucho ruido, aunque considerando que no tiene ninguno de los nombres legendarios del área de sistemas atrás ni a alguna empresa prominente.\nEn este post vamos a hablar de por qué es buena idea aprender Elixir en 2020.\nUn poco de historia # Fue creado por José Valim, que empezó a ser programado en 2011 y su versión 1.0 salió a la luz en 2014. Ahora en Junio 2019 va en su versión 1.8. Nació con la idea de mejorar el rendimiento de los programas sin afectar la productividad de los programadores. José Valim era un contribuidor al núcleo de Rails, hasta que se dio cuenta de que no podría escalar hasta el grado que necesitaba, sobre todo por Ruby y sus limitaciones. Ahí empieza la historia de Elixir y el aprovechamiento de la concurrencia provista por Erlang y su máquina virtual, BEAM.\nEn el siguiente documental explican por qué se creó y cómo es que resuelve algunos problemas para diferentes empresas:\nCaracterísticas de Elixir # Platiquemos un poco de las características de este lenguaje que lo hacen muy adecuado para crear programas modernos, aunque aprovecha tecnología de hace 30 años.\nFuncional # Una de las primeras cosas que resalta de Elixir es que es un lenguaje funcional, como Erlang. En otro post explicamos las ventajas y características de la programación funcional pero recordemos un poco las dos principales:\nSe basan en funciones puras Los valores son inmutables A partir de estas dos características se desprenden muchas otras que llevan a una mejor descomposición de los problemas, mejor rendimiento y mantenibilidad para los problemas adecuados:\nFunciones de orden superior (o tratar las funciones como cualquier otro valor) Evaluación retardada o perezosa Transparencia referencial Independencia de contexto de ejecución Pipelines para transformación de datos Debemos tener presente que la programación funcional no es la mejor opción para todos los casos, sobre todo presenta dificultades cuando se tienen que mantener estructuras de datos muy grandes que se tengan que modificar constantemente, algunos lenguajes tiene trucos inteligentes pero sigue sin ser lo óptimo.\nBEAM - Erlang # La tecnología que está atrás de Elixir es Erlang y su máquina virtual, la BEAM. Esto quiere decir que los programas hechos con Elixir corren como su fuera un programa hecho en Erlang sobre el entorno de ejecución que originalmente fue creado para él. Además al correr sobre el mismo entorno, Elixir puede aprovechar todo lo que ya existe en Erlang, desde sus librerías hasta varias de las herramientas de desarrollo.\n¿Por qué es tan importante la máquina virtual? La BEAM es la encargada de la ejecución de los programas creados con Erlang y muchos otros lenguajes, entre ellos Elixir. Se encarga de distribuir el procesamiento y administrar la memoria, así como conectarse con los nodos necesarios para la ejecución del programa. Además administra y levanta los procesos que los programas requieren. La BEAM es el soporte para las características que vienen.\nDistribuido # La BEAM está pensada para trabajar con sistemas distribuidos, específicamente puede funcionar a través de una red de computadoras y distribuir el programa y la carga a través de todos los nodos que la componen. De esta manera puedes crear aplicaciones que aprovechen la memoria y el procesamiento de toda una red de computadoras.\nAsí nació Erlang y ahora puedes aprovechar estas características con Elixir. Por ejemplo, puedes llamar y mandar mensajes a un proceso que vive en una computadora al otro lado del mundo justo como si estuviera viviendo en tu misma computadora, siempre y cuando la BEAM tenga conectados los nodos.\nEsto es una de las características que suma a una característica de la que vamos a hablar más tarde: resiliencia.\nConcurrente # Elixir y Erlang permiten crear programas concurrentes de manera sencilla. Su modelo de concurrencia está basado en actores, que son pequeños procesos muy ligeros que no comparten memoria entre ellos y se comunican mediante mensajes colocados en un mailbox. Este tipo de concurrencia permite crear también supervisores, que son procesos que \u0026ldquo;vigilan\u0026rdquo; a otros procesos y toman acciones cuando terminan o fallan.\nTodo esto permite crear estructuras de procesos complejas que nos habilitan para lograr diferentes objetivos. Un ejemplo son los árboles de supervisión (en realidad todas las aplicaciones de Erlang y Elixir lo tienen), que es una estructura de procesos que permite crear un programa resistente a fallos.\nSiendo uno de los puntos principales del lenguaje y la BEAM, existe un conjunto de patrones, librerías y procesos diseñados para aprovechar las características concurrentes llamado OTP, que es uno de los puntos más fuertes de la plataforma completa.\nResiliente # Las aplicaciones hechas en Elixir pueden llegar ser muy, muy resilientes. Es decir, puede aguantar mucho tiempo sin caerse y soportar problemas inesperados. Las aplicaciones hechas en Erlang pueden ofrecer 99.9999999% de disponibilidad, lo que quiere decir que sólamente van a estar indisponibles 32 milisegundos en un año. A esta resiliencia contribuyen tres de las características antes mencionadas: la distribución de al computación y la memoria, la concurrencia y los árboles de supervisión.\nVelocidad # Al ser un lenguaje compilado y gracias a la BEAM, que aprovecha todos los núcleos de procesamiento disponibles, Elixir es un lenguaje muy rápido en general. Aquí una muesta del tiempo que tarda en responder una petición web usando un framework llamado Phoenix:\nFácil para empezar a programar # Elixir fue creado con el objetivo de ser divertido y fácil de aprender aún siendo un lenguaje funcional. Sigue la filosofía de Ruby. Hereda gran parte de la sintaxis y las ideas de Ruby (a final de cuentas de allí nació). Ruby nació para ser un lenguaje disfrutable y lo mismo Elixir. La sintaxis y operadores lo hacen fácil de entender una vez que entiendes que no está basado en la sintaxis de C.\nPor ejemplo, uno de los operadores más usados, el pipe, permite hacer cosas bastante legibles:\nimport Enum, only: [map: 2, sum: 1, zip: 2] calculados = [1, 2, 3, 4] reales = [0.5, 0.2., 1.7, 5.9] error = calculados |\u0026gt; zip(reales) |\u0026gt; map(fn {c, r}-\u0026gt; :math.pow(c-r, 2) end) |\u0026gt; sum Elixir es de tipado dinámico, es decir, no necesitas declarar y mantener los tipos de las variables y de cada operación.\nLo anterior no quiere decir que todo sea fácil en Elixir. El modelo de programación que lo respalda (funcional), la sintaxis no basada en C y el modelo de concurrencia basado en actores no son cosas con las que tratemos todos los días si venimos de la programción no concurrente y en su mayor parte basada en la herencia de C.\nGrandes herramientas # Una característica que resalta de Elixir son las herramientas para desarrollo con las que cuenta. Primero, puede aprovecharse de todas las que Erlang provee y segundo porque los creadores pusieron especial atención en esto. La principal herramienta para desarrollo en Elixir es mix que permite desde iniciar un proyecto hasta monitorear tu código en producción mediante conectarse a la máquina virtual que lo está corriendo.\nOtra de las herramientas/características que la BEAM tiene son actualización de código en vivo (hot code swapping). Esto es especialmente difícil de lograr con sistemas que mantienen un estado en memoria, pero por lo menos es posible y permitido por la máquina virtual.\nHablando por ejemplo de monitorear un programa que está corriendo, la BEAM permite examinarlo hasta de manera visual:\n(por cierto, esto es un árbol de supervisión).\nMetaporgramación # La metagprogramación se refiere a la capacidad de algunos lenguajes de crear código (o su representación interna) con un programa hecho en el mismo lenguaje. Gran parte (casi todo) en Elixir está hecho con esta técnica, es decir, Elixir está implementado en Elixir.\nPero lo mejor es que el equipo deicidió darle estas capacidades a los usuarios del lenguaje. Así que, gracias a esto, podemos manejar el AST (Abstract Syntax Tree o Árbol de Sintaxis abstracta), que es la representación interna del lenguaje, como si fuera un estructura común de datos y crear nuestras propias macros y estructuras sintácticas.\nEsta habilidad permite por ejemplo la creación de macros para crear tu propio mini-lenguaje adentro de Elixir, lo que generalmente se conoce como un DSL (Domain Specific Language), adaptado a lo que necesitas en el sistema que estés programando.\nLa siguiente imagen da un ejemplo de cómo puede lucir un lenguaje para un domino específico.\nComo puedes ver es mucho más adecuado para el problema específico que si sólamente creáramos funciones.\nGran comunidad # La comunidad alrededor de Elixir es uno de los puntos más fuertes. Grandes programadores de otras comunidades y con mucha experiencia están apoyándolo y desarrollando el mismo lenguaje, librerías y herramientas para él, pero más importante, son muy abiertos y fomentan el trabajo de comunidad contestando dudas directamente y apoyando a programadores más inexpertos.\nEsto ha hecho que la comunidad de Elixir sea muy receptiva, cordial y que las herramientas y librerías estén creciendo mucho en el poco tiempo de vida que tiene.\nDesventajas # Nada es perfecto. Al empezar a programar en Elixir te puedes topar con algunas problemas, de los que ahora hablaremos.\nReciente creación # Su juventud como lenguaje hace que muchos de los problemas que te enfrentas sean recientes, no haya tantos programadores experimentados y la comunidad sea más pequeña (aunque está creciendo). Esto también implica que encontrarás menos librerías y algunas tendrán aún fallas de algún tipo por no haber sido probadas completamente por una gran cantidad de usuarios.\nSi vas a iniciar un proyecto que requiera muchos programadores, conseguir programadores de Elixir será más difícil que con otros lenguajes más longevos. Pero siempre puedes enseñarles 😉.\nRendimiento crudo bajo en comparación con otras soluciones # La BEAM no es tan poderosa en procesamiento numérico como lo son otras máquinas virtuales (como la JVM) o como soluciones que compilan directamente a código máquina (Rust o Go). Es mucho mucho más lenta que estos últimos, lo cuál no la hace una solución especialmente buena cuando se trata de procesar grandes cantidades de información por sí sola (procesamiento de imágenes, análisis y transformación de datos). Para solventar esto, la BEAM soporta \u0026ldquo;plugins\u0026rdquo; llamados NIF\u0026rsquo;s, escritos en otros lenguajes que permiten delegar esta tarea a módulos y funciones escritas en otro lenguaje más adecuado para la tarea en cuestión.\nCasos de Uso # Con las características mencionadas anteriormente te podrás dar una idea de para qué es bueno elixir:\nSistemas de misión crítica. Si necesitas un sistema que no se muera con nada y sea capaz de aguantar muchos tipos diferentes de fallas (incluso desconocidas) Elixir es una gran elección.\nSistemas web. La naturaleza de uso de la web actual hace que Elixir sea una gran elección si quieres que tu sistema ocupe pocos recursos, sea confiable, escale fácilmente y aguante una cantidad brutal de usuario simultáneamente.\nSistemas en tiempo real ligero (soft real-time). Las características de Elixir lo hacen adecuado para manejar interacciones en tiempo real con muy muy poco atraso en la comunicación. Es adecuado para juegos, salas de chat, sistemas de notificaciones e incluso IoT.\nSistemas que tienen que trabajar sobre muchas máquinas. La BEAM está especialmente hecha para eso.\nProgramas embebidos. La ligereza de sus procesos y la capacidad de crear árboles de supervisión lo hacen muy adecuado para crear software embebido. Hay un proyecto específicamente creado para eso, llamado Nerves. Con él podrás crear software a prueba de balas.\nEn dónde evitarlo # Las limitantes en cuanto al procesamiento de información cruda (number crunching) pueden hacer que Elixir no sea la mejor elección si la función principal de tu programa es algo que incluya muchas operaciones matemáticas sobre grandes cantidades de números: procesamiento y transformación de imágenes, análisis de video, etc.\nRecursos de aprendizaje. # En este post puedes ver unos cuantos recursos de aprendizaje: Recursos de aprendizaje de Elixir, pero en este blog vamos a ir subiendo algunos ejercicios para que puedas aprender más de él.\nConclusión # Conviene aprender Elixir por muchas razones. Te divertirás creando programas en él. En este blog vamos a ir compartiendo artículos para que puedas aprender más de él.\nNo dudes en comentarnos tus dudas y podemos compartir nuestras experiencias.\n","date":"2 junio 2019","externalUrl":null,"permalink":"/2019/06/02/por-qu%C3%A9-deber%C3%ADas-aprender-elixir/","section":"Posts","summary":"\u003ch2 class=\"relative group\"\u003eTL;DR\n    \u003cdiv id=\"tldr\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#tldr\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003e¿Por qué deberías considerar aprender Elixir? La respuesta fácil la encuentras en el siguiente gráfica y la plática de la que salió:\u003c/p\u003e","title":"¿Por qué deberías aprender Elixir?","type":"posts"},{"content":"","date":"2 junio 2019","externalUrl":null,"permalink":"/tags/elixir/","section":"Tags","summary":"","title":"Elixir","type":"tags"},{"content":"","date":"2 junio 2019","externalUrl":null,"permalink":"/tags/registro-gr%C3%A1fico/","section":"Tags","summary":"","title":"Registro-Gráfico","type":"tags"},{"content":"En este post explicaré los principios básicos de diseño de una API. Esta primera parte es bastante teórica, empezaremos con la práctica (no con la programación, sino con el diseño) en un post posterior.\nPrimero hablemos de la importancia del diseño o la arquitectura de la API. En la serie de posts hablaremos de API\u0026rsquo;s para consumo web, a través de HTTP, ya que son las de mayor uso y popularidad.\nLa importancia de diseñar tu API # Aunque parezca una tarea aburrida, innecesaria o burocrática, elegir un estilo de diseño de API\u0026rsquo;s te servirá de las siguientes maneras:\nMayor facilidad de desarrollo. Tener una forma de nombrar los endpoints (los links con los que los sistemas externos interactúan), una estrucutra de respuesta, un estándar de errores y otras cuestiones definidas de antemano te permitirá pasar directo al diseño e implementación de las funcionalidades cuando llegue el momento. Si escoges usar una estructura de diseño común y popular puede que incluso haya herramientas que te faciliten la tarea. Nuestra API estará preparada para ser mantenible y escalable. Familiariadad. Si sigues un patrón de diseño común, cuando otros desarrolladores usen tu API la entenderán más fácil y podrán comenzar a sacarle provecho más rápido. Menos documentación. Aprovechando lo anterior, puede que gran parte de la estructura y prácticas comunes del patrón que escogiste ya estén documentadas, por lo que normalmente tendrás que documentar sólamente las partes que son especeificas de tu API. El trabajo extra que pongas en diseñar tu API o por lo menos escoger un patrón de diseño común te ahorrará trabajo en el futuro, a tu equipo y a otros desarrolladores.\nDependiendo de la época y las necesidades han surgido varios estilos o patrones de diseño comunes. Aquí hablaremos de dos de los más usados a lo largo del tiempo y de los más populares.\nSOAP (Simple Object Access Protocol) # Este es el estilo de servicios más usado en el mundo empresarial. En realidad es un protocolo que establece desde la manera de comunicación hasta el lenguaje usado para transferir datos, entre otras cosas. Su nombre es un acrónimo que signfica Simple Object Access Protocol (Protocolo simple de acceso a objetos) y fue desarrollado por Microsoft inicialmente. El lenguaje que se usa para transferir datos es XML y tiene varios estándares que definen cada aspecto de la comunicación, por lo que no se queda en sólo un estilo de diseño de API\u0026rsquo;s. Su objetivo original era definir cómo acceder y usar servicios web.\nUna de las partes más fuertes del protocolo es la manera en que establece un contrato con el cliente acerca de la forma de usar los serivicios que expone. El archivo WSDL contiene la descripción de los serivcios expuestos en un lenguaje exclusivamente creado para eso, el Web Service Description Language, que se vale de XML. En este archivo define los servicios que la API provee, mediante la definición de una colección de endpoints, mensajes y tipos de datos. Este documento permite automatizar la creación de clientes mediante código.\nVentajas de SOAP # Pensado para transacciones complejas. Una parte de SOAP está pensada para usarse con transacciones. Si lo que requieres es que tu API realice transacciones ACID, trabajar con SOAP te facilitará la vida. Establece cada parte de la comunicación. Esto puede ser una ventaja o una desventaja, pero si estás con una tecnología que lo permite y aprovecha, trabajar con SOAP puede ser rápido y sin dolor, ya que los estándares estarán implementados en la platafoma/lenguaje y las herramientas de programación pueden aprovecharse de los estándares para facilitarte la vida. Interfaz definida. Mediante el documento WSDL, SOAP permite la lectura de la interfaz (los endpoints), los tipos de datos y sus mensajes, así como las acciones que se pueden realizar de manera automatizada, lo que hace sencillo entender y consumir la API, incluso de manera automatizada mediante una herramienta que cree el cliente automáticamente o un paquete de tu lenguaje que te facilite la vida. Desventajas de SOAP. # XML. Parsear y procesar XML es en geneal más difícil y requiere más pasos que hacer con otros lenguajes de transmisión de datos usados con otros estilos de API\u0026rsquo;s, pero esta deventaja sólo aplica si tu lenguaje y herramientas de desarrollo no soportan completamente los protocolos establecidos por SOAP. Así que la experiencia que tengas con SOAP depende en gran medida de las cosas implementadas por los lenguajes y herramientas en que programarás en el lenguaje (por ejmplo, los IDE\u0026rsquo;s para C# y Java soportan recibir el WSDL para automatizar gran parte del proceso de crear un cliente) Velocidad. Al ser un protocolo más complejo, aumenta la cantidad de procesamiento y transferencia de datos requerido para funcionar, lo que lo hace más lento que otras alternativas. Además, no es fácilmente cacheable, por lo que cada respuesta tiene que ser única y por lo tanto requiere mayores recursos. Conclusión acerca de SOAP # Muchos desarrolladores, sobre todo con poca experiencia, se escandalizan cuando tienen que trabajar en un API SOAP, sobre todo las generaciones recientes, y sí es un problema cuando tus herramientas no hacen fácil trabajar con este tipo de API\u0026rsquo;s (como con cualquier otro tipo de desarrollo, tecnología o protocolo). Sin embargo, sus características las hacen ideales para API\u0026rsquo;s transaccionales, por lo que es conveniente escorger este tipo de API\u0026rsquo;s en los casos adecuados. Además, puedes beneficiarte de su forma de establecer la interfaz de manera clara y estricta. Cada herramienta fue creada con un propósito y tiene sus usos adecuados.\nAPI\u0026rsquo;s RESTful # Una API REST aprovecha el diseño de las peticiones HTTP para crear servicios web con interfaces intuitivas. REST son las siglas de \u0026ldquo;Representational State Transfer\u0026rdquo; (Transferencia de Estado Representacional), que es un estilo de arquitectura de sistemas distribuidos (podemos pensar en la web como un sistema distribuido). Este estilo establece 6 características que se deben de cumplir para que un sistema sea considerado RESTful:\nArquitectura cliente-servidor. Existe un programa encargado de hacer peticiones (cliente) y uno encargado de responderlas (servidor). Interfaz uniforme. Todos los clientes deberían acceder a la misma interfaz. Si el servidor cumple con la interfaz, puede haber un número ilimitado de clientes independientes que cambian sin dependencias entre ellos o con la implementación del servidor. Esta es una de las razones principales por las que las API\u0026rsquo;s REST son tan usadas actualmente. Este punto lo trataremos más a profundidad en el siguiente artículo. Pero para cumplir esto mencionemos brevemente qué principios debe seguir esta interfaz para que cumpla con este propósito: Basada en recursos. Las URL\u0026rsquo;s de los endpoints hacen referencia a recursos, es decir, a elementos de datos que pueden ser representados como objetos con un tipo, datos asociados, relaciones con otros objetos y las operaciones que se pueden realizar sobre él. Manipulación de recursos mediante representaciones. La API no devuelve nunca el recurso original al cliente que lo solicita o solicita una operación sobre él, sino que lo hace a través de alguna representación de este recurso. Una representación es un subconjunto de los datos de recurso transmitido en un lenguaje adecuado: HTML, XML, JSON, MessagePack, etc. Mensajes autodescriptivos. Cada mensaje tiene suficiente información en sí mismo para ser procesado. HATEOAS. Estas son las siglas de Hypermedia As The Engine Of Applicaton State (Hypermedia como el motor del estado de la aplicación). La palabra hypermedia se refiere a un formato de texto (o hypertexto) que contiene links hacia otros documentos, imágenes, video y audio. Es una forma de mostrar las relaciones que existen conceptualmente en una red de información, incluyendo formatos más allá del texto. Por lo tanto, este punto se refiere a que la API debería ser navegable con la información expuesta en cada respuesta, las relaciones con otros recursos, los links a otros documentos y achivos. El autor de la deficinición de API\u0026rsquo;s REST hace enfásis en que no está casada con ningúna forma de transporte o protocolo de comunicación, pero su implementación bien puede depender de que el protocolo de comunicación tenga las características básicas como el usar URI\u0026rsquo;s para identificación. Todo el estado de la aplicación necesaria para funcionar será transmitido a partir de hypermedia. En el caso del HTTP, se usan las URL\u0026rsquo;s con su cadena da consulta (query string), las cabeceras y los cuerpos de petición y respuesta para mantener este estado. Sistema sin estado. Las conexiones entre los sistemas (cliente y servidor) no deberían dependender de un estado creado o mantenido a través de peticiones anteiores. Todo lo necesario para generar una respuesta se encuentra en la petición actual. Cacheable. Las respuestas pueden ser guardadas para ser contestadas más rápidamente por el mismo servidor o por un sistema intermedio. Sistema en capas. El sistema puede estar construido por varias capas de servicio y esto debe ser transparente para los clientes (no tienen que modificar sus llamadas). Código bajo demanda. El servidor debe ser capaz de envíar código a cliente para que sea ejecutado. Ventajas de REST # Flexibilidad. REST no define el lenguaje de transferencia de datos, el tipo de autenticación y otros detalles de la comunicación que se dejan a discreción de los implementadores. En la actualidad, la mayoría de las API\u0026rsquo;s REST usan JSON como lenguaje de transeferencia, pero bien podrían usar XML o MessagePack, incluso un lenguaje propietario. Popularidad. La extensión de uso de API\u0026rsquo;s RESTful ha hecho que proliferen herramientas para construirlas, probarlas y ponerlas en producción, por le que es muy sencillo desarrollarlas, aunque no deja de presentar retos. Escalabilidad. Esta es una de las razones por las que las API rest se han vuelto tan populares. Incrementar la cantidad de usuarios que se pueden atender con una API RESTful es más sencillo que son SOAP debido a la cacheabilidad y a que las conexiones sin estado permiten escalamiento horizontal (replicación de servidores) y por lo tanto los costos se abaratan. La mayoría de las API\u0026rsquo;s grandes conocidas siguen este estilo. Desventajas de REST # Flexibilidad. La flexibilidad es un don y maldición. Cuando a las personas se les permite hacer lo que sea, harán hasta lo inimaginable, por lo que se pueden encontrar implementaciones horribles y sin una guía definida nuestra propia API puede quedar hecha un asco. Transacciones. REST no establece una manera de manejar operaciones transaccionales, por lo que la implementación queda completamente del lado del diseño. Hay que tener en cuenta el manejo del estado, replicación de servidores, consistencia y condiciones de carrera. Esto no hace sencillo trabajar con transacciones en API\u0026rsquo;s REST. Seguridad. No estamos diciendo que REST sea más inseguro que SOAP, sino REST no establece los medios de protección de interacciones e información, por lo que queda completamente como decisión de los desarrolladores y arquitectos del sistema. Sin una implementación adecuada tu API quedará vulnerable. Otros estilos # Han surgido nuevas maneras de consumir y diseñar API\u0026rsquo;s como GraphQL y gRPC, pero cada una merece su propio artículo.\nNuestra API # Para crear nuestra API elegiremos el estilo RESTful, por su popularidad y porque lo que aprendamos tendrá aplicaciones útiles inmeditas y en el futuro.\nEn el camino aprenderemos:\nCómo dieseñar una API RESTful Buenas prácticas de transferencia de datos y de estado Cómo comunicar errores Crear una estructura de mensajes intuitiva Versionamiento de nuestra API Nombrado de los endpoints Seguridad El ejercicio será el siguiente:\nCrear una API que permita crear listas de vocabularios. Un usuario se registra y puede crear tantos vocabularios como desee. Un vocabulario consiste de una lista de palabras ordenadas por tiempo de inserción y su definción, que puede ser tomada del diccionario (fija) o definida por el usuario. Además una palabra puede tener imágenes adjuntas.\nEsta aplicación nos permitirá poner en práctica y aprender de todos los puntos antes mencionados y otros. No te pierdas el siguiente artículo.\n","date":"6 mayo 2019","externalUrl":null,"permalink":"/2019/05/06/dise%C3%B1o-y-desarrollo-de-una-api-restful-desde-cero-la-importancia-de-dise%C3%B1ar-tu-api/","section":"Posts","summary":"\u003cp\u003eEn este post explicaré \u003cstrong\u003elos principios básicos de diseño de una API\u003c/strong\u003e. Esta primera parte es bastante teórica, empezaremos con la práctica (no con la programación, sino con el diseño) en un post posterior.\u003c/p\u003e","title":"Diseño y desarrollo de una API RESTful desde cero - La importancia de diseñar tu API","type":"posts"},{"content":"","date":"6 mayo 2019","externalUrl":null,"permalink":"/tags/soap/","section":"Tags","summary":"","title":"Soap","type":"tags"},{"content":"","date":"19 abril 2019","externalUrl":null,"permalink":"/tags/editor/","section":"Tags","summary":"","title":"Editor","type":"tags"},{"content":"","date":"19 abril 2019","externalUrl":null,"permalink":"/tags/fuente/","section":"Tags","summary":"","title":"Fuente","type":"tags"},{"content":"","date":"19 abril 2019","externalUrl":null,"permalink":"/tags/ide/","section":"Tags","summary":"","title":"Ide","type":"tags"},{"content":"Personalizar el entorno de programación se ha convertido en uno de los temas más relevantes para los desarrolladores de software, nos permite ser más productivos y estar más contentos en general con el trabajo día a día. No dudo que el lugar en el que más pasamos tiempo los desarrolladores sea el editor de texto o IDE, y, por lo tanto, aprender a personalizarlo es bastante importante. Uno de los aspectos más importantes del editor de texto es la fuente tipográfica.\nEn éste artículo presentaré las fuentes que me parecen más interesantes diseñadas para programar, además de otras que aunque no fueron diseñadas para los programadores exclusivamente, hacen un gran trabajo. Aunque parezca un tema superfluo, tener un entorno adaptado a nuestros gustos, tanto estética como funcionalmente, es increíblemente efectivo para ser más productivos. Pero antes de empezar unas notas acerca de la tipografía.\nFuentes tipográficas # Las fuentes usadas usadas en entornos cotidianos, como este post, en los procesadores de texto, en la mayoría de los textos impresos, libros y revistas son fuentes espaciadas proporcionalmente, las letras ocupan espacio horizontal proporcional a lo anchas que son naturalmente, así la i y la m ocupan diferente espacio horizontal:\niiiiiiiiii\nmmmmmmmmmm\n¿Podrías decir que es el mismo número de letras? Son 10 de cada una.\nLas fuentes espaciadas proporcionalmente facilitan la lectura o el escaneo de palabras enteras, por lo que nos permiten leer más rápido. Sin embargo, tienen algunas desventajas: los los signos de puntuación, las letras delgadas y otros símbolos son fáciles de pasar por alto. Algo que no conviene en la programación, como ya sabrás.\nPor la razón anterior, y otras mencionadas en esta pregunta de Stack Overflow, los programadores estamos acostumbrados a usar fuentes monoespaciadas o con espaciado fijo. En este tipo de fuentes las letras ocupan el mismo espacio horizontal sin importar el ancho natural de la letra en cuestión, incluidos los signos de puntuación. Así se puede crear una “cuadrícula” de letras. Veamos otra vez el ejemplo de las letras i y m:\niiiiiiiiii mmmmmmmmmm Ahora puedes afirmar que hay el mismo número de caracteres aunque no sepas exactamente cuántos. ¿Cómo ayuda esto a los programadores? Aquí un ejemplo:\nif !i, do: func()\nif !i, do: func() ¿En qué tipo de fuente es más legible la expresión anterior? Al dar un espaciado fijo a cada letra podemos distinguir mejor los dos caracteres que existen. Por ejemplo, en la fuente monoespaciada podemos ver claramente el símbolo de negación.\nDespués de entender esto sabemos porque muchas de las fuentes usadas para programar llevan en su nombre “Mono”, quiere decir que es una fuente monoespaciada. Ahora sólo un detalle más acerca de algunas fuentes: las ligaduras.\nLigaduras # Las ligaduras en las fuentes tipográficas suceden cuando el conjunto de caracteres se ha diseñado para que algunos conjuntos especiales de dos o tres caracteres puedan ser representados con un solo trazo o glifo. Lo normal era en letras como la f y la i, para que el espacio no quedara desproporcionado. Puedes leer más a detalle sobre las ligaduras tradicionales en este artículo: Ligaduras. Aquí hay unos ejemplos de las ligaduras tradicionales:\nAhora bien, las ligaduras se pueden usar para mostrar caracteres especiales más legibles y entendibles como en el caso de los conjuntos de caracteres: =\u0026gt;, !=, ==. Varias fuentes han aprovechado las ligaduras para poder llevar esto a la realidad. Lo triste de esto es que no todos los editores de texto, IDE’s y terminales los soportan. Algo que debe quedar claro que sólo cambia la representación del texto, no los caracteres realmente escritos, por lo que no produce ningún problema con el código fuente.\nAhora sí, hablemos de algunas de las fuentes bonitas que podemos usar.\nFira Code # Una fuente con ligaduras diseñada exclusivamente para programadores. Open Source y gratuita, la pueden encontrar en su repositorio de Github. Es derivada de Fira Mono y añade las ligaduras. Aquí un ejemplo de cómo cambian los caracteres en ligadura, extraído del repo de Github:\nSi le quieren dar una oportunidad la pueden probar con VS Code.\nMonoid # Fuente monoespaciada semicondensada, también con ligaduras. Esta fuente al ser más condensada que Fira Code, permite tener más texto (código) en la pantalla, sin perder demasiada legibilidad. En Medium explica las decisiones de diseño que tomó a través de varios artículos.\nHasklig # Fuente diseñada por y para programadores de Haskell (aunque no limitada para ellos), debido al extenso uso que hace de los símbolos compuestos como =\u0026gt;, ==, \u0026gt;-, -\u0026laquo;, ::, el creador decidió hacer un fork de la fuente Source Code Pro y añadirle ligaduras. Se puede descargar en su repositorio de Github. Aquí un ejemplo de cómo luce:\nY aquí cómo se verían esos caracteres en Source Code Pro:\nInput # Input es una familia de fuentes tipográficas específicamente diseñadas para programadores, con propuestas bastante interesantes: ofrece fuentes proporcionales, monoespaciadas, serif y sans-serif.\n¿Fuentes proporcionales para el código? David Jonathan Ross, el diseñador, dice que las fuentes monoespaciadas ni siquiera llegan a tomar en cuenta el grosor de la fuente, por lo que a veces el resaltado de la sintaxis puede producir resultados extraños, debido a que su espacio horizontal se mantiene constante, así las letras anchas se aplastan y las mayúsculas parecen estiradas al lado de las minúsculas.\nPara resolver esto, su fuente proporcional intenta importar los atributos que hacen que una fuente monoespaciada sea atractiva: símbolos de puntuación grandes, espaciado generoso y caracteres fáciles de reconocer individualmente.\nUna gran cualidad de esta fuente es que es completamente personalizable. Se pueden personalizar caracteres como i, a, l, 0 (cero) y también se puede escoger que tan condensada (espacio horizontal) está la fuente, este es muy valioso en el caso de tener una pantalla pequeña con líneas de código largas.\nEn su página oficial pueden encontrar una muestra, esto es un ejemplo de cómo puede llegar a verse:\nEl ejemplo anterior es con fuente monoespaciada, a mí me sigue gustando más.\nEn la página de personalización pueden descargarla completamente gratis para uso personal, en el caso de usarse en publicaciones y en web se tiene que pagar por ella.\nOperator Mono # Esta fuente la vi usada en un tutorial Laracasts y me enamoré de ella, es una fuente monoespaciada sans-serif, diseñada para programadores y diseñadores, que tiene una característica que la hace muy notable: el estilo itálico cambia completamente del normal, se vuelve una fuente más estilizada, simulando las letras manuscritas.\nSus creadores pusieron especial énfasis en las llaves y los corchetes.\nEsta fuente no tiene ligaduras (aunque hay un proyecto que se las pone: aquí), no es Open Source y tiene un costo de $199 USD por los 10 estilos básicos. Se puede comprar en su sitio oficial.\nSi el tema de resaltado de sintaxis que usas hace buen uso de las cursivas esta fuente luce absolutamente hermosa.\nProggy Fonts # Este sitio tiene varias fuentes de la familia Proggy, lucen con un toque retro pero se ven muy bien, sobre todo si te gusta el estilo de 8 bits.\nAquí un ejemplo:\nEn el sitio puedes encontrar otras fuentes exclusivas para programar, todas gratis.\nBonus # En Programming Fonts puedes encontrar más opciones si no te convenció ninguna de las que mostramos aquí. También puedes probar muchos estilos diferentes.\nEn este repo de Github puedes encontrar más ejemplos.\nNota: Este post es una actualización de otro que hice tiempo.\n","date":"19 abril 2019","externalUrl":null,"permalink":"/2019/04/19/las-mejores-fuentes-tipogr%C3%A1ficas-para-programar/","section":"Posts","summary":"\u003cp\u003ePersonalizar el entorno de programación se ha convertido en uno de los temas más relevantes para los desarrolladores de software, nos permite ser más productivos y estar más contentos en general con el trabajo día a día. No dudo que el lugar en el que más pasamos tiempo los desarrolladores sea el editor de texto o IDE, y, por lo tanto, aprender a personalizarlo es bastante importante. Uno de los aspectos más importantes del editor de texto es la fuente tipográfica.\u003c/p\u003e","title":"Las mejores fuentes tipográficas para programar","type":"posts"},{"content":"","date":"19 abril 2019","externalUrl":null,"permalink":"/tags/monospace/","section":"Tags","summary":"","title":"Monospace","type":"tags"},{"content":"Los términos concurrencia y paralelismo siempre han sido relevantes en el entorno de la computación y desarrollo de software. Hablemos de la diferencia entre ellos y cómo podemos aplicarlos en nuestros programas. Son conceptos relacionados, pero decir que uno es el otro es como decir que las naranjas y manzanas son iguales.\nEmpecemos por el concepto más sencillo: el paralelismo.\nParalelismo # Se refiere a la ejecución simultánea de varios procesos computacionales. Esto significa que se requieren varios medios de ejecución física: varios procesadores (o un procesador con varios núcleos) o varias computadoras (sistemas distribuidos) y la suficiente memoria para mantenerlos. Los procesos pueden estar relacionados entre ellos, para realizar una misma tarea, o no.\nEl paralelismo está relacionado con la capacidad del sistema en el que se ejecuta el programa, con sus recursos disponibles y que el software lo pueda aprovechar.\nRob Pike, uno de los creadores del lenguaje Go, dice que el mundo real es paralelo. Y pensemos un poco: suceden muchas cosas al mismo tiempo, algunas relacionadas entre ellas, otras no.\nVeamos algunos ejemplos concretos de paralelismo en la vida real.\nEl torneo de ajedrez # Imagínate un torneo de ajedrez en el que entran 100 personas a participar pero tiene como límite de tiempo un día. Para lograr terminar a tiempo se tienen que jugar varias partidas simultáneamente. Aunque una partida no afecta el resultado de otra que se esté jugando al mismo tiempo, esas partidas sí afectan partidas futuras si el torneo se pensó en varias etapas. La cantidad de partidas simultáneas que se puedan jugar dependerá tanto del número de jugadores como de los recursos disponibles: lugares, para jugar, tableros, conjuntos de piezas, etc, y del diseño del torneo. Esto es un ejemplo de paralelismo con procesos relacionados.\nUn grupo musical # A menos que sea el hombre orquesta, una persona no puede tocar todos los instrumentos para producir una canción compleja. Cada miembro del grupo toma un instrumento y se encarga de producir las notas correctas en el momento adecuado. Esto es otro ejemplo de un proceso paralelo con tareas relacionadas entre sí.\nUn grupo tomando clase # Ahora piensa en un profesor que imparte clases a sus alumnos. Cada alumno tomando notas es un proceso corriendo al mismo tiempo. Un alumno produce sus propias notas con su estilo y contenido para consulta posterior. Esto es un ejemplo de paralelismo con tareas no relacionadas, ya que las notas de todos los alumnos no tienen por qué converger.\nEjemplos de programas paralelos # Hablemos de algunos sistemas y programas que pueden o necesitan ejecutar tareas en paralelo.\nLas computadoras actuales. Las computadoras actuales en general cuentan con un procesador con por lo menos dos núcleos. Cada núcleo es capaz de correr un proceso por lo que esa computadora, si el software lo aprovecha, puede correr dos procesos a la vez. Insistimos: los procesos no necesariamente están relacionados.\nRed de Bitcoin. Cuando se crea un nuevo bloque en el blockchain de la red de Bitcoin, muchas computadoras, llamadas \u0026ldquo;mineros\u0026rdquo;, compiten para encontrar la solución a un problema matemático para el que se requiere gran capacidad de cómputo. Todas empiezan al mismo tiempo y la primera que termine gana una cantidad de bitcoins por haber encontrado la solución. Entonces: las computadoras trabajan en paralelo compitiendo para encontrar una solución lo más rápido posible.\nSistemas web modernos. Casi todos los sistemas web modernos que tienen que atender a una cantidad considerable de usuarios ocupan varios sistemas computacionales para poder responder las peticiones en un tiempo razonable. La primera división que se hace generalmente tiene que ver con la base de datos y el programa encargado de recibir y procesar las peticiones web. Al trabajar en computadoras diferentes que pueden funcionar al mismo tiempo, se vuelve un sistema paralelo. Algunas arquitecturas más complejas incluyen un balanceador de carga, que distribuye las peticiones a diferentes computadoras encargadas de procesar las peticiones, y se levantan tantas como se necesiten.\nComo decíamos al principio, casi todos los sistemas computacionales modernos se valen del paralelismo para funcionar decentemente. Ahora pasemos a hablar de un concepto un poco menos fácil de entender.\nConcurrencia # Esta palabra intuitivamente la entendemos como la confluencia o el encuentro de varias cosas o procesos en un sólo lugar al mismo tiempo. Cuando un lugar está lleno de gente decimos que \u0026ldquo;está muy concurrido\u0026rdquo;. Esto nos puede llevar a confundir el término con paralelismo. En cuanto a las ciencias computacionales, es algo totalmente diferente: es una manera de diseñar, componer o estructurar programas. Concurrencia, entonces, se puede definir de la siguiente forma:\nLa composición de elementos (funciones, procesos, programas, etc) que se ejecutan independientemente pero interactúan entre sí. No necesariamente se ejecutan al mismo tiempo.\nHablamos de composición en el sentido de \u0026ldquo;acomodo\u0026rdquo; o \u0026ldquo;estructura\u0026rdquo; e incluso \u0026ldquo;diseño\u0026rdquo;.\nPor lo tanto, un programa concurrente es uno que se vale de distintos procesos indpendientes para lograr su objetivo, que pueden o no correr al mismo tiempo exactamente. Pongamos unos ejemplos de la vida real.\nEl podcaster # Piensa en una persona que quiere grabar un podcast. Para facilitarse la vida ha escrito su proceso en una lista de tareas:\nCrear borrador de los temas y el script Grabar el episodio Editar y decorar el episodio Publicarlo en los sitios de podcast mas populares ¿Son estos procesos independientes? Lo cierto es que cada uno necesita una entrada (que PUEDE venir del proceso anterior), pero no necesariamente la entrada producida por el proceso anterior. Es decir:\nCrear el borrador -\u0026gt; Independiente Grabar el episodio -\u0026gt; Puede o no ocupar un borrador, es mejor idea tener uno. Editar -\u0026gt; Requiere una grabación que editar y decorar y produce un episodio final. Publicar -\u0026gt; Requiere un episodio que publicar Por lo tanto, estos procesos se pueden ejecutar independientemente. Entonces, con estas tareas (y la manera de organizarlas) podemos tener un proceso de creación de podcasts concurrente. Imagina por ejemplo que el podcaster decide crear una parte del borrador, digamos 5 minutos, y grabarlos, sólo para escucharse a sí mismo y probar el tono y el feeling. Después repite la operación hasta tener 30 minutos de contenido. Este es un proceso que podemos decir que es concurrente porque aunque no podía grabar y escribir el borrador al mismo tiempo, estas tareas se estaban completando \u0026lsquo;al mismo tiempo\u0026rsquo;, no hizo una después de otra hasta completarla.\nImagínate el proceso algo así:\nConcurrencia es manejar varias tareas en un periodo de tiempo, aunque no se ejecuten simultáneamente. Pero podríamos hacer este proceso paralelo al integrar a más personas: una persona que escriba el borrador, empezando un poco antes que el encargado de hablar al micrófono comience. Así aceleramos el proceso. O los encargados de editar y publicar pueden estar trabajando en episodios anteriores mientras se graba uno nuevo.\nEl ajedrecista # Ahora imagina a un Gran Maestro (GM) del ajedrez al que retan a enfrentarse con 10 personas a ciegas al mismo tiempo. El ajedrecista acepta y juega contra los 10 formados en círculo. Para lograr esto (además de jugar muy bien ajedrez), el gran maestro debe establecer un orden para cada openente y, por lo menos en su mente, una manera de retomar cada juego cuando sea el turno. Las tareas (los juegos), vistos desde el lado del GM están relacionadas en el sentido de que cada una suma dificultad al encuentro, cada uno hace más difícil ganar al siguiente. Este proceso no puede paralelizarse porque perdería todo el sentido.\nUn equipo de trabajo # Pensemos en un equipo que tiene que desarrollar un programa más o menos complejo. El equipo está compuesto por un desarrollador backend, un frontend y un UX/UI. Además los coordina un administrador de proyectos (PM). El PM puede diseñar una forma de trabajo que permita a cada uno de los miembros trabajar en diferentes partes del proyecto para avanzar más rápido. Para lograr esta coordinación se necesita trabajo extra: reportes, juntas y coordinación de tareas, para no empezar algo de lo que no se tenga claridad.\nEjemplos de programas concurrentes # Ahora hablemos de algunos ejemplos de programas concurrentes, de la vida real:\nSistema operativo. Un sistema operativo ejecuta muchas tareas relacionadas entre sí para lograr que un sistema de hardware sea usable para los humanos, por ejemplo: leer entrada del ratón y el teclado, mostrar el resultado de los procesos en pantallas, ejecutar el reloj, ejecutar muchos programas que hacen de tu experiencia agradable (spotify, administrador de ventanas), servicios de red. Aunque las computadoras actuales tienen varios procesdores, no se acercan al número de tareas con las que un sistema opertivo trata al mismo tiempo. Como decíamos en la sección de paralelismo, actualmente casi todas las computadoras pueden correr varios procesos al mismo tiempo, por lo que puede que el sistema operativo se aproveche de esto. La siguiente ilustración es un ejemplo de cómo trataría en sistema operativo la entrada del texto \u0026ldquo;AB\u0026rdquo;: Servidor Web. Los servidores web están diseñados para atender a muchos clientes (usuarios) dentro de un corto espacio de tiempo. Un servidor web está tratando con varios usuarios al mismo tiempo sin que necesariamente todas sus tareas se ejecuten simultáneamente: atiende a cada usuario en muy corto periodo de tiempo y pasarse al siguiente. Puede funcionar en paralelo si cuenta con los recursos computacionales suficiente. Se parece al ajedrecista, \u0026ldquo;juega\u0026rdquo; con muchos usuarios al mismo tiempo, dividiendo sus recursos por tiempo.\nNavegador. Un navegador web es un sistema naturalmente concurrente. Cada una las pestañas que tienes abiertas puede contar como una de las tareas con las que el pobre navegador web tiene que trabajar para mantenerte contento. No es necesario que esté corriendo el código de todas al mismo tiempo para funcionar, sino que usa métodos diversos para identificar exactamente qué debe estar ejecutando en cada instante.\nAlgo que debemos hacer notar es que un sistema concurrente generalmente realiza más trabajo que uno secuencial, ya que tiene que coordinar las diversas tareas independientes y la utilización de recursos. Para lograrlo, existen varias técnicas, llamadas modelos de concurrencia.\nEn el desarrollo del software # Los lenguajes tienen diferentes maneras de permitirte aprovechar los recursos de cómputo para crear programas concurrentes y paralelos:\nHilos (threads). La forma más común en que lo permiten es mediante hilos: subprocesos que se coordinan entre sí, que ocupan menos memoria que un proceso normal y comparten memoria con otros hilos y con el proceso padre.\nProcesos. Programas que corren en su propio espacio de memoria independientemente de otros procesos. Lo que hace un proceso no le afecta a otro, por lo que hay que diseñar y mantener maneras de comunicarlos.\nTareas y Futuros. Estas son una abstracción sobre los procesos e hilos, que son los elementos más básicos de concurrencia. JavaScript con los callbacks (futuros), las promesas (futuros) y posteriormente con Async/Await (tareas) permiten crear programas que deben ser concurrentes.\nConclusión # Como resumen:\nLa concurrencia tiene que ver con el diseño del software, mientras que el paralelismo tiene que ver con la ejecución.\nPor ejemplo, un sistema operativo es concurrente y aplica a diversas técnicas para coordinar todos los procesos que necesita para que logre hacer una computadora usable para los humanos. Este sistema no necesariamente es paralelo (y por mucho tiempo no lo pudieron ser), ya que si no cuenta con más de un medio físico para la ejecución simultánea de tareas o procesos recurre a técnicas de compartimiento de procesador que hacen que para los humanos parezca que ejecuta muchas tareas al mismo tiempo.\nLa concurrencia permite aprovechar sistemas que permitan ejecución paralela para lograr la tarea a la mano más rápidamente.\nSaber crear sistemas concurrentes es una de las habilidades más importantes para un desarrollador moderno, independientemente del área en la que trabajes.\nGran parte del contenido de este post fue extraído de esta charla: Concurrency is not Parallelism.\n","date":"17 abril 2019","externalUrl":null,"permalink":"/2019/04/17/la-diferencia-entre-concurrencia-y-paralelismo/","section":"Posts","summary":"\u003cp\u003eLos términos \u003cstrong\u003econcurrencia\u003c/strong\u003e y \u003cstrong\u003eparalelismo\u003c/strong\u003e siempre han sido relevantes en el entorno de la computación y desarrollo de software. Hablemos de la diferencia entre ellos y cómo podemos aplicarlos en nuestros programas.\nSon conceptos relacionados, pero decir que uno es el otro es como decir que las naranjas y manzanas son iguales.\u003c/p\u003e","title":"La diferencia entre concurrencia y paralelismo","type":"posts"},{"content":"","date":"17 abril 2019","externalUrl":null,"permalink":"/tags/paralelismo/","section":"Tags","summary":"","title":"Paralelismo","type":"tags"},{"content":"En el articulo anterior hablamos de la programación funcional y por qué es importante. En este te daremos algunos recursos para que puedas iniciarte en ella.\nEmpezando ligero # Empecemos con algunos recursos para entenderla y apreciarla mejor.\nRuss Olsen tiene una plática en la que explica las bases y características principales de la programación funcional en 40 minutos de manera concisa y entretenida.\nLas bases # ¿Quieres aprender un poco de las bases de la programación funcional?\nLos chicos de Computerphile lo explican de manera sencilla en la siguiente charla:\nLa charla de John Hughes: \u0026ldquo;Why Functional Programming Matters\u0026rdquo; es imperdible. Aquí podrás ver algunas aplicaciones de la programación funcional y como es que importa para resolver problemas que de otra manera serían muy difíciles.\nCursos # En esta sección te recomendaremos los cursos ofrecidos por varias plataformas en línea para aprender programación funcional.\nFunctional Programming in Scala, te enseñará escala de la mano del diseñador líder del mismo lenguaje. Hay una especialización completa.\nIntroduction to Functional Programming, en este curso, uno de los grandes exponentes de la programación funcional, Erik Meijer, explica la programación funcional usando Haskell.\n¿Quieres más?\nEste no es un curso acerca de programación funcional como tal, pero usa un lenguaje funcional para enseñar los conceptos principales del diseño de lenguajes de programación: Programming Languages\nLibros # Un buen libro de introducción que recomiendo es la antología de Pragmatic Programmers sobre porgramación funcional. En ella podrás encontrar un compendio de 5 lenguajes funcionales y una prueba de los que es programar con ellos, así como la implementación de los conceptos principales. Los lenguajes que encontrarás son: Clojure, Elixir, Haskell, Scala, y Swift.\nA partir de ahí podrías, por las características de cada lenguaje, decidirte por uno y pasar a estudiar directamente ese lenguaje.\nPara programadores de JavaScript # La programación de funcional está teniendo un fuerte empuje por la comunidad de JavaScript. Hay dos libros que son recomendamos para que aprendas a programar funcionalmente con lo que ya sabes de JavaScript:\nFunctional Light JavaScript, @getify, la misma persona detrás de los libros \u0026ldquo;You Don\u0026rsquo;t Know JavaScript\u0026rdquo;, explica una forma ligera de escribir programas funcionales sin obsesionarse con la pureza.\nJavaScript Allongé, en este libro, que el autor dice que es un libro acerca de cómo programar con funciones, se explican los conceptos más usados por la programación funcional, te ayuda a entender los conceptos más importantes dentro de JavaScript para manejar la funciones de manera correcta y poderosa.\nEl clásico # Por último: Structure and Interpretation of Computer Programs es un libro que explica con los conceptos principales de la programación usando el estilo funcional, una joya que no se puede perder.\nEsperamos que estos recursos te sean de ayuda para empezar tu camino en la programación funcional.\n","date":"6 abril 2019","externalUrl":null,"permalink":"/2019/04/06/los-mejores-recursos-para-aprender-programaci%C3%B3n-funcional/","section":"Posts","summary":"\u003cp\u003eEn \u003ca\n  href=\"/2019/03/30/que-es-la-programacion-funcional.html\"\u003eel articulo anterior\u003c/a\u003e hablamos de la programación funcional y por qué es importante. En este te daremos algunos recursos para que puedas iniciarte en ella.\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003eEmpezando ligero\n    \u003cdiv id=\"empezando-ligero\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#empezando-ligero\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003eEmpecemos con algunos recursos para entenderla y apreciarla mejor.\u003c/p\u003e","title":"Los mejores recursos para aprender programación funcional","type":"posts"},{"content":"","date":"6 abril 2019","externalUrl":null,"permalink":"/tags/scala/","section":"Tags","summary":"","title":"Scala","type":"tags"},{"content":"En los últimos años ha estado cobrando relevancia (de nuevo) la programación funcional. ¿Qué diferencias tiene con los estilos más usados? En este artículo hablaremos de sus dos caracterísitcas más distintivas y el tipo de programas que se pueden crear con ella.\nDefinición # Se puede definir la programación funcional así:\nEstilo de programación en el que se usan principalmente funciones puras y valores inmutables. En los lenguajes funcionales, todo es una expresión, es decir, todo tiene un valor inmutable.\nEso es todo, todas las demás cosas que lees cuando se menciona la programación funcional se derivan de estas dos características. Ahora tenemos que definir estas dos características y ver como nos proporcionan amplias capacidades para crear programas altamente legibles, rápidos y que pueden procesar grandes cantidades de datos.\nFunciones puras # Una función pura es una que no hace referencia a nada fuera de ella para trabajar. En los lenguajes que pueden usar el estilo funcional, todo se puede tratar como si fuera una función. Los ejemplos esta vez los pondremos en JavaScript, ya que es el lenguaje más común en el que la programación funcional está teniendo auge.\ntasaIVA = 0.16; /* Función impura */ function calcularIVA(subtotal) { return subtotal * tasaIVA; // tasaIVA está definido fuera del ámbito de esta función } /* Esta función es pura */ function calcularIVAPura(subtotal, tasa) { return subtotal * tasa; } La primera función, calcularIVA, toma una variable que está fuera de ella para calcular su resultado. Esto es poco recomendable por varias razones, entre ellas:\nSi vemos la función por separado, tener uno o varios valores que no sabemos de dónde vienen hace el código poco mantenible y entendible. Si alguna parte del código modifica el valor sin que nos demos cuenta, nuestros cálculos serán erróneos. Modificar los datos que están afuera y saber exactamente a todo lo que vamos a afectar cuando el programa crezca es muy difícil. Los más importante: las funciones no dependen del contexto de ejecución, sólo de sus parámetros. En cambio, la función calcularIVAPura es una función que no depende de valores que no sabemos de dónde vienen para trabajar. Tiene la característica de que siempre que la llamemos con los mismos argumentos, va a devolver el mismo valor. Tampoco modifica nada en el exterior. Cuando modifiquemos un valor sabemos exactamente a qué vamos a afectar.\nVeamos ahora una a una de las ventajas que proporciona usar funciones puras.\nTransparencia referencial # Dentro de un contexto en el que se use la función, sabiendo que la función siempre que sea llamada con ciertos parámetros devolverá lo mismo, podemos sustituir la función con su valor directamente. Esto nos permite crear programas más legibles inicialmente.\nLa tranparencia referencial hace que las funciones sean cacheables (a través de técnicas como la programación dinámica y la memoización) y predecibles: al saber que una función llamada con los mismos parámetros devolverá lo mismo, podemos almacenar ese valor en vez de volver a llamar la función y usarlo directamente. Si la función es costosa en tiempo o procesamiento, el cachearla hará nuestro programa más eficiente.\nEvaluación diferida (lazy evaluation) # Para los lenguajes funcionales más puros, todo se puede tratar como una función. Al saber que las funciones no dependen del contexto para funcionar correctamente, puedo evaluarlas ahora mismo o más tarde. Para evitar procesamiento innecesario, los lenguajes funcionales difieren la evaluación de las funciones y valores hasta que realmente se requiera el valor para alguna otra operación. Mientras el valor está sólamente definido, sin haber sido procesado. La evaluación diferida es muy conveniente sobre todo al trabajar con colecciones de datos grandes u operaciones gigantes. Algunas de las ventajas de la evaluación diferida son las siguientes:\nAhorro en tiempo de procesamiento. Si defino un valor que es una función que corre sobre una colección de un millón de elementos, no tendré que esperar al procesamiento inicial porque no lo hará hasta que realmente ocupe los valores. Si por alguna razón no se ocupa ese valor más adelante en el programa, ese procesamiento ya nos lo ahorramos definitivamente. Ahorro en memoria. Cuando definimos colecciones muy grandes, los lenguajes con evaluación diferida no reservarán la memoria que van a ocupar inmediatamente, sino hasta que hagamos referencia a este valor para su procesamiento. De igual manera, si nunca se ocupó este valor o se canceló en algún punto del programa, nos ahorramos esa memoria. Colecciones diferidas. Algunos lenguajes de programación incluyen colecciones que nunca cargan en memoria todos lo valores que van necisitar nunca, sino que los van generando uno a uno. Esto permite crear colecciones infinitas conceptualmente, o procesar conjuntos de datos muy muy grandes sin staurar la memoria. Al preferir la evaluación diferida a la anticipada (eager), el estilo de programación funcional intenta evitar la iteración al máximo grado posible. Para trabajar con colecciones de datos u operaciones reptitivas se prefieren otras técnicas:\nRecursividad. La función se llama a sí misma con valores diferentes, produciendo eventualmente el resultado deseado. Operaciones sobre colecciones y rangos. Se busca aplicar funciones como map, que aplica una función a todos los elementos de una lista o reduce que transforma todos los elementos de una lista en uno solo. Comprensión de listas (list comprehension). Se crean nuevas listas a partir de lo que parece la iteración de una colección. Muy parecido a como lo hace la función map, pero recibiendo el código directamente en vez de una función. Esto permite que las operaciones sobre coleeciones sigan pudiendo ser evaluadas de manera diferida: no se aplican las funciones hasta que de verdad se necesita.\nConcurrencia # Lo repetimos: al no depender del contexto de de evaluación sino únicamente de sus valores de entrada, las funciones pueden ser corridas cuando sea y donde sea. Esto permite que las funciones puedan ser ejecutadas en un proceso concurrentes. Si el lenguaje de programción lo permite, estos procesos concurrentes se pueden ejecutar paralelamente.\nUna aplicación de esto es el patrón MapReduce que Google propuso para proceamiento de grandes cantidades de datos, y que es la base de Hadoop.\nPor último, debemos notar que la concurrencia y el paralelismo se llevan bien, pero no son lo mismo. Para aclararlo te recomendamos la siguiente plática de Rob Pike, uno de los creadores de el lenguaje Go (que no es funcional). Resumen: concurrencia es la composición de diferentes procesos independientes, mientras el paralelismo es la ejecución simultánea de estos procesos.\nComo puedes ver, la programación funcional se posiciona como una muy buena opción para tratamiento y procesamiento de GRANDES cantidades de datos, y sus patrones han inspirado arquitecturas de procesamiento famosas.\nAhora hablemos de la segunda característica importante de la programación funcional.\nValores Inmutables # Esta característica implica que todos los valores que se definen y almacenan en un programa son finales, no pueden ser modificados. ¿Cómo hacemos entonces para llegar a los valores que necesitamos? En un programa funcional, siempre se crean nuevos valores a partir de los antiguos. Esto implica que en un lenguaje funcional no existe el paso por referencia. Siempre que se pasa un valor a una función, se crea una copia independiente de estos valores. Tampoco existen las transformaciones \u0026ldquo;in place\u0026rdquo;. Si quiero reordenar una lista, por ejemplo, necesariamente crearé una nueva colección, esta vez con los valores ordenados, manteniendo la colección original intacta.\nEn general en los lenguajes funcionales todo es una expresión, es decir: cada cosa que se pueda escribir tiene un valor inmutable.\n¿Cómo ayuda que los valores sean inmutables?\nExistencia de funciones puras # Al no permitir que un elemento externo modifique los valores que se han pasado, podemos estar seguros que los datos de la función permanecerán intactos. En lenguajes que permiten la modificación de los tipos de datos compuestos (diccionarios, listas, arrays o tuplas) es posible que alguien modifique un valor que se le pasó a la función sin que nos percatemos, pero la inmutabilidad lo previene.\nIndependencia de ejecución # Tener valores que no van ser modificados por ninguna razón habilita la independencia de ejecución tanto en tiempo como en espacio. En tiempo de ejecución podemos mandar a ejecutar la función en otro procesador o máquina completamente diferente o diferir su ejecución hasta que sea necesario.\nCódigo legible y menos errores # Nunca más en la vida (mientras uses FP) volverás a dudar si una función devuelve el valor o lo modifica en la misma variable. Evitarás todos esos errores en los que pensabas que una función devolvía algo modificado y en realidad no devolvía nada no pasarán más.\nPor supuesto que este depende del lenguaje, pero tú mismo puedes seguir los mismos principios en tu código si usas un lenguaje como JavaScript que no es completamente fucnional pero permite aplicar los ideas principales.\nCómo hacer programas usables # Todos los programas útiles escriben en memoria, pintan algo en la pantalla, consultan una base de datos o un servicio web o mandan una respuesta HTTP. Si las funciones puras no deben tocar nada del exterior, ¿cómo hacer un programa que tenga un uso?\nLos programas escritos con lenguajes o en un estilo funcional usan principalmente funciones puras para su diseño, pero no son el único tipo de funciones que ocupan, justo para permitir la entrada y salida de datos del sistema. Lo importante es separar las funciones que lo hacen de las que son puras.\nOtros características # Para finalizar hablemos de algunas de las características que los diseñadores de programas funcionales han añandido para hacer la programación más fácil.\nPattern Matching # En algunos lenguajes funcionales no existe el concepto de asignación como lo conocemos en los lenguajes imperativos. El símbolo = representa algo parecido a lo que representa en las ecuaciones matemáticas: estamos afirmando la equivalencia entre dos valores, no asignándola. Por ejemplo en Elixir, las siguientes sentencias son válidas:\na = 5 5 = a La primera expresión puede parecer una asginación, pero en realidad, lo que está haciendo es \u0026ldquo;enlazar\u0026rdquo; el valor 5 a la variable recientemente creada, para hacer posible que tu aserción sea verdadera.\nEn el segundo caso en tiempo de ejecución el programa se limita a verificar que es verdad tu afirmación: si a tiene el valor 5, el programa continuará sin ningún problema, pero si no, surgirá un error en tiempo de ejecución. El pattern matching funciona a nivel también de parámetros:\ndefmodule fibonacci do def fib(1), do: 1 def fib(2), do: 1 def fib(n), do: fib(n-1) + fib(n-2) end Cada clausula de la función entrará sólo si se manda a llamar a la función con el parámetro que empareje con el declarado en los parámetros.\nFunciones de orden superior # En realidad ya hablamos un poco de ellas. Una función de orden superior puede recibir funciones como parámetros (recuerda que la funciones a final de cuenta simplemente son otro tipo de valores inmutables) o regresar funciones como parámetros.\nUn ejemplo en JavaScript:\n// Devuelve una función que recibe un parámetro y multiplica por el número provisto function producir_multiplicador(por_cuanto) { return ((n) =\u0026gt; n * por_cuanto) } doblar = producir_multiplicador(2) triplicar = producir_multiplicador(3) doblar(5) // 10 triplicar(5) // 15 Esto es una técnica común para producir código más adecuado al dominio de tu problema.\nConclusión # No hablamos de varias cosas que la programación funcional provee o permite realizar, como la composición de funciones, la aplicación parcial y los caombinadores, pero en artículos futuros hablaremos de algunos recursos que te ayudarán aprenderla.\nEsperamo haber aclarado algunos conceptos que se oyen alrededor de la programación funcional y cómo es que estos son habilitados por sus dos caracterísitcas principales: funciones puras y valores inmutables.\nNo dudes en dejarnos algún comentario si algo no quedó claro.\n","date":"30 marzo 2019","externalUrl":null,"permalink":"/2019/03/30/qu%C3%A9-es-la-programaci%C3%B3n-funcional/","section":"Posts","summary":"\u003cp\u003eEn los últimos años ha estado cobrando relevancia (de nuevo) la \u003cstrong\u003eprogramación funcional\u003c/strong\u003e. ¿Qué diferencias tiene con los estilos más usados?\nEn este artículo hablaremos de sus dos caracterísitcas más distintivas y el tipo de programas que se pueden crear con ella.\u003c/p\u003e","title":"¿Qué es la programación funcional?","type":"posts"},{"content":"","date":"30 marzo 2019","externalUrl":null,"permalink":"/tags/functional-programming/","section":"Tags","summary":"","title":"Functional-Programming","type":"tags"},{"content":"","date":"19 marzo 2019","externalUrl":null,"permalink":"/tags/dry/","section":"Tags","summary":"","title":"Dry","type":"tags"},{"content":"","date":"19 marzo 2019","externalUrl":null,"permalink":"/tags/kiss/","section":"Tags","summary":"","title":"Kiss","type":"tags"},{"content":"En este artículo hablaremos primero de la importancia de aprender principios: qué son, qué ventajas tienen y cómo aplicarlos.\nHallarás una explicación básica de cada principio y su importancia, pero cada principio tendrá un post extenso explicando sus aplicaciones, forma de implementarlo y ejemplos prácticos, un sólo artículo no es suficiente para explicarlos cuando se podría escribir un libro sobre cada principio.\nPonle atención a los primeros dos 😉. Pero antes hablemos de lo que es un principio en general.\n¿Qué es un principio? # Un principio se puede entender como una guía de comportamiento amplia aplicable a muchas situaciones. En general un principio no te dice que hacer exactamente, sino que te da pistas de cuál es la acción correcta a través de una gran cantidad de situaciones, pero los detalles están a cargo de ti mismo.\nEn ciencia un principio también se pueden entender como una ley o una verdad que se puede aplicar en una muchas situaciones.\nHablando de principios de diseño de software, puedes pensar en ellos como en un faro que te guía a través de la oscuridad de los requerimientos del problema 😛. A diferencia de los patrones de diseño, no establecen los pasos necesarios para aplicarlos, ni siquiera la situaciones en las que son aplicables, de hecho, se pueden crear varios patrones y reglas basándonos en ellos.\nAhora hablemos de los más relevantes.\nAlgunos principios de Diseño de Software # Los siguientes principios de diseño son de los que más escucharás a lo largo de tu carrera. Aquí presentamos una síntesis de lo que tratan pero cada uno tendrá su propio artículo extenso explicando ejemplos de cómo podemos aplicarlos.\nDon\u0026rsquo;t Repeat Yourself (No te repitas) # Este principio (conocido como DRY) se explica por sí mismo: debes evitar al máximo grado posible la repetición de código. Partiendo de este principio se han creado un montón de maneras de reutilizar lo que ya hemos programado, piénsalo un poco: funciones, módulos, bibliotecas, clases, prototipos, herencia, composición, macros, saltos (goto).\nEstas son sólo algunas maneras de evitar la repetición, claro, cada una de las estrategias anteriores lo logra a su manera y añade otras ventajas y desventajas.\n¿Por qué es importante? Existen varias razones:\nHace el código más mantenible. Evitar la repetición de código permite que si alguna vez cambia la funcionalidad que estás repitiendo, no lo tengas que hacer en todos los lugares en los que lo repetiste. Reduce el tamaño del código. Esto lo hace más legible y entendible, porque hay menos código que entender. Los procesos para evitar la repetición implican nombrar el pedazo de código que estás reutilizando para identificarlo, esto hace el código más legible si lo nombraste bien. Ahorra tiempo. Al tener pedazos de código disponibles para reutilizarlos, en el futuro estás más preparado para lograr lo mismo en menos tiempo. KISS # \u0026ldquo;Keep it simple[,] stupid\u0026rdquo;: hay discrepancias sobre si esta frase significa: \u0026ldquo;Déjalo simple, estúpido\u0026rdquo; o \u0026ldquo;Mantenlo estúpidamente simple\u0026rdquo;. Este principio establece que el código, el diseño, la documentación, todo lo relacionado con el software, debe ser tan simple como sea posible.\nLos programadores tendemos a complicar las cosas. Nos piden un formulario sencillo y queremos hacer un generador de formularios que soporte este y todos los formularios en el futuro. No tenemos ni 100 usuarios y ya queremos usar Kubernetes. Necesitamos un simple binding de datos y queremos meter Angular 7, Ionic 3 y 250 bibliotecas más.\nEste principio establece que:\nNuestro software en general debería tener tan pocos componentes (y por lo tanto líneas) como sea posible. No deberíamos tener funcionalidades que no se ocupen actualmente “por si en el futuro se ocupan”. La documentación debe tener la información estrictamente necesaria. El código debe ser lo más obvio y sencillo posible. Se deben evitar esas líneas que sólo sirven para presumir lo inteligente que eres. El diseño debe mantener la estructura simple, siempre que se pueda. ¿Por qué es importante? Las siguientes son algunas de las razones que justifican la existencia de este principio:\nProyectos más mantenibles. Hay mucho menos que explicar al mantener las cosas simples. El código es más fácil de mantener y actualizar. menos documentación. Hay menos cosas raras que documentar al hacer el código fácil, sin trucos de listillos que nadie entiende. Debugging más rápido. Al reducir la complejidad se pueden encontrar los errores más rápidamente. Mayor rendimiento económico. Los tres efectos anteriores permiten que la inversión económica inicial en el código creado tenga mayores rendimientos. Este es uno de los principios más difíciles de aplicar, si no es que el más difícil. Hacer algo simple para los demás requiere de pensar las cosas el tiempo suficiente, de tener la experiencia técnica necesaria para evitar intentar matar una mosca con un cañón (o investigar y tener la capacidad de aprender). A final de cuentas la simplicidad es la sofisticación más avanzada.\nLos principios que vienen están fundamentados sobre estos dos principios.\nPrincipios SOLID # Si te dedicas a programar, llegado cierto punto vas a encontrar estos principios mencionados que te sentirás obligado a aprender qué significan.\nSOLID es un acrónimo que engloba el nombre de 5 principios, originalmente dirigidos a la programación orientada a objetos, pero que son aplicables a muchas otras cosas.\nLos 5 principios son:\nSingle Responsibility (Responsabilidad Única). Una entidad de software debería tener una sola responsabilidad, esto también se puede interpretar como \u0026ldquo;tener una y sólo una razón para cambiar\u0026rdquo;. En pocas palabras, tu componente/función/clase debería hacer muy bien una sola cosa.\nOpen/Closed (Abierto/Cerrado). Una entidad de software (este principio está dirigido a las clases), debería estar abierto a extensión (crecer sus funcionalidades con otras entidades externas) pero cerrado a modificación.\nLiskov Substitution (Sustitución de Liskov). El principio de sustitución de Liskov habla de interfaces: si una entidad de software usa una clase, este debe ser capaz de usar clases derivadas de esta. Esto es muy parecido a la programación por contrato, en el que se establecen las interfaces antes de la implementación.\nInterface Segregation (Segregación de interfaces). Los clientes (las entidades de software) que usan una entidad de software (una clase, originalmente), no deberían estar obligados a depender de métodos que no usan. Para resolver esto, interfaces de gran tamaño se deben segregar, es decir, romper, en otras más pequeñas.\nDependency Inversion. El principio de Inversión de Dependencias establece que los módulos de alto nivel, es decir, los más cercanos a las ideas humanas de lo que debe hacer el software, no deben depender de los de bajo nivel (los más cercanos a la implementación de los detalles para la computadora). Ambos deberían depender de las abstracciones del problema (interfaces). Además los detalles de implementación deben depender de las abstracciones también. Se llama así porque en general la gente lo piensa al revés.\nEstos principios empiezan sencillos pero se van complicando, así que le dedicaremos más adelante un post entero a cada principio y a su aplicación, extendiéndola más allá del software orientado a objetos.\n¿Por qué son importantes? Permiten crear software estructurado correctamente que resista el paso del tiempo.\nComo podrás ver, estos principios pueden complicar con un poco el código. Sin embargo, dependiendo del fin del software que estés creando, puedes decidir aplicarlos o saltarte alguno de ellos.\nConclusión # Hay más principios de diseño de software de los que no hablamos en este momento, pero estos son los básicos que todo programador debe de conocer porque facilitan la vida.\nSi seguimos estos principios podremos hacer software mantenible, que sea fácil de actualizar, entender, compartir, explicar y que esté preparado para el futuro.\nSigue atento por los siguientes posts que explican cada principio en profundidad, con ejemplos reales.\n","date":"19 marzo 2019","externalUrl":null,"permalink":"/2019/03/19/principios-de-dise%C3%B1o-de-software/","section":"Posts","summary":"\u003cp\u003eEn este artículo hablaremos primero de la importancia de aprender \u003cstrong\u003eprincipios\u003c/strong\u003e: qué son, qué ventajas tienen y cómo aplicarlos.\u003c/p\u003e\n\u003cp\u003eHallarás una explicación básica de cada principio y su importancia, pero cada principio tendrá un post extenso explicando sus aplicaciones, forma de implementarlo y ejemplos prácticos, un sólo artículo no es suficiente para explicarlos cuando se podría escribir un libro sobre cada principio.\u003c/p\u003e","title":"Principios de Diseño de Software","type":"posts"},{"content":"","date":"12 marzo 2019","externalUrl":null,"permalink":"/tags/django-rest-framework/","section":"Tags","summary":"","title":"Django-Rest-Framework","type":"tags"},{"content":"","date":"12 marzo 2019","externalUrl":null,"permalink":"/tags/flask/","section":"Tags","summary":"","title":"Flask","type":"tags"},{"content":"","date":"12 marzo 2019","externalUrl":null,"permalink":"/tags/hug/","section":"Tags","summary":"","title":"Hug","type":"tags"},{"content":"Es una tarea común para un desarrollador el diseñar e implementar una API web. Veremos tres herramientas para desarrollar tu API, de lo más sencillo a lo más completo: Hug, Flask y Django Rest Framework.\nHug # Hug es una pequeña biblioteca para crear API\u0026rsquo;s muy fáciles de entender y mantener. Provee un serie de herramientas que permiten hacer tu API muy rápidamente, con poco código y siguiendo las mejores prácticas. Hug no es una biblioteca exclusiva para hacer API\u0026rsquo;s web, sino que se enfoca en permitirte crear API\u0026rsquo;s en el más amplio sentido de la palabra: una intefaz para permitir el uso automatizado (mediante código) de tu programa.\nSi haces una API en Hug, podrás exponerla a parte de en web como un módulo de Python o a la interfaz de línea de comandos.\nCon hug, puedes hacer algo tan sencillo como lo siguiente:\nimport hug @hug.get() def hola_apis(): return {\u0026#34;mensaje\u0026#34;: \u0026#34;Hola API\u0026#39;s\u0026#34;} ¡Y listo! Lo anterior es una API lista para ser consumida, no necesitas crear ni configuración ni caberceras ni nada más (aunque claro que las puedes poner).\nHug provee de cosas interesantes:\nDocumentación automática Verificación y validación de parámetros -\u0026gt; usando el type hinting de Python 3 Versionamiento de API\u0026rsquo;s (una de las cosas más difíciles de hacer bien en el ciclo de vida de una API) Múltiples tipos de salida con sólo cambiar la configuración Extensibilidad y flexibilidad Hug es compatible con WSGI (Web Server Gateway Interface) por lo que puedes ponerlo en producción usando Gunicorn o uWSGI detrás de un servidor HTTP como proxy reverso (NGINX o Apache, entre otros).\nAquí tienes un post introcutorio a Hug:\nCrear APIs REST con Python y Hug Cuándo usarlo: No he usado Hug en producción aún, pero promete ser muy bueno, sobre todo con las exigencias del mundo actual. Lo recomendaría para proyectos pequeños y medianos y para exponer bibliotecas o módulos que ya existen en alguna parte de código como versiones Web o CLI.\nFlask # Flask es una herramienta flexible para programar proyectos web en Python. Provee una capa mínima de ruteo y compatibilidad con WSGI, así como funcionalidades y helpers comunes para las tarea más comunes en desarrollo web.\nEntre las características de Flask están:\nIntegración por default con Jinja2 Soporte de cookies de sesión seguras Servidor web para desarrollo y debuggeo Personalmente, considero Flask como la opción más flexible para desarrollar proyectos web en Python. Además permite empezar fácil. Y comparándolo con otras opciones, es mucho más ligero, permitiéndote integrar tus propias opciones para diferentes partes del proyecto. Si tu proyecto es muy poco común o muy especializado, Flask es la mejor opción.\nAquí un pequeño ejemplo de cómo se empiza con Flask (sacado de su documentación en su mayoría)\nfrom flask import Flask, jsonify app = Flask(__name__) @app.route(\u0026#34;/\u0026#34;) def hello(): return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Hello World!\u0026#34;}) Así es: puedes empezar con un solo archivo, Flask hizo todo por ti.\nFlask también tiene bastantes módulos que te ayudan a desarrollar funcionalidades más rápido y con poco código.\nSi quieres aprender más aquí tienes algunos recursos:\nCreando una API y aplicación web con Flask\nDiseñando APIs con Flask\nConstruir una API rest con Flask\nMás adelante tendremos nuestro propio post 😉.\nCuándo usarlo: Personalmente lo uso para proyectos pequeños o medianos que sé que no crecerán demasiado en características en el mediano plazo. Si tienes que hacer cosas complicadas, Flask requiere bastante experiencia técnia y de arquitectura para que no se te vaya de las manos el proyecto, su flexibilidad puede trabajar en tu contra en estos casos.\nDjango y Django Rest Framework # Django es un framework MVT (Model-View-Template, su propia variante del MVC) para desarrollar proyectos web robustos de manera rápida.\nDjango provee:\nUn sistema de templating propio Un ORM (Object Relational Mapper – una capa de abstracción de la base de datos) Ruteo robusto Sistema de configuración robusto y adaptable Interfaz de administración automática Administración de usuarios \u0026hellip;y muchas otras cosas más. Como verás es mucho más robusto(viene por default con más cosas) que los otros dos, pero también es el que tiene la mayor curva de aprendizaje. Si encuentras algo para lo que no esté preparado Django o DRF éste es el caso en el que se requiere más experiencia técnica para modificarlo.\nDjango posee muchísimos paquetes para extenderlo en funciones y uno de los más famosos es el Django REST Framework (DRF a partir de ahora), que provee todas las funcionalidades que te imagines para desarrollar una API de manera sencilla y con pocas líneas de código.\nEl DRF permite crear endpoints a partir de modelos, relaciones entre modelos, endpoints customizados basados en clases y un montón de cosas más. Se enfoca en crear API\u0026rsquo;s navegables.\nAdemás nos da una interfaz para para pruebas desde el navegador web con todas las facilidades del mundo.\nPuedes pensar en Django y DRF como una navaja suiza con todo lo que necesitas para desarrollar una API un poco más compleja de manera rápida.\nNo pondremos el ejemplo de código aquí, porque en este caso el código se reparte entre varios archivos, pero te compartimos los siguientes recursos por si quieres irte por este camino y sients que es lo que necesitas:\n¿Qué es Django? - ESte es uno de los mejores tutoriales de Django en internet, muy completo, así que vale la pena que lo sigas si quieres aprenderlo.\nIntroducción a Django REST Framework - Este post lo puedes seguir una vez que tengas una comprensión básica de Django.\nCuándo usarlo: Django es mi elección para proyectos que se que pueden requerir caracterísitcas enterprise, pueden crecer en funcionalidades en el mediano plazo y estas funcionalidades no están demasiado fuera de lo común. Si quieres desarrollar algo rápidamente en estas condiciones, no hay nada que pensar: usa Django, con él (después de la curva de aprendizaje), estarás haciendo cosas medianamente complejas en muy poco tiempo, además de que su inmensa cantidad de módulos para hacer muchísimas cosas sin tanto trabajo te facilitará la vida.\nConclusión # Algo que hay que tener en mente siempre es que se debe de elegir la herramienta adecuada para el trabajo a la mano. En los tres casos de las herramientas propuestas anteriormente tienes que analizar muy bien tus necesidades antes de decidirte por una, pero incluso podrías usar una para una etapa del proyecto y cambiarla en una fase posterior.\nEsperamos que esta pequeña guía acerca de las opciones para elegir la mejor herramienta para crear tu API con flask te sea útil, y si tienes alguna opinión/experiencia diferente es bienvenida en los comentarios.\n","date":"12 marzo 2019","externalUrl":null,"permalink":"/2019/03/12/tres-formas-de-crear-apis-con-python/","section":"Posts","summary":"\u003cp\u003eEs una tarea común para un desarrollador el diseñar e implementar una API web. Veremos tres herramientas para desarrollar tu API, de lo más sencillo a lo más completo: Hug, Flask y Django Rest Framework.\u003c/p\u003e","title":"Tres formas de crear API's con Python","type":"posts"},{"content":"","date":"9 marzo 2019","externalUrl":null,"permalink":"/tags/deploy/","section":"Tags","summary":"","title":"Deploy","type":"tags"},{"content":"","date":"9 marzo 2019","externalUrl":null,"permalink":"/tags/despliegue/","section":"Tags","summary":"","title":"Despliegue","type":"tags"},{"content":"","date":"9 marzo 2019","externalUrl":null,"permalink":"/tags/django/","section":"Tags","summary":"","title":"Django","type":"tags"},{"content":"","date":"9 marzo 2019","externalUrl":null,"permalink":"/tags/producci%C3%B3n/","section":"Tags","summary":"","title":"Producción","type":"tags"},{"content":" Para no salir herido al combinar desarrollo y producción en Django. # Se usará Django \u0026gt;= 2.0\nSe usará Python \u0026gt;= 3.6\nProblemática # Mientras desarrollaba en Django, me encontré con un problema, requería hacer múltiples pruebas con el ORM para generar consultas complejas a base de datos. Para hacer la prueba se ejecuta:\n\u0026gt; python manage.py shell Con lo que se abrirá una consola de Python, en dicha consola se puede importar un modelo y con ese modelo hacer las pruebas requeridas.\n\u0026gt; from blog.models import Post \u0026gt; all_posts = Post.objects.all() Todo opera bien hasta que debemos importar múltiples modelos, al modificar un modelo se debe detener la consola Ctrl+C y ejecutarla de nueva cuenta, y de nueva cuenta cargar todos los modelos.\nA fin de no perder tiempo cargando los modelos en cada detención de la consola se opta por usar una herramienta llamada django-extensions\nLa instalo en mi proyecto usando:\n\u0026gt; pip install django-extensions y agregándola a mis apps en el archivo settings.py\nINSTALLED_APPS = ( ... \u0026#39;django_extensions\u0026#39;, ) Hecho eso, puedo ejecutar una consola donde se cargan ya todos los modelos listos para hacer consultas a la base de datos. Traducción: ahorramos mucho tiempo.\n\u0026gt; python manage.py shell_plus El siguiente problema que hallé es que esta herramienta no debe estar en producción, solo es para propósitos de desarrollo.\nPero, ¿Qué hacer?, ¿La agrego y quito de INSTALLED_APPS manualmente a cada push que haga en mi repositorio?, esa estrategia es muy propensa al error y a la hora de desplegar podemos tener un error por no tener instalada la herramienta.\nLa forma que me ha gustado más hasta ahora es hacer uso del paquete sys de Python, con el que puedo con uno de sus módulos leer los argumentos con los que se ejecuta la aplicación de Django.\nVámos como queda el archivo settings.py\nimport sys . . . DEBUG_COMMAND = set(\u0026#39;shell_plus\u0026#39;, \u0026#39;shell\u0026#39;, \u0026#39;runserver\u0026#39;) DJANGO_RUN_ARGS = set(sys.argv) if len(DJANGO_RUN_ARGS.intersection(DEBUG_COMMAND))\u0026gt;0: # Code executed in develop time INSTALLED_APPS.append(\u0026#39;django_extensions\u0026#39;) En DEBUG_COMMAND se definen los comandos que se ejecutan solo en desarrollo, hay que recordar que runserver se agrega también en el set dado que NO se debe pasar a producción la ejecución de Django por medio de dicho mecanismo, para producción lo correcto es pasarlo con un WSGI server diseñado para producción como guinicorn.\nDJANGO_RUN_ARGS es la variable que guardará los argumentos con los que se ejecuta Django.\nAmbas variables son un set, así es sencillo comprobar que argumentos serán catalogados como de desarrollo por medio de la intersección de ambas variables, el que haya elementos en la intersección implica que por lo menos uno de los argumentos se cataloga como de desarrollo.\nY bueno, solo falta agregar que después de la condicional se pueden agregar tanto código como se requiera.\nNo olvides comentar tu experiencia usando esta estrategia para manejar desarrollo y producción en Django.\n","date":"9 marzo 2019","externalUrl":null,"permalink":"/2019/03/09/producci%C3%B3n-y-desarollo-en-django/","section":"Posts","summary":"\u003ch2 class=\"relative group\"\u003ePara no salir herido al combinar desarrollo y producción en Django.\n    \u003cdiv id=\"para-no-salir-herido-al-combinar-desarrollo-y-producción-en-django\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#para-no-salir-herido-al-combinar-desarrollo-y-producci%c3%b3n-en-django\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSe usará Django \u0026gt;= 2.0\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSe usará Python \u0026gt;= 3.6\u003c/p\u003e","title":"Producción y desarollo en Django","type":"posts"},{"content":"¿Quieres empezar a escribir? Contribuye con tus artículos a la comunidad. En este post encontrarás una guía detallada para la instalación del repositorio y ver tus posts de manera local, así como la convenciones que seguimos antes de publicar un post. Como verás, todo está por desarrolladores y para desarrolladores.\nEl único paso # Si no quieres complicarte mucho la vida, has un fork del repositorio, y crea un archivo nombrado como YYYY-MM-DD-tu-titulo-como-slug.md en la carpeta _posts. Una vez que lo tengas listo, has un Pull Request y nosotros lo revisaremos, te daremos nuestros comentarios sobre el contenido, gramática, estilo, etc. y si lo aprobamos mezclaremos tu branch en el master para que tu artículo aparezca publicado.\nPero puede que quieras correr el sitio en tu local, ver tu artículo como un borrador antes de publicarlo y probar diferentes imágenes, para eso necesitas instalar el repositorio localmente. A continuación hablaremos de eso.\nAlgunos requisitos para aprobar tu artículo:\nDebe ser un tema relacionado con desarrollo, útil para la comunidad en general No se aceptan artículos de opinión Ortográfica y gramaticalmente correcto Tu estilo es ameno, amigable e invita a la gente seguirte leyendo Algunos puntos extra:\nUna buena imagen como cabecera (las imágenes generalmente se hostean externamente, puedes usar un serivicio como Cloudinary), pero también podrías subirla a la carpeta assets/images Tu escritura es entretenida Es un tema del que se ha escrito poco Gracias por contribuir a que la comunidad sea más fuerte.\n","date":"3 marzo 2019","externalUrl":null,"permalink":"/2019/03/03/la-forma-f%C3%A1cil-de-colaborar-en-the-dojo-mx-blog/","section":"Posts","summary":"\u003cp\u003e¿Quieres empezar a escribir? Contribuye con tus artículos a la comunidad. En este post encontrarás una guía detallada para la instalación del repositorio y ver tus posts de manera local, así como la convenciones que seguimos antes de publicar un post.\nComo verás, todo está por desarrolladores y para desarrolladores.\u003c/p\u003e","title":"La forma fácil de colaborar en The Dojo MX Blog","type":"posts"},{"content":"","date":"23 febrero 2019","externalUrl":null,"permalink":"/tags/patrones/","section":"Tags","summary":"","title":"\"Patrones","type":"tags"},{"content":"","date":"23 febrero 2019","externalUrl":null,"permalink":"/tags/de/","section":"Tags","summary":"","title":"De","type":"tags"},{"content":"","date":"23 febrero 2019","externalUrl":null,"permalink":"/tags/design-patterns/","section":"Tags","summary":"","title":"Design-Patterns","type":"tags"},{"content":"","date":"23 febrero 2019","externalUrl":null,"permalink":"/tags/dise%C3%B1o/","section":"Tags","summary":"","title":"Diseño\"","type":"tags"},{"content":"","date":"23 febrero 2019","externalUrl":null,"permalink":"/tags/gof/","section":"Tags","summary":"","title":"Gof","type":"tags"},{"content":"Parte del conocimiento fundamental de un desarrollador profesional de software son los Patrones de diseño (Design Patterns). En este artículo explicamos de manera concisa:\nQué son De dónde vienen Por qué deberías aprender algunos cuantos Por dónde empezar Qué son los patrones de diseño # \u0026ldquo;No hay nada nuevo bajo el sol\u0026rdquo;: es una conocida frase que quiere decir que gran parte de los problemas que la humanidad se ha enfrentado se siguen repitiendo vez tras vez. Aprovechando este conocimiento, los patrones de diseño se pueden definir como:\nSoluciones estándar a problemas conocidos (que se repiten) en el desarrollo de software\nEs decir, son soluciones que sabemos que funcionan para problemas que sabemos que existen desde antes que nosotros los encontráramos. Así de sencillo.\nComposición # Los patrones de diseño de software, se componen de cuatro partes:\nNombre. Permite referirte al patrón unívocamente y hablar con otras personas sobre esta solución específica sin tener que explicarla. Problema. La situación que resuelve el patrón específico. Incluye el contexto y los síntomas que se tienen que dar para usar este patrón. Solución. Describe todas las partes necesarias, su estructura y relacions que resuelven el problema sin hablar de una implementación específica, ya que un patrón se debe poder aplicar y adaptar a muchas situaciones diferentes. Consecuencias. Los resultados de aplicar este patrón tanto negativos como positivos, con el fin de poder evaluar si es conveniente usarlo. Historia # Como muchas otras cosas en la joven industria del desarrollo del software, el concepto de patrones de diseño fue adaptado de otro campo: la arquitectura, o el diseño de espacios físicos habitables.\nEl arquitecto Christopher Alexander se dio cuenta que al diseñar edificios y ciudades era común encontrarse con situaciones que se repetían una y otra vez. Así que empezó a crear una colección de estos problemas comunes y las soluciones que le habían funcionado, con lo que empezó a crear un \u0026ldquo;lenguaje de patrones\u0026rdquo;. Aquellas personas con las que compartía el conocimiento del problema y de la solución podían referirse a estos por los nuevos nombres sin tener que explicarlo todo de nuevo.\nEn su libro A Pattern Language (1977) puso por escrito una serie de patrones para situaciones de diseño arquitectónico para casas y edificios.\nEsto inspiró a Kent Beck y otras personas para usar y hablar de soluciones parecidas para el desarrollo de software, aproximadamente 10 años después de la publicación del libro.\nErich Gamma y otros tres autores conocidos como la \u0026ldquo;Banda de los cuatro\u0026rdquo;(Gang of Four o GoF) publicaron un libro llamado Design Patterns: Elements of reusable Object-Oriented Software que popularizó el término \u0026ldquo;Patrones de diseño\u0026rdquo; y mostró 23 patrones enfocados en la programación de sistemas y divididos en 3 categorías:\nCreacionales: Se enfocan en la forma de crear nuevos objetos Estructurales: Establecen la manera de relacionar objetos y clases (composición y herencia) De comportamiento: Se centran principalmente entre la comunicación entre objetos. Este es un libro obligado como referencia si quieres mejorar tus habilidades de desarrollo y diseño de software.\nImportancia # Conocer y usar los patrones de diseño nos da varias ventajas importantes:\nPermite que usemos soluciones probadas (o evitemos soluciones refutadas) por el tiempo, en muchos proyectos y muchas otras personas y evitemos otras que no han funcionado tan bien. Nos dan un lenguaje común que otras personas, que también entienden este \u0026ldquo;diccionario\u0026rdquo;, pueden comprender sin la necesidad de una explicación detallada. Esto es de gran importancia porque gran parte del proceso de desarrollo es entender el código que otros escribieron. Si entiendes los patrones de diseño más comunes, será mucho más fácil que entiendas el código y la arquitectura de otros programas que los usan. Nos dan la flexibilidad de construir sobre ellos. El que exista patrón que seguir no significa que siempre se tenga que implementar a la perfección, sin cambios. Estos patrones dan la capacidad de aprovechar las características que sirven para nuestro problema específico y agregar nuevas para adaptarlo completamente a nuestro problema. Pueden reducir la complejidad de un proyecto si son bien usados. En contra de los patrones de diseño # Todo en la vida y sobre todo en el desarrollo de software representa un intercambio de valor. Damos algo a cambio de otro bien, y nos corresponde personalmente evaluar si una herramienta en una situación determinada es conveniente. Deberíamos evitar usar algo simplemente porque los demás dicen que lo debemos usar o es lo más utilizado por todos. Además tenemos que evitar caer en lo que Cal Newport llama la mentalidad de \u0026ldquo;el mínimo beneficio\u0026rdquo;, aquella en la que justificamos el uso de algo sólo porque nos da un pequeño beneficio, sin considerar lo que damos para obtenerlo.\nDado el sermón anterior, pensemos en los contras de los patrones de diseño:\nLa urgencia de aplicar nuestro recién adquirido conocimiento nos puede llevar a buscar aplicar soluciones complicadas en donde no pertenecen. Algunos patrones han probado con el tiempo en realidad ser anti-patrones (te veo a ti singleton), soluciones que no se deberían aplicar nunca, o que es extremadamente difícil justificar su uso. A veces, la necesidad de aplicarlos revela el mal diseño de alguna otra parte de nuestro sistema: desde la estructura de nuestro sistema, hasta el lenguaje y la elección de otras herramientas. Los patrones de diseño tradicionales están casados con la programación orientada a objetos, que no siempre es la mejor para resolver el problema, aunque es lo más usado actualmente. Hay toda una horda de programadores respetados que han hablado en contra de los patrones de diseño (como Peter Norvig, para quien los patrones de diseño son flaquezas de tu lenguaje).\nPor dónde empezar # Habiendo hablado de las ventajas y advertencias, ¿por dónde puedes empezar, si te interesa?\nLos siguientes recursos son útiles:\nDesign Patters: Elements of reusable Object-Oriented Software. El libro de referencia de los patrones de diseño clásicos. También está en español, aunque es un poco difícil de conseguir.\nPara Python específicamente: Python Patterns y\nPython 3 Patterns\nHead First Design Patterns. A este libro se refieren como una guía con bromillas tontas y super pedagógica.\nPuedes encontrar una referencia completa de los patrones de diseño en wikipedia.\nEn este blog, publicaremos artículos dedicados a patrones de diseño, explicando cómo los hemos usado en nuestro trabajo diario, en los que explicaremos:\nEl patrón Cómo reconocer una situación para usarlo Su implementación (normalmente en Python) Otras maneras de aplicarlo Las desventajas de este patrón Conclusión # Un patrón de diseño es una solución \u0026ldquo;probada\u0026rdquo; aplicada a un problema conocido y repetido en diferentes circunstancias. A veces pueden fallar.\nConocer los patrones de diseño definitivamente te hará un mejor programador por su extendido uso. Aplicarlos puede y normalmente mejorará la arquitectura de tus programas y proyectos, pero hay que ser cautelosos. Aprender cómo se aplican es una buena inversión de tiempo, que te puede devolver grandes beneficios.\nGracias por leernos y no dudes en dejarnos tus comentarios.\n","date":"23 febrero 2019","externalUrl":null,"permalink":"/2019/02/23/patrones-de-dise%C3%B1o-qu%C3%A9-son-y-cu%C3%A1ndo-usarlos/","section":"Posts","summary":"\u003cp\u003eParte del conocimiento fundamental de un desarrollador profesional de software son los \u003cem\u003ePatrones de diseño\u003c/em\u003e (Design Patterns). En este artículo explicamos de manera concisa:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eQué son\u003c/li\u003e\n\u003cli\u003eDe dónde vienen\u003c/li\u003e\n\u003cli\u003ePor qué deberías aprender algunos cuantos\u003c/li\u003e\n\u003cli\u003ePor dónde empezar\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 class=\"relative group\"\u003eQué son los patrones de diseño\n    \u003cdiv id=\"qué-son-los-patrones-de-diseño\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#qu%c3%a9-son-los-patrones-de-dise%c3%b1o\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003e\u0026ldquo;No hay nada nuevo bajo el sol\u0026rdquo;: es una conocida frase que quiere decir que gran parte de los\nproblemas que la humanidad se ha enfrentado se siguen repitiendo vez tras vez. Aprovechando este conocimiento, los patrones de diseño se pueden definir como:\u003c/p\u003e","title":"Patrones de diseño: qué son y cuándo usarlos","type":"posts"},{"content":"","date":"21 febrero 2019","externalUrl":null,"permalink":"/tags/chain-of-responsibility/","section":"Tags","summary":"","title":"Chain-of-Responsibility","type":"tags"},{"content":" Propósito # Asegurar el bajo acoplamiento entre un request y su receiver dando a múltiples objetos oportunidad de manejar el request\nHace unas semanas me enfrenté a un tema de procesar un mensaje de un usuario y darle tratamiento por medio de un algoritmo de Natrual Language Processing. Antes de pasar el mensaje por el set de algoritmos apropiados hay que darle una serie de tratamientos previos:\nEliminar los acentos y solo dejar en ASCII el mensaje. Pasar el mensaje a lowercase. A primera luz, un código que puede fácilmente satisfacer es:\nmessage = \u0026#34;Dios bendiga a los héroes que nos dieron el internet.\u0026#34; message = message.lower() message = message.replace(\u0026#34;á\u0026#34;,\u0026#34;a\u0026#34;).replace(\u0026#34;é\u0026#34;,\u0026#34;e\u0026#34;) \\ .replace(\u0026#34;í\u0026#34;,\u0026#34;i\u0026#34;).replace(\u0026#34;ó\u0026#34;,\u0026#34;o\u0026#34;).replace(\u0026#34;ú\u0026#34;,\u0026#34;u\u0026#34;) print(message) # dios bendiga a los heroes que nos dieron el internet. Funcionó, se cumplió el objetivo.\nEl problema sobrevino en el momento que los algoritmos posteriores requieren más modificaciones en la cadena original. Poco a poco se fue agregando y agregando código para tareas como eliminar emojis, eliminar signos de puntuación, contraer palabras como hooooooola en hola y en el futuro no se sabe que más cosas habrá que hacer a la cadena original, pueden ser cosas tan diversas como \u0026ldquo;A cada cadena que se procese quiero que se quede un historial de la cadena original\u0026rdquo;, en ese momento hay que ir a reescribir código quebrantando el principio open/closed \u0026ldquo;software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\u0026rdquo;.\nSolución # El patrón de diseño Chain of responsibility como premisa principal es que más de una entidad de software (clase y/o función) pueda atender una petición. Dichas entidades pueden ser conocidas y de hecho se acaban implementando, pero también pueden ser desconocidas y esas no las podemos implementar pero debemos ser capaces de implementarlas en un futuro.\nPero, si el código anterior es muy sencillo, no veo caso de hacerlo complejo; a medida que los requerimientos van cambiando en el tiempo es muy probable que ese código se acabe agrupando en una función y esa función no hará más que crecer y entre más lo haga perderá el foco y se convertirá en una función que hará de todo, no cumplirá con otro principio (single responsibility) una entidad debe hacer solo una cosa y hacerla bien, la función además de escribir en disco tiene que pasar la frase a minúsculas, reemplazar caracteres no ASCII con caracteres ASCII por mencionar algo. El partir una gran función (gran ~= muchas responsabilidades) en muchas más pequeñas facilita la escritura de test unitarios y propicia a la re usabilidad de esa función en distintas partes de nuestro proyecto principalmente.\nEn este patrón la petición (request) es mandada de entidad en entidad (cada entidad es un eslabón de la cadena o handler), cada entidad maneja la petición y la pasa al siguiente eslabón hasta que se terminen los eslabones de la cadena o uno de ellos decida que hay que regresar un valor.\nSiguiendo con el problema original, el código propuesto es el siguiente (aquí uno en Java):\ndef to_lower(message=\u0026#34;\u0026#34;): if not isinstance(message,str): raise ValueError(\u0026#34;Message is not a string\u0026#34;) return message.strip().lower() def to_ascii(message): if not isinstance(message,str): raise ValueError(\u0026#34;Message is not a string\u0026#34;) message = message.replace(\u0026#34;á\u0026#34;,\u0026#34;a\u0026#34;).replace(\u0026#34;é\u0026#34;,\u0026#34;e\u0026#34;).replace(\u0026#34;í\u0026#34;,\u0026#34;i\u0026#34;).replace(\u0026#34;ó\u0026#34;,\u0026#34;o\u0026#34;).replace(\u0026#34;ú\u0026#34;,\u0026#34;u\u0026#34;) return message def to_disk(message): FILENAME = \u0026#34;historial.log\u0026#34; if not isinstance(message,str): raise ValueError(\u0026#34;Message is not a string\u0026#34;) with open(FILENAME,\u0026#34;a\u0026#34;,encoding=\u0026#34;UTF-8\u0026#34;) as fp: fp.write(f\u0026#34;{message}\\n\u0026#34;) return message def remove_all_punctuation(message): #all code to remove punctuation marks return message class Pipe: def __init__(self,message): self._message = message self.processors = [] def add_process(self,process_function): self.processors.append(process_function) def run(self): for process in self.processors: self._message = process(self._message) return self._message pipe=Pipe(\u0026#34;Dios bendiga a los héroes que nos dieron el internet.\u0026#34;) pipe.add_process(to_disk) pipe.add_process(to_lower) pipe.add_process(to_ascii) pipe.add_process(remove_all_punctuation) new_message=pipe.run() print(new_message) El código anterior es un código más profesional, más fácil de mantener ya que cumplimos con el principio open/closed y de paso de responsabilidad única.\nPodemos ir agregando funciones de procesamiento de manera más legible, también podemos quitarlas a voluntad dado que el nivel de acoplamiento es muy bajo. A todo ésto hay que añadir la ventaja de facilidad al escribir test unitarios que dan pie para el CI/CD.\nSe puede pensar al inicio que es una sobre-ingeniería para algo tan sencillo, pero los negocios son tan cambiantes en el tiempo que se vuelve un poco ingenuo pensar que lo que escribamos nunca lo tendremos que modificar, ¿Por qué no diseñar software que pueda ser modificable en el ahora y el futuro?. Este tema de los patrones de diseño es un tema muy extenso que poco a poco iremos cubriendo con entradas en este blog dando ejemplos sencillos como el anterior.\nLo importante es quedarse con el concepto de qué es lo que hace el patrón y no con la implementación como tal del código, en Java el código anterior puede ser muy diferente, sin embargo cumple el patrón. Tuve conciencia de esto leyendo que en un principio, en los años dorados de C, este patrón se implementaba con listas enlazadas,a su vez implementadas con apuntadores.\nSaludos y no dudes en ejercer tu derecho de réplica :) , discutamos un poco al respecto :D.\n","date":"21 febrero 2019","externalUrl":null,"permalink":"/2019/02/21/patr%C3%B3n-de-dise%C3%B1o-cadena-de-responsabilidad/","section":"Posts","summary":"\u003ch4 class=\"relative group\"\u003ePropósito\n    \u003cdiv id=\"propósito\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#prop%c3%b3sito\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAsegurar el bajo acoplamiento entre un \u003cem\u003erequest\u003c/em\u003e y su \u003cem\u003ereceiver\u003c/em\u003e dando a múltiples objetos oportunidad de manejar el \u003cem\u003erequest\u003c/em\u003e\u003c/p\u003e","title":"Patrón de diseño: Cadena de responsabilidad","type":"posts"},{"content":"","date":"21 febrero 2019","externalUrl":null,"permalink":"/tags/patrones/","section":"Tags","summary":"","title":"Patrones","type":"tags"},{"content":"Este es el primer post, esperamos que de muchos, del blog de The Dojo MX.\nEl objetivo de este blog es compartir información útil para los desarrolladores y contribuir al avance y desarrollo de los que nos dedicamos a hacer productos digitales.\nTemática y enfoque # Se tratarán todos los temas del amplio espectro que abarca desarrollar un producto de software, con un enfoque educativo. Algunos ejemplos de los tópicos a tratar son:\nDesarrollo web front y backend Lenguajes de programación en general Mejores prácticas de desarrollo Inteligencia Artificial Ciencias de la computación teóricas Algoritmia Ingeniería de software Open Source Contribuciones # Este es un blog Open Source. Está construido sobre GitHub Pages con Jekyll (tendremos que actualizar esto si un día cambia), lo cuál te permite contribuir con el simple hecho de hacer un PR si crees que podemos cambiar algo en la estructura del sitio o si quieres escribir un post.0\nEn uno de los siguientes posts daremos una lista de pasos detallados de cómo hacer esto, junto con los lineamientos para aceptar un post.\nSi tienes ideas o peticiones de temas que deberíamos tratar, puedes abrir un issue en GitHub.\nTambién puedes dejar algún comentario para dar ideas.\n¡Nos leemos pronto!\n","date":"28 octubre 2018","externalUrl":null,"permalink":"/2018/10/28/bienvenidos-al-blog-de-the-dojo-mx/","section":"Posts","summary":"\u003cp\u003eEste es el primer post, esperamos que de muchos, del blog de The Dojo MX.\u003c/p\u003e\n\u003cp\u003eEl objetivo de este blog es compartir información útil para los desarrolladores\ny contribuir al avance y desarrollo de los que nos dedicamos a hacer productos digitales.\u003c/p\u003e","title":"Bienvenidos al Blog de The Dojo MX","type":"posts"},{"content":"","date":"28 octubre 2018","externalUrl":null,"permalink":"/tags/opensource/","section":"Tags","summary":"","title":"Opensource","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]