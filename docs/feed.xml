<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://blog.thedojo.mx/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.thedojo.mx/" rel="alternate" type="text/html" /><updated>2025-08-19T00:06:24-06:00</updated><id>https://blog.thedojo.mx/feed.xml</id><title type="html">The Dojo MX Blog</title><author><name>Héctor Patricio</name><uri>https://github.com/hectorip</uri></author><entry><title type="html">Zig: un lenguaje que quiere reemplazar al poderoso C</title><link href="https://blog.thedojo.mx/2025/08/19/zig-un-lenguaje-que-quiere-reemplazar-al-poderoso-c.html" rel="alternate" type="text/html" title="Zig: un lenguaje que quiere reemplazar al poderoso C" /><published>2025-08-19T00:00:00-06:00</published><updated>2025-08-19T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2025/08/19/zig-un-lenguaje-que-quiere-reemplazar-al-poderoso-c</id><content type="html" xml:base="https://blog.thedojo.mx/2025/08/19/zig-un-lenguaje-que-quiere-reemplazar-al-poderoso-c.html"><![CDATA[<p>Recientemente hemos visto una ola de lenguajes listos para destronar
a los lenguajes de programación que forman la base de casi toda nuestra
computación actual: C y C++. Lenguajes como Rust y Go quieren reemplazarlos,
pero tenemos a otro competidor que apunta directamente hacia C y parece
que se está acercando aunque no tiene todavía una versión completamente estable.</p>

<p>En este artículo vamos a hablar de las características de Zig y cómo es que
planea reemplazar a C.</p>

<h2 id="las-características-de-zig">Las características de Zig</h2>

<p><a href="https://ziglang.org/">Zig</a> es actualmente desarrollado por la Zig Software
Foundation, una organización sin fines de lucro que básicamente fue creada para
seguir desarrollando el lenguaje. Pero <a href="https://andrewkelley.me/"><strong>Andrew Kelley</strong></a>,
lo empezó en 2015 con la idea de retar la forma en la que hacemos software.</p>

<p>Kelley es un programador con experiencia en C principalmente y mientras trabajaba en su
proyecto “Genesis Digital Audio Workstation” se decidió para crear Zig.
En sus propias palabras: <em>“mi meta es crear un lenguaje más pragmático que C.”</em></p>

<p>Algunas de las características que presenta en el artículo en el que
habla por primera vez de Zig son:</p>

<ol>
  <li><strong>Pragmatismo</strong>. Ser pragmático es lo mismo que ser práctico. Zig es un lenguaje
que se enfoca en resolver problemas reales y no en ser un lenguaje teórico, y quiere
ayudarte a lograr lo que necesitas hacer mejor que otros lenguajes.</li>
  <li><strong>Óptimo</strong>. Debe de ser iguale de rápido o más que C y más fácil de escribir.</li>
  <li><strong>Seguridad en memoria</strong>. Es la segunda característica más importante del lenguaje, Kelley
  dice que va en el asiento del copiloto.</li>
  <li><strong>Legible</strong>. zig debería evitar la sintaxis compleja y tener una forma canónica de hacer las cosas
  dando como resultado un código que sea fácil de leer, aunque te tengas que esforzar un poco para escribirlo.</li>
</ol>

<h2 id="algunas-decisiones-de-diseño">Algunas decisiones de diseño</h2>

<p>Se dice que los lenguajes de programación están creados por los miedos de sus diseñadores.
Por ejemplo, si alguien quiere hacer un nuevo lenguaje viniendo de lenguajes que
tardan mucho en compilar, por ejemplo C++, va a intentar hacer un lenguaje
que compile rápido, como fue le caso de Go.</p>

<p>Veamos algunas decisiones de diseño de Zig.</p>

<h3 id="interoperabilidad-completa-con-c">Interoperabilidad completa con C</h3>

<p>C tiene una dominación histórica en el mundo de la programación de sistemas. Muchos de los
sistemas importantes están escritos en C. Así es que Zig tiene como una decisón de diseño
crear programas que puedan ser usados desde C o al revés. Así que Zig es compatible con la
C ABI.</p>

<p>La <strong>C ABI</strong> (Application Binary Interface) es un conjunto de convenciones y reglas que
define cómo los programas compilados en C interactúan a nivel de código máquina.</p>

<h3 id="uso-de-tipos-opcionales">Uso de tipos opcionales</h3>

<p>El manejo de valores vacíos o nulos es uno de los grandes problemas en todo el desarrollo de
software. Así que Zig ha elegido usar tipos opcionales, es decir, valores que desde el
sistemas de tipos declaras que pueden contener un valor o no. Así el compilador te puede
ayudar a no dispararte en el pie dejando como nulo o aceptando un nulo en una variable donde
siempre debería haber un valor. Además, te puede ayudar a verificar que estás considerando
todos los casos posibles cuando tienes variables opcionales.</p>

<h3 id="manejo-de-errores">Manejo de errores</h3>

<p>Zig utiliza tipos de datos primitivos para manejar errores. Estos son los Error Sets y
Error Unions. Con estos dos tipos de datos puedes crear funciones que devuelvan un error
y manejarlo de forma más elegante.</p>

<h3 id="otras-características">Otras características</h3>

<p>Zig tiene otras características muy interesantes nacidas directamente del uso que su
principal creador, Andrew Kelley, hizo de C desde hace mucho tiempo. Por ejemplo tiene
características para evitar el preprocesador de C, por ejemplo, sintaxis directa para
compilación condicional.</p>

<h2 id="algunos-proyectos-importantes-en-zig">Algunos proyectos importantes en Zig</h2>

<p>Aunque todavía no tenemos una versión 100% estable de Zig, ya tenemos proyectos que
están haciendo olas en el mundo de la programación programados en Zig. Hablemos de
algunos de ellos:</p>

<ul>
  <li>
    <p><a href="https://bun.sh/">Bun</a>: Bun es un nuevo runtime de JavaScript que caracteriza
por su gran velocidad de ejecución. Aunque no tiene todas las características de
Node.js todavía, se lo lleva por mucho en rendimiento.</p>
  </li>
  <li>
    <p><a href="https://github.com/tigerbeetle/tigerbeetle">TigerBeetle</a>: TigerBeetle es una
base de datos financiera distribuida. Como te imaginarás, todo aquello que se quiera
usar en un entorno financiero serio debe ofrecer características fuertes de rendimiento
y seguridad.</p>
  </li>
  <li>
    <p><a href="https://github.com/ghostty-org/ghostty">Ghostty</a>: Ghostty es un emulador de terminal
escrito por el mismo creador de Terraform, Mitchell Hashimoto, que está intentando hacer
todas las cosas bien.</p>
  </li>
</ul>

<h2 id="conclusión">Conclusión</h2>

<p>Si estás metido en el desarrollo de sistemas, sin duda Zig es un lenguaje que vale la pena
voltear a ver, pero también si quieres aprender más sobre desarrollo de software a bajo nivel
con ideas modernas.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="zig" /><category term="zig-lang" /><category term="c" /><category term="c-lang" /><summary type="html"><![CDATA[Zig es un lenguaje prometedor que quiere reemplazar a C y competir con Rust por ser el nuevo lenguaje de sistemas. Hablemos de sus promesas y características.]]></summary></entry><entry><title type="html">¿Qué son los agentes inteligentes?</title><link href="https://blog.thedojo.mx/2025/05/16/que-son-los-agentes-inteligentes.html" rel="alternate" type="text/html" title="¿Qué son los agentes inteligentes?" /><published>2025-05-16T00:00:00-06:00</published><updated>2025-05-16T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2025/05/16/que-son-los-agentes-inteligentes</id><content type="html" xml:base="https://blog.thedojo.mx/2025/05/16/que-son-los-agentes-inteligentes.html"><![CDATA[<p>Con la llegada de los LLM’s, el término “agente” empezó a ganar más popularidad y
lo oímos por todos lados. En este artículo vamos a hablar de qué son, para entenderlo
lo mejor posible y no dejarnos llevar por el hype.</p>

<h2 id="qué-es-un-agente">¿Qué es un agente?</h2>

<p>Este es un concepto que ha sido muy difícil de definir y por muchaos lados encuentras definiciones diferentes.
En ester artículo vamos a dar una definicón sencilla y que nos parece práctica y que captura la idea principal
de toda esta ola de crear programas que puedan comportarse como agentes.</p>

<p>Primeo vamos a la etimología de la palabra: viene del latín “agere” que significa “hacer”, “actuar”, “mover”, entre
otros significados. En pocas palabras, un agente es cualquier entidad que puede tomar decisiones y actuar.
Esta definición confiere bastante flexibilidad, pero conlleva en el fondo un idea que para mi es
la característica principal: la <strong>autonomía</strong>.</p>

<p>En el caso de sistemas de software, vamos a definir a un agente como un <strong>programa</strong> que tiene un <strong>objetivo</strong> y para
lograrlo puede tomar decisiones <strong>autónomas</strong>. Estas decisiones pueden ser tomadas basadas en su <strong>percepción</strong>
del entorno, en su estado interno (incluida la memoria) o en una combinación de estas cosas. Finalmente un agente
puede <strong>actuar</strong> para modificar su contexto y lograr su objetivo. Una característica que no siempre se cumple
pero que a veces está implícita es que el agente está funcionando de manera <em>constante</em>, o sea que no es
un programa que prendas y apagues, sino que está corriendo todo el tiempo.</p>

<p>En esta definición sencilla, encontramos varias partes clave que debe tener un programa para ser considerado un agente:</p>

<ul>
  <li><strong>Objetivo</strong>: El agente debe tener un objetivo claro que quiere lograr y por lo tanto una manera de medir su éxito.</li>
  <li><strong>Autonomía</strong>: El agente debe ser capaz de tomar decisiones para los diferentes casos que se le presenten.</li>
  <li><strong>Percepción</strong>: Aunque no es completamente necesario, muchos agentes tienen la capacidad de leer su entorno para
tomar mejores decisiones.</li>
  <li><strong>Actuación</strong>: Los agentes pueden ser capaces de modificar su entorno, de hecho, esta, junto con el objetivo
es lo que le da sentido al concepto de agente.</li>
  <li><strong>Estado interno</strong>: Debido a que las tareas que realizan los agentes pueden ser complejas, muchas veces es 
necesario mantener un estado interno que les permita ejecutar un plan de múltiples pasos, y para eso necesitan un
registro interno. Este estado interno puede incluir diferentes tipos de memorias: a corto plazo, a largo plazo, cachés, etc.</li>
</ul>

<p>¿En qué se diferencia un agente de un programa normal? Para mi la principal diferencia es la capacidad de tomar
algún tipo de decisión autónoma y ejecutarla.</p>

<h2 id="por-qué-tanto-alboroto-con-los-agentes">¿Por qué tanto alboroto con los agentes?</h2>

<p>Como podrás notar, lo que acabamos de describir se puede lograr con cualquier programa desde hace mucho tiempo,
de hecho, tenemos ejemplos de programas que llamamos agentes desde hace década, justo porque cumplen con algunas 
de las características que describimos.</p>

<p>Por ejemplo:</p>

<ul>
  <li>Los programas que monitorean el estado de un servidor y mandan las estadísticas a un concentrador para tomar decisiones.</li>
  <li>Los agentes encargado de actualizar automáticamente tus sistemas operativos, como el Windows Update Agent.</li>
  <li>Programas encargados de negociar entre protocolos de comunicación, como en el caso de DHCP o DNS, o SMTP.</li>
</ul>

<p>Todos estos programas cumplen con la capacidad de tomar decisiones autónomas, cooperar con su entorno y ejecutar acciones
para lograr su objetivo. Pero, ¿entonces por qué el boom actual?</p>

<p>Una da las partes más difíciles de construir un programa que se pueda considerar un agentes es la de la
toma de decisiones. Los algoritmos internos capaces de adaptarse a muchas situaciones y tomar decisiones
sin que fueran explícitamente programados para eso son muy muy difíciles de construir. ¿Pero qué pasa si
podemos usar las nuevas tecnologías como el <em>corazón</em> de un agente?</p>

<p>Justamente, los LLM’s cons su capacidad limitada de razonamiento, toma de decisiones, adaptación, conocimiento
general y capacidad de generar texto bien formado (para usarlo en protocolos de comunicación), son una tecnología
perfecta para servir como los motores de decisión de un agente, todas las demás partes: la memoria, la observación
del contexto o el entorno, el estado interno y la capacidad de actuar son temas que ya teníamos más o menos resueltos.</p>

<p>Es por esto que los LLM’s y los nuevos sistemas capaces de adaptarse a una cantidad inimaginable de entradas
de información y adaptar su respuesta y comportamiento a ellas, así como la capacidad de ser modificados
para comportarse mejor para casos específicos, han creado una ola de software basado en la idea de los agentes.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Ahora ya sabes lo que es un agente de software, por qué decimos en esta última ola que los modernos son <em>inteligentes</em>
y qué está impulsando toda la emoción que se ve por todos lados.Los agentes son herramientas poderosas
para crear sistemas que hagan cosas complejas, normalmente con poca programación pero mucho
control de nuestro lado. Viene una época en la que cada vez se usarán más, por lo que te conviene
conocerlos y aprender a usar esta técnica de desarrollo. En un artículo futuro vamos a ver cómo crear
diferentes tipos de agentes con capacidades cada vez más complejas.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="agente" /><category term="IA" /><category term="inteligencia-artificial" /><category term="agents" /><summary type="html"><![CDATA[La palabra 'agente' anda por todos lados desde la salida de los LLM's. Hablemos de lo que son y cómo te pueden ayudar a desarrollar sistemas más complejos.]]></summary></entry><entry><title type="html">Debes leer ‘Thinking in Systems’</title><link href="https://blog.thedojo.mx/2025/05/15/debes-leer-thinking-in-systems.html" rel="alternate" type="text/html" title="Debes leer ‘Thinking in Systems’" /><published>2025-05-15T00:00:00-06:00</published><updated>2025-05-15T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2025/05/15/debes-leer-thinking-in-systems</id><content type="html" xml:base="https://blog.thedojo.mx/2025/05/15/debes-leer-thinking-in-systems.html"><![CDATA[<p>El libro “Thinking in Systems” de <a href="https://en.wikipedia.org/wiki/Donella_H._Meadows">Donella Hager Meadows</a>
es un libro muy importante para cualquier desarrollador de software. ¿Por qué? Los desarrolladores nos dedicamos
a hacer <em>sistemas</em>, y este es justo el tema principal del libro, escrito por una experta en sistemas complejos.</p>

<p>Veamos por qué puede ser una buena lectura para ti y por que te recomiendo leerlo lo antes posible.</p>

<h2 id="a-cerca-de-thinking-in-systems">A cerca de Thinking in Systems</h2>

<p><strong>Thinking in systems</strong> es un libro un poco antiguo, publicado hace casi 17 años, en 2008, después del
fallecimiento de su autora. Pero el primer borrador de libro ya estaba circulando en <strong>1993</strong>.
Esto te lo estoy diciendo como un recordatorio más de que muchas de las ideas que vale la pena leer tienen
mucho tiempo de haber sido escritas, sobre todo en comparadas con las ideas a las que les hacemos
caso en el mundo del software.</p>

<h2 id="de-qué-trata-thinking-in-systems">De qué trata Thinking in Systems</h2>

<p>Pero, ¿de qué trata <strong>Thinking in Systems</strong>? Este libro te da una introducción a los conceptos básicos
del modelado de sistemas, empezando por ejemplos muy sencillos y avanzando un poco en complejidad, sin
presentarte nada realmente complejo. Te ayuda a comprender cómo empezar a modelar un sistema usando
ejemplos y diagramas sencillos.</p>

<p>Pero antes, ¿qué es un sistema? El libro lo define como una conjunto de elementos que interactúan entre sí
para lograr un objetivo. Lo más importante de un sistema es que su comportamiento no se puede explicar
observando el comportamiento individual de sus elementos, por lo que se dice lo que distingue a un sistema
de un montón de elementos que no lo son es que <strong>“un sistema es más que la suma de sus partes”</strong>.</p>

<p>Los componentes principales de un sistema son:</p>

<ul>
  <li><strong>Almacenes (stock)</strong>: Es un lugar físico o virtual donde se almacenan o van acumulando cosas,
en sistemas de software los puedes pensar como un buffer. Los stocks pueden tener límites o no. En el libro
se usa el ejemplo de las existencias de una agencia automotriz, el stock es el inventario de autos
que tienen para la venta.</li>
  <li><strong>Flujos (flow)</strong>: Son los movimientos, es decir, entrada y salidas de las cosas que se mueven entre
almacenes o dentro y fuera del sistema.</li>
</ul>

<p>Y ya, con esto puedes empezar a modelar un sistema. Existen casos especiales sobre todo de flujos que
son muy importantes y que son lo que les da su comportamiento interesante:</p>

<ul>
  <li>
    <p><strong>Flujos de retroalimentación</strong>: Cuando los cambios en la condición de un almacén causan cambios en
sus flujos de entrada y de salida, tenemos un flujo de retroalimentación. Piénsalo en el caso 
de un sistema de control de inventario, si se ve que no hay suficientes autos para la venta de la
siguiente semana, se piden bastantes autos, pero si el almacén está casi lleno, se piden menos.</p>
  </li>
  <li>
    <p><strong>Tasas de cambio</strong>: Algo que considerar es que los cambios en el mundo real no son instantáneos, por lo que
todo lo que hemos hablado hasta ahora está afectado por un ritmo de cambio.</p>
  </li>
</ul>

<p>Pero ya te estoy adelantando de más, para que comprendas esto mejor, te recomiendo leer el libro.</p>

<h3 id="tipos-de-sistemas">Tipos de sistemas</h3>

<p>Lo más interesante de este libro es el análisis de los comportamientos de los sistemas, y cómo es que
aunque un sistema esté compuesto de partes completamente entendidas, el comportamiento del sistema
no es obvio o fácil de predecir, sin embargo, sí hay patrones que puedes identificar y entender.</p>

<p>El libro te presenta una clasificación de sistemas a la que le llama “un zoológico de sistemas”,
clasificándolos como si fueran especies bien entendidas de animales. Aquí podemos ver varios tipos
de sistemas y sus destinos finales:</p>

<ul>
  <li>Sistemas que se mantienen estables y funcionando.</li>
  <li>Sistemas resilientes que se adaptan a los cambios.</li>
  <li>Sistemas destinados a desaparecer: por su crecimiento desmedido o porque no producen resultados.</li>
</ul>

<p>En esta parte podrás aprender a identificar varios patrones más.</p>

<h2 id="cómo-controlar-y-cambiar-un-sistema">Cómo controlar y cambiar un sistema</h2>

<p>Una de las lecciones más importantes de “Thinking in Systems” es que los sistemas son muy sensibles
a los cambios y que no es fácil comprender su efectos. Por lo tanto, un sistema es <strong>difícil de controlar</strong>
o cambiar y no nos queda más que hacer experimentos para entender cómo cambiarlo.</p>

<p>El libro da una lista de 12 cosas que podemos hacer para cambiar un sistema, pero deja claro que ninguna
de esas cosas es infalible. Esto es importante porque los desarrolladores de software somos muy propensos
a sentir que entendemos un sistema más de lo que realmente lo entendemos y segundo a pensar que lo podemos
cambiar con facilidad haciendo intervenciones sencillas. Esto normalmente lleva al desastre.</p>

<h3 id="reglas-para-vivir-en-un-mundo-de-sistemas-complejos">Reglas para vivir en un mundo de sistemas complejos</h3>

<p>Finalmente, Donella da una lista de 15 reglas o principios para comportarnos mejor en un mundo en
el que los sistemas son engañosos, que se me hacen esenciales para cualquier persona que trabaje en el área del conocimiento,
y son especialmente importantes para los desarrolladores de software. Cuando los leas verás que tienen mucho
que ver con las “buenas prácticas” que se fomentan en diferentes metodologías de desarrollo de software.</p>

<p>La mayoría tienen que ver con la idea de manejar correctamente la información que tenemos, clarificarla,
registrarla y compartirla.</p>

<h2 id="qué-podemos-aprender-los-desarrolladores-de-software">Qué podemos aprender los desarrolladores de software</h2>

<p>Ya hemos repetido hasta el cansancio que los desarrolladores de software <em>debemos ser expertos en modelar
sistemas</em>. ¿Pero por qué? Recuerda que tu trabajo es representar el mundo real en un lenguaje de programación,
conectar diferentes piezas de software para que la información fluya, y mantener esos sistemas funcionando,
al mismo tiempo que cuidas de los recursos que consumen y te aseguras de que evolucionen para que sigan siendo
precisos y útiles.</p>

<p>Todo lo anterior implica <strong>primero</strong> entender el sistema del mundo real y <strong>después</strong> representarlo en nuestras
computadoras. Así que creo que es obvio por qué este libro es tan buena lectura para cualquier desarrollador de
software que quiera avanzar en su carrera: te ayudará a ser mejor en tu trabajo.</p>

<p>Pero el libro tiene una lección que me parece de suma importancia: los sistemas del mundo real son más complejos
de lo que podemos representar en cualquier medio de representación humano, por lo que debemos ser explícitos
sobre lo que estamos modelando y sus límite, siempre manteniendo una actitud de curiosidad, aprendizaje y
humildad intelectual. Este punto específicamente es lo que los desarrolladores de software se beneficiarán
de aprender a hacer, y es una de las razones por las que este libro es tan importante.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Si eres desarrollador de software y quieres mejorar tu habilidad para crear
sistemas complejos que sirvan en el mundo real, mientras antes leas este libro, mejor. No solo lo leas,
<strong>estudia</strong> Thinking in Systems, <em>toma notas</em>, y pon en práctica lo que aprendas en los nuevos sistemas que
diseñes y construyas.</p>

<p>El mensaje de fondo de Meadows es que aquellos que nos dedicamos a entender y modelar el mundo podemos
tener un gran impacto en la forma en la que funcionan las cosas, pero ese impacto no es fácil de lograr y
mucho menos inmediato. A final de cuentas, ¿no quieres que tu trabajo sea importante? Si es así, seguir
los consejos de este libro te ayudará a que eso suceda.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="libros" /><category term="sistemas" /><category term="complejidad" /><summary type="html"><![CDATA[El pensamiento de sistemas es una de las habilidades más importantes para los desarrolladores de software. Hablemos de un libro que te ayuda a cultivarlo.]]></summary></entry><entry><title type="html">Bases de datos para LLM’s</title><link href="https://blog.thedojo.mx/2025/05/10/bases-de-datos-para-llm-s.html" rel="alternate" type="text/html" title="Bases de datos para LLM’s" /><published>2025-05-10T00:00:00-06:00</published><updated>2025-05-10T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2025/05/10/bases-de-datos-para-llm-s</id><content type="html" xml:base="https://blog.thedojo.mx/2025/05/10/bases-de-datos-para-llm-s.html"><![CDATA[<p>Los LLM’s llegaron para cambiar la forma en la que usamos la computadora.
Pero sus limitaciones y casos de uso que nos abren, requieren que los
utilicemos en conjunto con otras tecnologías y nuevas arquitecturas, para
hacer software confiable, útil y que cumpla con lo que el usuario necesita.</p>

<p>Una parte importante es la fuente de información, ya que no podemos confiar en
ellos como fuentes de información exactas. ¿En qué tipos de bases de
datos podemos guardar información para crear programas en combinación con
los modelos generativos que sirvan lo mejor posible?</p>

<p>En este artículo vamos a hablar de eso, pero empecemos entendiendo por qué
se necesitan bases de datos con capacidades especiales.</p>

<h2 id="por-qué-se-necesitan-bases-de-datos-con-capacidades-especiales">¿Por qué se necesitan bases de datos con capacidades especiales?</h2>

<p>Pensemos en algunos de los casos que los LLMs pueden ser útiles para resolver:</p>

<ul>
  <li><strong>Chatbots</strong> más sofisticados que los basados en reglas, con mayor capacidad de respuesta y flexibilidad en
en el tipo de respuestas que puede dar.</li>
  <li>Sistemas de <strong>creación de contenido</strong> en general, que nos dan mejores ideas
o resultados finales de alta calidad.</li>
  <li><strong>Agentes autónomos</strong> más inteligentes que pueden tomar decisiones y realizar
tareas más complejas.</li>
  <li><strong>Asistentes personales</strong> que analizan el contexto, juntan información y la
usan para poder darnos ayuda en diferentes áreas.</li>
</ul>

<p>Para que un LLM sea realmente útil en cualquiera de estos contextos
necesitamos que tenga acceso a información <strong>actualizada</strong> y <strong>relevante</strong>.
Para hacer un chatbot que pueda responder preguntas sobre cualquier tema
no podemos confiar en lo que el modelo tiene codificado en sus parámetros, primero
porque puede estar desactualizado y segundo porque es propenso a cometer errores,
lo que se conoce como <em>alucinaciones</em>. Ni los modelos más avanzados se
escapan de eso, y de hecho algunos investigadores piensan que mientras
más “capaz” sea el modelo, más propenso a cometer alucinaciones. En mi experiencia,
pasa exactamente eso, un LLM muy avanzado puede hacer invenciones cada vez más
convincentes, pero que siguen sin estar apegadas a la realidad.</p>

<h3 id="lo-que-esperamos-del-software">Lo que esperamos del software</h3>

<p>Dependiendo del caso se requieren algunas características que se esperan del software
en general pero que los LLM’s no son especialmente buenos para cumplir, por ejemplo:</p>

<ol>
  <li><strong>Velocidad</strong>: Casi todos los programas que encaran al usuario final requieren responder lo
más rápido posible.</li>
  <li><strong>Exactitud</strong>: En la mayoría de los casos necesitamos que la información que nos proporciona
el LLM sea lo más exacta posible, muchas veces no necesitamos una precisión absoluta, pero por lo
menos esperamos que no sea completamente errónea la respuesta.</li>
  <li><strong>Frescura en la información</strong>: La información que usamos en el día a día cambia y si tenemos
un sistema que la usa, debe tener acceso a lo más actualizado.</li>
  <li><strong>Capacidad de atender a muchos usuarios</strong>: A veces el mismo sistema debe poder atender
a muchos usuarios. Esto nos enfrenta con dos problemas principalmente: la capacidad de cómputo
requerida para manejar todas las peticiones y el costo de correr los modelos.</li>
</ol>

<p>Es por eso que los proyectos basados en LLM’s utilizan técnicas para lograr dos cosas principalmente:</p>

<ol>
  <li><strong>Darle información correcta, actualizada y sucinta al LLM</strong>: Esto ataca los problemas de velocidad,
exactitud y frescura de la información.</li>
  <li><strong>Reducir la cantidad de tokens que consume el LLM</strong>: Esto también nos puede ayudar con casi
todos los puntos de arriba, pero principalmente con el costo.</li>
</ol>

<p>La técnica principal se llama en inglés <em>Retrieval Augmented Generation</em> (<strong>RAG</strong>). Hablemos brevemente de ella.</p>

<h2 id="qué-es-rag">¿Qué es RAG?</h2>

<p>La técnica o arquitectura RAG consiste básicamente en usar una base de datos para almacenar
la información relevante que le vamos a inyectar al LLM dependiendo de la tarea que
tenga que realizar. La parte difícil está compuesta por dos etapas, que podemos resumir en dos preguntas:</p>

<ol>
  <li>¿Cómo preparo la información para que el LLM pueda usarla?</li>
  <li>¿Cómo hago que cuando el LLM necesite información, pueda acceder a ella de manera rápida y eficiente?</li>
</ol>

<p>No vamos a profundizar mucho en la implementación de RAG, pero uno de los puntos
más importantes para tener un sistema exitoso es la base de datos que usamos para
almacenar la información, que tiene que ver más con la segunda pregunta.</p>

<h2 id="bases-de-datos-para-proyectos-con-llms">Bases de datos para proyectos con LLM’s</h2>

<p>Hablemos de dos tipos diferentes de bases de datos que pueden ayudar a tu sistema a cumplir con
lo que se espera de un sistema de software, mientras aprovechamos las capacidades de los LLM’s.</p>

<h3 id="bases-de-datos-vectoriales">Bases de datos vectoriales</h3>

<p>Los modelos de lenguaje pueden generar texto, pero también pueden generar vectores. Estos vectores
representan el significado de los textos en un espacio vectorial. En inglés se les conoce como
<em>embeddings</em> y en español casi no se usa la traducción pero les podemos llamar <em>incorporaciones</em>.</p>

<p>El punto es que al transformar el texto en un vector que representa <em>su significado</em> podemos
hacer operaciones con los vectores para encontrar textos que sean similares o relacionados.
Y aunque esto lo podríamos programar manualmente, una programa especializado en eso nos sería
de mucha ayuda. Además, los vectores que te dan los modelos de lenguaje tienen una dimensión
muy grande, por lo que no es fácil de manejarlos con técnicas tradicionales.</p>

<p>Para que tu LLM tenga acceso a información relevante, una técnica transformar toda la información
que quieres que el LLM pueda usar en <em>embeddings</em> y guardarlos en una base de datos vectorial.
Las bases de datos vectoriales pueden ayudarte a <em>traer</em> (<strong>R</strong>etrieval) la información más
relevante cuando la necesites, de manera rápida y eficiente.</p>

<p>Aquí te presento algunos ejemplos de bases de datos vectoriales que puedes usar:</p>

<ul>
  <li><strong><a href="https://github.com/facebookresearch/faiss">Faiss</a></strong>: No es propiamente una base de datos, sino una
biblioteca open-source creada por Facebook AI Research, muy eficiente en búsqueda
y clustering de vectores densos. Se usa comúnmente embebida en aplicaciones Python/C++ para
implementar búsquedas vectoriales locales. También puede ser usado para crear tu propia base
de datos vectorial.</li>
  <li><strong><a href="https://milvus.io/">Milvus</a></strong>: Es de código abierto, diseñada para escalabilidad horizontal
y manejo de miles de millones de vectores. Ofrece un servicio completo (con clustering, replicación) ideal
para APIs de búsqueda semántica. También tienen una versión gestionada llamada Zilliz Cloud.</li>
  <li><strong><a href="https://www.pinecone.io/">Pinecone</a></strong>: Plataforma SaaS especializada en vectores. Es una de las formas
más sencillas de empezar y ofrecen una capa gratuita para pequeños proyectos.</li>
  <li><strong><a href="https://www.chromadb.dev/">ChromaDB</a></strong>: Otro proyecto open-source, que ha evolucionado a no solamente
ser una base de datos de vectores sino también de documentos, con funciones como búsqueda de texto completo,
filtrado de metadatos y almacenamiento multi-modal. También es una de las formas más sencillas de empezar
porque puedes embeberla en tu proyecto de forma sencilla.</li>
  <li><strong><a href="https://weaviate.io/">Weaviate</a></strong>: Es un proyecto open source hecho en Go. Su enfoque es completamente
ser una base de datos pensada para servir a aplicaciones de inteligencia artificial, sobre todo a
aquellas basadas en texto. Te puede ayudar desde convertir tus documentos en vectores y almacenarlos,
hasta hacer búsquedas de diferentes tipos.</li>
  <li><strong><a href="https://qdrant.tech/">Qdrant</a></strong>: Otro motor open-source con características a los anteriores, desarrollado
en Rust, pero que ofrece características enterprise, tiene versiones gestionadas y parece que es
usado en proyectos grandes.</li>
  <li><strong>PostgreSQL</strong> tiene la extensión PGVector para almacenar y comparar embeddings en columnas de una tabla, por
lo que si ya tienes una aplicación y no quieres agregar una nueva pieza de tecnología que mantener,
el viejo confiable PostgreSQL puede ser una buena opción.</li>
</ul>

<h3 id="bases-de-datos-de-grafos">Bases de datos de grafos</h3>

<p>Las bases de datos de grafos sirven muy bien para representar relaciones entre entidades.
Este tipo de representación es muy útil para modelar sistemas de información, y por lo tanto
para crear búsquedas semánticas y recomendaciones por similitud o temas relacionados.</p>

<p>Aunque este tipo de bases de datos tienen menos relevancia en los proyectos para LLM’s,
te pueden ayudar para crear mejores sistemas que contesten mejor a las peticiones de los
usuarios y que abaraten el costo de las respuestas por el uso de tokens.</p>

<p>A los sistemas que usan una base de datos de grafos para enriquecer las respuestas les llaman
<em>GraphRAG</em> (Graph-based Retrieval Augmented Generation). Aquí puedes usar las clásicas bases de datos
de grafos de toda la vida:</p>

<ul>
  <li><strong><a href="https://neo4j.com/">Neo4j</a></strong>: Igual un desarrollo de código abierto, con versiones gestionadas y
enterprise. Si quieres irte por el camino fácil, esta es una de las mejores opciones, por su
confiabilidad y soporte.</li>
  <li><strong><a href="https://www.arangodb.com/">ArangoDB</a></strong>: Es una base datos híbrida, pensada tanto para grafos
como para vectores, promete cubrir los dos lados de los que hablamos en este artículo: la flexibilidad
de los vectores con la capacidad de grafos. No es open-source, pero tienen una versión de comunidad
para que puedas probarla.</li>
  <li><strong><a href="https://dgraph.io/">Dgraph</a></strong>: Es una base de datos de grafos open-source, recientemente adquirida
por una empresa llamada Hypermode, enfocada en desarrollo de software con LLM’s. Promete procesar
terabytes de datos y responder en tiempo real.</li>
</ul>

<h2 id="conclusiones">Conclusiones</h2>

<p>Las bases de datos vectoriales y de grafos son herramientas poderosas que
te pueden ayudar a cumplir con las expectativas y necesidades de los proyectos
que son típicos de desarrollar con LLM’s. Para usarlas correctamente hay que
comprender su funcionamiento lo suficiente, pero no es necesario que te
vayas a cada detalle.</p>

<p>Cuando estamos desarrollando software siempre aplica el dicho de usar la herramienta
correcta para el problema y este es un ejemplo claro de la aplicación de este principio.
Pero siempre hay que equilibrarlo con la simplicidad y recordando que cada pieza de
software o hardware que agreguemos al proyecto aumenta la complejidad y el costo
de correr y mantener el proyecto.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="llms" /><category term="bases-de-datos" /><category term="vectores" /><category term="grafos" /><category term="embeddings" /><summary type="html"><![CDATA[Los LLM's nos permiten crear softeware que no creíamos posible hasta hacer poco. Pero necesitan que les demos información de manera especial. ¿Qué tipo de bases datos se requieren para crear proyectos útiles? En este artículo lo veremos.]]></summary></entry><entry><title type="html">El arte genérico: una historia de la metaprogramación en C++</title><link href="https://blog.thedojo.mx/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++.html" rel="alternate" type="text/html" title="El arte genérico: una historia de la metaprogramación en C++" /><published>2025-04-17T00:00:00-06:00</published><updated>2025-04-17T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++</id><content type="html" xml:base="https://blog.thedojo.mx/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++.html"><![CDATA[<p>Hablar de metaprogramación en C++ suele generar cierto rechazo, y no sin razón: dominar el lenguaje ya representa un reto considerable, y sumarle la complejidad de los teamplates puede parecer excesivo. A diferencia de otros lenguajes con mecanismos más flexibles o integrados, C++ exige un conocimiento profundo no solo del lenguaje, sino también del compilador y su comportamiento. Comprender cómo interactúan las plantillas, como se resuelven los tipos, como se gestionan las sobrecargas o se aplican las optimizaciones es esencial para escribir código genérico eficaz, lo que convierte esta práctica en un desafío tanto técnico como mental.</p>

<p>Pero el desafío que implica la Metaprogramación no es exclusivo de C++; otros lenguajes también han buscado formas de extender sus propias capacidades, enfrentándose a problemas similares desde enfoques muy distintos.</p>

<p>A lo largo de la historia de la informática, diversos lenguajes han explorado la metaprogramación desde ángulos muy distintos. LISP fue pionero absoluto en este campo, abordando el código como si fuera datos y utilizando macros para modificar y extender el propio lenguaje desde dentro. Esa fusión entre programa y datos sentó las bases de lo que hoy conocemos como metaprogramación.</p>

<p>Por otro lado, Ada introdujo desde etapas tempranas mecanismos más estructurados, como los generics, que ofrecían una forma de reutilización de código orientada a la seguridad y el tipado fuerte. Por ejemplo, al definir un paquete genérico para pilas:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">generic</span>
   <span class="n">type</span> <span class="n">Elemento</span> <span class="n">is</span> <span class="k">private</span><span class="p">;</span>
<span class="n">package</span> <span class="n">Pilas</span> <span class="n">is</span>
   <span class="n">procedure</span> <span class="n">Push</span> <span class="p">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">in</span> <span class="n">out</span> <span class="n">Pilas</span><span class="p">;</span> <span class="n">E</span> <span class="o">:</span> <span class="n">in</span> <span class="n">Elemento</span><span class="p">);</span>
   <span class="n">function</span> <span class="n">Pop</span> <span class="p">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">in</span> <span class="n">out</span> <span class="n">Pilas</span><span class="p">)</span> <span class="k">return</span> <span class="n">Elemento</span><span class="p">;</span>
<span class="k">private</span>
   <span class="n">type</span> <span class="n">Pilas</span> <span class="n">is</span> <span class="n">array</span> <span class="p">(</span><span class="n">Natural</span> <span class="n">range</span> <span class="o">&lt;&gt;</span><span class="p">)</span> <span class="n">of</span> <span class="n">Elemento</span><span class="p">;</span>
<span class="n">end</span> <span class="n">Pilas</span><span class="p">;</span>
<span class="n">package</span> <span class="n">Pilas_Enteros</span> <span class="n">is</span> <span class="k">new</span> <span class="nf">Pilas</span> <span class="p">(</span><span class="n">Elemento</span> <span class="o">=&gt;</span> <span class="n">Integer</span><span class="p">);</span>

</code></pre></div></div>

<p>Mientras Ada se centra en la metaprogramación estática, otros lenguajes exploraron la reflexión y los meta‑objetos para ganar flexibilidad en tiempo de ejecución. Java, por ejemplo, utiliza Annotation Processors para generar código antes de compilar, C# aprovecha Roslyn para inspeccionar y modificar su árbol de sintaxis, D ofrece CTFE y mixins, y Rust incorpora procedural macros que derivan implementaciones de rasgos automáticamente.</p>

<p>Uno de los primeros antecedentes directos de la metaprogramación en C++ lo encontramos en C, particularmente en el uso creativo de su preprocesador. Más allá de las clásicas macros con funciones, surgieron técnicas como los X-macros, que permitían generar múltiples fragmentos de código reutilizando una lista común de componentes. Esta técnica consistía en definir un conjunto de macros en un archivo de cabecera que podía incluirse varias veces, redefiniendo la macro principal en cada inclusión para producir diferentes versiones del código.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// xmacro.h</span>
<span class="cp">#define COMPONENTS \
    X(int, age)     \
    X(char*, name)  \
    X(double, salary)
</span></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"mac.h"</span><span class="cp">
</span>
<span class="c1">// 1. Definir la estructura usando las X-macros</span>
<span class="cp">#define X(type, name) type name;
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">COMPONENTS</span>
<span class="p">}</span> <span class="n">Employee</span><span class="p">;</span>
<span class="cp">#undef X
</span>
<span class="c1">// 2. Declarar funciones específicas para imprimir cada campo</span>
<span class="kt">void</span> <span class="nf">print_age</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"age: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_name</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"name: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_salary</span><span class="p">(</span><span class="kt">double</span> <span class="n">salary</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"salary: %.2f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">salary</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 3. Usar X-macros para llamar automáticamente a las funciones de impresión</span>
<span class="cp">#define X(type, name) print_##name(e.name);
</span><span class="kt">void</span> <span class="nf">print_employee</span><span class="p">(</span><span class="n">Employee</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">COMPONENTS</span>
<span class="p">}</span>
<span class="cp">#undef X
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Employee</span> <span class="n">emp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="s">"John Doe"</span><span class="p">,</span> <span class="mi">55000</span><span class="p">.</span><span class="mi">5</span><span class="p">};</span>
    <span class="n">print_employee</span><span class="p">(</span><span class="n">emp</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Aunque limitada y propensa a errores, esta estrategia fue una solución creativa a la falta de mecanismos más robustos, y se ha usado en tareas como la serialización de estructuras o la generación repetitiva de código.</p>

<p>La evolución hacia C++ introdujo un enfoque más robusto y expresivo para la generación de código: en lugar de depender de las macros del preprocesador — propensas a errores y difíciles de depurar — , el lenguaje apostó por mecanismos estáticos como los templates. Esta decisión, formalizada en el estándar C++98, marcó un hito importante en la historia del lenguaje. Originalmente concebidos por Bjarne Stroustrup a principios de los años 90, los templates surgieron como una extensión natural de la idea de reutilización de código sin sacrificar eficiencia. Esta elección estaba alineada con la filosofía de C++: ofrecer un control fino sobre el rendimiento y el uso eficiente de los recursos.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="c1">// Definición de la clase Persona</span>
<span class="k">struct</span> <span class="nc">Persona</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nombre</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">edad</span><span class="p">;</span>

    <span class="c1">// Sobrecarga del operador &gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">otra</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">edad</span> <span class="o">&gt;</span> <span class="n">otra</span><span class="p">.</span><span class="n">edad</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Plantilla max para comparar dos objetos de cualquier tipo</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">max</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Comparar enteros</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="mf">5.5</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Comparar flotantes</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Comparar caracteres</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="s">"Hola"</span><span class="p">,</span> <span class="s">"Mundo"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Comparar cadenas de caracteres</span>

    <span class="c1">// Crear objetos Persona</span>
    <span class="n">Persona</span> <span class="n">p1</span><span class="p">{</span><span class="s">"Ana"</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
    <span class="n">Persona</span> <span class="n">p2</span><span class="p">{</span><span class="s">"Luis"</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>

    <span class="c1">// Usar la plantilla max con objetos Persona</span>
    <span class="n">Persona</span> <span class="n">mayor</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"La persona mayor es: "</span> <span class="o">&lt;&lt;</span> <span class="n">mayor</span><span class="p">.</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" con "</span> <span class="o">&lt;&lt;</span> <span class="n">mayor</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;&lt;</span> <span class="s">" años."</span><span class="p">;</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Un ejemplo sobresaliente del poder de la metaprogramación en C++ es la Standard Template Library (STL). Diseñada hace más de dos décadas, esta biblioteca demostró que es posible construir algoritmos y estructuras de datos altamente reutilizables, seguros y eficientes sin sacrificar rendimiento. Su arquitectura, basada completamente en templates, permite que muchas decisiones se tomen en tiempo de compilación, lo que facilita optimizaciones que en otros lenguajes se delegan al tiempo de ejecución. Gracias a este enfoque, los programadores pueden trabajar con listas, vectores, mapas y muchos otros contenedores de forma abstracta, sin comprometer el control sobre el rendimiento.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="c1">// Clase personalizada</span>
<span class="k">struct</span> <span class="nc">Persona</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nombre</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">edad</span><span class="p">;</span>

    <span class="c1">// Sobrecarga del operador &gt; (requisito para usar con maximo&lt;T&gt;)</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">otra</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">edad</span> <span class="o">&gt;</span> <span class="n">otra</span><span class="p">.</span><span class="n">edad</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Para usar en búsquedas</span>
    <span class="kt">bool</span> <span class="n">esMayorDeEdad</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">edad</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Template genérico como ejemplo de metaprogramación</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">maximo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Función para imprimir un vector genérico (puede usarse con cualquier tipo imprimible)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">imprimirVector</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">titulo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">titulo</span> <span class="o">&lt;&lt;</span> <span class="s">":</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- "</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" ("</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;&lt;</span> <span class="s">" años)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Persona</span> <span class="n">p1</span><span class="p">{</span><span class="s">"Ana"</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
    <span class="n">Persona</span> <span class="n">p2</span><span class="p">{</span><span class="s">"Luis"</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>
    <span class="n">Persona</span> <span class="n">p3</span><span class="p">{</span><span class="s">"Carlos"</span><span class="p">,</span> <span class="mi">40</span><span class="p">};</span>
    <span class="n">Persona</span> <span class="n">p4</span><span class="p">{</span><span class="s">"Elena"</span><span class="p">,</span> <span class="mi">35</span><span class="p">};</span>

    <span class="c1">// Uso del template maximo</span>
    <span class="n">Persona</span> <span class="n">mayor</span> <span class="o">=</span> <span class="n">maximo</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Entre "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" y "</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">nombre</span>
              <span class="o">&lt;&lt;</span> <span class="s">", el mayor es: "</span> <span class="o">&lt;&lt;</span> <span class="n">mayor</span><span class="p">.</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" con "</span> <span class="o">&lt;&lt;</span> <span class="n">mayor</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;&lt;</span> <span class="s">" años.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// STL: vector y sort con lambda</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Persona</span><span class="o">&gt;</span> <span class="n">personas</span> <span class="o">=</span> <span class="p">{</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">personas</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">personas</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">edad</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="n">imprimirVector</span><span class="p">(</span><span class="n">personas</span><span class="p">,</span> <span class="s">"Personas ordenadas por edad"</span><span class="p">);</span>

    <span class="c1">// Uso de std::find_if para buscar al primer mayor de edad</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">personas</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">personas</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">esMayorDeEdad</span><span class="p">();</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">personas</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Primera persona mayor de edad: "</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Uso de std::map con string -&gt; Persona</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Persona</span><span class="o">&gt;</span> <span class="n">directorio</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">persona</span> <span class="o">:</span> <span class="n">personas</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">directorio</span><span class="p">[</span><span class="n">persona</span><span class="p">.</span><span class="n">nombre</span><span class="p">]</span> <span class="o">=</span> <span class="n">persona</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Directorio (map de nombre -&gt; edad):</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">nombre</span><span class="p">,</span> <span class="n">persona</span><span class="p">]</span> <span class="o">:</span> <span class="n">directorio</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" tiene "</span> <span class="o">&lt;&lt;</span> <span class="n">persona</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;&lt;</span> <span class="s">" años</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>La STL no solo consolidó el papel de la metaprogramación en el ecosistema de C++, sino que también mostró cómo podía usarse para diseñar software genérico, modular y de alto rendimiento.</p>

<p>Durante mucho tiempo, trabajar con metaprogramación en C++ fue una tarea ardua: los mensajes de error crípticos, la dificultad de depuración y la complejidad sintáctica desalentaban incluso a programadores experimentados. A pesar de la gran utilidad de los templates, las actualizaciones significativas fueron pausadas durante un largo periodo, desde el estándar de 1998 hasta la llegada de C++11 en 2011.</p>

<p>Sin embargo, el lenguaje comenzó a evolucionar de manera más progresiva, incorporando características como auto, decltype, constexpr y variadic templates, que facilitaban la escritura de código genérico más expresivo. Posteriormente, C++14 y C++17 siguieron refinando estas ideas, mientras que C++20 marcó un punto de inflexión con la inclusión de concepts, que aportaron una forma formal y clara de expresar los requisitos de los tipos en las plantillas.</p>

<p>La introducción de concepts en C++20 representó un paso crucial en esta evolución. Inspirados en gran medida por las ideas de Alexander Stepanov, cocreador de la STL, los concepts permiten especificar de forma clara y expresiva qué requisitos debe cumplir un tipo para ser utilizado en una plantilla. Esta abstracción permite escribir código genérico más legible y seguro, con validaciones en tiempo de compilación que antes requerían técnicas mucho más complejas o indirectas. Gracias a herramientas como concepts, la metaprogramación en C++ ha dejado de ser un arte oscuro para convertirse en una práctica más accesible, robusta y expresiva.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
</span>
<span class="c1">// Concepto que exige un método miembro `area()` que devuelva un número (real o entero)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">TieneArea</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">area</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Función que suma el área de todas las figuras que cumplen con el concepto TieneArea</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">TieneArea</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="kt">double</span> <span class="nf">area_total</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">figuras</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">figura</span> <span class="o">:</span> <span class="n">figuras</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">figura</span><span class="p">.</span><span class="n">area</span><span class="p">();</span>  <span class="c1">// Se garantiza que existe</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Clases que implementan el método `area()`</span>
<span class="k">struct</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">ancho</span><span class="p">,</span> <span class="n">alto</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">area</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ancho</span> <span class="o">*</span> <span class="n">alto</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Circulo</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">radio</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">area</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">3.14159</span> <span class="o">*</span> <span class="n">radio</span> <span class="o">*</span> <span class="n">radio</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Clase que NO implementa `area()` y no cumple el concepto</span>
<span class="k">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Rectangulo</span><span class="o">&gt;</span> <span class="n">rectangulos</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">},</span> <span class="p">{</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Circulo</span><span class="o">&gt;</span> <span class="n">circulos</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mf">1.0</span><span class="p">},</span> <span class="p">{</span><span class="mf">2.5</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Área total de rectángulos: "</span> <span class="o">&lt;&lt;</span> <span class="n">area_total</span><span class="p">(</span><span class="n">rectangulos</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Área total de círculos: "</span> <span class="o">&lt;&lt;</span> <span class="n">area_total</span><span class="p">(</span><span class="n">circulos</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// std::vector&lt;Punto&gt; puntos = { {1.0, 2.0}, {3.0, 4.0} };</span>
    <span class="c1">// area_total(puntos);  // Error de compilación: Punto no tiene `area()`</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Además, de cara a C++26, se contempla la incorporación de mecanismos de reflexión estática, una capacidad largamente esperada que permitiría inspeccionar y manipular tipos y estructuras del programa durante la compilación. Esta funcionalidad ampliaría aún más el poder de la metaprogramación en C++, facilitando tareas como la generación automática de código, la serialización de objetos o la validación estructural sin recurrir a macros o técnicas intrusivas.</p>

<p>La metaprogramación en C++ ha evolucionado de forma notable: desde los ingeniosos — aunque limitados — usos del preprocesador, hasta un presente donde los templates, concepts y la futura incorporación de reflexión estática conforman un ecosistema cada vez más potente, seguro y expresivo. Lejos de ser una técnica reservada a expertos, hoy se consolida como una herramienta estratégica para escribir código genérico, reutilizable y eficiente. Comprender esta evolución no solo permite valorar mejor el diseño del lenguaje, sino también adoptar una perspectiva más madura sobre cómo abstraemos y optimizamos nuestros programas. En última instancia, Metaprogramación en C++ es ampliar los límites de lo que podemos construir con precisión, elegancia y control.</p>]]></content><author><name>Francisco Zavala</name><uri>https://github.com/Nobody-1321</uri></author><category term="c++" /><category term="metaprogramación" /><summary type="html"><![CDATA[La metaprogramación en C++ ha recorrido un camino tan complejo como fascinante, hasta convertirse en una herramienta clave para el desarrollo de software genérico y de alto rendimiento]]></summary></entry><entry><title type="html">Reseña del libro ‘Deep Learning’ de MIT Press Essential Knowledge Series</title><link href="https://blog.thedojo.mx/2025/02/23/resena-del-libro-deep-learning-de-mit-essential-knowledge-series.html" rel="alternate" type="text/html" title="Reseña del libro ‘Deep Learning’ de MIT Press Essential Knowledge Series" /><published>2025-02-23T00:00:00-06:00</published><updated>2025-02-23T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2025/02/23/resena-del-libro-deep-learning-de-mit-essential-knowledge-series</id><content type="html" xml:base="https://blog.thedojo.mx/2025/02/23/resena-del-libro-deep-learning-de-mit-essential-knowledge-series.html"><![CDATA[<p>La serie <strong>The MIT Press Essential Knowledge Series</strong> es una serie de libros de introducción
a diferentes temas interesantes y actuales, sobre todo de ciencia y tecnología.</p>

<p>Me gustan mucho porque son lo suficientemente introductorios para que cualquiera
sin conocimiento previo del tema específico pueda introducirse, pero lo suficientemente
completos para salir con una buena visión general de ese tema específico.</p>

<p>El libro del que quiero hablar es de un tema que se ha vuelto cada vez más importante,
el <strong>Deep Learning</strong>.</p>

<h2 id="reseña-del-deep-learning-de-john-d-kelleher">Reseña del Deep Learning de John D. Kelleher</h2>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/v1740318616/Deep_learning_csd5gy.jpg" alt="Portada del libro Deep Learning de John D. Kelleher" class="align-center" /></p>

<p>En este libro empezarás desde la introducción a lo que llamamos inteligencia artificial,
machine learning y finalmente deep learning, junto con los efectos que ha tenido en el mundo.</p>

<p>Me gusta mucho que el libro te explica en términos simples la base matemática que sustenta
todo lo que hacemos con los modelos y te aclara los términos que se escuchan por todos lados
sin ser tan difícil de entender. Por ejemplo:</p>

<ul>
  <li>Te aclara que un <strong>modelo</strong> es una función en el sentido matemático y te explica cuál es el
trabajo del entrenamiento para llegar a ese modelo</li>
  <li>Explica lo que es el <strong>aprendizaje</strong> y la <strong>experiencia</strong></li>
  <li>Aclara qué es un <strong>parámetro</strong></li>
  <li>Deja muy claros los pasos de <strong>entrenamiento</strong> e <strong>inferencia</strong></li>
</ul>

<p>Después de poner las cartas sobre la mesa respecto términos y definiciones, se pasa a hablar
de la historia de la inteligencia artificial y cómo es que llegamos <em>casi</em> hasta donde estamos
ahora, porque este libro se escribió antes del boom de los LLMs, pero viéndolo desde nuestra
perspectiva te puedes dar cuenta de lo mucho que sabe el autor del tema porque ya menciona
a los transformadores (la base de los LLMs modernos) como un tipo de modelo de Deep Learning importante.</p>

<p>Después de esto, pasa a explicar cómo se entrena a un perceptrón, o un modelo de una neurona,
para que puedas entender el procedimiento básico y después pasar a los modelos que son
el centro del libro: los modelos profundos.</p>

<p>En este libro aprenderás que el deep learning es simplemente una forma de entrenar modelos
que están compuestos por varias capas de neuronas, y que es un campo en sí mismo porque
estos modelos no son tan fáciles de entrenar e incluso requieren matemáticas específicas y
técnicas que han ido surgiendo con la prueba y el error.</p>

<p>El libro te explica dos algoritmos esenciales en el deep learning:</p>

<ul>
  <li>El descenso de gradiente (gradient descent)</li>
  <li>El algoritmo de retropropagación (backpropagation)</li>
</ul>

<p>Esta es la parte más pesada del libro respecto a matemáticas, incluso dice que te la puedes
leer por encima si te cuestan mucho trabajo, pero que también puedes comprobar por ti
mismo las matemáticas que te explica. Aquí es justo donde digo que esta serie profundiza
lo suficiente para no sentirse como un libro sin profundidad que es la pura introducción.</p>

<p>El libro finaliza con un análisis de lo que el autor considera lo que sigue para el deep learning
y la inteligencia artificial en general, como la explicabilidad, la eficiencia, el cómputo
especializado en imitar el cerebro, los transformadores (BERT), etc.</p>

<p>Espero que este resumen te de una idea de lo que trata el libro.</p>

<h2 id="conclusión-y-opinión">Conclusión y opinión</h2>

<p>Si te quieres entender de manera un poco más profunda cómo funcionan las redes
neuronales en general y los detalles de las redes neuronales profundas, este
libro es una excelente introducción, porque incluso te da un viaje por las matemáticas
detrás del entrenamiento de los modelos que usamos diariamente.</p>

<p>Como se escribió en 2019, no te habla de LLMs o cosas similares, pero sí de las
bases que les permitieron nacer: el transformador. Incluso menciona cosas no tan
famosas, como la computación neuromórfica, de la que no dudo que pueda
tener relevancia en el futuro, o impactar en nuevas tecnologías y nuevas formas
de crear inteligencia artificial.</p>

<p>Por su extensión, además, es un libro que vale la pena. Es cierto que se podría
mejorar un poco en la forma de escribirlo, pero no es algo que te vaya a impedir
extraer la información relevante.</p>

<p>Si tienes bases de matemáticas de nivel preparatoria, en la que entiendes el
álgebra y un poco de cálculo, estás del otro lado para entender este libro.
Si no, puedes saltarte los capítulos matemáticos y leer todo lo demás para
para darte una idea superficial del tema de Deep Learning y cómo puedes
empezar a aprender la parte más técnica e incluirlo en tus desarrollos.</p>

<p>Eso sí, este libro no tiene ni una línea de código, es un libro completamente
conceptual para entender la bases antes de aventarnos de cabeza a la programación.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="libros" /><category term="deep-learning" /><category term="machine-learning" /><category term="matemáticas" /><summary type="html"><![CDATA[Hablemos del libro 'Deep Learning' de MIT Essential Knowledge Series, una introducción suficiente al tema.]]></summary></entry><entry><title type="html">Un concepto importante: los buffers</title><link href="https://blog.thedojo.mx/2024/12/30/un-concepto-importante-los-buffers.html" rel="alternate" type="text/html" title="Un concepto importante: los buffers" /><published>2024-12-30T00:00:00-06:00</published><updated>2024-12-30T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/12/30/un-concepto-importante-los-buffers</id><content type="html" xml:base="https://blog.thedojo.mx/2024/12/30/un-concepto-importante-los-buffers.html"><![CDATA[<p>El concepto de buffer es usado por todos lados en el desarrollo de software, pero siento
que es un concepto poco entendido. En este artículo vamos a hablar de qué son los buffers,
para qué se usan y cómo pueden ayudarte a resolver problemas y diseñar mejor software.</p>

<h2 id="qué-es-un-buffer">¿Qué es un buffer?</h2>

<p>Primero hablemos de dónde viene la idea de los buffers. Un buffer es un concepto importante en
teoría de sistemas. Los buffers se utilizan para almacenar temporalmente datos, asegurando que
eventualmente lleguen a su destino final. Esto ocurre a una velocidad o ritmo diferente al
que fueron generados originalmente.</p>

<p>Traducir la palabra <em>“buffer”</em> es difícil, porque no hay un concepto en español que abarque
todos los usos que se le dan en el desarrollo de software.Algunos ejemplos de uso de buffers en el desarrollo de software son:</p>

<ul>
  <li>Amortiguador</li>
  <li>Almacén temporal</li>
  <li>Memoria intermedia</li>
  <li>Regulador</li>
</ul>

<p>Esta última palabra te puede empezar a sonar, ya que en el desarrollo de software usamos
los buffers para <em>regular</em> el flujo de datos entre diferentes sistemas o componentes.
Los buffers causan retrasos intencionales en el flujo de datos.</p>

<p>Empecemos a hablar de cómo se usan en el desarrollo de software.</p>

<h2 id="buffers-en-acción">Buffers en acción</h2>

<p>Estos son algunos ejemplos de este concepto que seguro conoces o has visto aplicados en
software. Recuerda que lo que estamos buscando entender es el concepto, por lo que vamos a
explicar cómo el ejemplo es un buffer, pero no vamos a entrar en detalles de la implementación.</p>

<h3 id="escritura-en-archivos">Escritura en archivos</h3>

<p>Cuando escribimos en un archivo, los sistemas operativos usan buffers para guardar los datos
en memoria antes de escribirlos en su destino final, ya que si escribiera directamente en el disco
byte por byte, sería muy lento. Además, escribir directamente en el disco por cada byte que un
programa mande a escribir causaría problemas de estabilidad y rendimiento. Aquí no tenemos que
explicar mucho por qué un buffer, ya que es el ejemplo más común. Incluso en varios lenguajes
de programación los objetos que se usan para escribir en los archivos tienen “Buffer” o “Buffered”
en su nombre.</p>

<h3 id="uso-de-servicios-remotos">Uso de servicios remotos</h3>

<p>Usar un servicio o una función a través de la red (un servicio remoto) es costoso en tiempo
y recursos en comparación con cualquier cálculo local que se haga. Por eso es buena idea
usar buffers para guardar información antes de hacer una llamada a un servicio remoto.
Por ejemplo, en desarrollo web, cuando se hace un auto-completado o búsqueda mientras se sigue
escribiendo, el programa espera a que el campo tenga un número de caracteres para hacer
una llamada al servicio de búsqueda que pueda tener sentido.</p>

<h3 id="caching">Caching</h3>

<p>Este ejemplo no podía faltar. El caché es un tipo de buffer que guarda información <em>temporalmente</em>
con varios objetivos:</p>

<ol>
  <li>Ahorrar cómputo</li>
  <li>Acelerar el acceso a la información</li>
  <li>Evitar la sobrecarga de los recursos</li>
</ol>

<p>Como sabemos, lo más difícil del cachee es decidir primero qué guardar y luego cómo
refrescarlo para que se no sea obsoleto.</p>

<h3 id="buffering-de-contenido-multimedia">Buffering de contenido multimedia</h3>

<p>Debido a que el contenido multimedia es muy pesado, un buen reproductor o sistema de streaming
casi siempre incluye un buffer que va descargando el contenido a mayo velocidad y un poco
adelantado para tener un reproducción fluida. Si no lo incluimos, estamos a merced de la velocidad
y las intermitencias de la red.</p>

<h2 id="cómo-pueden-ayudarte-a-diseñar-mejor-software">¿Cómo pueden ayudarte a diseñar mejor software?</h2>

<p>Escribir software usando buffers es más complejo que hacerlo sin ellos, ya que son una pieza más
que puede causar problemas y que en algún momento vas a tener que depurar. Pero los buffers complican
el código y las pruebas de software, son indispensables para el buen rendimiento y la estabilidad de los
sistemas. Incluso algunos lenguajes de programación como Java, tienen buffers incorporados en su
librería estándar.</p>

<p>Recuerda, usar buffers te va a ayudar a escribir software:</p>

<ul>
  <li>Más estable</li>
  <li>Con mejor rendimiento</li>
  <li>Más resiliente</li>
  <li>Más eficiente</li>
</ul>

<p>Así que te conviene buscar oportunidades para usarlos lo mejor posible.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Los buffers son interesantes. Son una herramienta poderosa que puedes usar para resolver
problemas con mejor calidad y que te permiten crear características arquitectónicas
deseables, a costa de hacer el código un poco más complejo. Sin embargo, si los ocultas
correctamente detrás de interfaces efectivas, los documentas bien y los pruebas,
te ayudarán mucho.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="software-development" /><category term="programming" /><category term="técnicas-de-programación" /><category term="buffer" /><summary type="html"><![CDATA[Los buffers son una herramienta poderosa que puedes usar para resolver problemas. Hablemos de algunos ejemplos y cómo te pueden ayudar a diseñar mejor software.]]></summary></entry><entry><title type="html">¿Qué son los requerimientos funcionales?</title><link href="https://blog.thedojo.mx/2024/11/23/que-son-los-requerimientos-funcionales.html" rel="alternate" type="text/html" title="¿Qué son los requerimientos funcionales?" /><published>2024-11-23T00:00:00-06:00</published><updated>2024-11-23T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/11/23/que-son-los-requerimientos-funcionales</id><content type="html" xml:base="https://blog.thedojo.mx/2024/11/23/que-son-los-requerimientos-funcionales.html"><![CDATA[<p><strong>“Requerimientos funcionales”</strong> es una expresión muy rebuscada para un concepto
muy sencillo relacionado con el diseño de los sistemas de software: <strong>las
cosas que tu sistema HACE</strong>.</p>

<p>En este artículo hablaremos de formas de encontrarlos, definirlos, documentarlos
y tenerlos listos para la siguiente etapa del desarrollo de software.</p>

<h2 id="cómo-definir-las-funciones-de-un-sistemas">Cómo definir las funciones de un sistemas</h2>

<p>La primera tarea como arquitecto de software tiene que ver con la de
<strong>entender completamente</strong> lo que el software tiene que HACER. El software
normalmente tiene unas pocas funciones principales, pero muchas tareas
secundarias o terciarias que las soportan, y es por eso que descubrirlas
y describirlas todas no es una tarea sencilla.</p>

<h2 id="cómo-encontrarlos">Cómo encontrarlos</h2>

<p>La forma más eficiente de encontrar los requerimientos funcionales o funciones
que debe tener tu sistema es viviendo el proceso o problema que tu sistema va a
resolver. Es por esto que algunos de los mejores sistemas son creados por gente
que “se rasca su propia comezón” (<em>“scratch their own itch”</em>). Es decir, que
resuelven un problema que ellos mismos viven o han vivido, y que por eso
mismo <strong>entienden a fondo</strong>.</p>

<p>Una de las ventajas de atender un problema que tú vives, es que tienes
retroalimentación inmediata sobre si el sistema resuelve el problema o no.</p>

<p>Pero esto no siempre es posible, sobre todo cuando construyes software como
profesión, porque no siempre puedes dedicar tiempo y recursos suficientes para
tú realizar la operación de lo que quieres resolver, o simplemente no es práctico.
Así que la segunda mejor opción que tenemos es <strong>platicar con los usuarios</strong>.</p>

<p>Aquí es donde entran un montón de habilidades “blandas”. Un mejor nombre para estas
habilidades es <em>“habilidades personales e interpersonales”</em>. O habilidades básicas
humanas. Así que, a menos que tengas a alguien en tu equipo que lo haga por ti,
(y que siempre vaya a estar contigo), te conviene desarrollarlas.</p>

<h2 id="cómo-documentarlos">Cómo documentarlos</h2>

<p>No existe una forma aceptada por todos para documentar nada en el software,
dependiendo de la cultura del equipo y de la empresa en general. Veamos algunas
de las formas más comunes. Cabe mencionar que estas formas no son excluyentes,
se pueden combinar para ver diferentes aspectos de una misma función.</p>

<h3 id="historias-de-usuario">Historias de Usuario</h3>

<p>En este estilo de documentación, describes las funciones del sistema desde la
perspectiva del usuario. Se lleva muy bien con procesos modernos de desarrollo de
productos digitales, relacionados con el desarrollo ágil de software.</p>

<p>Tienen el siguiente formato:</p>

<ul>
  <li>Como [rol de usuario]</li>
  <li>Quiero [acción/función]</li>
  <li>Para [beneficio/valor]</li>
</ul>

<p>Como puedes ver, antes de empezar a crear historias de usuario, debes por lo menos
tener un idea de las personas que van a usar el sistema y lo roles que desempeñan.
Después, describes la función que va a realizar, desde su punto de vista, pero
también intentando mostrar cómo funcionará internamente el sistema para cumplir
con esa función.</p>

<p>Y finalmente, la razón de existencia de esta función: cómo es que beneficia al usuario
o la empresa que crea el software. Esta última parte es muy importante, ya que nos
hace pensar en si realmente es necesario tener esta función o no.</p>

<h3 id="casos-de-uso">Casos de Uso</h3>

<p>Este tipo de documentación viene de la época en la que se prefería el desarrollo en cascada,
pero a mi me sigue pareciendo muy útil. Es más formal y detallada, incluye:</p>

<ul>
  <li>Actores (usuarios o sistemas externos) involucrados</li>
  <li>Flujo principal: el caso en el que todo sale bien</li>
  <li>Flujos alternativos: los casos en los que algo sale mal o se manejan de otra manera</li>
  <li>Precondiciones y postcondiciones: cómo está el sistema antes y después de la ejecución</li>
</ul>

<p>En muchos sistemas de documentación, los casos de uso requieren un identificador para
referirse a ellos en etapas posteriores, como cuando se hacen pruebas o se crean
tareas específicas para el equipo de desarrollo.</p>

<p>Los recomiendo mucho en el caso de sistemas o funciones críticas, en donde es
necesario pensar más a profundidad antes de empezar a desarrollar.
Puedes encontrar un ejemplo y una plantilla aquí:
<a href="https://lsi2.ugr.es/~mvega/docis/casos%20de%20uso.pdf">Casos de uso</a>.</p>

<h2 id="cómo-mantenerlos-actualizados">Cómo mantenerlos actualizados</h2>

<p>El software es dinámico, y no basta con definir o documentar cómo funciona una
sola vez, tenemos que mantener actualizadas las funciones documentadas del
sistema o agregar nuevas conforme vayan apareciendo.</p>

<p>Aquí tienes algunas sugerencias para mantener actualizados los requerimientos:</p>

<h3 id="revisar-y-actualizar">Revisar y actualizar</h3>

<p>Si tienes suficiente personal, siempre debería haber un owner de la documentación
y esta persona debería revisar y asegurarse que los diferentes miembros del equipo
mantengan actualizadas las funciones documentadas y documenten las nuevas.</p>

<h3 id="control-de-versiones">Control de versiones</h3>

<p>Es buena idea mantener los documentos de requerimientos bajo control de versiones,
igual que el código. De hecho, una de las mejores formas de hacer documentación es
tratarla exactamente como código, como se sugiere en <a href="https://www.writethedocs.org/guide/docs-as-code/">Docs as Code</a>.</p>

<p>Cada cambio debería ir acompañado de:</p>

<ul>
  <li>Fecha del cambio</li>
  <li>Razón del cambio</li>
  <li>Persona responsable</li>
  <li>Impacto en el sistema</li>
</ul>

<h3 id="trazabilidad">Trazabilidad</h3>

<p>Puedes mantener una matriz de trazabilidad que conecte los requerimientos con:</p>

<ul>
  <li>El código que los implementa</li>
  <li>Las pruebas que los verifican</li>
  <li>Otra documentación relacionada</li>
</ul>

<p>Para que esta matriz sea útil, se debe de incluir su actualización en el proceso
de desarrollo y considerarse dentro de la definición de “terminado” de una tarea (<em>definition of done</em>).
Esto es buena idea sólo si tienes un equipo grande y un proyecto complejo, ya que requiere
bastante trabajo en sí mismo.</p>

<h3 id="comunicación-efectiva">Comunicación efectiva</h3>

<p>Esto es esencial para todos los procesos de desarrollo de software, pero debes asegurarte
que mientras más avance tu proyecto y más gente se involucre, más se haga:</p>

<ul>
  <li>Que todos los cambios en los requerimientos sean comunicados a equipo de desarrollo y puestos en un documento que los describa</li>
  <li>Que las personas involucradas en el proyecto sepan de los cambios y sientan que su voz es escuchada, también registrando sus comentarios y sugerencias</li>
</ul>

<p>Es importante dejar la registro de la comunicación y las decisiones tomadas para que el
conocimiento del software sea accesible para todos.</p>

<h3 id="una-alternativa-design-documents">Una alternativa: Design Documents</h3>

<p>Los Design Documents son documentos que se usan en algunas big techs para documentar cómo se
va implementar una función. Como es natural, estos documentos son bastante técnicos y
algo tardados, pero incluyen por lo menos una descripción de la función que se quiere
implementar y <em>cómo se va a implementar</em>.</p>

<p>Están pensados para obtener consenso sobre la forma en la que se va a hacer algo y
son una buena idea si tienes un equipo de desarrollo maduro que puede llegar rápido
a compromisos para lograr implementar algo.</p>

<p>Un conjunto histórico de estos documentos, puede ser una buena alternativa para
documentar los requerimientos funcionales de un sistema.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Entender lo que necesitamos que haga nuestro software es el primer paso para crear
software útil. Los requisitos funcionales o funciones y su documentación son una herramienta
para mantener un registro histórico y asegurarnos de que entendemos lo que se requiere.
Esto también puede servir para obtener aprobación de las personas interesadas en que
el software se realice y evitar malentendidos en el futuro.</p>

<p>También facilitan la estimación de recursos y tiempos, y permiten un desarrollo más eficiente
y enfocado. Finalmente, mejoran la comunicación entre todas las partes involucradas.</p>

<p>Es importante dedicar el tiempo y esfuerzo necesarios para documentarlos adecuadamente
(en mi opinión más como una herramienta de entendimiento que como una obligación) y mantenerlos
actualizados durante la vida del proyecto. Un sistema bien diseñado comienza con funciones
bien definidas, entendidas y gestionadas.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="arquitectura" /><summary type="html"><![CDATA[El análisis de requerimientos es una parte fundamental del desarrollo de software y es importantísima para crear sistemas exitosos.]]></summary></entry><entry><title type="html">¿Qué es la programación asíncrona?</title><link href="https://blog.thedojo.mx/2024/10/31/que-es-la-programacion-asincrona.html" rel="alternate" type="text/html" title="¿Qué es la programación asíncrona?" /><published>2024-10-31T00:00:00-06:00</published><updated>2024-10-31T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/10/31/que-es-la-programacion-asincrona</id><content type="html" xml:base="https://blog.thedojo.mx/2024/10/31/que-es-la-programacion-asincrona.html"><![CDATA[<p>La programación asíncrona es uno de los primeros temas avanzados que encontrarás
al programar, especialmente si desarrollas aplicaciones web. Esto es aún más
común si haces <strong>JavaScript</strong>, que es un lenguaje que se usa en entornos de
ejecución asíncronos.</p>

<p>En este artículo la explicaremos para que puedas programar de manera asíncrona
con seguridad.</p>

<h2 id="por-qué-existe---el-caso-de-la-programación-asíncrona">¿Por qué existe? - El caso de la programación asíncrona</h2>

<p>Imagínate un proceso de la vida real en el que tengas una conjunto de recursos
limitados, que sean completamente necesarios para terminar el trabajo. Por ejemplo,
imagina que quieres hacer una comida especial, en la que necesitas usar un horno.
En el horno puedes poner un platillo a la vez, ya que requiere un tiempo y temperatura
específica. Pero este platillo especial tal vez va acompañado de una sopa que puedes
hacer mientras el platillo principal está en el horno.</p>

<p>En términos computacionales, estas dos tareas están sucediendo de manera concurrente,
aunque tú literalmente no estés haciendo ambas cosas al mismo tiempo. No vale la pena que
te sientes a esperar a que el lomo del horno esté listo para empezar a hacer la sopa.
Puedes hacer la sopa mientras esperas, ya que no ocupan los mismos recursos.</p>

<p>Exactamente pasa lo mismo en los programas de computadora, se tienen que ejecutar tareas
que usan recursos compartidos o lentos, como por ejemplo el sistema de archivos o la red.
En la programación web también se da que el programa está esperando la respuesta de el
usuario y mientras tanto puede seguir haciendo otras cosas. Aquí es donde entra la programación
asíncrona.</p>

<h2 id="qué-es-la-programación-asíncrona">¿Qué es la programación asíncrona?</h2>

<p>Para entenderla primero tenemos que entender la programación tradicional o
síncrona (creo que la palabra correcta en español es <em>sincrónica</em>).</p>

<p>En la programación tradicional, las cosas siempre suceden en un orden estricto:
una instrucción empieza y hasta que no se termina, no se ejecuta la siguiente.
Observa el siguiente código, en Python, para a abrir un arhivo:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">archivo.txt</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Archivo leído</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Log final</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>El resultado de este código es:</p>

<pre><code class="language-log">Archivo leído
Log final
</code></pre>

<p>En este código todo sucede de manera perfectamente secuencial.</p>

<p>Pero en lenguajes con programación asíncrona, esta operación que es tardada
en términos computacionales se puede hacer de manera asíncrona, es decir
fuera de orden.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">fs</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nf">readFile</span><span class="p">(</span><span class="dl">"</span><span class="s2">archivo.txt</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">utf8</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Archivo leído</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Esperando a que se lea el archivo</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>El resultado de este código es:</p>

<pre><code class="language-log">Esperando a que se lea el archivo
Archivo leído
</code></pre>

<p>Observa cómo en esta versión, el código que está ANTES: <code class="language-plaintext highlighter-rouge">console.log("Archivo leído")</code>,
se ejecuta DESPUÉS. Esto es una demostración de código asíncrono.</p>

<p>La explicación a esto está en que con la programación asíncrona podemos modificar
<strong>cuándo se ejecutan las cosas</strong>. Pero otra visión es que se pueden ejecutar cosas
en diferentes “lados” o “momentos” y tú elegir <strong>cuándo</strong> usas los resultados de
la ejecución.</p>

<p>Usamos este ejemplo de abrir un archivo porque por su naturaleza es lento (comparado)
con cálculos u operaciones comunes.</p>

<p>La <strong>programación asíncrona</strong> es un forma de ejecutar las acciones de tu programa en
la que no se espera siempre que una acción o instrucción termine para continuar
con el programa.</p>

<p>Como vimos en el primer ejemplo, en la programación síncrona (también llamada
<em>bloqueante</em> [blocking]), ninguna acción comienza hasta que le previa haya terminado.
En la programación asíncrona, con técnicas o palabras reservadas específicas le
indicamos al motor de ejecución que no es necesario a que una acción termine para
continuar con la siguiente, pero también le podemos decir qué hacer cuando la
acción termine. Por esto mismo, la programación asíncrona también se conoce como
<em>no bloqueante</em> (non-blocking).</p>

<h2 id="para-qué-sirve-la-programación-asíncrona">Para qué sirve la programación asíncrona</h2>

<p>Veamos las restricciones que tenemos, para entender por qué es útil. Cuando
creas un sistema, la velocidad de ejecución puede verse limitada por dos
categorías de cosas:</p>

<ul>
  <li>De los cálculos que estás haciendo</li>
  <li>De la información que estás obteniendo o guardando en algún lugar</li>
</ul>

<p>En el primer caso, llamamos a la ejecución <strong>CPU bound</strong> y en el segundo <strong>I/O bound</strong>.
En español me gusta llamarle <strong>limitado por el procesador</strong> y <strong>limitado por la entrada
y salida de datos</strong>.</p>

<h3 id="cpu-bound---limitado-por-la-cantidad-de-cálculos-que-puedes-hacer">CPU bound - limitado por la cantidad de cálculos que puedes hacer</h3>

<p>Cuando tu programa es pesado en los cálculos que tiene que hacer, como cuando
tienes que procesar multimedia, hacer multiplicación de matrices o cosas
similares, puedes decir que tu programa es <strong>CPU bound</strong>, o que está limitado por
el poder de procesamiento. Es decir, mientras más poderoso sea el procesador,
más rápido será tu programa. Esto también es cierto si tienes múltiples
procesadores <em>y puedes distribuir el cómputo entre ellos</em>, por ejemplo:</p>

<ul>
  <li>Si tienes un procesador con múltiples cores o múltiples hilos de ejecución físicos</li>
  <li>Si tienes múltiples computadoras en una red</li>
</ul>

<p>En el primer caso, necesitas una plataforma que te ayude a utilizar el poder
de procesamiento de los múltiples cores, sea implícitamente o explícitamente. Por
ejemplo plataformas como la <strong>máquina virtual de Erlang</strong> (llamada BEAM), automáticamente distribuyen
la carga en los múltiples cores disponibles. En otros lenguajes como en Python,
tienes que hacerlo explícitamente, pero incluso eso tiene limitaciones. Pero
esto que te estoy diciendo es <strong>programación concurrente</strong>.</p>

<p>La programación asíncrona se puede ver como una herramienta para manejar la
programación concurrente y hacerla más sencilla. Piénsala como en una capa de
abstracción sobre la programación concurrente, que te permite <strong>expresar de forma
explícita</strong> que otras partes del programa <em>pueden</em> estarse ejecutando en otro
tiempo o en otro <em>espacio</em> (proceso o hilo).</p>

<h3 id="io-bound---limitado-por-la-velocidad-de-entrada-y-salida-de-datos">I/O bound - limitado por la velocidad de entrada y salida de datos</h3>

<p>Cuando un programa consume o produce mucha información tiene que
ponerla en algún lugar. Este lugar puede ser:</p>

<ul>
  <li>La memoria RAM</li>
  <li>El disco duro (o sistema de archivos)</li>
  <li>La red (mandarla o pedirla a otra computadora)</li>
</ul>

<p>Cuando tu programa hace mucho esto, se dice que el programa está limitado por la
velocidad de entrada y salida de datos, o <strong>I/O bound</strong>.</p>

<p>La programación asíncrona te puede ayudar de manera más sencilla, sobre todo en
el caso de las peticiones de red. ¿Cómo? Justo en el ejemplo que vimos antes de abrir
un archivo: mientras esperas a que el disco duro lea el archivo y lo mande por el bus
de datos y se cargue en la memoria RAM (que son AÑOS computacionalmente hablando),
podemos seguir haciendo otras cosas. Igual que en el caso anterior, estos procesos
son concurrentes, y una de las maneras más sencillas de expresarlo es con la programación
asíncrona, en el que simplemente decimos que en algún momento <em>podemos</em> usar el resultado
de la lectura del archivo.</p>

<p>Exactamente pasa lo mismo en el caso de las peticiones de red (que son EONES comparadas con
la lectura de archivos o cálculos comunes). De hecho, el manejo de esas peticiones y de
todo lo relacionado con entrada y salida de datos es uno de los secretos de por qué
Node.js es tan bueno para manejar peticiones HTTP.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Entender la programación asíncrona es esencial en la programación moderna, muchos
lenguajes y sobre todo <em>entornos de ejecución</em> lo implementan. Entenderla y usarla
te ayudará a crear programas más eficientes y que cumplan con el rendimiento que
tus usuario esperan. En un artículo futuro veremos una comparación entre programación
asíncrona y programación concurrente manejada de otras maneras.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="async/await" /><category term="concurrencia" /><category term="javascript" /><summary type="html"><![CDATA[Entender la programación asíncrona es un requisito si eres un desarrollador de software que quiere sacar el mejor rendimiento de una computadora, hablemos de qué es y cómo dominarla.]]></summary></entry><entry><title type="html">¿Qué es la búsqueda binaria?</title><link href="https://blog.thedojo.mx/2024/10/26/que-es-la-busqueda-binaria.html" rel="alternate" type="text/html" title="¿Qué es la búsqueda binaria?" /><published>2024-10-26T00:00:00-06:00</published><updated>2024-10-26T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/10/26/que-es-la-busqueda-binaria</id><content type="html" xml:base="https://blog.thedojo.mx/2024/10/26/que-es-la-busqueda-binaria.html"><![CDATA[<p>Uno de los algoritmos más fáciles de entender, que incluso sin preparación
aplicamos en la vida real y que se enseña en las primeras clases de programación
es la <strong>búsqueda binaria</strong>. Vamos a hablar de este algoritmo y su relación
profunda con las ciencias de la computación y la información en general.</p>

<h2 id="búsqueda-binaria-en-la-vida-real">Búsqueda binaria en la vida real</h2>

<p>¿Alguna ves has jugado “Adivina Quién”? Es un juego de mesa en el
que cada jugador tiene un tablero con un conjunto de personajes con
características físicas distintas, como el color de pelo, diferentes
accesorios, y otros rasgos distintivos. Cada jugador escoge secretamente
un personaje y el otro lo tiene que adivinar, haciendo preguntas que
le permitan ir eliminando a los personajes que el otro jugador no ha elegido.
¿Cuál es la mejor estrategia para adivinar con la menor cantidad de
preguntas? Podrías pensar que es por cosas muy distintivas, por ejemplo,
si hay dos personajes con sombrero, y preguntas si tiene sombrero, puede
parecer una buena estrategia, pero no lo es.</p>

<p>En este caso, suponiendo que tenemos 40 personajes y solo dos tienen sombrero y
suponiendo que tienes 40 personajes, sólo 5% de las veces te ayudará reducir
significativamente el número de personajes, por lo que la mayoría de las veces
será una pregunta extra si la haces inicialmente. Lo mejor es empezar por las
características que dividan el conjunto de personajes en dos grupos más o menos
iguales. Por ejemplo, si hay 40 personajes y 20 tienen el pelo largo y 20 el corto,
la pregunta si el personaje tiene el pelo largo, te dejará con 20 personajes.
La siguiente pregunta debería ser algo similar.</p>

<p>Esto es exactamente lo que hace la búsqueda binaria, ir partiendo el conjunto
de elementos en dos grupos más o menos iguales e ir eliminando la mitad en cada
paso.</p>

<h2 id="búsqueda-binaria-en-la-computación">Búsqueda binaria en la computación</h2>

<p>El algoritmo de búsqueda binaria se aplica para encontrar un valor en una
colección <em>ordenada</em> de elementos. Esto es para tener una forma sencilla de
eliminar la mitad del espacio de búsqueda en cada paso. Y puedes pensar justamente
que la necesidad de tener que ordenar los elementos es precisamente una de sus
des</p>

<h2 id="implementación-en-pseudocódigo">Implementación en pseudocódigo</h2>

<p>Aquí puedes ver una implementación de la búsqueda binaria en pseudocódigo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>búsqueda_binaria(arreglo, elemento_buscado):
    inicio = 0
    fin = longitud(arreglo) - 1
    mientras inicio &lt;= fin:
        medio = (inicio + fin) // 2  # división entera

        si arreglo[medio] == elemento_buscado:
            retornar medio
        sino si arreglo[medio] &lt; elemento_buscado:
            inicio = medio + 1
        sino:
            fin = medio - 1
    retornar -1  # Elemento no encontrado
</code></pre></div></div>

<p>En pocas palabras, nombramos dos índices, <code class="language-plaintext highlighter-rouge">inicio</code> y <code class="language-plaintext highlighter-rouge">fin</code>, que van a ser
los que nos dicen en qué parte vamos a buscar. Después, calculamos el centro
de la lista, sumando el inicio y el fin y dividiendo entre dos. Otra forma de
calcularlo sería restando el inicio y el fin, dividiendo entre dos y sumándole
el inicio. Estas dos formas son equivalentes.</p>

<p>Ahora, comparamos el elemento buscado con el elemento en el centro. Si es igual,
hemos encontrado el elemento y terminamos. Si es menor, tenemos que agarrar 
la parte de la lista que está a la derecha, es decir, los elementos mayores.
Para esto, el inicio es un elemento a la derecha del medio (<code class="language-plaintext highlighter-rouge">inicio = medio + 1</code>)
y el fin se queda igual. Si el elemento buscado es mayor, tenemos que agarrar
la parte de lista que está a la izquierda, y ahora el que cambia es el fin.</p>

<p>De esta manera, en cada paso nuestro espacio de búsqueda se reduce a la mitad.</p>

<p>Si llegamos a un punto en el que el inicio es mayor que el fin, entonces no
encontramos el elemento y retornamos -1 (el -1 es una forma de que el
programa nos diga que no encontramos el elemento, muy usada en programación).</p>

<h2 id="complejidad">Complejidad</h2>

<p>Con un arreglo pequeño pensarás que la búsqueda binaria es más lenta una búsqueda
aleatoria o secuencial y así es, pero recuerda que los algoritmos eficientes
se notan cuando el tamaño de los datos crece.</p>

<p>Al ir cortando sucesivamente a la mitad el espacio de búsqueda, la complejidad
de la búsqueda binaria crece en forma logarítmica.</p>

<p>Expliquemos un poco eso. Un logaritmo es la función que nos ayuda a encontrar
el exponente al que hay que elevar un número para obtener otro. En la búsqueda
binaria, el número que queremos “obtener” (en verdad, es recorrer) es el número
de elementos en el arreglo que vamos a buscar.</p>

<p>Suponiendo que en cada paso hacemos más o menos 5 operaciones, por ejemplo,
para buscar en un arreglo de 1000 elementos y tomando en cuenta lo que hemos
visto de cómo se va reduciendo el espacio de búsqueda, tendríamos la siguiente
sucesión:</p>

<p>Elementos por buscar: 1000</p>

<p>Operaciones totales: 5</p>

<hr />

<p>Elementos por buscar: 500</p>

<p>Operaciones totales: 10</p>

<hr />

<p>Elementos por buscar: 250</p>

<p>Operaciones totales: 15</p>

<hr />

<p>Elementos por buscar: 125</p>

<p>Operaciones totales: 20</p>

<hr />

<p>Elementos por buscar: 62</p>

<p>Operaciones totales: 25</p>

<hr />

<p>Elementos por buscar: 31</p>

<p>Operaciones totales: 30</p>

<hr />

<p>Elementos por buscar: 15</p>

<p>Operaciones totales: 35</p>

<hr />

<p>Elementos por buscar: 7</p>

<p>Operaciones totales: 40</p>

<hr />

<p>Elementos por buscar: 3</p>

<p>Operaciones totales: 45</p>

<hr />

<p>Elementos por buscar: 1</p>

<p>Operaciones totales: 50</p>

<hr />

<p>Observa cómo es que el número de operaciones no creció al mismo ritmo que el número de
elementos. El número de operaciones creció sumó sólo 5 operaciones cada que duplicamos
el número de elementos. Aquí es donde está el logaritmo, como estamos duplicando o
multiplicando por dos, la base de nuestro logaritmo es el 2. ¿Cuánto “pasos” vamos a
tener que hacer? Cuantas veces tengamos que duplicar el número de elementos para llegar
al número total de elementos del arreglo en el peor de los casos. Esto es el logaritmo
base 2.</p>

<p>Así que la complejidad de la búsqueda binaria es \(O(\log n)\). Donde \(n\) es el
número de elementos en el arreglo.</p>

<h2 id="implementaciones">Implementaciones</h2>

<p>Vamos a ver dos implementaciones en Python, una iterativa y otra recursiva.</p>

<p>Empezamos con la iterativa:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">elemento_buscado</span><span class="p">):</span>
    <span class="n">inicio</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fin</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">inicio</span> <span class="o">&lt;=</span> <span class="n">fin</span><span class="p">:</span>
        <span class="n">medio</span> <span class="o">=</span> <span class="p">(</span><span class="n">inicio</span> <span class="o">+</span> <span class="n">fin</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">==</span> <span class="n">elemento_buscado</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">medio</span>
        <span class="k">elif</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">elemento_buscado</span><span class="p">:</span>
            <span class="n">inicio</span> <span class="o">=</span> <span class="n">medio</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fin</span> <span class="o">=</span> <span class="n">medio</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

</code></pre></div></div>

<p>Y la versión recursiva:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">elemento_buscado</span><span class="p">,</span> <span class="n">inicio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fin</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fin</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arreglo</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">inicio</span> <span class="o">&gt;</span> <span class="n">fin</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">medio</span> <span class="o">=</span> <span class="p">(</span><span class="n">inicio</span> <span class="o">+</span> <span class="n">fin</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">==</span> <span class="n">elemento_buscado</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">medio</span>
    <span class="k">elif</span> <span class="n">arreglo</span><span class="p">[</span><span class="n">medio</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">elemento_buscado</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">elemento_buscado</span><span class="p">,</span> <span class="n">medio</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arreglo</span><span class="p">,</span> <span class="n">elemento_buscado</span><span class="p">,</span> <span class="n">inicio</span><span class="p">,</span> <span class="n">medio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Debido a la sintaxis de Python, la versión recursiva es un poco más verbosa,
por el manejo que tienes que hacer de los parámetros por defecto, pero si no
fuera por eso, en general me gusta más la versión recursiva.</p>

<p>Finalmente, si quieres hacer un programa que funcione con esta forma de búsqueda,
tienes que asegurarte de que las inserciones en el arreglo sean ordenadas, una forma
sencilla es usar un algoritmo parecido para encontrar el lugar adecuado para insertarlo.</p>

<h2 id="uso-en-el-mundo-real">Uso en el mundo real</h2>

<p>Lo que vimos en la sección anterior es para que entiendas cómo funciona, pero
lenguajes como Python, Ruby y otros, probablemente ya tengan implementaciones de
este algoritmo muy común. Por ejemplo, en Python tenemos el módulo <code class="language-plaintext highlighter-rouge">bisect</code> que 
permite hacer lo mismo con muchas menos líneas. Ejemplo:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">bisect</span>

<span class="n">lista</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">elemento</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">indice</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">.</span><span class="nf">bisect_left</span><span class="p">(</span><span class="n">lista</span><span class="p">,</span> <span class="n">elemento</span><span class="p">)</span> <span class="c1"># en realidad nos dice el valor más pequeño que es mayor o igual al elemento buscado
</span>
<span class="c1"># si el índice es más grande que el número de elementos, no está en la lista
</span><span class="k">if</span> <span class="n">indice</span> <span class="o">!=</span> <span class="nf">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lista</span><span class="p">[</span><span class="n">indice</span><span class="p">]</span> <span class="o">==</span> <span class="n">elemento</span><span class="p">:</span> 
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">El elemento </span><span class="si">{</span><span class="n">elemento</span><span class="si">}</span><span class="s"> está en el índice </span><span class="si">{</span><span class="n">indice</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">El elemento </span><span class="si">{</span><span class="n">elemento</span><span class="si">}</span><span class="s"> no está en la lista</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Puedes ver más detalles del módulo <code class="language-plaintext highlighter-rouge">bisect</code> en la <a href="https://docs.python.org/3/library/bisect.html">documentación oficial</a>.</p>

<h2 id="conclusión">Conclusión</h2>

<p>La búsqueda binaria es uno de los algoritmos que todos los desarrolladores deberíamos conocer.
Espero que este artículo te haya ayudado a entender cómo funciona y su importancia.</p>]]></content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="algoritmos" /><category term="búsqueda" /><summary type="html"><![CDATA[Hablemos de un algoritmo sencillo que incluso utilizamos en la vida real pero que es muy importante en el mundo de la computación.]]></summary></entry></feed>