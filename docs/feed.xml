<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://blog.thedojo.mx/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.thedojo.mx/" rel="alternate" type="text/html" /><updated>2024-09-16T23:28:15-06:00</updated><id>https://blog.thedojo.mx/feed.xml</id><title type="html">The Dojo MX Blog</title><author><name>H√©ctor Patricio</name><uri>https://github.com/hectorip</uri></author><entry><title type="html">¬øC√≥mo funciona TensorFlow?</title><link href="https://blog.thedojo.mx/2024/09/16/como-funciona-tensorflow.html" rel="alternate" type="text/html" title="¬øC√≥mo funciona TensorFlow?" /><published>2024-09-16T00:00:00-06:00</published><updated>2024-09-16T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/09/16/como-funciona-tensorflow</id><content type="html" xml:base="https://blog.thedojo.mx/2024/09/16/como-funciona-tensorflow.html"><![CDATA[<p><strong>TensorFlow</strong> es una de las herramientas m√°s populares e influyentes
en el campo de la del aprendizaje autom√°tico. En este art√≠culo vamos a ver
qu√© es exactamente y c√≥mo funciona.</p>

<h2 id="qu√©-es-tensorflow">¬øQu√© es TensorFlow?</h2>

<p>Siempre que hablamos de TensorFlow se dice que es una ‚Äúbiblioteca (o librer√≠a)
para hacer aprendizaje autom√°tico, pero este definici√≥n no es muy
expl√≠cita y por eso vamos a ver <em>c√≥mo nos permite</em> crear modelos de
aprendizaje.</p>

<p>Para crear modelos de aprendizaje autom√°tico, tenemos que hacer muchos c√°lculos
matem√°ticos, la gran mayor√≠a son operaciones de multiplicaci√≥n de matrices.
Estos c√°lculos no son eficientes en un procesador tradicional y por eso se
requiere de toda la ayuda que se pueda conseguir para hacerlos lo m√°s r√°pido
posible y gastando menos energ√≠a.</p>

<p>Es aqu√≠ donde entra <strong>TensorFlow</strong>, una biblioteca que permite <em>representar</em> estos
c√°lculos mediante grafos de c√≥mputo y despu√©s ejecutarlos en procesadores
especializados como tarjetas gr√°ficas y otros procesadores eficientes en
operaciones matem√°ticas pesadas. Adem√°s, TensorFlow abstrae al usuario final (t√∫),
de los detalles de implementaci√≥n de muchas funciones y operaciones matem√°ticas
que se usan mucho en el aprendizaje autom√°tico. Y finalmente, con su <em>API</em> de alto
nivel, <strong>Keras</strong>, te permite crear diferentes tipos de redes neuronales sin
que tengas que pelearte con los detalles de implementaci√≥n.</p>

<p>Y es aqu√≠ donde empieza lo interesante. ¬øQu√© es un grafo de c√≥mputo? ¬øC√≥mo
llegamos a √©l y para qu√© nos sirve? Veamos.</p>

<h2 id="grafos-de-c√≥mputo-de-tensorflow">Grafos de c√≥mputo de TensorFlow</h2>

<p>Para entenderlo, vamos a ver un ejemplo sencillo de un c√°lculo y su
representaci√≥n, por ejemplo, sumemos dos n√∫meros, que llamaremos X y Y.</p>

<p>¬øC√≥mo representa TensorFlow esto? Este es el grafo de c√≥mputo que podemos ver con
una herramienta de an√°lisis de TensorFlow llamada TensorBoard:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_250/v1726379906/Screenshot_2024-09-14_at_23.53.34_1_izykn5.png" alt="Imagen de un grafo de c√≥mputo de TensorFlow" class="align-center" /></p>

<p>Puedes pensar en este grafo como una serie de nodos que representan cada uno
una operaci√≥n sobre conjuntos de datos num√©ricos llamados tensores. Cuando
ejecutamos este grafo, los tensores <em>fluyen</em> por estos nodos, transform√°ndose
en cada uno, hasta que obtenemos el resultado final de la operaci√≥n. (Los nodos
que dicen <code class="language-plaintext highlighter-rouge">Identity</code> son operaciones de copia o lectura de valores, √∫tiles para
el funcionamiento interno de  TensorFlow).</p>

<p>La otra cosa que podemos notar hasta abajo de la gr√°fica son los dos nodos que
representan nuestros n√∫meros simples: X scalar y Y scalar, ya que los definimos
como n√∫meros simples, que tambi√©n pueden pensarse como tensores de una dimensi√≥n.</p>

<p>Formalmente, TensorFlow te da una serie de estructuras de datos, que puedes
ir construyendo poco a poco para definir todas las operaciones que necesites hacer.</p>

<p>En una red neuronal, estos grafos son mucho m√°s complicados, pero justo ese es
el trabajo de TensorFlow: ayudarte a definirlos y a ejecutarlos en el hardware
m√°s conveniente para tu proyecto.</p>

<p>Usar los grafos de c√≥mputo de TF te permite varias cosas m√°s:</p>

<ul>
  <li><strong>Optimizaci√≥n de las operaciones</strong>: TensorFlow tiene todo un sistema de optimizaci√≥n
llamado <code class="language-plaintext highlighter-rouge">Grappler</code>, que se encarga varias optimizaciones.</li>
  <li><strong>Paralelizaci√≥n</strong>. Con las operaciones divididas, TensorFlow puede verificar
qu√© operaciones son independientes y puede ejecutarlas en otros procesadores
si est√°n disponibles.</li>
  <li><strong>Exportaci√≥n</strong>. Una vez teniendo las operaciones definidas en un grafo, no necesitamos
de Python para ejecutarlas, as√≠ que TensorFlow puede ejecutarlas en otros dispositivos
y usando otros lenguajes.</li>
</ul>

<p>Esta definici√≥n de grafos de c√≥mputo no es la √∫nica forma de trabajar con TensorFlow,
ya que desde su versi√≥n 2.0, tambi√©n permite trabajar con un modo m√°s imperativo,
que se siente m√°s integrado con Python y m√°s din√°mico: la ejecuci√≥n adelantada (en
ingl√©s: <em>eager execution</em>). Con esta forma de ejecuci√≥n, las operaciones se van
ejecutando inmediatamente despu√©s de definirlas. Esto es m√°s f√°cil de programar y
de leer, pero deja poco espacio para la optimizaci√≥n. Es justamente como la comparaci√≥n
entre un lenguaje compilado y uno interpretado.</p>

<h2 id="tensorflow-y-keras">TensorFlow y Keras</h2>

<p>Keras era otra biblioteca que se cre√≥ por separado, para hacer m√°s f√°cil de usar
la versi√≥n 1.0 de TensorFlow, que era bastante m√°s verbosa de programar (por s√≥lo
soportar grafos de c√≥mputo est√°ticos).Sin embargo, en la versi√≥n 2.0 de TensorFlow,
Keras se volvi√≥ parte del paquete.</p>

<p>Keras te permite crear modelos de aprendizaje profundo de manera sencilla. Es la
manera f√°cil de usar TensorFlow, pero tambi√©n te permite complicarte tanto como quieras
o necesites (esperamos que sea esto √∫ltimo). Keras usa el principio de ‚Äúrevelaci√≥n
progresiva de la complejidad‚Äù, lo que significa que puedes empezar de manera muy
sencilla e ir aprendiendo cosas conforme vayas avanzando en hacer cosas m√°s complejas.</p>

<p>As√≠ que la forma m√°s com√∫n de usar TensorFlow para crear tus modelos de machine
learning es mediante la interfaz de Keras, que adem√°s de todo te provee de
utilidades que son de uso muy com√∫n en las redes neuronales. Por ejemplo, provee
regularizadores, inicializadores, funciones de activaci√≥n, optimizadores, y muchas
utilidades m√°s. Es por eso que ya casi no se concibe el uso de TensorFlow para
casos comunes sin usar Keras.</p>

<h2 id="tensorflow-y-mlir">TensorFlow y MLIR</h2>

<p>MLIR es una herramienta para crear compiladores hecha por parte del mismo
equipo que hizo LLVM, la infraestructura para compiladores que est√° detr√°s
de la mayor√≠a de los compiladores modernos.</p>

<p>La especialidad de MLIR es hacer traducciones para arquitecturas de hardware no
tradicionales,usando un lenguaje intermedio multi-capa al que le puedes agregar
m√°s plugins para diferentes arquitecturas de ejecutores. MLIR es muy usado
para computaci√≥n de alto rendimiento, justamente la que necesitamos para
crear modelo de aprendizaje autom√°tico complejos en tiempos y con costos
razonables.</p>

<p>As√≠ que TensorFlow, aprovechando este sistema, usa MLIR para compilar los
grafos de c√≥mputo y los modelos para hardware espec√≠fico, para que se pueda
obtener el mejor rendimiento posible.</p>

<h2 id="tensorflow-y-su-relaci√≥n-con-el-hardware">TensorFlow y su relaci√≥n con el hardware</h2>

<p>Despu√©s de la secci√≥n anterior, es muy probable que la relaci√≥n de TF con
el hardware quede muy clara: TensorFlow ayuda a que se pueda compilar
de mejor manera el c√≥digo con los c√°lculos para poder ejecutarlo
en el hardware especializado.</p>

<p><strong>IF</strong> soporta gran variedad de tipos de hardware y es por eso que hasta el
momento es la biblioteca de machine learning con mejor soporte para
distribuir tus modelos en diferentes dispositivos, desde procesadores
especializados hasta que corran directamente en tu tel√©fono o navegador.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Si quieres hacer machine learning, lo m√°s probable es que tengas que
aprender TensorFlow, una herramienta muy √∫til para hacer los modelos usados
hoy.</p>

<p>Espero que lo que hablamos sobre TensorFlow en este art√≠culo te haya ayudado
a entenderlo un poco m√°s. En otro art√≠culo hablaremos de su competidor
m√°s directo: <strong>PyTorch</strong>.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="tensorflow" /><category term="machine-learning" /><category term="ai" /><category term="deep-learning" /><summary type="html"><![CDATA[TensorFlow permite crear modelos de aprendizaje autom√°tico sin que te tengas que plear con la forma en la que se hacen los c√°lculos en los ejecutores. Hablemos m√°s de c√≥mo funciona.]]></summary></entry><entry><title type="html">Por qu√© debes leer Designing Data-intensive Applications</title><link href="https://blog.thedojo.mx/2024/08/30/por-que-debes-leer-designing-data-intensive-applications.html" rel="alternate" type="text/html" title="Por qu√© debes leer Designing Data-intensive Applications" /><published>2024-08-30T00:00:00-06:00</published><updated>2024-08-30T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/08/30/por-que-debes-leer-designing-data-intensive-applications</id><content type="html" xml:base="https://blog.thedojo.mx/2024/08/30/por-que-debes-leer-designing-data-intensive-applications.html"><![CDATA[<p>Uno de los libros m√°s recomendados para todos los desarrolladores modernos
es ‚ÄúDesigning Data-intensive Applications‚Äù de <a href="https://martin.kleppmann.com/">Martin Kleppmann</a>.
En este art√≠culo corto vamos a hablar de por qu√© vale la pena leerlo.</p>

<h2 id="qui√©n-es-martin-kleppmann">¬øQui√©n es Martin Kleppmann?</h2>

<p><strong>Martin</strong> es un desarrollador, investigador, escritor y profesor de ciencias
de la computaci√≥n bastante prol√≠fico. Actualmente trabaja en la <a href="https://www.cst.cam.ac.uk/">Universidad
de Cambridge</a> y ha trabajado en empresas como
<a href="https://www.crunchbase.com/organization/rapportive">Rapportive</a>(que √©l fund√≥
y fue comprada por LinkedIn, y tambi√©n trabaj√≥ ah√≠).</p>

<p>Es tambi√©n al autor de <a href="https://roundrobin.pub/">Secret Colors</a>. Un libro de
criptograf√≠a de llave p√∫blica y llave privada para ni√±os, de la editorial
Round Robin.</p>

<p><strong>Kleppmann</strong> es un experto en todo lo que tiene que ver con estructuras
y manejo de datos. En el presente (2024), su inter√©s est√° en la
coordinaci√≥n de datos entre sistemas locales, es decir, el software
funciona principalmente en un dispositivo que puede estar o no
conectado a una red y despu√©s puede sincronizarse con otros sistemas
remotos, para adquirir m√°s funciones como respaldos o sincronizaci√≥n.</p>

<p>Pero su trabajo m√°s notable hasta el momento es <strong>Designing Data-intensive
Applications</strong> (<em>DDiA</em> a partir de ahora). Veamos por qu√©.</p>

<h2 id="de-qu√©-trata-designing-data-intensive-applications">¬øDe qu√© trata Designing Data-intensive Applications?</h2>

<p>Podemos resumir <em>DDiA</em> como un libro de dise√±o de software enfocado en los
datos y sus interacciones. Es un libro de dise√±o en el sentido amplio:
abarca desde la arquitectura de software, hasta la elecci√≥n de algoritmos
para lograr las caracter√≠sticas arquitect√≥nicas deseadas.</p>

<p>El libro tiene tres grandes partes:</p>

<ol>
  <li>
    <p>En la primera habla de los principios fundamentales de los sistemas que hacen
uso intensivo de datos. Habla de las caracter√≠sticas arquitect√≥nicas
que los sistemas intensivos es datos deben tener para ser usables. Tambi√©n
se sientan las formas b√°sicas de almacenar y representar datos a diferentes
niveles.</p>
  </li>
  <li>
    <p>En la segunda parte, se habla de sistemas distribuidos y sus implicaciones
y las dificultades que conllevan. Aqu√≠ se tratan temas como replicaci√≥n,
particiones y transacciones. Tambi√©n se tratan los temas fundamentales para
tener datos confiables: consistencia y consenso.</p>
  </li>
  <li>
    <p>Aqu√≠ se habla de sistemas que derivan datos de otros datos, como √≠ndices,
caches y cosas similares, como puedes notar, elementos que son fundamentales
en cualquier sistema de software serio moderno.</p>
  </li>
</ol>

<p>Se habla de todo lo necesario para aprender el manejo
de grandes cantidades de datos, desde las formas de modelarlos y almacenarlos,
hasta distribuirlos y procesarlos para crear subproductos √∫tiles.</p>

<h2 id="el-estilo-del-libro">El estilo del libro</h2>

<p>DDiA tiene un estilo bastante relajado, nada acercado a la academia, m√°s bien,
es amigable y f√°cil de leer. Adem√°s tiene un poco de humor sutil que har√° el libro
todav√≠a m√°s disfrutable.</p>

<p>Para complementar, el libro tiene im√°genes, algunas dibujadas a mano que
te ayudan a ubicarte en el gran esquema de todas las ideas que trata.</p>

<p>As√≠ que si te preocupa que sea un libro denso, para nada lo es.</p>

<h2 id="qu√©-beneficios-obtendr√°s-al-leerlo">Qu√© beneficios obtendr√°s al leerlo</h2>

<p>Si eres un desarrollador de software con experiencia, especialmente en el
backend, podr√°s profundizar tu experiencia en el entendimiento de la forma
en la que se tratan los datos para crear sistemas confiables, escalables y
mantenibles. Toma en cuenta que este libro, como su nombre lo dice
est√° enfocado en el <strong>dise√±o</strong>. Este libro te dar√° ideas pr√°cticas para
aplicarlas a tus proyectos.</p>

<p>Si est√°s en cualquier otra √°rea del desarrollo de software, este libro te
ayudar√° a entender mejor c√≥mo funciona la capa de almacenamiento de datos
en cualquier sistema y puede ayudarte a hacerlo mejor en tu √°rea, porque
en todas las capas y √°reas del desarrollo necesitamos tratar con datos,
a veces poco, a veces mucho.</p>

<h2 id="conclusiones">Conclusiones</h2>

<p>Si quieres leer un libro sobre dise√±o de software, no puedes fallar con
<strong>Designing Data-intensive Applications</strong>. Vale mucho m√°s la pena que otros
libros de dise√±o de software por su profundidad y practicidad, adem√°s de
que te va a dar de qu√© platicar con otros desarrolladores de software
que pueden estar en el mismo camino de desarrollo profesional que t√∫.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="Matin-Kleppmann" /><category term="dato" /><category term="bases-de-datos" /><summary type="html"><![CDATA[Platiquemos de uno de esos libros que todo desarrollador sabe que debe leer, que puede ayudarte a entender las aplicaciones modernas.]]></summary></entry><entry><title type="html">Alternativas a Git</title><link href="https://blog.thedojo.mx/2024/07/18/alternativas-a-git.html" rel="alternate" type="text/html" title="Alternativas a Git" /><published>2024-07-18T18:00:00-06:00</published><updated>2024-07-18T18:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/07/18/alternativas-a-git</id><content type="html" xml:base="https://blog.thedojo.mx/2024/07/18/alternativas-a-git.html"><![CDATA[<p>Git es una herramienta que se considera <em>obligatoria</em> para los desarrolladores
modernos por ser el programa usado para versionamiento de c√≥digo usado por
la mayor√≠a de los proyectos.</p>

<p>Pero no es ning√∫n secreto que Git es una herramienta dif√≠cil de comprender y
que el 90% de los desarrolladores le dan <strong>el uso m√°s b√°sico</strong>, temiendo romper algo
y por eso tener que usar comandos m√°s avanzados.</p>

<p>Hablemos de por qu√© es as√≠ y despu√©s veamos algunas alternativas interesantes.</p>

<h2 id="los-or√≠genes-de-git">Los or√≠genes de Git</h2>

<p>Al igual que otros sistemas de control de versiones, Git naci√≥ como soporte al
desarrollo de uno de los proyectos de software m√°s importantes de todos los
tiempos: el kernel de Linux. Fue creado por <strong>Linus Torvalds</strong>.</p>

<p>Su objetivo no era ser una herramienta de uso masivo y f√°cil de usar, sino
trabajar sin las limitantes de las herramientas que exist√≠an en ese momento.
Y claramente, Linus lo cre√≥ a su manera. Algo interesante es que se llama
‚ÄúGit‚Äù porque en ingl√©s brit√°nico es una palabra despectiva que se usa para
llamar a alguien tonto o desagradable. Linus nombra sus proyectos como a s√≠
mismo, y como cualquiera lo podr√≠a llamar as√≠ a √©l, decidi√≥ ponerle ese nombre
a su sistema de manejo de versiones.</p>

<p><strong>Git</strong> empez√≥ a ser usado por la comunidad de Linux en 2005 y despu√©s por otros
proyectos Open Source, pero su √©xito se dispar√≥ cuando en 2008 surgi√≥ GitHub
que facilit√≥ su uso. Por ser una herramienta tan √∫til, ahora la tenemos como el
est√°ndar en versionmiento de c√≥digo.</p>

<p>Pero no es el √∫nico sistema de control de versiones moderno, hablemos de
dos alternativas.</p>

<h2 id="fossil">Fossil</h2>

<p>Fossil fue creado por el autor de SQLite, <a href="https://www.hwaci.com/drh/"><strong>Richard Hipp</strong></a>, y al igual que Git,naci√≥
para soportar a este proyecto de software libre, el principal de su Hipp.</p>

<p>Al buscar un sistema de control de versiones moderno, Richard no encontr√≥ nada que lo convenciera
al cien por ciento, por lo que decidi√≥ crear Fossil, con las siguientes caracter√≠sticas:</p>

<ol>
  <li><strong>Integraci√≥n de Wiki y Tickets</strong>: Fossil tiene incluye estas herramientas a las que Hipp y
su equipo estaban acostumbrados.</li>
  <li><strong>Foro y chat</strong>: Fossil est√° pensado para tambi√©n ser el centro de conversaci√≥n del proyecto.</li>
  <li><strong>Autosync</strong>: permite que los cambios se sincronicen autom√°ticamente sin tener que andar haciendo
magia con las ramas y los commits.</li>
</ol>

<p>Personalmente, me gusta mucho la idea de tener todo integrado en un mismo
sistema, y pienso que el que sistemas como Jira y Confluence se integren directamente
con GitHub, Bitbucket y cosas similares, es una se√±al de que esta integraci√≥n
es un muy buena idea que ayuda a que el proceso de software sea m√°s fluido.</p>

<p>Puedes encontrar m√°s informaci√≥n en <a href="https://fossil-scm.org/">fossil-scm.org</a>,
para instalarlo por tu cuenta. Pero tambi√©n existe una versi√≥n hosteada en la
que de manera gratuita podr√°s tener el servicio de Fossil, equivalente a
GitHub: <a href="https://chiselapp.com/">Chisel</a>.</p>

<h2 id="pijul">Pijul</h2>

<p>Pijul es un sistema de control de versiones pensado para ser lo m√°s f√°cil de usar.
Tiene un fundamento matem√°tico: la teor√≠a de parches (patch theory), lo cu√°l te da
garant√≠as interesantes, como la facilidad de uso y la reducci√≥n de errores
catastr√≥ficos. Combina las dos formas principales en las que se han creado sistemas
control de versiones: los sistemas basados en spapshots (como la mayor√≠a de los
sistemas de control de versiones m√°s conocidos, incluido Git) y los sistemas
basados en parches (como <a href="https://darcs.net/">Darcs</a>, un SVC poco conocido pero
m√°s f√°cil de usar).</p>

<p>Los sistemas basados en snapshots son m√°s r√°pidos pero m√°s fr√°giles y dif√≠ciles de
usar y los basado en parches son lentos. Es por eso que Pijul cobina lo mejor de ambos
tipos de sistemas y mientras se mantiene lo suficientemente r√°pido sigue siendo f√°cil
de usar incluso en situaciones en las que Git se vuelve complejo, como en merges,
conflictos y cherry-picks. En un post posterior hablaremos ge Pijul.</p>

<p>Puedes encontrarlo en <a href="https://pijul.org/">pijul.org</a>, te recomiendo
que si quieres probar algo fundamentalmente diferente a Git, pero con las mismas
funciones externas, le des una oportunidad.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>No vamos a reemplazar a Git en el corto plazo y probablmente nunca lo hagamos
por lo extendido que est√° su uso (piensa en el efecto Lindsey), pero es bueno
saber que existen alternativas. Estas herramientas
nos ense√±an cosas interesantes sobre el desarrollo de software, como que casi
siempre hay m√°s de una forma de lograr lo que queremos.
Ojal√° que en el futuro, Git tome algunas de las ideas de estos proyectos y mejore su
experiencia de usuario.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="git" /><category term="version-control" /><category term="fossil" /><category term="pijul" /><summary type="html"><![CDATA[Git es una herramienta compleja, ya que no fue pensada desde el principio para tener buena experiencia de usuario, veamos algunas alternativas.]]></summary></entry><entry><title type="html">5 pl√°ticas de StrageLoop que tienes que ver</title><link href="https://blog.thedojo.mx/2024/03/30/5-platicas-de-strageloop-que-tienes-que-ver.html" rel="alternate" type="text/html" title="5 pl√°ticas de StrageLoop que tienes que ver" /><published>2024-03-30T00:00:00-06:00</published><updated>2024-03-30T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/03/30/5-platicas-de-strageloop-que-tienes-que-ver</id><content type="html" xml:base="https://blog.thedojo.mx/2024/03/30/5-platicas-de-strageloop-que-tienes-que-ver.html"><![CDATA[<p><em>StrangeLoop</em> fue una de las mejores conferencias de tecnolog√≠a del mundo
porque en ella se tratan temas poco comunes relacionados con la
computaci√≥n, el desarrollo de software e incluso el arte, y lo mejor: la
combinaci√≥n entre entras cosas.</p>

<p>Si te gusta reflexionar sobre temas profundos de la computaci√≥n,
te recomiendo mucho que le eches un ojo a las pl√°ticas de esta conferencia,
la mayor√≠a est√°n disponibles en su canal de
<a href="https://youtube.com/@StrangeLoopConf">YouTube</a>.</p>

<p>En este art√≠culo te recomendar√© cinco de las que me han parecido las mejores
pl√°ticas de la conferencia. Todas est√°n en ingl√©s, aunque parece que puedes poner
traducci√≥n autom√°tica en YouTube. Empecemos.</p>

<h2 id="el-desastre-en-el-que-estamos-metidos---joe-armstrong">El desastre en el que estamos metidos - Joe Armstrong</h2>

<p>Esta es la pl√°tica m√°s representativa de todas las ediciones de StrangeLoop.
Su t√≠tulo original es <strong>‚ÄúThe Mess We‚Äôre In‚Äù</strong>.
<strong>Joe Armstrong</strong> fue el creador del lenguaje Erlang y una gran figura en la
industria del desarrollo de software, co-creador del lenguaje Erlang y de su m√°quina
virtual, que a√∫n hoy siguen esando adelantados a su tiempo.</p>

<p>Joe habla de lo complejo que es el ambiente en el que los desarrolladores
trabajamos, record√°ndonos la complejidad de las computadoras.
La pl√°tica nos hace ver por qu√© es un milagro que existan sistemas funcionales
y lo fr√°giles que son.</p>

<p>Armstrong explora varios problemas, inclu√≠do el problema medioambiental
que las computadoras pueden generar con su consumo de energ√≠a.</p>

<p>Esta imagen tiene un resumen de los problemas que menciona:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_1200/v1709865988/Screenshot_2024-03-07_at_20.40.20_vsidm5.png" alt="Resumen de la charla de Joe Armostrong" class="align-center" /></p>

<p>Si quieres cobrar conciencia o recordar la complejidad a la que nos 
enfrentamos, pero sobre todo entender  puedes ver la charla aqu√≠: <a href="https://www.youtube.com/watch?v=lKXe3HUG2l4">The Mess We‚Äôre In</a></p>

<h2 id="deja-de-escribir-programas-muertos---jack-rusher">Deja de escribir programas muertos - Jack Rusher</h2>

<p><strong>Jack Rusher</strong> nos habla de c√≥mo muchas de las cosas a las que ya estamos
acostumbrados como programadores en realidad son cosas que hemos heredado de las
limitaciones que ten√≠amos en el pasado, y que no hemos hecho el esfuerzo por cambiar.</p>

<p>Gran parte de lo que hacemos y creemos muy normal son f√≥siles de que nos tienen
atados al pasado, pero ahora tenemos la capacidad de hacer muchas cosas m√°s
din√°micas e interesantes.</p>

<p>Esta pl√°tica te puede abrir la mente respecto a nuevas formas de programar y
te presenta entornos modernos, din√°micos y no convencionales que pueden cambiar
la forma en la que trabajamos.</p>

<p>La puedes ver aqu√≠: <a href="https://youtu.be/8Ab3ArE8W3s?si=7MprB-mKxO0M4-A0">Stop Writing dead programs</a></p>

<h2 id="desarrollo-de-juegos-en-8-bits---kevin-zurawel">Desarrollo de juegos en 8 bits - Kevin Zurawel</h2>

<p>El desarrollo de software siempre ha estado limitado por el hardware en el
que se va a ejecutar, pero como la mayor√≠a de veces las computatadoras
son mucho m√°s poderosas de lo que necesitamos, no nos damos cuenta la mayor√≠a
de los desarrolladores de software.</p>

<p>El desarrollo de juegos para plataformas antiguas (claro, modernas en su tiempo)
presentaba retos muy interesantes para los desarrolladores, de los cu√°les
podemos aprender sobre todo para tener idea de los compromisos que se
tienen que hacer para lograr cosas incre√≠bles para la √©poca.</p>

<p>Kevin Zurawel es un experto en desarrollo de juegos y actualmente tiene una
p√°gina dedicada al desarrollo de juegos retro llamada <a href="https://famicom.party/">Famicom.party</a>.</p>

<p>Si quieres aprender m√°s sobre el desarrollo de software en condiciones
extremadamente limitadas puedes verla aqu√≠:
<a href="https://youtu.be/TPbroUDHG0s?si=clvg5je8GDoC4dMS">Game Development in Eight Bits</a></p>

<h2 id="haciendo-f√°ciles-las-cosas-dif√≠ciles---julia-evans">Haciendo f√°ciles las cosas dif√≠ciles - Julia Evans</h2>

<p>Saber explicar cosas complejas es una de las habilidades m√°s importantes que
se pueden tener como miembro de un equipo de desarrollo. <a href="https://jvns.ca/">Julia Evans</a>
es una de las mejores personas en el mundo en hacer esto.</p>

<p><strong>‚ÄúAlgunas veces me tardo 10 a√±os en aprender cosas b√°sicas‚Äù</strong>, dice Julia en
esta conferencia, y creo que es algo con lo que todos nos podemos
idenfificar, porque todos nos enfrentamos con este ripo de situaciones.</p>

<p>Durante la pl√°tica, Julia analiza el comportamiento de herramientas
que usamos continuamente, nos hace ver c√≥mo tinen un comportamiento
no esperado y c√≥mo podemos mejorar nuestro <strong>entendimiento</strong>.</p>

<p>Tambi√©n nos habla de la importancia de usar herramientas que reduzcan
la carga cognitiva mediante permitirte la inspecci√≥n detallada de lo que
est√° pasando.</p>

<p>Julia Evans es una gran contribuidora a la comunidad de desarrollo de
software con sus explicaciones y herramientas esclarecedoras sobre
temas comunes pero a la vez complejos del desarrollo de software.</p>

<p>Si quieres aprender m√°s sobre c√≥mo simplificarte las cosas complejas 
del desarrollo de software, puedes ver la charla aqu√≠:
<a href="https://youtu.be/30YWsGDr8mA?si=8j32cj6MKGXRQRoX">Making hard things easy</a></p>

<h2 id="una-probadita-de-tipos-dependientes---david-christiansen">Una probadita de tipos dependientes - David Christiansen</h2>

<p>Los sistemas de tipos siempre han sido algo que causa fuertes reacciones
en los programadores, sea en contra o a favor. Mi teor√≠a es que la mayor√≠a
de las personas que los odian es porque no han (o hemos) trabajado con un buen
sistema de tipos.</p>

<p>Hay lenguajes con sistemas de tipos muy avanzados que te permiten de verdad
hacer cosas √∫tiles, y los m√°s avanzados son los que tienen <strong>sistemas de
tipos dependientes</strong>. Estos sistemas de tipos te permiten crear dise√±os con
tus programas de tal manera que el compilador puede comprobar muchas cosas
por adelantado.</p>

<p>Si nunca has escuchado de ellos, esta pl√°tica es una muy buena introducci√≥n
junto con una colecci√≥n de lenguajes que los tienen.Puedes verla aqu√≠:
<a href="https://youtu.be/VxINoKFm-S4?si=rG-zQi0P3Sl6fMSb">A Little Taste of Dependent Types</a>.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Aprender de los grandes presentadores y pensadores que han presentado en StrangeLoop
es una gran idea que no tiene ning√∫n costo. No te pierdas la oportunidad de dejar que
te hagan pensar en cosas profundas de tu profesi√≥n, y que te lleven por lugares
que tal vez ni siquiere hab√≠as pensado que exist√≠an.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="talks" /><category term="charlas" /><category term="strangeloop" /><category term="software-engineering" /><summary type="html"><![CDATA[StrangeLoop es una de las conferencias m√°s importantes de software en el mundo, con pl√°ticas incre√≠bles. Aqu√≠ ver√°s 5 pl√°ticas que no te puedes perder.]]></summary></entry><entry><title type="html">¬øQu√© producimos los desarrolladores de software?</title><link href="https://blog.thedojo.mx/2024/03/09/que-producimos-los-desarrolladores-de-software.html" rel="alternate" type="text/html" title="¬øQu√© producimos los desarrolladores de software?" /><published>2024-03-09T00:00:00-06:00</published><updated>2024-03-09T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2024/03/09/que-producimos-los-desarrolladores-de-software</id><content type="html" xml:base="https://blog.thedojo.mx/2024/03/09/que-producimos-los-desarrolladores-de-software.html"><![CDATA[<p>Para algunos, la respuesta a la pregunta del t√≠tulo es simplemente ‚Äú<em>software</em>‚Äù,
porque parece tan obvia que el mismo nombre lo dice. Y aunque el <strong>software</strong>
tiene una definici√≥n concreta, en este art√≠culo vamos a desmunazar los productos
de un proceso de desarrollo de software. Lo que quiero que veas es que el
desarrollo de software no s√≥lamente es crear programas que fucncionen, ya
que para que el software sea efectivo tiene que <strong>evolucionar</strong>, y aqu√≠
entra el punto importante.</p>

<h2 id="qu√©-es-un-sistema-de-software">¬øQu√© es un sistema de software?</h2>

<p>Un sistema de software incluye varias cosas, algunas obvias, otras no tanto.
Vamos a analizar de la m√°s a la menos visible.</p>

<h3 id="el-software-corriendo">El software corriendo</h3>

<p>Esta es la parte m√°s visible y en la que muchos se quedar√≠an. El software en
ejecuci√≥n significa una computadora ejecutando instrucciones que cumplan con
el prop√≥sito del software. Si pudi√©ramos hacer que la computadora ejecutara lo
que necesitamos de mnanera m√°gica, sin tener que darle instrucciones a sus
diferentes partes, esta parte seguir√≠a existiendo.</p>

<p>Ejemplos del software en ejecuci√≥n son:</p>

<ul>
  <li>Una <strong>p√°gina web</strong> mostrando la infomaci√≥n que un cliente necesita</li>
  <li><strong>Word</strong> recibiendo las instrucciones de tu teclado y mostrando lo que escribes
en la pantalla</li>
  <li><strong>grep</strong> buscando la expresi√≥n regular que quieres encontrar en un conjunto de documentos</li>
</ul>

<p>A veces, dependiendo del proceso pactado, no entregamos el software corriendo, sino entregamos
<em>artefactos</em> que tienen que ser ejecutados para poner el software corriendo.</p>

<h3 id="ejecutables">Ejecutables</h3>
<p>Los ejecutables son los <em>artefactos</em> que hacen que sea posible realizar las tareas que 
pensamos para nuestro software. Estos artefactos pueden tomar muchas formas,
por ejemplo, pueden ser archivos compilados .exe, empaquetados .dmg (de MacOS),
o incluso compilados que contienen instrucciones para una arquitectura de procesador
espec√≠fica.</p>

<p>En el caso de lenguajes y plataformas interpretadas los ejecutables son
directamente el c√≥digo fuente, que adem√°s requieren que el usuario final tenga
un entorno preparado en su computadora para poder correrlo.</p>

<h3 id="c√≥digo-fuente">C√≥digo fuente</h3>
<p>El c√≥digo fuente, <em>para mi</em>, es la parte medular de los resultados de un proceso de desarrollo
de software. Tiene la informaci√≥n necesaria para realizar las tareas que el software
tiene que hacer y tras pasar por un proceso (compilaci√≥n, empaquetamiento, despliegue, etc),
se pueden producir los ejecutables que dar√°n vida al software ejecut√°ndose.</p>

<p>El entregar el c√≥digo fuente al usuario final depender√° del acuerdo comercial al que se 
llegue al inciar el proyecto (por ejemplo, le podemos entregar el puro ejecutable como hace
la mayor√≠a del software comercial o de fuente cerrada), pero tambi√©n podr√≠amos entregar 
el c√≥digo fuente entero para que la persona que lo recibe pueda hacer cosas importantes:</p>

<ul>
  <li>Revisarlo: con el fin de que el software cumpla exactamente con lo que se desea y no tenga
funciones ocultas no deseadas</li>
  <li>Extenderlo: crear nuevas funciones o mejorar las existentes</li>
  <li>Repararlo: si se encuentra alguna falla, eliminarla</li>
  <li>Mantenerlo: A veces, las dependencias del software van quedando desactulizadas y hay que hacer
modificaciones en este para que siga funcionando</li>
  <li>Actualizarlo: llevarlo a nuevas versiones de su lenguaje o hacer que compile o produzca ejecutable
para nuevas plataformas</li>
</ul>

<p>Como puedes ver, si quieres que tu software evolucione y se adapte a nuevas necesidades o incluso
simplemente para que se mantenga funcional a trav√©s del tiempo, lo ideal es que tengas
el c√≥digo fuente a tu disposici√≥n. Es aceptado que el c√≥digo funete debe incluir un conjunto de pruebas
autom√°ticas que permitan verificar su funcionamiento m√°s eficientemente. Estas prubas pueden incluir:</p>

<ul>
  <li>Pruebas unitarias: las que prueban las unidades m√°s b√°sicas del c√≥digo, como funciones o m√©todos</li>
  <li>Pruebas de integraci√≥n: corren el sistema como si fueran un usuario y permiten verifcar que funcione correctamente</li>
</ul>

<p>Pero el c√≥digo fuente no basta para que el mantenimiento a trav√©s del tiempo sea √≥ptimo.</p>

<h3 id="documentaci√≥n">Documentaci√≥n</h3>
<p>Esta palabra tan temida por los desarrolladores de software en realidad es uno de nuestos
productos y a la vez insumos m√°s importantes. La documentaci√≥n es informaci√≥n sobre el 
software puesta en un lugar persistente.</p>

<p>Esta documentaci√≥n debe incluir por lo menos:</p>

<ol>
  <li>Explicaci√≥n de lo que el sistema hace. Es lo que le llamar√≠amos ‚Äúlos requerimientos‚Äù.</li>
  <li>Dise√±o del sistema: Se habla de c√≥mo est√° construido el sistema, por qu√© se pens√≥ de esta forma y c√≥mo
eso cumple con lo que se requer√≠a. Incluye la arquitectura a diferentes niveles y el registro de las decisiones
junto con su justificaci√≥n.</li>
  <li>Documentaci√≥n t√©cnica. En esta parte se habla de la tecnolog√≠a usada: los lenguajes usados, las plataformas
sobre las que corre, las bases de datos, los sistemas operativos etc. Adem√°s una buena idea es incluir
las bases sobre las que se escogieron estos elementos.</li>
  <li>Documentaci√≥n para desarrolladores. Esta es la documentaci√≥n que habla de lo que un desarrollador
tiene que hacer para seguir desarrollando el proyecto o para hacer que el software se ejecute, sea 
desplegarlo en un sistema de usuario final o producir los ejecutables. Esta documentai√≥n incluye la 
documentaci√≥n del c√≥digo en el que se describe su funcionamiento interno y el dise√±o que tiene.</li>
  <li>Manual de usuario. Opcional, pero dependiendo de la complejidad de las fucniones que el softwae haga
y de su intefaz, puede convertise en un elemento absolutamente necesario. En este se describen
a detalle las cosas que el usuaio puede hacer y las consecuencias de estas acciones.</li>
</ol>

<p>Hasta aqu√≠ se quedar√≠an algunos, ¬øpero podemos ir m√°s all√°? Sobre todo pensemos en que, para que el software
sea exitoso, necesita evolucionar. ¬øQui√©n crea nuevo c√≥digo?</p>

<h3 id="un-equipo-funcional">Un equipo funcional</h3>
<p>En teor√≠a, con todo lo anterior cualquier desarrollador de software podr√≠a tomar un proyecto y seguirlo evolucionando,
pero esta teor√≠a se queda lejos de la pr√°ctica por varias razones. La primera es que necesariamente
todos los artefactos anteriores van a tener defectos o estar incompletos, por lo que para que un nuevo
equipo o desarrllador tome el proyecto requerir√° hacer lo que llamamos <strong>‚Äúarqueolog√≠a de software‚Äù</strong>, intentando completar
y entender las decisiones no documentadas y todas las dem√°s partes de informaci√≥n faltantes.</p>

<p>A√∫n si los artefactos producidos estuvieran completos, el que un nuevo equipo tome el proyecto requiere tiempo y
esfuerzo para estudiarlos y empezar a producir nuevas funciones o a corregir errores. Si queremos que 
el proceso de desarrollo continue r√°pidamente, lo mejor es que el equipo que lo desarroll√≥ lo siga evolucionando.</p>

<p>Los mejores proyectos de software incluyen a un grupo de personas  que conocen la forma de desarrollo m√°s 
eficiente, las partes delicadas del proyecto, los fallos pendientes por componer, y las cosas que le faltan.</p>

<p>Adem√°s, este grupo de personas tienen una forma de trabajar y de coordinaci√≥n eficiente que puede ayudarlos
a ser m√°s productivos.</p>

<p>Con esto podemos concluir que el resultado del proceso de desarrollo de software no es solo una serie de artefactos,
sino que tambi√©n puede inlcuir a un equipo de personas que sereian los m√°s adecuados para seguirlo desarrollando.</p>

<p>Pero hablemos de un elemento no tangible.</p>

<h3 id="nuevo-conocimiento">Nuevo conocimiento</h3>

<p>Siempre que alguien escribe software, su mente se modifica de tal manera que volver a su estado
anterior es imposible. Este nuevo estado en el que la mente del programador se encuentra
contine informaci√≥n sobre el problema que acaba de resolever, de tal manera que si 
desapareciera todo el c√≥digo fuente y toda la documentaci√≥n junto con los ejecutables, para 
este desarrollador no ser√≠a tan desastroso porque volver a producrilos le tomar√≠a una 
fracci√≥n del tiempo que ya gast√≥ en hacerlos.</p>

<p>Esta modificaci√≥n en la mente de las personas es un elemento no visible pero sin duda valioso,
que permite crear cada vez software m√°s complejo y con mayores capacidades.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>
<p>El proceso de desarrollo de software no s√≥lamente produce software corriendo o ejecutables.
Nuestro trabajo produce otras cosas de valor de las que deber√≠amos ser conscientes y buscar 
optimizar, evitando la simpleza de pensar que lo √∫nico que vale es el software corriendo, que c√≥mo puedes ver en este
art√≠ulo, es una parte m√≠nima de todo el valor que puedes producir, eso sin contar el valor que 
tu software produce al ser ejecutado por las personas que le pueden sacar provecho.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="software" /><category term="ingenieria-de-software" /><category term="arquitectura" /><summary type="html"><![CDATA[Tu proceso de desarrollo de software produce muchas m√°s cosas que s√≥lamente software corriendo. En este art√≠culo hablaremos de otros resultados de trabajo]]></summary></entry><entry><title type="html">Engines de JavaScript y sus usos</title><link href="https://blog.thedojo.mx/2023/12/14/engines-de-javascript-y-sus-usos.html" rel="alternate" type="text/html" title="Engines de JavaScript y sus usos" /><published>2023-12-14T00:00:00-06:00</published><updated>2023-12-14T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/12/14/engines-de-javascript-y-sus-usos</id><content type="html" xml:base="https://blog.thedojo.mx/2023/12/14/engines-de-javascript-y-sus-usos.html"><![CDATA[<p>Ya hemos explicado antes qu√© es un <a href="/2020/05/17/que-es-un-engine-de-javascript.html">engine de JavaScript</a>. Como resumen, es el programa encargado de correr tus programas de JavaScript: recibe tus archivos o c√≥digo de JS y ejecuta las acciones en el sistema operativo en el que se est√° ejecutando.</p>

<p>Estos engines actualmente son programas complejos que no solamente interpretan el c√≥digo, sino que lo analizan y compilan a c√≥digo m√°quina para que sea m√°s eficiente su ejecuci√≥n.</p>

<p>En este art√≠culo vamos a hablar de algunos engines de JavaScript populares y en d√≥nde puedes encontrar su c√≥digo o sus ejecutables para que los puedas usar. Pero antes hablemos de la utilidad que puede tener un motor de JS fuera de un navegador.</p>

<h2 id="usos-de-un-motor-de-js">Usos de un motor de JS</h2>

<p>A veces, queremos darle a nuestros usuarios una manera de ejecutar c√≥digo de manera arbitraria o de modificar el sistema mediante instrucciones que ellos mismos metan en nuestras plataformas o programas. En vez de crear todo un lenguaje o de implementar nuestro propio compilador o int√©rprete, podemos embeber o incluir un motor de un lenguaje conocido y con implementaciones robustas y disponibles para su uso. <strong>Esta es exactamente el caso de uso que los engines de JS que podemos encontrar implementados cumplen</strong>.</p>

<p>Un ejemplo de qui√©n usa engine fuera de un navegador es un proyecto que ha cambiado el mundo del desarrollo web y que es muy popular: <strong>NodeJS</strong>, es un entorno de ejecuci√≥n de JavaScript que se basa en el motor V8 de Google y que sirve principalmente para crear aplicaciones web. Mediante el uso de V8, puedes crear servidores web usando JavaScript, y Node se encarga de envolverlo para que puedas usar todas funcionalidades que te ofrece el sistema operativo en el que se est√° ejecutando.</p>

<p>Otro ejemplo de uso de un motor de JS fuera de un browser es <a href="https://www.mongodb.com/docs/manual/release-notes/3.2-javascript/">MongoDB</a>, que usa el motor SpiderMonkey de Mozilla para ejecutar c√≥digo de JavaScript en sus bases de datos.</p>

<p>Si buscas m√°s, puedes encontrar un mont√≥n de ejemplos en los que un motor de JavaScript es usado fuera de un navegador.</p>

<h2 id="engines-de-javascript">Engines de JavaScript</h2>

<p>Ahora s√≠, hablemos de los diferentes motores de JavaScript en orden de popularidad.</p>

<h3 id="v8">V8</h3>

<p>Es el motor desarrollado por Google, usado principalmente en Chrome, NodeJS y Deno. Actualmente tambi√©n est√° detr√°s de Microsoft Edge. Es el m√°s popular y el que m√°s desarrollo tiene. Est√° escrito en C++ y ha tenido varias iteraciones, mejorando los componentes internos. Adem√°s cuenta con un JIT compiler que lo hace eficiente en la mayor√≠a de los casos. Otra ventaja de V8 es que puede ejecutar tambi√©n <a href="https://webassembly.org/">WebAssembly</a>.</p>

<p>Si quieres desarrollar algo que tenga soporte completo del est√°ndar ECMAScript, sea estable y tenga buen rendimiento, con V8 no te puedes equivocar. La desventaja es que tendr√°s que usarlo como un biblioteca de C++, o por lo menos customizarlo un poco para que se adapte a tus necesidades y hagas los puentes con tu programa, plataforma o lenguaje de programaci√≥n, tal como Deno (que est√° escrito en Rust).</p>

<p>Puedes ver su blog t√©cnico aqu√≠: <a href="https://v8.dev/blog">https://v8.dev/blog</a>. Adem√°s, si quieres aprender c√≥mo hacer complejos o quieres contribuir, su c√≥digo fuente est√° disponible de manera abierta en GitHub: <a href="https://github.com/v8/v8">V8 Github</a>.</p>

<h3 id="spidermonkey">SpiderMonkey</h3>

<p>Este motor de JS est√° desarrollado por Mozilla y es usado en Firefox, Servo y en MongoDB. Igual que V8, est√° escrito en C++, pera tambi√©n incluye partes en <a href="https://www.rust-lang.org/">Rust</a> e incluso en JavaScript. A parte de ejecutar JS, tambi√©n puede ejecutar WebAssembly.</p>

<p>Si tienes un proyecto en Rust o C++, SpiderMonkey puede ser una gran opci√≥n. La principal diferencia con V8 es la velocidad de desarrollo, puedes esperar menos cambios que puedan romper tu c√≥digo, pero tambi√©n menos mejoras y actualizaciones, que con V8.</p>

<p>Puedes ver su documentaci√≥n aqu√≠: <a href="https://firefox-source-docs.mozilla.org/js/index.html">SpiderMonkey</a>.</p>

<h3 id="chakracore">ChakraCore</h3>

<p>Este motor fue desarrollado por Microsoft y es usado en Chakra (que es un <em>runtime</em> de JS incluye otras cosas m√°s como API‚Äôs para poder darle m√°s funcionalidad al engine), que a su vez era usado en Edge y Windows (Edge ahora usa Chromium).</p>

<p>ChakraCore est√° escrito en C++ y C, y presenta una API en C para usarlo en proyectos compatibles con esto. Puede ser compilado para cualquier sistema operativo de 64 bits, pero solamente para Windows para procesadores ARM y de 32 bits. Ya que Microsoft lo dej√≥ de usar, se piensa ahora completamente como un proyecto a cargo de la comunidad.</p>

<p>En las pruebas que yo hice, fue el m√°s f√°cil de compilar y usar, pero si te fijas en su repositorio, no tiene un desarrollo tan activo.</p>

<p>Puedes ver su documentaci√≥n aqu√≠: <a href="https://github.com/chakra-core/ChakraCore">ChakraCore</a>. Nota como no est√° bajo el nombre de chakra-core y no en el repositorio de Microsoft.</p>

<h3 id="javascriptcore">JavaScriptCore</h3>

<p>Este es el motor desarrollado por Apple, usado en Safari principalmente. Al igual que los otros, est√° escrito en C y C++, pero tiene bindings para Objective-C, Swift y C. As√≠, se puede usar para darle la capacidad a aplicaciones de iOS y macOS de ejecutar c√≥digo de JS, pero si tienes algo m√°s en C en que puedas envolverlo, sin ning√∫n problemas puedes usarlo en cualquier proyecto.</p>

<p>Puedes ver su documentaci√≥n aqu√≠: <a href="https://developer.apple.com/documentation/javascriptcore">JavaScriptCore</a>.</p>

<h3 id="rhino">Rhino</h3>

<p>Tambi√©n es desarrollado por Mozilla, pero esta vez escrito en Java. Rhino viene incluido en algunas distribuciones de Java. As√≠ que si tienes un proyecto en Java, Rhino es una gran opci√≥n, pero debes estar atento a las caracter√≠sticas que soporta, porque parece que su desarrollo no est√° tan activo.</p>

<p>Puedes ver su documentaci√≥n aqu√≠: <a href="https://github.com/mozilla/rhino">Rhino</a>.</p>

<h2 id="engines-ligeros">Engines ligeros</h2>

<p>Existen una gran variedad de engines de JS m√°s ligeros, no con todas las caracter√≠sticas de los que acabamos de ver, con la idea de que los puedas embeber en proyectos que dispongan de pocos recursos, tal como sistemas embebidos o proyectos de IoT. Otro buen caso de uso para estos es cuando no requieras las funcionalidades completas de JS sino simplemente soporte b√°sico en tu programa.</p>

<p>Aqu√≠ una lista de los m√°s populares:</p>

<ul>
  <li><a href="https://bellard.org/quickjs/">QuickJS</a>: Desarrollado por Fabrice Bellard, quien tambi√©n cre√≥ <a href="https://www.ffmpeg.org/">FFmpeg</a>. QuickJS s√≥lo pesa 210Kb en su forma m√°s sencilla.</li>
  <li><a href="https://duktape.org/">Duktape</a>: Tambi√©n es muy peque√±o, promete funcionar en sistemas con 160Kb de memoria y 64Kb de RAM. Est√° escrito en C y soporta la ES2015 o ES6.</li>
  <li><a href="https://github.com/espruino/Espruino">Espruino</a>. Corre en sistemas con 128Kb de memoria y 8Kb de RAM. Est√° escrito tambi√©n en C y est√° pensado para darle soporte a sus propias tarjetas de microncontroladores de bajo consumo, programadas en JS. Pero a√∫n as√≠, lo puedes usar en cualquier proyecto que sea compatible con su API de C o correrlo directamente.</li>
</ul>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Espero que esta lista de motores de JavaScript te sea √∫til para conocer m√°s del ecosistema del que muchos s√≥lo somos usuarios y para entender que JS te puede servir para darles superpoderes a tus sistemas y plataformas. Ya hay muchos proyectos que te permiten hacerlo reduciendo el trabajo al m√≠nimo.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="javascript-engine" /><category term="v8" /><category term="chakra" /><summary type="html"><![CDATA[En este art√≠culo hablaremos de los diferente engines de JavaScript que existen, d√≥nde los puedes encontrar y para qu√© los puedes usar.]]></summary></entry><entry><title type="html">Mojo üî•: un lenguaje prometedor</title><link href="https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor.html" rel="alternate" type="text/html" title="Mojo üî•: un lenguaje prometedor" /><published>2023-12-13T00:00:00-06:00</published><updated>2023-12-13T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor</id><content type="html" xml:base="https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor.html"><![CDATA[<p><a href="https://www.nondot.org/sabre/" target="_blank">Chris Lattner</a>, uno de los creadores de <a href="https://llvm.org">LLVM</a> y <a href="https://www.swift.org/">Swift</a>, ha estado desarrollando un nuevo lenguaje basado en la sintaxis de <strong>Python</strong> pero pensado para atacar su punto m√°s d√©bil: <strong>la velocidad de ejecuci√≥n</strong>.</p>

<p>Este lenguaje se llama <a href="https://modular.com/mojo">Mojo</a>, y est√° siendo publicitado como un lenguaje para hacer aplicaciones de <strong>inteligencia artificial</strong>. Como ya dijimos, su enfoque principal est√° en ser un lenguaje que produzca programar eficientes, por lo que puede ser usado para cualquier aplicaci√≥n que requiera alto rendimiento o hacer una gran cantidad de c√°lculos, justo como las aplicaciones de <em>machine learning</em>.</p>

<p>En este art√≠culo veremos el motivo detr√°s de su nacimiento, sus caracter√≠sticas y analizaremos si te conviene aprenderlo o deber√≠as buscar alguna otra alternativa. Primero, entendamos la fundaci√≥n de Mojo.</p>

<h2 id="mlir---representaci√≥n-intermedia-multi-capa">MLIR - Representaci√≥n intermedia multi-capa</h2>

<p>LLVM es un proyecto que se define como infraestructura para la construcci√≥n de compiladores. Imag√≠nate que es como un framework para construir compiladores. Muchos de los lenguajes actuales est√°n creados usando este proyecto. Por ejemplo <a href="https://rust.org">Rust</a>, Swift y <a href="https://julialang.org">Julia</a> est√°n construidos sobre LLVM.</p>

<p>Una de las partes que hace muy √∫til a LLVM es su <strong>representaci√≥n intermedia</strong>. Esta representaci√≥n intermedia permite que los diferentes lenguajes de programaci√≥n que funcionan sobre √©l se aprovechen de las optimizaciones que LLVM hace sobre el c√≥digo intermedio. El flujo del c√≥digo es el siguiente:</p>

<ol>
  <li>El c√≥digo fuente es compilado a c√≥digo intermedio (<strong>IR</strong>).</li>
  <li>El <strong>IR</strong> es optimizado.</li>
  <li>El <strong>IR</strong> es compilado a c√≥digo de m√°quina.</li>
</ol>

<p>De hecho, se dice que Swift es s√≥lo az√∫car sint√°ctico sobre la representaci√≥n intermedia de LLVM, es decir, que se parece mucho a esta representaci√≥n intermedia y aprovecha sus caracter√≠sticas.</p>

<p>MLIR (Multi-layer Intermediate Representation o Representaci√≥n intermedia multi-capa) es una representaci√≥n intermedia de m√°s alto nivel que la representaci√≥n intermedia tradicional. No en el sentido de que sea m√°s f√°cil de entender para los humanos, sino que en vez de mapearse directamente con una infraestructura de compilaci√≥n, representa un modelo m√°s abstracto que puede ser mapeado a diferentes infraestructuras de compilaci√≥n, de manera especializada para cada una de ellas. As√≠ permite que un mismo c√≥digo fuente pueda ser compilado para diferentes ejecutores, como GPU‚Äôs, TPU‚Äôs, CPU‚Äôs, etc, sin tener que crear una nueva representaci√≥n intermedia o crear nuevo c√≥digo fuente.</p>

<h2 id="entra-mojo-">Entra Mojo üî•</h2>

<p>Toda esta explicaci√≥n anterior es para entender que Mojo es para MLIR lo que Swift es para LLVM. Aprovecha gran parte de las caracter√≠sticas de MLIR para crear un lenguaje de programaci√≥n que pueda usar ejecutores especializados en c√≥mputo de alto rendimiento como GPU‚Äôs y TPU‚Äôs, pero presentando una sintaxis m√°s amigable para los humanos, a diferencia de CUDA, o C++, por ejemplo.</p>

<p>Mojo te ayuda aprovechar el paralelismo masivo de los GPU‚Äôs sin tener que preocuparte por aprender un nuevo lenguaje o siquiera tener que pensar en d√≥nde finalmente se ejecutar√° tu programa.</p>

<p>Ya que Python es la lingua franca del mundo de la inteligencia artificial, Mojo inicialmente fue pensado como una extensi√≥n de Python (lo que llamar√≠amos un superconjunto de Python), en el sentido de que todo el c√≥digo v√°lido en Python es c√≥digo v√°lido en Mojo, muy parecido a la relaci√≥n que existe entre la sintaxis de TypeScript y JavaScript.</p>

<h2 id="caracter√≠sticas-de-mojo">Caracter√≠sticas de Mojo</h2>

<p>Las pruebas iniciales de Mojo revelan que puede ser hasta <strong>68,000</strong> veces m√°s r√°pido que Python en ciertas tareas (s√≠, le√≠ste bien <strong>sesenta y ocho mil</strong>), mientras que C++ llega a ser <strong><em>s√≥lo</em> 5,000</strong> veces m√°s r√°pido. Claro, esto no habla muy bien de Python, pero debes pensar en que su objetivo no es ser un lenguaje de alto rendimiento, sino un lenguaje de alto nivel y f√°cil de usar.</p>

<p>Mojo quiere aprovechar la facilidad de uso de Python junto con su ecosistema de bibliotecas y desarrollos para hacer un ecosistema de desarrollo de inteligencia artificial m√°s r√°pido y f√°cil de usar. Una de las primeras diferencias con Python es que es un lenguaje <strong>compilado</strong>.</p>

<p>Hablemos de algunas de las cosas que Mojo le aumenta a Python:</p>

<ol>
  <li>
    <p><strong>Sistema de tipos progresivos</strong>. Te permite usar el sistema de tipos tanto como lo necesites (por eso es progresivo). Pero debes tener en cuenta que los tipos te sirven tanto para verificar que el programa es correcto como <strong>para optimizar el c√≥digo que se genera</strong>.</p>
  </li>
  <li>
    <p><strong>Abstracciones sin costo</strong>. Muy parecido a Rust, Mojo te da acceso a usar abstracciones de alto nivel que no incrementan el costo de ejecuci√≥n.</p>
  </li>
  <li>
    <p><strong>Seguridad de memoria</strong>. Tiene un sistema de seguridad de memoria parecido al de Rust, mediante la pertenencia y el pr√©stamo de referencias (ownership + borrow checker).</p>
  </li>
  <li>
    <p><strong>Metaprogramaci√≥n</strong>. Te permite crear c√≥digo parametrizado que se transforma en tiempo de compilaci√≥n.</p>
  </li>
</ol>

<p>Como puedes ver, Mojo es un lenguaje muy interesante que aprovecha las caracter√≠sticas que hemos aprendido en lenguajes modernos que han sido √∫tiles para crear mejores sistemas. El uso de MLIR es la base de su rendimiento, que permite que los programas que generas se puedan optimizar para ejecutores de diferentes tipos, incluidos algunos masivamente paralelos.</p>

<h2 id="deber√≠as-aprenderlo">¬øDeber√≠as aprenderlo?</h2>

<p>Mojo es un lenguaje que servir√° tanto para hacer aplicaciones de IA como herramientas de bajo nivel para sistemas operativos, por lo que yo lo pensar√≠a como un <strong>lenguaje de programaci√≥n de sistemas de √∫ltima generaci√≥n</strong> que permitir√° hacer cosas muy interesantes en el futuro.</p>

<p>Ahora mismo (Diciembre de 2023), es un lenguaje de c√≥digo cerrado, es decir, su desarrollo est√° llevado por una empresa privada y el c√≥digo fuente no est√° disponible para que otros lo vean o contribuyan. Seg√∫n Lattner, esto permite inicialmente que se se avance de manera m√°s efectiva, en lo que personalmente estoy de acuerdo. Se espera que Mojo sea de c√≥digo abierto cuando alcance el nivel de madurez necesario.</p>

<p>Adem√°s, est√° en una etapa muy temprana de su desarrollo en la que ni siquiera cumple con todas las caracter√≠sticas de Python, por lo que todo lo que aprendas ahora s√≥lo ser√° un vistazo que te puede ayudar a definir si lo quieres usar cuando salga su versi√≥n lista para producci√≥n.</p>

<p>Personalmente, creo que es un buena inversi√≥n del tiempo si est√°s metido en crear aplicaciones de alto rendimiento, programaci√≥n de sistema o quieres crear sistemas que usen inteligencia artificial como una de sus caracter√≠sticas principales. Por el contrario, para desarrollo web creo que tomar√° un poco m√°s de tiempo en serte √∫til.</p>

<p>Otro caso para el que puede serte √∫til es para aprender las caracter√≠sticas de los lenguajes modernos, como los tipos progresivos o la seguridad de memoria mediante el pr√©stamos de referencias.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Mojo es un lenguaje interesante, muy prometedor y que est√° en la raya de la innovaci√≥n en creaci√≥n de lenguajes y caracter√≠sticas modernas. Si eres curioso y te gustan en general los lenguajes de programaci√≥n, creo que es una gran opci√≥n para empezar a aprender y tal vez en el futuro recoger los beneficios si cumple con sus promesas.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="mojo" /><category term="python" /><category term="machine-learning" /><summary type="html"><![CDATA[El ecosistema de desarrollo est√° cambiando y se est√°n dise√±ando nuevos lenguajes de programaci√≥n y entornos de ejecuci√≥n m√°s adecuados para los problemas actuales. Hablemos de Mojo.]]></summary></entry><entry><title type="html">¬øQu√© es Real Time en sistemas de software?</title><link href="https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales.html" rel="alternate" type="text/html" title="¬øQu√© es Real Time en sistemas de software?" /><published>2023-12-09T00:00:00-06:00</published><updated>2023-12-09T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales</id><content type="html" xml:base="https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales.html"><![CDATA[<p>A veces, los programadores usamos muy libremente los conceptos. Uno de ellos es el de Real Time. En este art√≠culo vamos a hablar de lo que significa realmente el t√©rmino, lo vamos a definir claramente y sobre todo aprenderemos a diferenciar los distintos niveles o garant√≠as que debe ofrecer un sistema en tiempo real.</p>

<h2 id="qu√©-es-real-time">¬øQu√© es Real Time?</h2>

<p>Un sistema que provee garant√≠as de Tiempo Real o Real Time es aquel que <strong>garantiza</strong> que una tarea se va a ejecutar en un tiempo determinado. Esto es muy importante en sistemas cr√≠ticos, como los que se usan en la industria automotriz, aeroespacial, m√©dica, en los que ejecutar NO ejecutar una tarea en un tiempo determinado puede tener consecuencias catastr√≥ficas.</p>

<p>Pero tambi√©n hay sistemas en los que es <em>deseable</em> que una tarea se ejecute antes de cierto tiempo, por ejemplo, cuando estamos transmitiendo informaci√≥n en forma de audio o video de algo que es importante que se comunique r√°pidamente. As√≠, podemos hacer llamadas o videollamadas que son √∫tiles.</p>

<p>Los dos casos anteriores, nos dan la pauta para por lo menos distinguir dos tipos de sistemas Real Time:</p>

<ol>
  <li>
    <p><strong>Hard Realtime</strong>. Son sistemas que deben garantizar con un 100% de certeza que la tarea que quieres que hagan se va a realizar <em>m√°ximo</em> en el tiempo qu especifica el mismo sistema. En estos sistemas no hay margen de error, si el sistema no puede cumplir con el tiempo especificado se considera que fall√≥, por lo que no es seguro operarlo. Este tipo de sistemas se usan en ocasiones en las que es muy muy importante que la tarea en cuesti√≥n se ejecute lo m√°s r√°pido posible, normalmente porque el no hacerlo o tener un retraso podr√≠a tener consecuencias mortales o catastr√≥ficas.</p>
  </li>
  <li>
    <p><strong>Soft Realtime</strong>. Los sistemas de este tipo, garantizan que <em>m√≠nimo</em> cierto porcentaje de las veces que un sistema se ejecute, la tarea se va a ejecutar en el tiempo especificado, normalmente lo m√°s r√°pido posible. A diferencia de los sistemas de tiempo real fuerte, puede que cierto n√∫mero de acciones tarden un poco m√°s de lo esperado, pero esto no llevar√≠a a pensar que el sistema fall√≥. Este tipo de sistemas se usa para cosas no tan cr√≠ticas pero en las que es deseable que la tarea est√° lista lo m√°s r√°pido posible, por ejemplo, en juegos, aplicaciones de videoconferencia, sistemas de coordinaci√≥n de trabajo (Figma, Google Docs, etc).</p>
  </li>
</ol>

<h2 id="c√≥mo-puedes-lograr-un-sistema-real-time">C√≥mo puedes lograr un sistema Real Time</h2>

<p>Lo primero en que debemos pensar es qu√© tipo de realtime necesitamos. Como te puedes imaginar, lograr un sistema Hard Realtime es mucho m√°s complicado que lograr un sistema Soft Realtime. Esto es porque en el primero, no hay margen de error, mientras que en el segundo, podemos relajarnos un poco.</p>

<p>Algunas sugerencias para lograr sistemas realtime son:</p>

<ol>
  <li>
    <p><strong>Usa un ecosistema que est√© pensado para esto</strong>. Hay lenguajes de programaci√≥n y plataformas que mediante diferentes t√©cnicas te ayudan a lograr funcionalidades real time, pero normalmente se queden al nivel de aplicaciones de soft realtime. Algunos ejemplos son lenguajes que aprovechan la concurrencia y controlan efectivamente el tiempo de ejecuci√≥n de tu programa o te permiten hacerlo de manera sencilla, como: Go, Elixir y NodeJS.</p>
  </li>
  <li>
    <p><strong>Usa un lenguaje de programaci√≥n que te de control granular sobre el tiempo de ejecuci√≥n</strong>. Con esto principalmente me refiero a una cosa: que no tengan recolector de basura. Recuerda que este proceso puede parar el programa por un tiempo no conocido y de manera no controlada, por lo que si quieres lograr aplicaciones hard realtime, ser√° una tarea extremadamente dif√≠cil. Lamento dec√≠rtelo, pero si quieres asegurar que tu programa se comporte como deseas, vas a tener que controlar casi cada detalle, en lenguajes como C, C++ o Rust.</p>
  </li>
  <li>
    <p><strong>Asegura la fiabilidad de tu infraestructura</strong>. Para que un sistema realtime sea confiable, vas a necesitar que la infraestructura sea resistente a fallas. Esto lo logras eliminando puntos √∫nicos de fallo, es decir, aquellos puntos de tu programa o infraestructura que si fallan hacen que todo el sistema se caiga. Para lograr esto tienes que pensar en arquitecturas distribuidas, redundancia de datos, escalamiento autom√°tico, etc.</p>
  </li>
</ol>

<p>Espero que estos consejos te sirvan y si se me est√° pasando alguno, por favor, d√©jame un comentario.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Conocer los diferentes niveles de servicio que un sistema puede garantizar y comprender las caracter√≠sticas que presentan, te puede ayudar a tomar en serio la responsabilidad de dise√±ar un sistema realtime y la dificultad que implica.</p>

<p>Piensa profundamente si realmente se requiere un sistema con estas caracter√≠sticas (sobre todo si es hard realtime) y si es as√≠, toma en serio la responsabilidad de dise√±arlo y construirlo, espero que los consejos que te di en este art√≠culo te sirvan para lograrlo.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="real-time" /><category term="tiempo-real" /><category term="sistemas-cr√≠ticos" /><summary type="html"><![CDATA[Hablemos que significa que los sistemas sean Real Time y qu√© principios puedes seguir para lograr que tu sistema lo sea.]]></summary></entry><entry><title type="html">Las tres garant√≠as de seguridad de un hash</title><link href="https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash.html" rel="alternate" type="text/html" title="Las tres garant√≠as de seguridad de un hash" /><published>2023-08-28T00:00:00-06:00</published><updated>2023-08-28T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash</id><content type="html" xml:base="https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash.html"><![CDATA[<p>En este art√≠culo profundizaremos sobre las garant√≠as de seguridad m√≠nimas que una funci√≥n hash debe cumplir para ser criptogr√°ficamente segura. En un art√≠culo anterior: <a href="/2021/12/02/algoritmos-criptograficos-que-es-un-hash.html">¬øQu√© es un hash?</a> ya hablamos m√°s detalladamente de la definici√≥n y de los algoritmos que puedes usar a√∫n hoy de manera segura.</p>

<p>Empecemos por una peque√±a definici√≥n de lo que es una funci√≥n hash en la criptograf√≠a.</p>

<h2 id="qu√©-es-un-hash">¬øQu√© es un hash?</h2>

<p>Un hash es una funci√≥n que te devuelve un valor de tama√±o fijo independientemente del tama√±o de la entrada, esto implica una compresi√≥n de datos. Las funciones hash que son usadas en criptograf√≠a, tienen la caracter√≠stica de entregar valores completamente <em>impredecibles</em>, tanto para un humano como para una computadora. Es decir que no hay manera de saber qu√© valor va a entregar una funci√≥n hash para un valor dado si no le has pasado ese valor antes.</p>

<p>Lo anterior no quiere decir que las funciones hash devuelvan algo diferente cada vez que las ejecutas, sino que para un valor dado, siempre devuelven el mismo resultado, y aqu√≠ es donde radica su utilidad.</p>

<p>Un hash perfecto se comportar√≠a como un generador de valores aleatorios, pero debido a lo que hemos dicho anteriormente, deben ser <strong>deterministas</strong> al mismo tiempo que <strong>impredecibles</strong>.</p>

<p>Para medir la seguridad de una funci√≥n hash, se usan tres pruebas, que se conocen como las garant√≠a de seguridad de un hash.</p>

<p>Estas garant√≠as son:</p>

<ol>
  <li>Resistencia a la primera preimagen</li>
  <li>Resistencia a la segunda preimagen</li>
  <li>Resistencia a la colisi√≥n</li>
</ol>

<p>Cada una de estas garant√≠as se refiere a un tipo de ataque que se puede hacer a una funci√≥n hash. Vamos a explicarlas pero antes aclaremos algunos t√©rminos.</p>

<h2 id="imagen-y-preimagen">Imagen y preimagen</h2>

<p>En matem√°ticas, una funci√≥n es una relaci√≥n entre dos conjuntos de valores, uno de entrada y uno de salida. En la mayor√≠a la de las funciones matem√°ticas comunes, cada valor de entrada tiene un √∫nico valor de salida.</p>

<p>Tomemos como ejemplo: \(f(x) = x + 1\), esta funci√≥n toma un valor \(x\) y le suma \(1\), por lo que cada valor de \(x\) tiene un √∫nico valor de salida, porque sabemos que un n√∫mero cualquiera tiene solamente un sucesor.</p>

<p>Pero no todas las funciones se comportan as√≠, por ejemplo: \(f(x) = x^2\). En esta funci√≥n el valor 4 puede ser generado por dos valores de entrada diferentes: \(2\) y \(-2\).</p>

<p>Cuando vemos una funci√≥n as√≠ no es com√∫n que nos definan el conjunto de entrada, as√≠ que asumimos que el conjunto de entrada o <strong>dominio</strong> es el conjunto de los n√∫meros reales, y el conjunto de salida o <strong>codominio</strong> es el conjunto de los n√∫meros reales.</p>

<p>Pensemos en el dominio y codominio como conjuntos amplios en los que los valores de entrada y salida <em>podr√≠an estar</em>. La <strong>imagen</strong> de una funci√≥n es el conjunto de valores que <em>est√°n</em> en el codominio, es decir, los valores que la funci√≥n <em>puede</em> devuelve. La <strong>preimagen</strong> es el conjunto de valores que <em>pueden</em> ser entrada de la funci√≥n.</p>

<p>En t√©rminos pr√°cticos para nosotros los programadores, la imagen es casi equivalente al codominio, y la preimagen es el dominio.</p>

<p>Esta imagen sacada de Wikipedia lo ilustra un poco mejor:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_600/v1693144037/Codomain2_kzda4n.svg" alt="Imagen vs Codomino" class="align-center" /></p>

<p>La imagen es el √°rea amarilla, mientras que Y es el codominio, y X es el dominio. Lo √∫ltimo que nos hace falta saber es que aunque imagen y preimagen son los conjuntos de entradas y salidas del algoritmo, tambi√©n nos podemos referir as√≠ a un valor individual de este conjunto.</p>

<p>Apliquemos los aprendido al ejemplo de la funci√≥n \(f(x) = x^2\). El dominio es el conjunto de los n√∫meros reales, y el codominio tambi√©n es el conjunto de los n√∫meros reales. La imagen es el conjunto de los <strong>n√∫meros reales positivos que tengan una ra√≠z cuadrada</strong>, y la preimagen es el conjunto de los n√∫meros reales. Un ejemplo concreto: para el valor <code class="language-plaintext highlighter-rouge">4</code> considerado como resultado de la funci√≥n o <strong>imagen</strong>, tendr√≠a <em>dos</em> preim√°genes: \(2\) y \(-2\).</p>

<p>Ahora s√≠, hablemos de la primera garant√≠a de seguridad de un hash.</p>

<h2 id="resistencia-a-la-primera-preimagen">Resistencia a la primera preimagen</h2>

<p>Aqu√≠ debes poner atenci√≥n a los valores <em>que se dan</em> para hacer la prueba de seguridad. Presta atenci√≥n a cuando se dice ‚Äúdado un valor‚Äù, estos son la valores que suponemos que ya se conocen.</p>

<p>En la primera garant√≠a es: <strong>Dada</strong> una <em>imagen</em> es computacionalmente inviable encontrar una <em>preimagen</em> que la genere.</p>

<p>En palabras de programadores: Dado un hash, es computacionalmente inviable encontrar un valor que al ser pasado a la funci√≥n hash, genere ese hash.</p>

<p>¬øPor qu√© decimos <strong>un</strong> valor que genere ese hash y no <strong>el</strong> valor que genere ese hash? Porque para un valor de salida, puede haber m√°s de un valor de entrada que lo genere. Especialmente para los hashes, su conjunto de valores posibles es infinito: todas las combinaciones de bits posibles de cualquier tama√±o.</p>

<p>¬øCu√°l es el tama√±o del conjunto de posibles salida? Eso depende del hash usado y su n√∫mero de bits. Por ejemplo, el SHA-256 genera hashes de 256 bits, por lo que su conjunto de posibles valores es \(2^{256}\), que es un n√∫mero muy grande, pero no infinito, por lo que es posible que dos valores generen el mismo hash. Cada uno de esos valores ser√≠a <em>una preimagen</em> de un hash dado.</p>

<p>Entonces ya tenemos todo el escenario: nos han dado un hash y tenemos que encontrar uno de los infinitos valores que pueden producir ese hash, una preimagen.</p>

<p>Pues bien, para un hash criptogr√°ficamente seguro esta operaci√≥n debe de ser imposible de realizar de manera m√°s eficiente que usando fuerza bruta, es decir, probando todos los valores posibles hasta encontrar uno que genere el hash dado.</p>

<p>Para que un hash sea considerado seguro, hallar una preimagen por fuerza bruta deber√≠a tomar \(2^{n}\) operaciones, donde \(n\) es el n√∫mero de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, toma \(2^{256}\) operaciones, que es un n√∫mero muy grande, computacionalmente inviable.</p>

<p>Por ejemplo, imagina que puedes hacer 1 mill√≥n de operaciones por segundo, aproximadamente \(2^{19}\). Encontrar una primera preimagen para el SHA-256 te tomar√≠a \(2^{256} / 2^{19}\), es decir \(2^{247}\) segundos, mientras que lo que se calcula que ha durado el universo son \(2^{38}\) segundos.</p>

<p>Pongamos un ejemplo en Python. Supongamos que la funci√≥n <code class="language-plaintext highlighter-rouge">hash</code> es un hash seguro, y que la funci√≥n <code class="language-plaintext highlighter-rouge">mensaje_aleatorio</code> devuelve un mensaje diferente cada vez. Pon atenci√≥n en lo que recibe la funci√≥n <code class="language-plaintext highlighter-rouge">primera_preimagen</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">primera_preimagen</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">mensaje_aleatorio</span><span class="p">()</span>
    <span class="k">while</span> <span class="nf">hash</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="n">h</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nf">mensaje_aleatorio</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">m</span>
</code></pre></div></div>

<p>Este deber√≠a ser el mejor ataque que se pueda hacer sobre un hash seguro.</p>

<h2 id="resistencia-a-la-segunda-preimagen">Resistencia a la segunda preimagen</h2>

<p>Esta garant√≠a de seguridad es muy parecida a la primera, pero lo que se recibe aqu√≠ es una <em>preimagen</em> y se debe encontrar otra preimagen que genere el mismo hash.</p>

<p>La garant√≠a de seguridad deber√≠a ser la misma: encontrar una segunda preimagen deber√≠a ser computacionalmente inviable, es decir, que tomar√≠a \(2^{n}\) operaciones, donde \(n\) es el n√∫mero de bits del hash.</p>

<p>Pongamos un ejemplo en Python. Observa que usamos la funci√≥n <code class="language-plaintext highlighter-rouge">primera_preimagen</code> que definimos antes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">segunda_preimagen</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nf">hash</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="nf">primera_preimagen</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m2</span>
</code></pre></div></div>

<p>Este ataque no implica m√°s que hashear el mensaje y encontrar una primera preimagen de ese hash. Si el hash es resistente a la primera preimagen, entonces tambi√©n lo ser√° a la segunda.</p>

<p>Parece que esta garant√≠a no tiene mucho sentido, pero vayamos a la tercera y la m√°s conocida.</p>

<h2 id="resistencia-a-colisiones">Resistencia a colisiones</h2>

<p>Una colisi√≥n es cuando dos valores diferentes generan el mismo hash. Ya mencionamos que, al tener un conjunto infinito de valores de entrada y tener un conjunto muy grande (<em>pero limitado</em>) de valores de salida, es inevitable que suceda esto, de hecho, en este caso, un conjunto infinito de valores de entrada generan el mismo hash.</p>

<p>Pero hagamos un caso concreto. Imagina que tu hash recibir√° cadenas de bits de 512 bits, y generar√° un hash de 256 bits. Esto significa que el conjunto de posibles valores de entrada es \(2^{512}\) y el de posibles valores de salida es \(2^{256}\). A cada valor de salida le corresponden \(2^{512}/2^{256} = 2^{512-256}\) valores de entrada, es decir, que para cada valor de salida hay \(2^{256}\) valores de entrada que generan el mismo hash.</p>

<p>Bueno, pues la tercera garant√≠a de seguridad indica que <strong>debe ser computacionalmente inviable encontrar una colisi√≥n</strong>. En este caso no se nos da nada, ni una imagen (hash), ni una preimagen (valor de entrada). Se puede escoger cualquier valor de entrada para encontrar una colisi√≥n.</p>

<p>Aqu√≠ entra la segunda garant√≠a de seguridad, si la funci√≥n hash es resistente a la segunda preimagen, es resistente a colisiones. En Python, el mejor algoritmo para encontrar una colisi√≥n deber√≠a ser el siguiente para un hash seguro:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">encontrar_colision</span><span class="p">():</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">mensaje_aleatorio</span><span class="p">()</span>
    <span class="k">return</span> <span class="nf">encontrar_segunda_preimagen</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<p>La garant√≠a de seguridad que debe de cumplir un hash seguro es que encontrar una colisi√≥n deber√≠a tomar \(2^{n/2}\) operaciones, donde \(n\) es el n√∫mero de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, tomar√≠a \(2^{128}\) operaciones, que sigue siendo un n√∫mero muy grande, computacionalmente inviable.</p>

<p>¬øPor qu√© \(2^{n/2}\)? Porque es m√°s f√°cil encontrar <em>un par</em> de valores que generen el mismo hash sin tener restricciones, que encontrar <em>un valor</em> que genere un hash dado.</p>

<p>Si haces \(N\) hashes, puedes tener ~\(N^2\) oportunidades para encontrar una colisi√≥n por que puedes comparar cada hash con todos los dem√°s. Esto es lo que se conoce como la paradoja del cumplea√±os.</p>

<h2 id="c√≥mo-se-vuelve-inseguro-un-hash">C√≥mo se vuelve inseguro un hash</h2>

<p>Un hash seguro se comporta de manera completamente impredecible con respecto a su valor de entrada. Los hashes inseguros empiezan a dar muestras de regularidad en sus salidas o tienen salidas demasiado peque√±as.</p>

<p>De esta manera, es posible encontrar m√©todos estad√≠sticos para analizar las salidas y as√≠ encontrar patrones que permitan encontrar colisiones o preim√°genes m√°s f√°cilmente.</p>

<p>Pero en realidad, tiene mucho que ver con su construcci√≥n y las formas en las que puedes truquear los valores que le das para reducir el n√∫mero de pasos que se necesitan para encontrar una preimagen o una colisi√≥n.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>En este art√≠culo vimos las tres garant√≠as de seguridad que debe cumplir una funci√≥n hash para ser criptogr√°ficamente segura. Te sirven para entender claramente de lo que se habla cuando se han encontrado colisiones en un hash, y poder evaluar la gravedad de la situaci√≥n.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="hash" /><category term="criptograf√≠a" /><category term="md5" /><category term="sha-256" /><summary type="html"><![CDATA[Veamos m√°s profundamente las garant√≠as de seguridad que debe cumplir un hash para ser considerado seguro. Por fin entenderemos lo que es una colisi√≥n y qu√© significa para nosotros.]]></summary></entry><entry><title type="html">¬øQu√© es la filosof√≠a de la computaci√≥n?</title><link href="https://blog.thedojo.mx/2023/08/19/que-es-la-filosofia-de-la-computacion.html" rel="alternate" type="text/html" title="¬øQu√© es la filosof√≠a de la computaci√≥n?" /><published>2023-08-19T00:00:00-06:00</published><updated>2023-08-19T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/08/19/que-es-la-filosofia-de-la-computacion</id><content type="html" xml:base="https://blog.thedojo.mx/2023/08/19/que-es-la-filosofia-de-la-computacion.html"><![CDATA[<p>La filosof√≠a es una de las ramas m√°s importantes del saber humano y, para mi, es la fundaci√≥n de todas las dem√°s ramas del conocimiento y de las ciencias. En este art√≠culo hablaremos de la filosof√≠a de la computaci√≥n y c√≥mo esta te puede ayudar como programador o desarrollador de software.</p>

<p>Empecemos primero hablando de qu√© es la filosof√≠a y luego combin√°ndola con la computaci√≥n.</p>

<h2 id="qu√©-es-la-filosof√≠a">¬øQu√© es la filosof√≠a?</h2>

<p>La filosof√≠a busca <strong>responder las preguntas fundamentales de la existencia humana</strong>. Casi ninguna de las preguntas importantes se ha podido responder de manera definitiva, pero lo interesante que nos puede ofrecer la filosof√≠a es una an√°lisis profundo de las posibles respuestas y de las implicaciones de cada una de ellas. As√≠, se ha generado mucho conocimiento que nos ayuda a entender mejor el mundo y a nosotros mismos.</p>

<p>Adem√°s, la filosof√≠a ha desarrollado m√©todos que nos pueden ayudar a examinar temas dif√≠ciles de manera efectiva.</p>

<p>Pongamos un ejemplo. Una de las grandes preguntas que muchos fil√≥sofos han intentado responder es ‚Äú¬øCu√°l es la mejor forma de vivir?‚Äù. No hay una respuesta definitiva, pero en la exploraci√≥n se han encontrado y propuesto muchas pr√°cticas que mejoran la vida humana y que sirven en diferentes situaciones.</p>

<p>Adem√°s han surgido modelos de pensamiento que consisten en una serie de ideas y pr√°cticas que pueden darle sentido a una vida bien practicadas: Estoicismo, Epicureismo, etc. Combinadas pueden servirte para mucho para analizar una situaci√≥n en la vida o para encontrar una forma de actuar.</p>

<p>En resumen: la filosof√≠a te ayudar√° a <em>pensar mejor</em> sobre cuestiones importantes en la vida y en las diferentes √°reas de importancia. <strong>¬øC√≥mo se puede relacionar esto con la computaci√≥n?</strong></p>

<h2 id="qu√©-es-la-filosof√≠a-de-la-computaci√≥n">¬øQu√© es la filosof√≠a de la computaci√≥n?</h2>

<p>La filosof√≠a de la computaci√≥n es lo que acabamos de describir pero aplicado a las preguntas que le conciernen a la computaci√≥n. Preguntas fundamentales para todos los que tenemos tratos profundos con las computadoras:</p>

<ul>
  <li>¬øQu√© es la computaci√≥n?</li>
  <li>¬øQu√© es una computadora?</li>
  <li>¬øQu√© es un programa?</li>
  <li>¬øQu√© es computable?</li>
  <li>¬øQu√© es programar?</li>
  <li>¬øQu√© es un lenguaje de programaci√≥n?</li>
  <li>¬øC√≥mo puedo crear programas √∫tiles?</li>
</ul>

<p>Estas preguntas parecen tener un respuesta concreta pero hay algunas situaciones en los que podemos dudar de qu√© tan √∫til o real es lo que sabemos.</p>

<p>La filosof√≠a no se queda all√≠, tiene por lo menos las siguientes √°reas:</p>

<ul>
  <li><strong>La ontolog√≠a</strong>. En la que se preguntan cosas como las que acabamos de ver, que tienen que ver con la existencia y la definici√≥n de las cosas</li>
  <li><strong>La sem√°ntica</strong>. El significado de los t√©rminos que usamos</li>
  <li><strong>La axiolog√≠a</strong>. Analiza los valores que fundamentan la computaci√≥n y los eventos relacionados con estos</li>
  <li><strong>La epistemolog√≠a</strong>. Es el an√°lisis del conocimiento y las formas de obtenerlo: ¬øc√≥mo podemos conocer m√°s acerca de la computaci√≥n? ¬øC√≥mo podemos saber si lo que sabemos es correcto? ¬øC√≥mo <em>sabemos</em> que <em>sabemos</em>?</li>
  <li><strong>La metodolog√≠a</strong>. Qu√© m√©todos podemos seguir para practicar la computaci√≥n y la obtenci√≥n de conocimiento de esta de la mejor manera</li>
  <li><strong>La est√©tica</strong>. Analiza la percepci√≥n que tenemos de los artefactos computacionales y los conceptos relacionados con encontrar agradable o de valor esa percepci√≥n: orden, belleza, significado, etc.</li>
  <li><strong>La √©tica</strong>. Est√° basada en la axiolog√≠a, es decir, en la definici√≥n de lo que consideramos de valor y qu√© acciones o pr√°cticas nos acercan o alejan de lo que consideramos que puede ser ‚Äúbueno‚Äù como resultado de la computaci√≥n</li>
</ul>

<p>Como puedes ver, es amplia, pero cada una de las √°reas te puede ayudar en temas espec√≠ficos en tu pr√°ctica diaria.</p>

<p>A diferencia de la filosof√≠a com√∫n, la filosof√≠a de la computaci√≥n tiene mucho menos de existencia y a penas hay unos cu√°ntos escritos y personas que la han practicado en los √∫ltimos a√±os, as√≠ que si te introduces estar√°s en un campo en que tendr√°s que aplicar las t√©cnicas filos√≥ficas a esta √°rea espec√≠fica, y es probable que te lleves muchas sorpresas.</p>

<h2 id="por-qu√©-es-importante-la-filosof√≠a-de-la-computaci√≥n">¬øPor qu√© es importante la filosof√≠a de la computaci√≥n?</h2>

<p>La filosof√≠a de la computaci√≥n o de ciencias de la computaci√≥n te puede ayudar d√°ndote los fundamentos que necesitas sobre todo para enfrentarte a las cuestiones dif√≠ciles de tu trabajo.</p>

<p>Tener fundamentos para definir lo que quieres lograr, d√≥nde est√°n los l√≠mites de tu trabajo y qu√© es posible, te puede hacer mucho m√°s disfrutable tu d√≠a a d√≠a.</p>

<p>No es algo sin lo que puedas trabajar, pero mientras m√°s sepas de esta √°rea, sin duda m√°s disfrutar√°s de tu trabajo.</p>

<p>Pero esto va mucho m√°s all√°: todas las ideas importantes del <em>desarrollo de software</em>
tienen un camino en la filosof√≠a de la computaci√≥n, as√≠ que si quieres desarrollar mejor software, sin duda es un √°rea fundamental.</p>

<h2 id="c√≥mo-aprender-filosof√≠a-de-la-computaci√≥n">¬øC√≥mo aprender filosof√≠a de la computaci√≥n?</h2>

<p>Recomiendo mucho empezar por lo b√°sico y para esto me ha servido el canal de <a href="https://camilochs.github.io/web/">Camilo Chac√≥n Sartori</a> en <a href="https://www.youtube.com/@camilo_chacon_s">YouTube</a>, en el que tiene una serie en la que te <a href="https://www.youtube.com/watch?v=eVxR8io5xTg&amp;list=PLbA-PGKWV-JhWcaZ0HzHFIFbnVakY9t1o">introduce a las partes de la filosof√≠a de la computaci√≥n</a>.</p>

<p>Pero tambi√©n tiene un video que se llama <a href="https://www.youtube.com/watch?v=97InfGEK3Zw">¬øQu√© es la filosof√≠a de computaci√≥n?</a>, en el que te da una introducci√≥n b√°sica.</p>

<p>Despu√©s, puedes empezar a leer sobre los autores que han escrito de esto por a√±os. Yo recomiendo a William J. Rapaport con su escrito <a href="https://cse.buffalo.edu/~rapaport/Papers/philcs-complete.pdf">A Philosophy of Computer Science</a>.</p>

<p>Y finalmente, para profundizar todav√≠a m√°s, tenemos el libro del mismo autor, publicado en 2023: <a href="https://www.wiley.com/en-us/Philosophy+of+Computer+Science%3A+An+Introduction+to+the+Issues+and+the+Literature-p-9781119891901">Philosophy of Computer Science: An Introduction to the Issues and the Literature</a>.</p>

<p>Si le echas un ojo a esto y te parece intimidante, puedes entrar por algo que tiene una menor barrera y que tambi√©n incluir√≠a en el √°rea de la filosof√≠a de la computaci√≥n: la filosof√≠a de la informaci√≥n. Para esto recomiendo mucho el libro <a href="https://buttondown.email/hillelwayne/archive/data-and-reality-2nd-edition/">Data and Reality</a> de William Kent. En el canal tenemos un <a href="https://youtu.be/i4lADcMZsZo">resumen de este libro</a>.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Aprender filosof√≠a de la computaci√≥n es una muy buena idea para tu carrera. Te ayudar√° a plantearte y a <em>intentar</em> resolver las preguntas importantes. Este intento de contestar las preguntas importantes relacionadas con la computaci√≥n y el desarrollo de software te dar√° m√°s armas para enfrentarte a los problemas del d√≠a a d√≠a y a disfrutarlos m√°s.</p>

<p>Finalmente, las herramientas que desarrollas en el estudio de estos problemas te puede ayudar mucho m√°s all√° de la filosof√≠a: <strong>te ayudar√° a resolver problemas de manera m√°s efectiva.</strong></p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="computaci√≥n" /><category term="filosof√≠a" /><category term="filosof√≠a-de-la-computaci√≥n" /><summary type="html"><![CDATA[Veamos qu√© es y c√≥mo te puede ayudar la filosof√≠a de la computaci√≥n en tu carrera como desarrollador de software.]]></summary></entry></feed>