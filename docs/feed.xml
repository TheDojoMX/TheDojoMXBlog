<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://blog.thedojo.mx/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.thedojo.mx/" rel="alternate" type="text/html" /><updated>2023-12-13T10:31:10-06:00</updated><id>https://blog.thedojo.mx/feed.xml</id><title type="html">The Dojo MX Blog</title><author><name>H√©ctor Patricio</name><uri>https://github.com/hectorip</uri></author><entry><title type="html">Mojo üî•: un lenguaje prometedor</title><link href="https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor.html" rel="alternate" type="text/html" title="Mojo üî•: un lenguaje prometedor" /><published>2023-12-13T00:00:00-06:00</published><updated>2023-12-13T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor</id><content type="html" xml:base="https://blog.thedojo.mx/2023/12/13/mojo-un-lenguaje-prometedor.html"><![CDATA[<p><a href="https://www.nondot.org/sabre/" target="_blank">Chris Lattner</a>, uno de los creadores de <a href="https://llvm.org">LLVM</a> y <a href="https://www.swift.org/">Swift</a>, ha estado desarrollando un nuevo lenguaje basado en la sintaxis de <strong>Python</strong> pero pensado para atacar su punto m√°s d√©bil: <strong>la velocidad de ejecuci√≥n</strong>.</p>

<p>Este lenguaje se llama <a href="https://modular.com/mojo">Mojo</a>, y est√° siendo publicitado como un lenguaje para hacer aplicaciones de <strong>inteligencia artificial</strong>. Como ya dijimos, su enfoque principal est√° en ser un lenguaje que produzca programar eficientes, por lo que puede ser usado para cualquier aplicaci√≥n que requiera alto rendimiento o hacer una gran cantidad de c√°lculos, justo como las aplicaciones de <em>machine learning</em>.</p>

<p>En este art√≠culo veremos el motivo detr√°s de su nacimiento, sus caracter√≠sticas y analizaremos si te conviene aprenderlo o deber√≠as buscar alguna otra alternativa. Primero, entendamos la fundaci√≥n de Mojo.</p>

<h2 id="mlir---representaci√≥n-intermedia-multi-capa">MLIR - Representaci√≥n intermedia multi-capa</h2>

<p>LLVM es un proyecto que se define como infraestructura para la construcci√≥n de compiladores. Imag√≠nate que es como un framework para construir compiladores. Muchos de los lenguajes actuales est√°n creados usando este proyecto. Por ejemplo <a href="https://rust.org">Rust</a>, Swift y <a href="https://julialang.org">Julia</a> est√°n construidos sobre LLVM.</p>

<p>Una de las partes que hace muy √∫til a LLVM es su <strong>representaci√≥n intermedia</strong>. Esta representaci√≥n intermedia permite que los diferentes lenguajes de programaci√≥n que funcionan sobre √©l se aprovechen de las optimizaciones que LLVM hace sobre el c√≥digo intermedio. El flujo del c√≥digo es el siguiente:</p>

<ol>
  <li>El c√≥digo fuente es compilado a c√≥digo intermedio (<strong>IR</strong>).</li>
  <li>El <strong>IR</strong> es optimizado.</li>
  <li>El <strong>IR</strong> es compilado a c√≥digo de m√°quina.</li>
</ol>

<p>De hecho, se dice que Swift es s√≥lo az√∫car sint√°ctico sobre la representaci√≥n intermedia de LLVM, es decir, que se parece mucho a esta representaci√≥n intermedia y aprovecha sus caracter√≠sticas.</p>

<p>MLIR (Multi-layer Intermediate Representation o Representaci√≥n intermedia multi-capa) es una representaci√≥n intermedia de m√°s alto nivel que la representaci√≥n intermedia tradicional. No en el sentido de que sea m√°s f√°cil de entender para los humanos, sino que en vez de mapearse directamente con una infraestructura de compilaci√≥n, representa un modelo m√°s abstracto que puede ser mapeado a diferentes infraestructuras de compilaci√≥n, de manera especializada para cada una de ellas. As√≠ permite que un mismo c√≥digo fuente pueda ser compilado para diferentes ejecutores, como GPU‚Äôs, TPU‚Äôs, CPU‚Äôs, etc, sin tener que crear una nueva representaci√≥n intermedia o crear nuevo c√≥digo fuente.</p>

<h2 id="entra-mojo-">Entra Mojo üî•</h2>

<p>Toda esta explicaci√≥n anterior es para entender que Mojo es para MLIR lo que Swift es para LLVM. Aprovecha gran parte de las caracter√≠sticas de MLIR para crear un lenguaje de programaci√≥n que pueda usar ejecutores especializados en c√≥mputo de alto rendimiento como GPU‚Äôs y TPU‚Äôs, pero presentando una sintaxis m√°s amigable para los humanos, a diferencia de CUDA, o C++, por ejemplo.</p>

<p>Mojo te ayuda aprovechar el paralelismo masivo de los GPU‚Äôs sin tener que preocuparte por aprender un nuevo lenguaje o siquiera tener que pensar en d√≥nde finalmente se ejecutar√° tu programa.</p>

<p>Ya que Python es la lingua franca del mundo de la inteligencia artificial, Mojo inicialmente fue pensado como una extensi√≥n de Python (lo que llamar√≠amos un superconjunto de Python), en el sentido de que todo el c√≥digo v√°lido en Python es c√≥digo v√°lido en Mojo, muy parecido a la relaci√≥n que existe entre la sintaxis de TypeScript y JavaScript.</p>

<h2 id="caracter√≠sticas-de-mojo">Caracter√≠sticas de Mojo</h2>

<p>Las pruebas iniciales de Mojo revelan que puede ser hasta <strong>68,000</strong> veces m√°s r√°pido que Python en ciertas tareas (s√≠, le√≠ste bien <strong>sesenta y ocho mil</strong>), mientras que C++ llega a ser <strong><em>s√≥lo</em> 5,000</strong> veces m√°s r√°pido. Claro, esto no habla muy bien de Python, pero debes pensar en que su objetivo no es ser un lenguaje de alto rendimiento, sino un lenguaje de alto nivel y f√°cil de usar.</p>

<p>Mojo quiere aprovechar la facilidad de uso de Python junto con su ecosistema de bibliotecas y desarrollos para hacer un ecosistema de desarrollo de inteligencia artificial m√°s r√°pido y f√°cil de usar. Una de las primeras diferencias con Python es que es un lenguaje <strong>compilado</strong>.</p>

<p>Hablemos de algunas de las cosas que Mojo le aumenta a Python:</p>

<ol>
  <li>
    <p><strong>Sistema de tipos progresivos</strong>. Te permite usar el sistema de tipos tanto como lo necesites (por eso es progresivo). Pero debes tener en cuenta que los tipos te sirven tanto para verificar que el programa es correcto como <strong>para optimizar el c√≥digo que se genera</strong>.</p>
  </li>
  <li>
    <p><strong>Abstracciones sin costo</strong>. Muy parecido a Rust, Mojo te da acceso a usar abstracciones de alto nivel que no incrementan el costo de ejecuci√≥n.</p>
  </li>
  <li>
    <p><strong>Seguridad de memoria</strong>. Tiene un sistema de seguridad de memoria parecido al de Rust, mediante la pertenencia y el pr√©stamo de referencias (ownership + borrow checker).</p>
  </li>
  <li>
    <p><strong>Metaprogramaci√≥n</strong>. Te permite crear c√≥digo parametrizado que se transforma en tiempo de compilaci√≥n.</p>
  </li>
</ol>

<p>Como puedes ver, Mojo es un lenguaje muy interesante que aprovecha las caracter√≠sticas que hemos aprendido en lenguajes modernos que han sido √∫tiles para crear mejores sistemas. El uso de MLIR es la base de su rendimiento, que permite que los programas que generas se puedan optimizar para ejecutores de diferentes tipos, incluidos algunos masivamente paralelos.</p>

<h2 id="deber√≠as-aprenderlo">¬øDeber√≠as aprenderlo?</h2>

<p>Mojo es un lenguaje que servir√° tanto para hacer aplicaciones de IA como herramientas de bajo nivel para sistemas operativos, por lo que yo lo pensar√≠a como un <strong>lenguaje de programaci√≥n de sistemas de √∫ltima generaci√≥n</strong> que permitir√° hacer cosas muy interesantes en el futuro.</p>

<p>Ahora mismo (Diciembre de 2023), es un lenguaje de c√≥digo cerrado, es decir, su desarrollo est√° llevado por una empresa privada y el c√≥digo fuente no est√° disponible para que otros lo vean o contribuyan. Seg√∫n Lattner, esto permite inicialmente que se se avance de manera m√°s efectiva, en lo que personalmente estoy de acuerdo. Se espera que Mojo sea de c√≥digo abierto cuando alcance el nivel de madurez necesario.</p>

<p>Adem√°s, est√° en una etapa muy temprana de su desarrollo en la que ni siquiera cumple con todas las caracter√≠sticas de Python, por lo que todo lo que aprendas ahora s√≥lo ser√° un vistazo que te puede ayudar a definir si lo quieres usar cuando salga su versi√≥n lista para producci√≥n.</p>

<p>Personalmente, creo que es un buena inversi√≥n del tiempo si est√°s metido en crear aplicaciones de alto rendimiento, programaci√≥n de sistema o quieres crear sistemas que usen inteligencia artificial como una de sus caracter√≠sticas principales. Por el contrario, para desarrollo web creo que tomar√° un poco m√°s de tiempo en serte √∫til.</p>

<p>Otro caso para el que puede serte √∫til es para aprender las caracter√≠sticas de los lenguajes modernos, como los tipos progresivos o la seguridad de memoria mediante el pr√©stamos de referencias.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Mojo es un lenguaje interesante, muy prometedor y que est√° en la raya de la innovaci√≥n en creaci√≥n de lenguajes y caracter√≠sticas modernas. Si eres curioso y te gustan en general los lenguajes de programaci√≥n, creo que es una gran opci√≥n para empezar a aprender y tal vez en el futuro recoger los beneficios si cumple con sus promesas.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="mojo" /><category term="python" /><category term="machine-learning" /><summary type="html"><![CDATA[El ecosistema de desarrollo est√° cambiando y se est√°n dise√±ando nuevos lenguajes de programaci√≥n y entornos de ejecuci√≥n m√°s adecuados para los problemas actuales. Hablemos de Mojo.]]></summary></entry><entry><title type="html">¬øQu√© es Real Time en sistemas de software?</title><link href="https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales.html" rel="alternate" type="text/html" title="¬øQu√© es Real Time en sistemas de software?" /><published>2023-12-09T00:00:00-06:00</published><updated>2023-12-09T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales</id><content type="html" xml:base="https://blog.thedojo.mx/2023/12/09/que-es-real-time-en-sistemas-computacionales.html"><![CDATA[<p>A veces, los programadores usamos muy libremente los conceptos. Uno de ellos es el de Real Time. En este art√≠culo vamos a hablar de lo que significa realmente el t√©rmino, lo vamos a definir claramente y sobre todo aprenderemos a diferenciar los distintos niveles o garant√≠as que debe ofrecer un sistema en tiempo real.</p>

<h2 id="qu√©-es-real-time">¬øQu√© es Real Time?</h2>

<p>Un sistema que provee garant√≠as de Tiempo Real o Real Time es aquel que <strong>garantiza</strong> que una tarea se va a ejecutar en un tiempo determinado. Esto es muy importante en sistemas cr√≠ticos, como los que se usan en la industria automotriz, aeroespacial, m√©dica, en los que ejecutar NO ejecutar una tarea en un tiempo determinado puede tener consecuencias catastr√≥ficas.</p>

<p>Pero tambi√©n hay sistemas en los que es <em>deseable</em> que una tarea se ejecute antes de cierto tiempo, por ejemplo, cuando estamos transmitiendo informaci√≥n en forma de audio o video de algo que es importante que se comunique r√°pidamente. As√≠, podemos hacer llamadas o videollamadas que son √∫tiles.</p>

<p>Los dos casos anteriores, nos dan la pauta para por lo menos distinguir dos tipos de sistemas Real Time:</p>

<ol>
  <li>
    <p><strong>Hard Realtime</strong>. Son sistemas que deben garantizar con un 100% de certeza que la tarea que quieres que hagan se va a realizar <em>m√°ximo</em> en el tiempo qu especifica el mismo sistema. En estos sistemas no hay margen de error, si el sistema no puede cumplir con el tiempo especificado se considera que fall√≥, por lo que no es seguro operarlo. Este tipo de sistemas se usan en ocasiones en las que es muy muy importante que la tarea en cuesti√≥n se ejecute lo m√°s r√°pido posible, normalmente porque el no hacerlo o tener un retraso podr√≠a tener consecuencias mortales o catastr√≥ficas.</p>
  </li>
  <li>
    <p><strong>Soft Realtime</strong>. Los sistemas de este tipo, garantizan que <em>m√≠nimo</em> cierto porcentaje de las veces que un sistema se ejecute, la tarea se va a ejecutar en el tiempo especificado, normalmente lo m√°s r√°pido posible. A diferencia de los sistemas de tiempo real fuerte, puede que cierto n√∫mero de acciones tarden un poco m√°s de lo esperado, pero esto no llevar√≠a a pensar que el sistema fall√≥. Este tipo de sistemas se usa para cosas no tan cr√≠ticas pero en las que es deseable que la tarea est√° lista lo m√°s r√°pido posible, por ejemplo, en juegos, aplicaciones de videoconferencia, sistemas de coordinaci√≥n de trabajo (Figma, Google Docs, etc).</p>
  </li>
</ol>

<h2 id="c√≥mo-puedes-lograr-un-sistema-real-time">C√≥mo puedes lograr un sistema Real Time</h2>

<p>Lo primero en que debemos pensar es qu√© tipo de realtime necesitamos. Como te puedes imaginar, lograr un sistema Hard Realtime es mucho m√°s complicado que lograr un sistema Soft Realtime. Esto es porque en el primero, no hay margen de error, mientras que en el segundo, podemos relajarnos un poco.</p>

<p>Algunas sugerencias para lograr sistemas realtime son:</p>

<ol>
  <li>
    <p><strong>Usa un ecosistema que est√© pensado para esto</strong>. Hay lenguajes de programaci√≥n y plataformas que mediante diferentes t√©cnicas te ayudan a lograr funcionalidades real time, pero normalmente se queden al nivel de aplicaciones de soft realtime. Algunos ejemplos son lenguajes que aprovechan la concurrencia y controlan efectivamente el tiempo de ejecuci√≥n de tu programa o te permiten hacerlo de manera sencilla, como: Go, Elixir y NodeJS.</p>
  </li>
  <li>
    <p><strong>Usa un lenguaje de programaci√≥n que te de control granular sobre el tiempo de ejecuci√≥n</strong>. Con esto principalmente me refiero a una cosa: que no tengan recolector de basura. Recuerda que este proceso puede parar el programa por un tiempo no conocido y de manera no controlada, por lo que si quieres lograr aplicaciones hard realtime, ser√° una tarea extremadamente dif√≠cil. Lamento dec√≠rtelo, pero si quieres asegurar que tu programa se comporte como deseas, vas a tener que controlar casi cada detalle, en lenguajes como C, C++ o Rust.</p>
  </li>
  <li>
    <p><strong>Asegura la fiabilidad de tu infraestructura</strong>. Para que un sistema realtime sea confiable, vas a necesitar que la infraestructura sea resistente a fallas. Esto lo logras eliminando puntos √∫nicos de fallo, es decir, aquellos puntos de tu programa o infraestructura que si fallan hacen que todo el sistema se caiga. Para lograr esto tienes que pensar en arquitecturas distribuidas, redundancia de datos, escalamiento autom√°tico, etc.</p>
  </li>
</ol>

<p>Espero que estos consejos te sirvan y si se me est√° pasando alguno, por favor, d√©jame un comentario.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Conocer los diferentes niveles de servicio que un sistema puede garantizar y comprender las caracter√≠sticas que presentan, te puede ayudar a tomar en serio la responsabilidad de dise√±ar un sistema realtime y la dificultad que implica.</p>

<p>Piensa profundamente si realmente se requiere un sistema con estas caracter√≠sticas (sobre todo si es hard realtime) y si es as√≠, toma en serio la responsabilidad de dise√±arlo y construirlo, espero que los consejos que te di en este art√≠culo te sirvan para lograrlo.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="real-time" /><category term="tiempo-real" /><category term="sistemas-cr√≠ticos" /><summary type="html"><![CDATA[Hablemos que significa que los sistemas sean Real Time y qu√© principios puedes seguir para lograr que tu sistema lo sea.]]></summary></entry><entry><title type="html">Las tres garant√≠as de seguridad de un hash</title><link href="https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash.html" rel="alternate" type="text/html" title="Las tres garant√≠as de seguridad de un hash" /><published>2023-08-28T00:00:00-06:00</published><updated>2023-08-28T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash</id><content type="html" xml:base="https://blog.thedojo.mx/2023/08/28/las-tres-garantias-de-seguridad-de-un-hash.html"><![CDATA[<p>En este art√≠culo profundizaremos sobre las garant√≠as de seguridad m√≠nimas que una funci√≥n hash debe cumplir para ser criptogr√°ficamente segura. En un art√≠culo anterior: <a href="/2021/12/02/algoritmos-criptograficos-que-es-un-hash.html">¬øQu√© es un hash?</a> ya hablamos m√°s detalladamente de la definici√≥n y de los algoritmos que puedes usar a√∫n hoy de manera segura.</p>

<p>Empecemos por una peque√±a definici√≥n de lo que es una funci√≥n hash en la criptograf√≠a.</p>

<h2 id="qu√©-es-un-hash">¬øQu√© es un hash?</h2>

<p>Un hash es una funci√≥n que te devuelve un valor de tama√±o fijo independientemente del tama√±o de la entrada, esto implica una compresi√≥n de datos. Las funciones hash que son usadas en criptograf√≠a, tienen la caracter√≠stica de entregar valores completamente <em>impredecibles</em>, tanto para un humano como para una computadora. Es decir que no hay manera de saber qu√© valor va a entregar una funci√≥n hash para un valor dado si no le has pasado ese valor antes.</p>

<p>Lo anterior no quiere decir que las funciones hash devuelvan algo diferente cada vez que las ejecutas, sino que para un valor dado, siempre devuelven el mismo resultado, y aqu√≠ es donde radica su utilidad.</p>

<p>Un hash perfecto se comportar√≠a como un generador de valores aleatorios, pero debido a lo que hemos dicho anteriormente, deben ser <strong>deterministas</strong> al mismo tiempo que <strong>impredecibles</strong>.</p>

<p>Para medir la seguridad de una funci√≥n hash, se usan tres pruebas, que se conocen como las garant√≠a de seguridad de un hash.</p>

<p>Estas garant√≠as son:</p>

<ol>
  <li>Resistencia a la primera preimagen</li>
  <li>Resistencia a la segunda preimagen</li>
  <li>Resistencia a la colisi√≥n</li>
</ol>

<p>Cada una de estas garant√≠as se refiere a un tipo de ataque que se puede hacer a una funci√≥n hash. Vamos a explicarlas pero antes aclaremos algunos t√©rminos.</p>

<h2 id="imagen-y-preimagen">Imagen y preimagen</h2>

<p>En matem√°ticas, una funci√≥n es una relaci√≥n entre dos conjuntos de valores, uno de entrada y uno de salida. En la mayor√≠a la de las funciones matem√°ticas comunes, cada valor de entrada tiene un √∫nico valor de salida.</p>

<p>Tomemos como ejemplo: \(f(x) = x + 1\), esta funci√≥n toma un valor \(x\) y le suma \(1\), por lo que cada valor de \(x\) tiene un √∫nico valor de salida, porque sabemos que un n√∫mero cualquiera tiene solamente un sucesor.</p>

<p>Pero no todas las funciones se comportan as√≠, por ejemplo: \(f(x) = x^2\). En esta funci√≥n el valor 4 puede ser generado por dos valores de entrada diferentes: \(2\) y \(-2\).</p>

<p>Cuando vemos una funci√≥n as√≠ no es com√∫n que nos definan el conjunto de entrada, as√≠ que asumimos que el conjunto de entrada o <strong>dominio</strong> es el conjunto de los n√∫meros reales, y el conjunto de salida o <strong>codominio</strong> es el conjunto de los n√∫meros reales.</p>

<p>Pensemos en el dominio y codominio como conjuntos amplios en los que los valores de entrada y salida <em>podr√≠an estar</em>. La <strong>imagen</strong> de una funci√≥n es el conjunto de valores que <em>est√°n</em> en el codominio, es decir, los valores que la funci√≥n <em>puede</em> devuelve. La <strong>preimagen</strong> es el conjunto de valores que <em>pueden</em> ser entrada de la funci√≥n.</p>

<p>En t√©rminos pr√°cticos para nosotros los programadores, la imagen es casi equivalente al codominio, y la preimagen es el dominio.</p>

<p>Esta imagen sacada de Wikipedia lo ilustra un poco mejor:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_600/v1693144037/Codomain2_kzda4n.svg" alt="Imagen vs Codomino" class="align-center" /></p>

<p>La imagen es el √°rea amarilla, mientras que Y es el codominio, y X es el dominio. Lo √∫ltimo que nos hace falta saber es que aunque imagen y preimagen son los conjuntos de entradas y salidas del algoritmo, tambi√©n nos podemos referir as√≠ a un valor individual de este conjunto.</p>

<p>Apliquemos los aprendido al ejemplo de la funci√≥n \(f(x) = x^2\). El dominio es el conjunto de los n√∫meros reales, y el codominio tambi√©n es el conjunto de los n√∫meros reales. La imagen es el conjunto de los <strong>n√∫meros reales positivos que tengan una ra√≠z cuadrada</strong>, y la preimagen es el conjunto de los n√∫meros reales. Un ejemplo concreto: para el valor <code class="language-plaintext highlighter-rouge">4</code> considerado como resultado de la funci√≥n o <strong>imagen</strong>, tendr√≠a <em>dos</em> preim√°genes: \(2\) y \(-2\).</p>

<p>Ahora s√≠, hablemos de la primera garant√≠a de seguridad de un hash.</p>

<h2 id="resistencia-a-la-primera-preimagen">Resistencia a la primera preimagen</h2>

<p>Aqu√≠ debes poner atenci√≥n a los valores <em>que se dan</em> para hacer la prueba de seguridad. Presta atenci√≥n a cuando se dice ‚Äúdado un valor‚Äù, estos son la valores que suponemos que ya se conocen.</p>

<p>En la primera garant√≠a es: <strong>Dada</strong> una <em>imagen</em> es computacionalmente inviable encontrar una <em>preimagen</em> que la genere.</p>

<p>En palabras de programadores: Dado un hash, es computacionalmente inviable encontrar un valor que al ser pasado a la funci√≥n hash, genere ese hash.</p>

<p>¬øPor qu√© decimos <strong>un</strong> valor que genere ese hash y no <strong>el</strong> valor que genere ese hash? Porque para un valor de salida, puede haber m√°s de un valor de entrada que lo genere. Especialmente para los hashes, su conjunto de valores posibles es infinito: todas las combinaciones de bits posibles de cualquier tama√±o.</p>

<p>¬øCu√°l es el tama√±o del conjunto de posibles salida? Eso depende del hash usado y su n√∫mero de bits. Por ejemplo, el SHA-256 genera hashes de 256 bits, por lo que su conjunto de posibles valores es \(2^{256}\), que es un n√∫mero muy grande, pero no infinito, por lo que es posible que dos valores generen el mismo hash. Cada uno de esos valores ser√≠a <em>una preimagen</em> de un hash dado.</p>

<p>Entonces ya tenemos todo el escenario: nos han dado un hash y tenemos que encontrar uno de los infinitos valores que pueden producir ese hash, una preimagen.</p>

<p>Pues bien, para un hash criptogr√°ficamente seguro esta operaci√≥n debe de ser imposible de realizar de manera m√°s eficiente que usando fuerza bruta, es decir, probando todos los valores posibles hasta encontrar uno que genere el hash dado.</p>

<p>Para que un hash sea considerado seguro, hallar una preimagen por fuerza bruta deber√≠a tomar \(2^{n}\) operaciones, donde \(n\) es el n√∫mero de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, toma \(2^{256}\) operaciones, que es un n√∫mero muy grande, computacionalmente inviable.</p>

<p>Por ejemplo, imagina que puedes hacer 1 mill√≥n de operaciones por segundo, aproximadamente \(2^{19}\). Encontrar una primera preimagen para el SHA-256 te tomar√≠a \(2^{256} / 2^{19}\), es decir \(2^{247}\) segundos, mientras que lo que se calcula que ha durado el universo son \(2^{38}\) segundos.</p>

<p>Pongamos un ejemplo en Python. Supongamos que la funci√≥n <code class="language-plaintext highlighter-rouge">hash</code> es un hash seguro, y que la funci√≥n <code class="language-plaintext highlighter-rouge">mensaje_aleatorio</code> devuelve un mensaje diferente cada vez. Pon atenci√≥n en lo que recibe la funci√≥n <code class="language-plaintext highlighter-rouge">primera_preimagen</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">primera_preimagen</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">mensaje_aleatorio</span><span class="p">()</span>
    <span class="k">while</span> <span class="nf">hash</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="n">h</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nf">mensaje_aleatorio</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">m</span>
</code></pre></div></div>

<p>Este deber√≠a ser el mejor ataque que se pueda hacer sobre un hash seguro.</p>

<h2 id="resistencia-a-la-segunda-preimagen">Resistencia a la segunda preimagen</h2>

<p>Esta garant√≠a de seguridad es muy parecida a la primera, pero lo que se recibe aqu√≠ es una <em>preimagen</em> y se debe encontrar otra preimagen que genere el mismo hash.</p>

<p>La garant√≠a de seguridad deber√≠a ser la misma: encontrar una segunda preimagen deber√≠a ser computacionalmente inviable, es decir, que tomar√≠a \(2^{n}\) operaciones, donde \(n\) es el n√∫mero de bits del hash.</p>

<p>Pongamos un ejemplo en Python. Observa que usamos la funci√≥n <code class="language-plaintext highlighter-rouge">primera_preimagen</code> que definimos antes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">segunda_preimagen</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nf">hash</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="nf">primera_preimagen</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m2</span>
</code></pre></div></div>

<p>Este ataque no implica m√°s que hashear el mensaje y encontrar una primera preimagen de ese hash. Si el hash es resistente a la primera preimagen, entonces tambi√©n lo ser√° a la segunda.</p>

<p>Parece que esta garant√≠a no tiene mucho sentido, pero vayamos a la tercera y la m√°s conocida.</p>

<h2 id="resistencia-a-colisiones">Resistencia a colisiones</h2>

<p>Una colisi√≥n es cuando dos valores diferentes generan el mismo hash. Ya mencionamos que, al tener un conjunto infinito de valores de entrada y tener un conjunto muy grande (<em>pero limitado</em>) de valores de salida, es inevitable que suceda esto, de hecho, en este caso, un conjunto infinito de valores de entrada generan el mismo hash.</p>

<p>Pero hagamos un caso concreto. Imagina que tu hash recibir√° cadenas de bits de 512 bits, y generar√° un hash de 256 bits. Esto significa que el conjunto de posibles valores de entrada es \(2^{512}\) y el de posibles valores de salida es \(2^{256}\). A cada valor de salida le corresponden \(2^{512}/2^{256} = 2^{512-256}\) valores de entrada, es decir, que para cada valor de salida hay \(2^{256}\) valores de entrada que generan el mismo hash.</p>

<p>Bueno, pues la tercera garant√≠a de seguridad indica que <strong>debe ser computacionalmente inviable encontrar una colisi√≥n</strong>. En este caso no se nos da nada, ni una imagen (hash), ni una preimagen (valor de entrada). Se puede escoger cualquier valor de entrada para encontrar una colisi√≥n.</p>

<p>Aqu√≠ entra la segunda garant√≠a de seguridad, si la funci√≥n hash es resistente a la segunda preimagen, es resistente a colisiones. En Python, el mejor algoritmo para encontrar una colisi√≥n deber√≠a ser el siguiente para un hash seguro:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">encontrar_colision</span><span class="p">():</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">mensaje_aleatorio</span><span class="p">()</span>
    <span class="k">return</span> <span class="nf">encontrar_segunda_preimagen</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<p>La garant√≠a de seguridad que debe de cumplir un hash seguro es que encontrar una colisi√≥n deber√≠a tomar \(2^{n/2}\) operaciones, donde \(n\) es el n√∫mero de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, tomar√≠a \(2^{128}\) operaciones, que sigue siendo un n√∫mero muy grande, computacionalmente inviable.</p>

<p>¬øPor qu√© \(2^{n/2}\)? Porque es m√°s f√°cil encontrar <em>un par</em> de valores que generen el mismo hash sin tener restricciones, que encontrar <em>un valor</em> que genere un hash dado.</p>

<p>Si haces \(N\) hashes, puedes tener ~\(N^2\) oportunidades para encontrar una colisi√≥n por que puedes comparar cada hash con todos los dem√°s. Esto es lo que se conoce como la paradoja del cumplea√±os.</p>

<h2 id="c√≥mo-se-vuelve-inseguro-un-hash">C√≥mo se vuelve inseguro un hash</h2>

<p>Un hash seguro se comporta de manera completamente impredecible con respecto a su valor de entrada. Los hashes inseguros empiezan a dar muestras de regularidad en sus salidas o tienen salidas demasiado peque√±as.</p>

<p>De esta manera, es posible encontrar m√©todos estad√≠sticos para analizar las salidas y as√≠ encontrar patrones que permitan encontrar colisiones o preim√°genes m√°s f√°cilmente.</p>

<p>Pero en realidad, tiene mucho que ver con su construcci√≥n y las formas en las que puedes truquear los valores que le das para reducir el n√∫mero de pasos que se necesitan para encontrar una preimagen o una colisi√≥n.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>En este art√≠culo vimos las tres garant√≠as de seguridad que debe cumplir una funci√≥n hash para ser criptogr√°ficamente segura. Te sirven para entender claramente de lo que se habla cuando se han encontrado colisiones en un hash, y poder evaluar la gravedad de la situaci√≥n.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="hash" /><category term="criptograf√≠a" /><category term="md5" /><category term="sha-256" /><summary type="html"><![CDATA[Veamos m√°s profundamente las garant√≠as de seguridad que debe cumplir un hash para ser considerado seguro. Por fin entenderemos lo que es una colisi√≥n y qu√© significa para nosotros.]]></summary></entry><entry><title type="html">¬øQu√© es la filosof√≠a de la computaci√≥n?</title><link href="https://blog.thedojo.mx/2023/08/19/que-es-la-filosofia-de-la-computacion.html" rel="alternate" type="text/html" title="¬øQu√© es la filosof√≠a de la computaci√≥n?" /><published>2023-08-19T00:00:00-06:00</published><updated>2023-08-19T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/08/19/que-es-la-filosofia-de-la-computacion</id><content type="html" xml:base="https://blog.thedojo.mx/2023/08/19/que-es-la-filosofia-de-la-computacion.html"><![CDATA[<p>La filosof√≠a es una de las ramas m√°s importantes del saber humano y, para mi, es la fundaci√≥n de todas las dem√°s ramas del conocimiento y de las ciencias. En este art√≠culo hablaremos de la filosof√≠a de la computaci√≥n y c√≥mo esta te puede ayudar como programador o desarrollador de software.</p>

<p>Empecemos primero hablando de qu√© es la filosof√≠a y luego combin√°ndola con la computaci√≥n.</p>

<h2 id="qu√©-es-la-filosof√≠a">¬øQu√© es la filosof√≠a?</h2>

<p>La filosof√≠a busca <strong>responder las preguntas fundamentales de la existencia humana</strong>. Casi ninguna de las preguntas importantes se ha podido responder de manera definitiva, pero lo interesante que nos puede ofrecer la filosof√≠a es una an√°lisis profundo de las posibles respuestas y de las implicaciones de cada una de ellas. As√≠, se ha generado mucho conocimiento que nos ayuda a entender mejor el mundo y a nosotros mismos.</p>

<p>Adem√°s, la filosof√≠a ha desarrollado m√©todos que nos pueden ayudar a examinar temas dif√≠ciles de manera efectiva.</p>

<p>Pongamos un ejemplo. Una de las grandes preguntas que muchos fil√≥sofos han intentado responder es ‚Äú¬øCu√°l es la mejor forma de vivir?‚Äù. No hay una respuesta definitiva, pero en la exploraci√≥n se han encontrado y propuesto muchas pr√°cticas que mejoran la vida humana y que sirven en diferentes situaciones.</p>

<p>Adem√°s han surgido modelos de pensamiento que consisten en una serie de ideas y pr√°cticas que pueden darle sentido a una vida bien practicadas: Estoicismo, Epicureismo, etc. Combinadas pueden servirte para mucho para analizar una situaci√≥n en la vida o para encontrar una forma de actuar.</p>

<p>En resumen: la filosof√≠a te ayudar√° a <em>pensar mejor</em> sobre cuestiones importantes en la vida y en las diferentes √°reas de importancia. <strong>¬øC√≥mo se puede relacionar esto con la computaci√≥n?</strong></p>

<h2 id="qu√©-es-la-filosof√≠a-de-la-computaci√≥n">¬øQu√© es la filosof√≠a de la computaci√≥n?</h2>

<p>La filosof√≠a de la computaci√≥n es lo que acabamos de describir pero aplicado a las preguntas que le conciernen a la computaci√≥n. Preguntas fundamentales para todos los que tenemos tratos profundos con las computadoras:</p>

<ul>
  <li>¬øQu√© es la computaci√≥n?</li>
  <li>¬øQu√© es una computadora?</li>
  <li>¬øQu√© es un programa?</li>
  <li>¬øQu√© es computable?</li>
  <li>¬øQu√© es programar?</li>
  <li>¬øQu√© es un lenguaje de programaci√≥n?</li>
  <li>¬øC√≥mo puedo crear programas √∫tiles?</li>
</ul>

<p>Estas preguntas parecen tener un respuesta concreta pero hay algunas situaciones en los que podemos dudar de qu√© tan √∫til o real es lo que sabemos.</p>

<p>La filosof√≠a no se queda all√≠, tiene por lo menos las siguientes √°reas:</p>

<ul>
  <li><strong>La ontolog√≠a</strong>. En la que se preguntan cosas como las que acabamos de ver, que tienen que ver con la existencia y la definici√≥n de las cosas</li>
  <li><strong>La sem√°ntica</strong>. El significado de los t√©rminos que usamos</li>
  <li><strong>La axiolog√≠a</strong>. Analiza los valores que fundamentan la computaci√≥n y los eventos relacionados con estos</li>
  <li><strong>La epistemolog√≠a</strong>. Es el an√°lisis del conocimiento y las formas de obtenerlo: ¬øc√≥mo podemos conocer m√°s acerca de la computaci√≥n? ¬øC√≥mo podemos saber si lo que sabemos es correcto? ¬øC√≥mo <em>sabemos</em> que <em>sabemos</em>?</li>
  <li><strong>La metodolog√≠a</strong>. Qu√© m√©todos podemos seguir para practicar la computaci√≥n y la obtenci√≥n de conocimiento de esta de la mejor manera</li>
  <li><strong>La est√©tica</strong>. Analiza la percepci√≥n que tenemos de los artefactos computacionales y los conceptos relacionados con encontrar agradable o de valor esa percepci√≥n: orden, belleza, significado, etc.</li>
  <li><strong>La √©tica</strong>. Est√° basada en la axiolog√≠a, es decir, en la definici√≥n de lo que consideramos de valor y qu√© acciones o pr√°cticas nos acercan o alejan de lo que consideramos que puede ser ‚Äúbueno‚Äù como resultado de la computaci√≥n</li>
</ul>

<p>Como puedes ver, es amplia, pero cada una de las √°reas te puede ayudar en temas espec√≠ficos en tu pr√°ctica diaria.</p>

<p>A diferencia de la filosof√≠a com√∫n, la filosof√≠a de la computaci√≥n tiene mucho menos de existencia y a penas hay unos cu√°ntos escritos y personas que la han practicado en los √∫ltimos a√±os, as√≠ que si te introduces estar√°s en un campo en que tendr√°s que aplicar las t√©cnicas filos√≥ficas a esta √°rea espec√≠fica, y es probable que te lleves muchas sorpresas.</p>

<h2 id="por-qu√©-es-importante-la-filosof√≠a-de-la-computaci√≥n">¬øPor qu√© es importante la filosof√≠a de la computaci√≥n?</h2>

<p>La filosof√≠a de la computaci√≥n o de ciencias de la computaci√≥n te puede ayudar d√°ndote los fundamentos que necesitas sobre todo para enfrentarte a las cuestiones dif√≠ciles de tu trabajo.</p>

<p>Tener fundamentos para definir lo que quieres lograr, d√≥nde est√°n los l√≠mites de tu trabajo y qu√© es posible, te puede hacer mucho m√°s disfrutable tu d√≠a a d√≠a.</p>

<p>No es algo sin lo que puedas trabajar, pero mientras m√°s sepas de esta √°rea, sin duda m√°s disfrutar√°s de tu trabajo.</p>

<p>Pero esto va mucho m√°s all√°: todas las ideas importantes del <em>desarrollo de software</em>
tienen un camino en la filosof√≠a de la computaci√≥n, as√≠ que si quieres desarrollar mejor software, sin duda es un √°rea fundamental.</p>

<h2 id="c√≥mo-aprender-filosof√≠a-de-la-computaci√≥n">¬øC√≥mo aprender filosof√≠a de la computaci√≥n?</h2>

<p>Recomiendo mucho empezar por lo b√°sico y para esto me ha servido el canal de <a href="https://camilochs.github.io/web/">Camilo Chac√≥n Sartori</a> en <a href="https://www.youtube.com/@camilo_chacon_s">YouTube</a>, en el que tiene una serie en la que te <a href="https://www.youtube.com/watch?v=eVxR8io5xTg&amp;list=PLbA-PGKWV-JhWcaZ0HzHFIFbnVakY9t1o">introduce a las partes de la filosof√≠a de la computaci√≥n</a>.</p>

<p>Pero tambi√©n tiene un video que se llama <a href="https://www.youtube.com/watch?v=97InfGEK3Zw">¬øQu√© es la filosof√≠a de computaci√≥n?</a>, en el que te da una introducci√≥n b√°sica.</p>

<p>Despu√©s, puedes empezar a leer sobre los autores que han escrito de esto por a√±os. Yo recomiendo a William J. Rapaport con su escrito <a href="https://cse.buffalo.edu/~rapaport/Papers/philcs-complete.pdf">A Philosophy of Computer Science</a>.</p>

<p>Y finalmente, para profundizar todav√≠a m√°s, tenemos el libro del mismo autor, publicado en 2023: <a href="https://www.wiley.com/en-us/Philosophy+of+Computer+Science%3A+An+Introduction+to+the+Issues+and+the+Literature-p-9781119891901">Philosophy of Computer Science: An Introduction to the Issues and the Literature</a>.</p>

<p>Si le echas un ojo a esto y te parece intimidante, puedes entrar por algo que tiene una menor barrera y que tambi√©n incluir√≠a en el √°rea de la filosof√≠a de la computaci√≥n: la filosof√≠a de la informaci√≥n. Para esto recomiendo mucho el libro <a href="https://buttondown.email/hillelwayne/archive/data-and-reality-2nd-edition/">Data and Reality</a> de William Kent. En el canal tenemos un <a href="https://youtu.be/i4lADcMZsZo">resumen de este libro</a>.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Aprender filosof√≠a de la computaci√≥n es una muy buena idea para tu carrera. Te ayudar√° a plantearte y a <em>intentar</em> resolver las preguntas importantes. Este intento de contestar las preguntas importantes relacionadas con la computaci√≥n y el desarrollo de software te dar√° m√°s armas para enfrentarte a los problemas del d√≠a a d√≠a y a disfrutarlos m√°s.</p>

<p>Finalmente, las herramientas que desarrollas en el estudio de estos problemas te puede ayudar mucho m√°s all√° de la filosof√≠a: <strong>te ayudar√° a resolver problemas de manera m√°s efectiva.</strong></p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="computaci√≥n" /><category term="filosof√≠a" /><category term="filosof√≠a-de-la-computaci√≥n" /><summary type="html"><![CDATA[Veamos qu√© es y c√≥mo te puede ayudar la filosof√≠a de la computaci√≥n en tu carrera como desarrollador de software.]]></summary></entry><entry><title type="html">¬øPor qu√© debes aprender ciencias de la computaci√≥n?</title><link href="https://blog.thedojo.mx/2023/08/12/por-que-debes-aprender-ciencias-de-la-computacion.html" rel="alternate" type="text/html" title="¬øPor qu√© debes aprender ciencias de la computaci√≥n?" /><published>2023-08-12T00:00:00-06:00</published><updated>2023-08-12T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/08/12/por-que-debes-aprender-ciencias-de-la-computacion</id><content type="html" xml:base="https://blog.thedojo.mx/2023/08/12/por-que-debes-aprender-ciencias-de-la-computacion.html"><![CDATA[<p>Las ciencias de la computaci√≥n a veces parecen algo m√≠tico para los desarrolladores, algo que s√≥lo aquellos que trabajan en <em>Big Tech</em> o en la <em>NASA</em> pueden entender. Pero si programas, es algo <em><strong>ya que usas a diario</strong></em>, por lo que te conviene comprenderlo mejor.</p>

<p>Empecemos por el principio definiendo qu√© son y c√≥mo te pueden ayudar.</p>

<h2 id="qu√©-son-las-ciencias-de-la-computaci√≥n">¬øQu√© son las ciencias de la computaci√≥n?</h2>

<p>Las <strong>ciencias de la computaci√≥n</strong> son un campo de estudio que busca entender los principios que rigen el <strong>fen√≥meno de la computaci√≥n</strong> en general. Podemos definir la computaci√≥n como el proceso de transformar informaci√≥n en algo √∫til, normalmente de manera dirigida.</p>

<p>Las ciencias de la computaci√≥n abarcan desde la definici√≥n y estudio conceptual de los principios que rigen la computaci√≥n, hasta la implementaci√≥n de algoritmos y estructuras de datos, junto con su <strong>ejecuci√≥n en medios f√≠sicos</strong>. Esta √∫ltima parte es la que m√°s nos concierne como desarrolladores.</p>

<p>Como podr√°s ver, es un campo muy amplio, pero muy interesante y que puede darte una visi√≥n m√°s amplia de lo que haces d√≠a a d√≠a, pero que adem√°s te puede ayudar a comprender los componentes principales del entorno en el que tus programas corren y c√≥mo funcionan.</p>

<p>Algunos de los principios temas que trata son:</p>

<ul>
  <li>Lo que es posible calcular y lo que no</li>
  <li>En qu√© medios se puede ejecutar un programa</li>
  <li>Cu√°les son formas eficientes y confiables de almacenar informaci√≥n</li>
  <li>C√≥mo se puede representar la informaci√≥n</li>
  <li>C√≥mo se puede transmitir la informaci√≥n sin que se corrompa</li>
  <li>C√≥mo se puede transformar la informaci√≥n de manera eficiente</li>
  <li>C√≥mo proteger la informaci√≥n</li>
  <li>C√≥mo coordinar varias computadoras</li>
</ul>

<p>C√≥mo podr√°s ver, son problemas a los que nos enfrentamos d√≠a a d√≠a en nuestro trabajo de manera continua.</p>

<h2 id="por-qu√©-son-importantes">¬øPor qu√© son importantes?</h2>

<p>La mayor√≠a de los problemas que resolvemos en nuestro trabajo diario ya han sido resueltos en el pasado, por personas usando conocimientos que podemos considerar como ciencias de la computaci√≥n y puestos en pr√°ctica en forma de algoritmos y estructuras de datos, implementados en los lenguajes de programaci√≥n que usamos. Tambi√©n los frameworks y librer√≠as que usamos son implementaciones de estos principios.</p>

<p>Pero, ¬øqu√© pasa cuando quieres hacer algo que va m√°s all√° de lo que tu lenguaje o tu plataforma te ofrece por default? Aqu√≠ es donde entra el conocimiento de c√≥mo funciona la computaci√≥n de manera m√°s profunda, los principios que rigen la computaci√≥n, y las t√©cnicas para resolver problemas.</p>

<p>Si quieres hacer cosas que vayan m√°s all√° de lo com√∫n, las ciencias de la computaci√≥n te pueden proporcionar las herramientas y habilidades para lograrlo de manera sostenible.</p>

<p>Saber ciencias de la computaci√≥n puede hacer la diferencia entre primero, que seas capaz de crear eficazmente lo que te est√°s imaginando y segundo que sea exitoso y pueda seguir creciendo.</p>

<h2 id="c√≥mo-aprender-ciencias-de-la-computaci√≥n">¬øC√≥mo aprender ciencias de la computaci√≥n?</h2>

<p>La parte m√°s importante de este art√≠culo es c√≥mo aprender ciencias de la computaci√≥n. Si cursaste la universidad en una carrera relacionada con la computaci√≥n, es probable que ya tengas las bases, o por lo menos la idea de los temas principales que puedes estudiar.</p>

<p>Pero lo triste es que casi siempre se ense√±a de manera segregada (se tratan los temas por separado sin ver la relaci√≥n entre ellos) y desactualizada (se presenta la visi√≥n de los a√±os 70s o 80s).</p>

<p>Por eso, independientemente de tu formaci√≥n, te recomiendo que leas los siguientes libros:</p>

<ul>
  <li><a href="https://mitpress.mit.edu/books/computational-thinking">Computational Thinking</a>. En este libro tendr√°s una introducci√≥n a los temas principales del pensamiento computacional, algo completamente necesario para entender las ciencias de la computaci√≥n.</li>
  <li><a href="https://mitpress.mit.edu/9780262527125/great-principles-of-computing/">Great Principles of Computing</a>. Para mi este libro presenta la visi√≥n m√°s moderna de las ciencias de la computaci√≥n. En el art√≠culo <a href="/2023/05/13/libros-que-todo-desarrollador-de-software-deberia-leer-cs.html">‚ÄúLibros que todo desarrollador deber√≠a leer: ciencias de la computaci√≥n‚Äù</a>, encontrar√°s m√°s recomendaciones.</li>
</ul>

<p>Si no sabes nada de ciencias de la computaci√≥n puede empezar con algo m√°s ligero como:</p>

<ul>
  <li><a href="https://www.amazon.com/Computer-Science-Distilled-Computational-Problems/dp/0997316020">Computer Science Distilled</a></li>
  <li><a href="https://pll.harvard.edu/course/cs50-introduction-computer-science">CS50</a></li>
</ul>

<p>Si tienes alguna otra recomendaci√≥n, no dudes en ponerla en los comentarios.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Aprender ciencias de la computaci√≥n es una buena idea para tu carrera, independientemente de la etapa en la que te encuentres o de la rama de la programaci√≥n a la que te dediques. Te ayudar√° a evitar la frustraci√≥n de no saber por qu√© algo no funciona, o peor a√∫n, que funcione y no saber por qu√©.</p>

<p>Consulta los recursos que recomendamos en este art√≠culo y empieza a aprender hoy mismo. Adem√°s en este blog encontrar√°s muchos art√≠culos relacionados con las ciencias de la computaci√≥n, as√≠ que no dudes en explorarlos.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="ciencias-de-la-computaci√≥n" /><category term="cs" /><category term="computer-science" /><summary type="html"><![CDATA[Las ciencias de la computaci√≥n te ayudar√°n a ser mejor desarrollador, independientemente de la rama de la programaci√≥n a la que te dediques. Veamos como.]]></summary></entry><entry><title type="html">La matriz del conocimiento para devs</title><link href="https://blog.thedojo.mx/2023/06/29/la-matriz-del-conocimiento-para-devs.html" rel="alternate" type="text/html" title="La matriz del conocimiento para devs" /><published>2023-06-29T00:00:00-06:00</published><updated>2023-06-29T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/06/29/la-matriz-del-conocimiento-para-devs</id><content type="html" xml:base="https://blog.thedojo.mx/2023/06/29/la-matriz-del-conocimiento-para-devs.html"><![CDATA[<p>La epistemolog√≠a es la rama de la filosof√≠a que estudia la naturaleza del conocimiento. Una de sus principales tareas es la de estudiar c√≥mo se adquiere el conocimiento y c√≥mo se representa.</p>

<p>La <strong>matriz de Rumsfeld</strong> es una herramienta que nos ayuda a representar el conocimiento y a identificar qu√© conocimiento nos falta para tomar decisiones. En este art√≠culo vamos a ver c√≥mo funciona y c√≥mo nos puede ayudar.</p>

<h2 id="la-matriz-de-rumsfeld">La matriz de Rumsfeld</h2>

<p>Seg√∫n nuestro grado de conocimiento y la consciencia que tenemos de √©l, podemos clasificarlo en 4 categor√≠as:</p>

<ol>
  <li>Lo que sabemos que sabemos</li>
  <li>Lo que sabemos que <strong>no</strong> sabemos</li>
  <li>Lo que <strong>no</strong> sabemos que sabemos</li>
  <li>Lo que <strong>no</strong> sabemos que <strong>no</strong> sabemos</li>
</ol>

<p>La representaci√≥n tradicional es la siguiente:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1688048267/Ilustracio%CC%81n_sin_ti%CC%81tulo_5_lpvjyv.png" alt="Matriz de Rumsfeld" class="align-center" /></p>

<p>Pero no me gusta porque pone las cuatro categor√≠as como del mismo tama√±o. Mi representaci√≥n personal, que me parece que guarda mejor las proporciones es esta:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1688048203/Ilustracio%CC%81n_sin_ti%CC%81tulo_6_lonjhl.png" alt="Matriz de Rumsfeld" class="align-center" /></p>

<p>Bueno, haci√©ndola un poco m√°s legible (y rompiendo las proporciones) quedar√≠a as√≠:</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1688048200/Ilustracio%CC%81n_sin_ti%CC%81tulo_8_rg17f0.png" alt="Matriz de Rumsfeld" class="align-center" /></p>

<p>Pero quiero que te quedes con la idea de una frase que escuch√© en una serie llamada Dark: ‚ÄúLo que sabemos que sabemos es una gota, lo que no sabemos es un oc√©ano.‚Äù</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1688017245/5557d4f59b6ee4332ffae7f2a68513b7_n0ci5o.png" alt="Escena de Dark" /></p>

<h2 id="ejemplos">Ejemplos</h2>

<p>Pongamos algunos ejemplos de cada categor√≠a para entenderlos mejor.</p>

<h3 id="categor√≠a-1-lo-que-sabemos-que-sabemos">Categor√≠a 1: Lo que sabemos que sabemos</h3>

<p>En este √°rea est√°n todas las cosas que nuestra consciencia puede encontrar y a veces incluso explicar. Por ejemplo si eres programador sabes que sabes alg√∫n lenguaje de programaci√≥n, como Python, Go, Scala. Hablando del futuro sabemos que es muy probable que todos estos lenguajes tengan nuevas versiones, o que se encuentren vulnerabilidades en ellos y que se tengan que actualizar.</p>

<p>Tambi√©n podr√≠amos incluir el conocimiento acad√©mico, cosas que hayamos estudiado recientemente y cosas similares.</p>

<h2 id="categor√≠a-2-lo-que-sabemos-que-no-sabemos">Categor√≠a 2: Lo que sabemos que no sabemos</h2>

<p>Siguiendo el ejemplo de los lenguajes de programaci√≥n, normalmente sabemos uno o dos, pero estamos conscientes de que no conocemos su funcionamiento interno, o que no conocemos otros lenguajes, por ejemplo Ocaml, Haskell, etc. O sabemos que no podemos montar una infraestructura de Kubernetes, pero sabemos que existe y que hay gente que lo sabe hacer, as√≠ que podr√≠amos investigarlo. Tambi√©n hay cosas que son imposibles de conocer y lo sabemos, por ejemplo, cuando va a salir exactamente la pr√≥xima versi√≥n de Python.</p>

<h2 id="categor√≠a-3-lo-que-no-sabemos-que-sabemos">Categor√≠a 3: Lo que no sabemos que sabemos</h2>

<p>Aqu√≠ se empiezan a  poner dif√≠ciles las cosas, ¬øc√≥mo que hay cosas que no sabemos que sabemos? Este es el conocimiento t√°cito, cosas que hemos adquirido indirectamente o que ya est√°n tan interiorizadas que no nos damos cuenta que sabemos. Por ejemplo cuando eres programador no te das cuenta que <em>est√°s haciendo matem√°ticas</em> con el simple hecho de programar. Entonces sabes matem√°ticas (por lo menos una rama de ellas), pero no te das cuenta. Otro ejemplo es con nuestro lenguaje natural, sabemos conjugar en todas las formas de subjuntivo, pero no sab√≠amos ni c√≥mo se llama eso.</p>

<p>Una sub-categor√≠a este tipo de conocimiento es el que tenemos pero no nos damos cuenta que es relevante para el problema en cuesti√≥n que estamos tratando.</p>

<h2 id="categor√≠a-4-lo-que-no-sabemos-que-no-sabemos">Categor√≠a 4: Lo que no sabemos que no sabemos</h2>

<p>Esta es la m√°s dif√≠cil de entender, en ingl√©s le llaman los ‚Äúunknown unknowns‚Äù  y son todas aquellas cosas que no sab√≠amos siquiera que ten√≠amos que preguntar. En el caso de los lenguajes de programaci√≥n, por ejemplo est√° el caso de los lenguajes que ni siquiera hemos escuchado su nombre, o de todos aquellos conceptos que no sabemos que existen. Por ejemplo, si no sabemos que existe la programaci√≥n funcional, no sabemos que no sabemos programaci√≥n funcional.</p>

<p>Respecto al futuro, este conocimiento son aquellas cosas que no podemos prever que pasar√°n, por ejemplo, que un proyecto dejar√° de mantenerse de manera s√∫bita, que su autor principal morir√°, etc.</p>

<p>Cuando eres completamente nuevo en un campo, esta parte es tan abrumadora y se come completamente a la categor√≠a 2, las de las cosas que sabemos que no sabemos, que es muy f√°cil pensar que sabes todo lo que hay que saber, pero no es as√≠. Cuando vas conociendo m√°s el √°rea o el tema, vas sacando cosas de esta categor√≠a y las vas poniendo en la categor√≠a 2, las cosas que sabes que no sabes, y ah√≠ es cuando empiezas a <em>de verdad</em> conocer algo.</p>

<p>Lo m√°s peligroso (y tambi√©n la mayores oportunidades) para los proyectos y para nosotros est√°n en esta categor√≠a.</p>

<h2 id="c√≥mo-nos-ayuda-esta-clasificaci√≥n">¬øC√≥mo nos ayuda esta clasificaci√≥n?</h2>

<p>Esta matriz nos da consciencia de la cantidad de conocimiento <strong>que nos hace falta</strong> y nos hace pensar adem√°s que hay cosas que ni siquiera nos imaginamos que no sabemos.</p>

<p>La matriz de Rumsfeld, est√° principalmente considerada como una herramienta para la toma de decisiones y el <strong>an√°lisis de riesgos</strong>. Las principales formas de aplicarla son:</p>

<ol>
  <li><strong>Al planear de proyectos</strong>, en donde podemos analizar las cuatro categor√≠as para encontrar los riesgos de que un proyecto sea factible y salga en el tiempo y presupuesto planeados.</li>
  <li><strong>Al escoger tu stack tecnol√≥gico</strong>. Recuerda que cuando empiezas a conocer algo puedes sentir que lo sabes todo y tener una confianza excesiva al tener pocas preguntas sobre el tema, pero esto s√≥lo es una se√±al de que la categor√≠a 4, los desconocidos desconocidos, es demasiado grande. Eso es exactamente lo que pasa con las tecnolog√≠as demasiado nuevas o que est√°s empezando a conocer, lo que puede hacer que un proyecto se vuelva inviable. Por eso, guiarte por esta matriz para escoger la tecnolog√≠a que vas a usar te puede proteger de tomar decisiones demasiado arriesgadas.</li>
  <li><strong>Desarrollo de software resiliente</strong>. Al evaluar contra qu√© te deber√≠as proteger, vale tener en cuenta que hay cosas que son imposibles de predecir o imposibles de saber. Esto te llevar√° a fortalecer las √°reas del sistema cr√≠ticas para recuperarse de cualquier problema, conocido o desconocido, que puedan afectar su funcionamiento general.</li>
</ol>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>La matriz del conocimiento nos ayuda a poner los pies en la tierra respecto a los riesgos y lo que de verdad podemos considerar que sabemos. √ösala para planear tus proyectos, escoger tu tecnolog√≠a y proteger tus sistemas contra cosas que pueden ser catastr√≥ficas.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="conocimiento" /><category term="epistemolog√≠a" /><summary type="html"><![CDATA[La principal trae de un desarrollador es representar el conocimiento en procesos computacionales. Veamos una herramienta que te puede ayudar a administrar mejor ese conocimiento.]]></summary></entry><entry><title type="html">Sigue el ciclo de la creatividad</title><link href="https://blog.thedojo.mx/2023/06/27/sigue-el-ciclo-de-la-creatividad.html" rel="alternate" type="text/html" title="Sigue el ciclo de la creatividad" /><published>2023-06-27T00:00:00-06:00</published><updated>2023-06-27T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/06/27/sigue-el-ciclo-de-la-creatividad</id><content type="html" xml:base="https://blog.thedojo.mx/2023/06/27/sigue-el-ciclo-de-la-creatividad.html"><![CDATA[<p>Hay algunas personas que creen que el desarrollo de software s√≥lo trata de resolver problemas anal√≠ticamente, pero lo cierto es que para encontrar soluciones siempre se requiere de creatividad.</p>

<p>Sin embargo, muchas veces pensamos que la creatividad como desarrolladores de software no es nuestro fuerte, pero no hay nada m√°s lejos de la realidad. Si te has dedicado exitosamente a esto por un tiempo, has demostrado que eres creativo o creativa, s√≥lo que no de la manera que se considera tradicionalmente, eso que tiene que ver con el arte, la belleza y otras cosas.</p>

<p>Tu creatividad generalmente se demuestra en la aplicaci√≥n y mezcla de ideas para resolver problemas en nuevas situaciones.</p>

<p>En el libro <a href="https://kadavy.medium.com/mind-management-not-time-management-25ebd3a58dc6"><strong>‚ÄúMind Management, Not Time Management‚Äù</strong> de David Kadavy</a>, se habla de un ciclo de creatividad y en este art√≠culo lo quiero aplicar a nuestro trabajo de desarrollo de software.</p>

<h2 id="el-ciclo-de-la-creatividad">El ciclo de la creatividad</h2>

<p>Creo que esto no te va ense√±ar nada nuevo, porque probablemente lo <em>has vivido</em> muchas veces. Pero vamos a ponerle estructura y nombres a los diferentes pasos para que podamos replicarlo de manera m√°s consciente.</p>

<p>El ciclo de la creatividad est√° compuesto por cuatro fases:</p>

<ul>
  <li><strong>Preparaci√≥n</strong>: Tienes que obtener la mayor cantidad informaci√≥n, estudiar el problema y se <strong>analizar</strong> las posibles soluciones. En nuestro caso incluso puede que tengamos que hacer algunas pruebas de concepto. Es muy importante entender que en esta etapa <strong>no vas resolver el problema</strong>, si encuentras alg√∫n tipo de bloqueo debes dejarlo pasar y seguir explorando.</li>
  <li><strong>Incubaci√≥n</strong>: En esta fase tienes que de pensar en el problema, se hace otra cosa, se descansa, se duerme, se hace ejercicio. Tu mente procesar√° lo que acabas de leer, de manera inconsciente.</li>
  <li><strong>Iluminaci√≥n</strong>: Esta parte no la puedes forzar, a veces incluso tienes que repetir las dos fases de manera c√≠clica hasta que llega la respuesta. Aqu√≠ es donde todo parece que hace click y la soluci√≥n aparece ‚Äúde la nada‚Äù (ya sabes que no es as√≠ porque has hecho mucho trabajo previo.)</li>
  <li><strong>Verificaci√≥n</strong>: Ahora que tienes una idea, falta comprobarla y m√°s importante a√∫n: llevarla a cabo. En esta tienes que asegurarte que la soluci√≥n que encontraste es correcta, <em>o tienes que hacer lo suficiente para empezar a probarla</em>. Puede que te equivoques y tengas que volver a empezar el ciclo, pero con nuevos conocimientos.</li>
</ul>

<p>Este ciclo me pareci√≥ muy interesante porque se me hace equivalente en pasos a los pasos que <strong>George Polya</strong> propone. En su libro <strong>‚ÄúHow to Solve It‚Äù</strong> habla de cuatro pasos para resolver problemas:</p>

<ol>
  <li>Entender el problema == Preparaci√≥n e Incubaci√≥n</li>
  <li>Idear un plan == Incubaci√≥n e Iluminaci√≥n (La parte <strong><em>m√°s dif√≠cil</em></strong>, Polya dice que si tienes un plan, ya casi resolviste el problema)</li>
  <li>Llevar a cabo el plan == Verificaci√≥n</li>
  <li>Revisar el plan == Verificaci√≥n</li>
</ol>

<h2 id="ejemplo">Ejemplo</h2>

<p>El ejemplo m√°s cl√°sico en el que usamos el ciclo de la creatividad naturalmente es cuando estamos resolviendo un bug dif√≠cil. Veamos los pasos:</p>

<ol>
  <li>
    <p>Preparaci√≥n: Intentamos entender el bug, y el comportamiento esperado, consultamos la documentaci√≥n o el c√≥digo que lo est√° produciendo. Si es lo suficientemente dif√≠cil, este bug se va con nosotros a dormir.</p>
  </li>
  <li>
    <p>Incubaci√≥n: Despu√©s de sentirte derrotado por el bug, te alejas, ya sea porque termin√≥ el d√≠a de trabajo, porque te vas a hacer otras cosas o porque simplemente te quieres despejar.</p>
  </li>
  <li>
    <p><strong>Iluminaci√≥n</strong>: Durante alguna otra actividad, como ba√±√°ndote, caminando, haciendo ejercicio o tambi√©n cuando regreses al c√≥digo, ves la soluci√≥n, como si siempre hubiera estado ah√≠, de manera obvia.</p>
  </li>
  <li>
    <p>Verificaci√≥n: Implementas la soluci√≥n y pruebas que todo est√© funcionando como deber√≠a.</p>
  </li>
</ol>

<p><strong>¬øVes c√≥mo s√≠ te ha pasado?</strong> Ese es el ciclo de la creatividad, que nosotros usamos resolviendo problemas. Veamos algunas formas de extenderlo y aprovecharlo mejor.</p>

<h2 id="aplicaci√≥n-el-poder-de-la-preparaci√≥n">Aplicaci√≥n: el poder de la preparaci√≥n</h2>

<p>Ahora que ya tienes un nombre para esto que te pasa muy constantemente, puedes aprovecharlo para desencadenarlo intencionalmente.</p>

<p>Antes, pensemos un poco. ¬øCu√°l es la parte del ciclo que nos interesa aprovechar? Para mi es el poder de <strong>incubaci√≥n</strong>, que es lo que produce la iluminaci√≥n, o sea, lo que hace que te lleguen las ideas para resolver tu problema de manera creativa.</p>

<p>Pero, ¬øc√≥mo vas a incubar si no tienes nada que hacer crecer? Es aqu√≠ donde entra el valor de la preparaci√≥n. Si quieres resolver un problema dif√≠cil, inclusive uno que sientes que ahora mismo est√° un poco por encima de tus capacidades, la mejor manera de hacerlo es aprovechando este ciclo. Primero te preparas lo mejo que puedas, estudiando el problema, analizando los posibles caminos que puedes seguir e incluso haciendo algunas pruebas de concepto. Seguro que esto ya lo haces.</p>

<p>Despu√©s y esto es la parte m√°s importante de este art√≠culo (y la que te puede estar fallando), tienes que <strong>alejarte del problema</strong>. As√≠ es, olv√≠date de √©l, cambia de problema, ve a dormir, sal a pasear, date un ba√±o. Tienes que hacer algo que ocupe tu mente.</p>

<p>David Kadavy dice en su libro que esto te permite olvidarte de las ideas que no funcionan y fortalecer las que s√≠, y me parece una buena propuesta. Si lo comparas con un algoritmo, buscar una soluci√≥n a un problema es como hacer una b√∫squeda en un √°rbol, s√≥lo que este √°rbol tiene m√°s ramas de las que puedes seguir, as√≠ que tienes que podarlas. La incubaci√≥n es la poda, que adem√°s fortalece las ramas que es m√°s probable que te lleven a la soluci√≥n.</p>

<p>Esto tambi√©n se puede aplicar de manera m√°s sencilla.Por ejemplo, ¬øtienes que dise√±ar una pieza de software y sientes que no tienes ni idea de por d√≥nde empezar? Combinando las ense√±anzas de Polya con el ciclo de la creatividad, lo primero es definir completamente el problema. Una vez que sientas que lo has entendido (muchas veces ayuda ponerlo por escrito e incluso pedir que alguien m√°s lo revise).</p>

<p>Despu√©s de esto, <em>sobre todo si no tienes una soluci√≥n clara</em>, o propuestas que hacer, <strong>busca alejarte lo m√°s posible</strong>. Es por eso que muchos profesionales veteranos y exitosos tienen actividades alternas, alejadas de la programaci√≥n e incluso de la computadora. Cuando regreses a trabajar sobre el problema, es mucho m√°s probable que tengas una soluci√≥n.</p>

<p>Se que esto suena m√°gico, pero nada te puede convencer m√°s que la propia que ya tienes resolviendo problemas de otro estilo. Si esto no funciona, recuerda que puedes repetir el ciclo tantas veces como sea necesario.</p>

<p>Claro, esto no asegura que la soluci√≥n te llegar√° m√°gicamente siempre, pero con esto aumentamos las probabilidades de que tu naturaleza creativa trabaje por ti.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Siempre que puedas, frente a problemas dif√≠ciles, aplica este ciclo: prep√°rate lo mejor que puedas, explorando soluciones, asegur√°ndote de entender todas la variables del problema, escribiendo la definici√≥n del problema. Despu√©s <strong>al√©jate de problema</strong>, as√≠ permitir√°s que se <strong>incube</strong>.</p>

<p>Finalmente, regresa y trata de resolverlo de nuevo. Claro que despu√©s de esto tienes que ejecutar y verificar tu soluci√≥n.</p>

<p>Espero que esta informaci√≥n te sea √∫til y que la puedas aplicar en tu d√≠a a d√≠a.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="creatividad" /><category term="resoluci√≥n-de-problemas" /><summary type="html"><![CDATA[La programaci√≥n es una profesi√≥n muy creativa y por eso es importante que aprendamos a manejarla, hablemos de las etapas para resolver un problema de forma creativa y c√≥mo puedes aprovecharlas.]]></summary></entry><entry><title type="html">Modelos mentales para desarrolladores: modelos elementales</title><link href="https://blog.thedojo.mx/2023/06/22/modelos-mentales-para-desarrolladores-elementales.html" rel="alternate" type="text/html" title="Modelos mentales para desarrolladores: modelos elementales" /><published>2023-06-22T00:00:00-06:00</published><updated>2023-06-22T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/06/22/modelos-mentales-para-desarrolladores-elementales</id><content type="html" xml:base="https://blog.thedojo.mx/2023/06/22/modelos-mentales-para-desarrolladores-elementales.html"><![CDATA[<p>La <strong>mente</strong> es la principal herramienta del desarrollador de software. Puedes ayudar a que se desempe√±e mejor si le das, a su vez, herramientas que te permitan <em>organizar, comprender, combinar y analizar m√°s r√°pido la informaci√≥n</em>. Estas herramientas adem√°s te pueden ayudar a ver cosas claramente que antes eran imposibles de ver, o a llegar m√°s profundo en los an√°lisis.</p>

<p>Estas herramientas son los <strong>modelos mentales</strong>, que en este art√≠culo explicaremos, pero adem√°s daremos algunos ejemplos que te servir√°n directamente como desarrollador. Estos ejemplos son, a nuestro modo de ver, los modelos esenciales que debes conocer. Empecemos dando una definici√≥n clara.</p>

<h2 id="qu√©-son-los-modelos-mentales">¬øQu√© son los modelos mentales?</h2>

<p>Un modelo mental es una estructura que te permite organizar la informaci√≥n que recibes o que observas, para que puedas ver aspectos particulares de esta, aplicarle proyecciones o simplemente para que puedas entenderla mejor. Tambi√©n se puede pensar en ellos como en <em>lentes</em> que te permiten ver el mundo de una forma particular.</p>

<p>Los desarrolladores de software estamos acostumbrados a usar modelos para representar la realidad. Recuerda que un modelo es una abstracci√≥n, <strong>una representaci√≥n simplificada</strong> de la realidad que se enfoca en ciertos elementos y deja fuera otros.</p>

<p>Los modelos mentales son esto mismo, pero la diferencia es que tienen aplicaci√≥n a trav√©s de muchas situaciones. Estos modelos mentales te permiten usar la informaci√≥n de manera m√°s eficiente y, a veces, ver la realidad m√°s claramente. <strong>Charlie Munger</strong>, uno de los principales proponentes de los modelos mentales, dice que para pensar efectivamente, debes tener una <strong>malla o red de modelos mentales</strong> que puedas usar para pensar mejor. Algo a lo que se pueden parece un poco es a los patrones de dise√±o, pero aplicados a la vida real.</p>

<p>Nuestro objetivo es ayudarte a construir esta malla de modelos mentales que te permitan ser m√°s efectivo en el desarrollo de software. Empecemos con los m√°s b√°sicos.</p>

<h3 id="la-navaja-de-ockham">La navaja de Ockham</h3>

<p>Este es uno de los modelos mentales que m√°s personas conocen. En l√≠neas generales establece que cuando est√©s buscando explicaciones a algo que hayas observado y est√©s decidiendo entre varios posibles caminos, <strong>el m√°s sencillo es el que tiene la mayor probabilidad de ser la explicaci√≥n correcta</strong>.</p>

<p>¬øC√≥mo se puede aplicar a los problemas que nos enfrentamos <em>com√∫nmente</em> como desarrolladores? Siempre que est√©s decidiendo entre diferentes dise√±os que cumplen con los requerimientos <strong>actuales</strong>, escoge el m√°s sencillo de los dise√±os, sin dejarte influir demasiado <em>por que podr√≠as necesitar en el futuro</em>. Esto se conecta con el principio de <a href="https://martinfowler.com/bliki/Yagni.html">YAGNI</a> (You aren‚Äôt gonna need it), que dice que no debes implementar cosas que no necesitas ahora, porque podr√≠as necesitarlas en el futuro. Tambi√©n se conecta con el principio de buscar la simplicidad al m√°ximo en el desarrollo de software.</p>

<p>Tambi√©n lo puedes aplicar a los procesos que modelas en el software: cuando est√©s descubriendo el por qu√© de algo,</p>

<h3 id="el-mapa-no-es-el-territorio">El mapa no es el territorio</h3>

<p>Los desarrolladores de software trabajamos creando <strong>modelos</strong> de la realidad que pueden ser representados dentro de una computadora, muchas veces para simular procesos o simplemente capturamos ideas que ya son abstractas para que corran dentro de la computadora.</p>

<p>Un <strong>mapa</strong> es un <strong>modelo</strong> de un territorio f√≠sico. Pero podemos cometer el error de pensar que el mapa y el territorio son equivalentes, cuando lo cierto es que, al ser un modelo, el mapa es una representaci√≥n imperfecta y simplificada del territorio real.</p>

<p>As√≠ son todos los modelos y debemos recordarlo, para muchos casos, la mayor√≠a yo dir√≠a, <strong>no existe un modelo absolutamente</strong> correcto y todos dejan algo fuera. Todos son arbitrarios y si alguien de nuestro equipo tiene una visi√≥n diferente, deber√≠amos escucharla, tratar de entenderla y ver c√≥mo podemos integrar ambas visiones en un solo modelo.</p>

<p>Tus representaciones, tus modelos, <strong>no son la realidad</strong>, por lo que siempre pueden mejorarse. Adem√°s de que confiar en un modelo como en una gu√≠a perfecta te puede llevar a cometer errores graves. Es por eso que es bueno recordar siempre, que los modelos (los mapas) son representaciones imperfectas de la realidad (el territorio), y que algunos son m√°s <em>convenientes</em> que otros para diferentes acciones o situaciones, adem√°s de que no <strong>existe EL MODELO correcto</strong> para cierta situaci√≥n.</p>

<p>Si aplicas este modelo mental a los mismos modelos mentales, ver√°s por qu√© necesitas una variedad de ellos para poder pensar mejor.</p>

<h2 id="el-ganador-se-lo-lleva-todo">El ganador se lo lleva todo</h2>

<p>Hay procesos en el mundo, de hecho, muchos, en los que los ‚Äúpremios‚Äù (puedes pensar en ellos como las recompensas o beneficios de una actividad) no se distribuyen uniformemente, sino que las ganancias se acumulan en un s√≥lo lugar, para que unos pocos se lleven la mayor√≠a de los beneficios.</p>

<p>En la actualidad, muchos procesos se comportan as√≠, pero adem√°s se exacerba con la tecnolog√≠a digital, en la que los ganadores de procesos como por la creaci√≥n de contenido. Para aplicar este modelo, debes aprender a ver qui√©n se lleva la mayor√≠a de los beneficios.</p>

<p>Este modelo aplicado al software se puede ver en la puesta en marcha de las aplicaciones, pero de forma inversa. A diferencia de lo que puede pasar en otras industrias, un proyecto a medio terminar provee un valor casi nulo. Yo me atrever√≠a a decir que un proyecto de software que no est√© en producci√≥n, vale cero. As√≠ que, siempre esfu√©rzate por entregar el software o ponerlo en manos de tus usuarios lo m√°s pronto posible.</p>

<h2 id="la-falacia-del-costo-hundido">La falacia del costo hundido</h2>

<p>Todos hemos enfrentado esta pregunta: ¬øsigo invirtiendo tiempo y esfuerzo en este proyecto que no est√° dando resultados? <strong>¬øHasta cuando debo seguir invirtiendo en este proyecto?</strong></p>

<p>A veces llegamos a la conclusi√≥n de que lo mejor ser√≠a dejar de invertir en ese proyecto <strong>YA MISMO</strong>, pero algo nos detiene: <strong>el tiempo y esfuerzo que ya hemos invertido</strong>. Esto es el <strong>costo hundido</strong>. Los seres humanos tenemos naturalmente m√°s aversi√≥n por <em>perder</em> algo, que deseos de <em>ganar</em> m√°s cosas.</p>

<p>Pensar que lo que ya invertimos lo vamos a perder si dejamos algo que no nos ha dado resultados (y no tiene pinta de que los vaya a dar) nos detiene de tomar decisiones que son muy claras: si no <em>hubi√©ramos</em> invertido ese tiempo y esfuerzo, no tendr√≠amos razones para seguir invirtiendo en este proyecto o aunque sea para mantenerlo. O sea que una inversi√≥n pasada, en vez de producirnos beneficios, nos est√° produciendo p√©rdidas, por el puro temor a perderla.</p>

<p>Este modelo mental se puede aplicar a los proyectos de desarrollo de software que despu√©s de cambiar de estrategia muchas veces no han dado rendimientos. Adem√°s como desarrolladores a veces estamos orgullosos de la arquitectura o los logros t√©cnicos de cierto sistema o cierta parte del c√≥digo, pero ha llegado el momento de reemplazarla por algo que se adec√∫e mejor a las necesidades actuales.</p>

<p>Recuerda que el esfuerzo o tiempo que ya invertiste <strong>nunca es una raz√≥n suficiente</strong> para mantener algo, sobre todo si hay razones para tomar otro camino.</p>

<h3 id="rendimientos-decrecientes">Rendimientos decrecientes</h3>

<p>Hay muchos procesos en la vida cotidiana en los que observamos que ‚Äúmientras m√°s, mejor‚Äù. Como m√°quinas de generalizaci√≥n que somos, tendemos a extender este pensamiento a todas las cosas en la vida, pero muchas cosas, no se comportan as√≠.</p>

<p>De eso trata la ley de rendimientos decrecientes, te hace entender que <strong>no siempre m√°s es mejor</strong>. De hecho, en la mayor√≠a de los procesos naturales se cumple una ley:</p>

<blockquote>
  <p>Por cada unidad a√±adida, <strong>el rendimiento de la siguiente unidad va a disminuir</strong>.</p>
</blockquote>

<p>As√≠ es: hay muchas cosas en la naturaleza que mientras m√°s tienes de ellas, cada cosa que a√±ades te va a dar menos beneficios que la cosa anterior que a√±adiste. Algunos ejemplos emp√≠ricos:</p>

<ul>
  <li>
    <p>Hacer ejercicio es muy bueno, si haces por lo menos 1 hora 4 veces a la semana ejercicio de cierto tipo te vas a sentir muy bien (claro combinado con otros factores como la buena alimentaci√≥n). Pero si haces el doble de ejercicio, no te vas a sentir el doble de bien, de hecho si llegas a cierto punto, como hacer 3 horas diarias te vas a sentir excesivamente cansado y puede que con el tiempo tu cuerpo muestre se√±ales de fatiga.</p>
  </li>
  <li>
    <p>Si est√°s en un restaurante y pides un postre, el primero te va a saber muy bien, pero si pides otro, el segundo no te va a saber tan bien como el primero, y si pides otro, puede que te enfermes y termines odiando ese postre espec√≠fico.</p>
  </li>
  <li>
    <p>Cuando riegas una planta, echarle agua es bueno hasta cierto punto, si le echas demasiada, la planta se va a ahogar y se va a morir.</p>
  </li>
  <li>
    <p>Salir al sol est√° bien, es bueno para nuestra salud si lo haces a la hora correcta y cuidas la cantidad de sol a la que te expones. Pero si te expones demasiado, te vas a quemar y vas a tener problemas de salud.</p>
  </li>
  <li>
    <p>Finalmente, el dinero: tener dinero es bueno hasta cierto punto, pero hay una cantidad que a mi parecer depende de el lugar en el que vivas, que tener dinero extra 1) no te va a hacer m√°s feliz, 2) incrementar m√°s tu riqueza te meter√° en problemas que no tendr√≠as antes. La siguiente gr√°fica muestra la relaci√≥n entre el dinero y la felicidad:</p>
  </li>
</ul>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_500/v1687450180/Ilustracio%CC%81n_sin_ti%CC%81tulo_4_qhinhf.png" alt="Gr√°fica de rendimientos decrecientes" class="align-center" /></p>

<p>En estos ejemplos hablamos de cosas buenas que primero te van dando cada vez menos beneficios, y luego se pueden volver perjudiciales. Para aplicarlo al desarrollo de software piensa en los siguientes ejemplos:</p>

<ul>
  <li>
    <p><strong>Equipos</strong>: Un equipo bien balanceado es <em>necesario</em> para hacer proyectos serios, pero eso no significa que mientras m√°s grande el equipo, mejor. Cada persona agregada al proyecto va agregando menos valor que la anterior y muy r√°pido se llega al punto en el que una persona m√°s a√±adida da√±a la productividad del equipo.</p>
  </li>
  <li>
    <p><strong>Horas de trabajo</strong>: A (casi) todos nos gusta nuestro trabajo y para lograr nuestros objetivos, en general, debemos de ponerle bastantes horas. Sin embargo, si trabajamos demasiado en un corto espacio de tiempo van a pasar dos cosas progresivamente: 1) Cada hora de trabajo sin que te distraigas va a rendir menos y 2) si sigues trabajando a pesar de esto, vas a cometer errores que despu√©s te puede costar mucho tiempo arreglar, o incluso cometer errores que no puedas arreglar, catastr√≥ficos (por ejemplo: un DELETE sin WHERE).</p>
  </li>
  <li>
    <p><strong>Abstracci√≥n</strong>: En el desarrollo de software, la abstracci√≥n es una herramienta esencial y siempre se necesita de ella para crear buen software. Pero si abstraes demasiado, tu c√≥digo se vuelve inmantenible y muy dif√≠cil de entender. Igual que con otras cosas, el punto de retornos negativos de la abstracci√≥n es muy f√°cil de alcanzar.</p>
  </li>
  <li>
    <p><strong>Pruebas unitarias</strong>: Las pruebas unitarias son una gran herramienta tanto para asegurar la calidad del software como para ayudar en su dise√±o. Sin embargo, hay una tendencia a querer buscar que todo tu c√≥digo est√© cubierto por pruebas unitarias: <strong>tener 100% de cobertura</strong>. Este es un caso muy caracter√≠stico de rendimientos decrecientes: mientras m√°s pruebas unitarias tengas, cada prueba unitaria que agregues va a darte menos beneficios que la anterior, pero se pone peor. Intentar tener 100% de pruebas te lleva a hacer c√≥digo que mucho m√°s complejo y dif√≠cil de mantener.</p>
  </li>
</ul>

<p>Para mi, este es uno de los modelos mentales m√°s √∫tiles, debido a que estamos en un mundo en el que ser eficiente en recursos te puede dar una gran ventaja competitiva.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Los modelos mentales son herramientas para organizar la informaci√≥n que son muy √∫tiles para personas que trabajan principalmente pensando y analizando el mundo real. Los desarrolladores de software pertenecemos a ese grupo, as√≠ que aprender a modelar la realidad de forma m√°s efectiva puede darnos una gran ventaja para resolver problemas y as√≠ avanzar m√°s r√°pido en nuestra carrera.</p>

<p>Seguiremos creando m√°s art√≠culos hablando de esto, para  darte herramientas que te permitan ser un mejor desarrollador de software y mejor profesional.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="modelos-mentales" /><category term="desarrollo-de-software" /><summary type="html"><![CDATA[Los modelos mentales te permitir√°n resolver problems m√°s r√°pido y con mejores resultados, hablemos de algunos de ellos que nos aplican directamente como desarrolladores.]]></summary></entry><entry><title type="html">¬øSon aplicables y pr√°cticos los principios SOLID?</title><link href="https://blog.thedojo.mx/2023/06/17/son-aplicables-y-practicos-los-principios-solid.html" rel="alternate" type="text/html" title="¬øSon aplicables y pr√°cticos los principios SOLID?" /><published>2023-06-17T00:00:00-06:00</published><updated>2023-06-17T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/06/17/son-aplicables-y-practicos-los-principios-solid</id><content type="html" xml:base="https://blog.thedojo.mx/2023/06/17/son-aplicables-y-practicos-los-principios-solid.html"><![CDATA[<p>Los <strong>principios SOLID</strong>, se ense√±an como verdades incuestionables sobre el buen desarrollo de software. Aunque, justo por la educaci√≥n, antes era completamente partidario de estos, con el tiempo me fui dando cuenta de varias de las fallas que presentan.</p>

<p>En este art√≠culo te voy a hablar de las fallas generales como conjunto, pero tambi√©n es un √≠ndice para una serie de art√≠culos que escrib√≠ sobre cada uno de ellos, analiz√°ndolo a profundidad.</p>

<h2 id="ambig√ºedad">Ambig√ºedad</h2>

<p>Cuando buscas la explicaci√≥n sobre c√≥mo aplicar alguno de estos principios, normalmente encuentras muchas explicaciones diferentes. Algunas de estas explicaciones se contraponen, siguen siendo ambiguas, o de plano no se entienden.</p>

<p>Con el principio que m√°s pasa es con el ‚ÄúSingle Responsibility‚Äù (SRP), en el cu√°l diferentes personas no nos ponemos de acuerdo respecto a lo que una ‚ÄúResponsabilidad‚Äù significa. Pero tambi√©n pasa con la aplicaci√≥n de los dem√°s principios a diferentes entornos de programaci√≥n.</p>

<h2 id="complican-exageradamente-el-c√≥digo">Complican exageradamente el c√≥digo</h2>

<p>La aplicaci√≥n sin razonamiento profundo de estos principios puede complicar el c√≥digo de manera exagerada, sobre todo en lenguajes inflexibles o con sistemas de tipos complicados (s√≠, te estoy viendo a ti, <strong>Java</strong>), que justo es donde m√°s se aplica.</p>

<p>El ejemplo m√°s claro de esto es el ‚ÄúDependency Inversion Principle‚Äù, que te lleva a hacer cosas bastante raras en el c√≥digo para lograrlo, como ya dije, sobre todo cuando el sistema de tipos te lo complica.</p>

<p>Y aunque es cierto que a veces es necesario y bastante √∫til hacer lo que este principio propone, para mi el 80% del software no lo necesita y s√≥lo est√°s haciendo una sobre-ingenier√≠a que no se justifica.</p>

<h2 id="se-usan-como-un-c√≥digo-moral">Se usan como un c√≥digo moral</h2>

<p>Los principios SOLID, entre otras cosas, normalmente se usan para avergonzar a las personas que no los conocen o no los aplican. Normalmente hablan de tu val√≠a como desarrollador@ de software basado en el supuesto conocimiento de cosas como estas, y otros principio o reglas (completamente) arbitrarias, sobre todo basadas en el libro Clean Code.</p>

<p>Esta revoltura de principios morales y conveniencia t√©cnica es un <strong>gran error para la comunidad de software</strong>, ya que lleva a la sobre-ingenier√≠a, a la aplicaci√≥n ciega de principios y t√©cnicas que no tienen sentido en tu caso particular e incluso al desprecio del trabajo de otros programadores.</p>

<p>Para mi, este es el punto m√°s grave, tal vez no directamente de los principios SOLID, sino de la forma en la que se ense√±an.</p>

<h2 id="an√°lisis-m√°s-profundo">An√°lisis m√°s profundo</h2>

<p>En este blog hemos escrito 5 art√≠culos analizando cada uno de los principios que lo componen, viendo si conviene aplicarlos y describiendo alternativas. En la mayor√≠a de los casos incluso hablamos de principios m√°s profundos (lo que nos hace ver que los ‚Äúprincipios SOLID‚Äù deber√≠a ser algo como ‚Äúreglas SOLID‚Äù).</p>

<p>Aqu√≠ los puedes ver:</p>

<ul>
  <li>SRP: <a href="/2022/12/01/analisis-de-los-principios-solid-principio-de-responsabilidad-unica.html">An√°lisis de los Principios SOLID: Principio de Responsabilidad √önica</a></li>
  <li>OCP: <a href="/2022/12/03/el-principio-abierto-cerrado-open-closed.html">El Principio Abierto/Cerrado</a></li>
  <li>LSP: <a href="/2023/03/06/el-principio-de-substitucion-de-liskov.html">El Principio de Sustituci√≥n de Liskov</a></li>
  <li>ISP: <a href="/2023/04/01/el-principio-de-segregacion-de-interfaces.html">El Principio de Segregaci√≥n de Interfaces</a></li>
  <li>DIP: <a href="/2023/04/22/el-principio-de-inversion-de-dependencias.html">El Principio de Inversi√≥n de Dependencias</a></li>
</ul>

<p>Espero que estos art√≠culos te sirvan para analizar m√°s profundamente lo que todos ense√±an como dogmas que se deben de seguir al pie de la letra, bajo la amenaza de no ser un buen programador o programadora que se ir√° al infierno de los desarrolladores si no lo sigue.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="solid" /><category term="principios" /><summary type="html"><![CDATA[Los principios SOLID son algo que se considera como 'axiomas' de las buenas pr√°cticas del software. Pero, ¬øson realmente √∫tiles?]]></summary></entry><entry><title type="html">Libros que todo desarrollador de software deber√≠a leer: desarrollo de carrera</title><link href="https://blog.thedojo.mx/2023/06/15/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo-de-carrera.html" rel="alternate" type="text/html" title="Libros que todo desarrollador de software deber√≠a leer: desarrollo de carrera" /><published>2023-06-15T00:00:00-06:00</published><updated>2023-06-15T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2023/06/15/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo-de-carrera</id><content type="html" xml:base="https://blog.thedojo.mx/2023/06/15/libros-que-todo-desarrollador-de-software-deberia-leer-desarrollo-de-carrera.html"><![CDATA[<p>En este art√≠culo vamos a hablar de los libros que te pueden ayudar a avanzar en tu carrera como desarrollador de software, que desde mi punto de vista, son esenciales.</p>

<p>Algunos desarrolladores piensan que basta simplemente con aprender a programar o dise√±ar software bien, pero lo cierto es que tambi√©n hay que tener otras habilidades y conocimientos para que tu carrera avance a buen ritmo, y llegues a puestos de liderazgo si as√≠ lo deseas.</p>

<p>En este post hablaremos de tres tipos de libros:</p>

<ul>
  <li>Consejos de carrera para desarrolladores y habilidades blandas</li>
  <li>Libros de historia de la computaci√≥n</li>
  <li>Temas que te pueden ayudar a desarrollar habilidades de soporte</li>
</ul>

<p>Como siempre, si tienes alguna recomendaci√≥n, puedes dejarla en los comentarios. Empecemos.</p>

<h2 id="desarrollo-de-carrera">Desarrollo de carrera</h2>

<p>En estos libros ver√°s consejos espec√≠ficos de desarrolladores experimentados sobre la carrera de programador, qu√© habilidades y actitudes te conviene desarrollar.</p>

<h3 id="the-pragmatic-programmer--david-thomas--andrew-hunt">The Pragmatic Programmer | David Thomas &amp; Andrew Hunt</h3>

<p><a href="https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686286553/71f743sOPoL._AC_UF1000_1000_QL80__vibioc.jpg" alt="Portada de The Pragmatic Programmer" class="align-center" /></a></p>

<p>Este es uno de los mejores libros sobre la carrera como programador, que te da consejos de dos programadores <strong>muy muy experimentados</strong>. Su tema principal es el <strong>pragmatismo</strong>, que es una filosof√≠a que te dice que no hay una sola forma de hacer las cosas, sino que debes adaptarte a las circunstancias y hacer lo que sea necesario para lograr tus objetivos. Otra forma de ver el pragmatismo es que hay que ser pr√°ctico, y no darle tantas vueltas a las cosas.</p>

<p>A grandes rasgos trata estos temas:</p>

<ol>
  <li>Introducci√≥n a la filosof√≠a pragm√°tica</li>
  <li>C√≥mo ser pragm√°tico al desarrollar software (nota que no es al <em>programar</em>, sino al crear programas)</li>
  <li>Herramientas que te pueden servir para desarrollar buen software</li>
  <li>C√≥mo llevar un proyecto pragm√°ticamente</li>
</ol>

<p>Estaba en la duda de clasificarlo entre los libros de desarrollo de software o desarrollo de carrera, porque aunque habla sobre t√©cnicas espec√≠ficas y temas t√©cnicos, su esp√≠ritu es una meta-habilidad o una actitud hacia el desarrollo y hacia la vida: el pragmatismo.</p>

<p>Puedes comprarlo aqu√≠: <a href="https://amzn.to/3oXvmNk" target="_blank" rel="noopener">The Pragmatic Programmer</a>.</p>

<h3 id="the-practice-of-programming--brian-w-kernighan--rob-pike">The Practice of Programming | Brian W. Kernighan &amp; Rob Pike</h3>

<p><a href="https://www.goodreads.com/book/show/1032758.The_Practice_of_Programming" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686488400/71a9H3K9cgL._AC_UF1000_1000_QL80__af2e79.jpg" alt="Portada de The Practice of Programming" class="align-center" /></a></p>

<p>Brian W. Kernighan es un desarrollador de software, programador y cient√≠fico de la computaci√≥n de las grandes ligas. ¬øHas escuchado sobre <code class="language-plaintext highlighter-rouge">AWK</code>? Es un programa y lenguaje programaci√≥n legendario, y se llama as√≠ por sus creadores: Alfred Aho, Peter Weinberger y <strong>Brian Kernighan</strong>.</p>

<p><strong>Rob Pike</strong> es uno de los co-creadores del lenguaje de programaci√≥n Go, y tambi√©n es un desarrollador de software con mucha experiencia. Ha co-creado otros lenguajes de programaci√≥n, como Oberon.</p>

<p>En <strong>‚ÄúThe Practice of Programming‚Äù</strong> explican todas las pr√°cticas que un desarrollador de software debe tener o aprender para desarrollar software exitosamente. Este libro se gu√≠a por los siguientes principios:</p>

<ol>
  <li>Simplicidad</li>
  <li>Claridad</li>
  <li>Generalidad</li>
  <li>Automatizaci√≥n</li>
</ol>

<p>Estos principios son aplicados a cosas como el estilo, la documentaci√≥n, las pruebas, etc. Al igual que el libro anterior, estaba dudando en clasificarlo como libro de desarrollo de software, pero creo que el enfoque general, aunque muy t√©cnico, va m√°s enfocado en el desarrollo de una mentalidad conveniente.</p>

<p>Puedes comprarlo aqu√≠: <a href="https://amzn.to/42zssMz" target="_blank" rel="noopener">The Practice of Programming</a>.</p>

<h3 id="code-ahead--yegor-bugayenko">Code Ahead | Yegor Bugayenko</h3>

<p><a href="https://www.yegor256.com/code-ahead.html" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686348326/yegor_code_kislix.png" alt="Portada de Code Ahead" class="align-center" /></a></p>

<p><strong>Yegor Bugayenko</strong> es un autor poco conocido de este lado del mundo, pero en Rusia es m√°s famoso. Ha escrito varios libros sobre programaci√≥n como <strong>‚ÄúElegant Objects‚Äù</strong> (1 y 2). Pero tambi√©n escribi√≥ este libro sobre la carrera de programador, que es muy bueno.</p>

<p>Yo lo describir√≠a como una <em>visi√≥n c√≠nica de la carrera de programaci√≥n</em>, con algunas recomendaciones sobre actitudes, formas de trabajo y <strong>t√°cticas para progresar en tu carrera</strong>. No creo que se deba tomar como una gu√≠a, sino m√°s bien como un contrapeso a las opiniones de carrera m√°s tradicionales, para ampliar tu visi√≥n. Adem√°s s√≠ creo que dice algunas verdades inc√≥modas que no a todos les gustar√° escuchar.</p>

<p>El punto d√©bil de libro es su formato (que para mi fall√≥ completamente), en el que trat√≥ de hacer un historia de ficci√≥n (supongo que al estilo de The Phoenix Project), pero que en realidad s√≥lo consiste en una serie de explicaciones del protagonista.</p>

<p>A pesar de lo mencionado anteriormente, creo que es un libro que vale mucho la pena leer y que te puede ayudar a ver las cosas desde otra perspectiva.</p>

<p>Puedes comprarlo en Amazon: <a href="https://amzn.to/43Dm0FK" target="_blank" rel="noopener">Code Ahead</a></p>

<h3 id="the-phoenix-project--gene-kim-kevin-behr--george-spafford">The Phoenix Project | Gene Kim, Kevin Behr &amp; George Spafford</h3>

<p><a href="https://itrevolution.com/product/the-phoenix-project/" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686458596/TPP_3rd_cover_border-664x998.jpg_ohgr0o.webp" alt="Portada de The Phoenix Project" class="align-center" /></a></p>

<p>Este libro, a diferencia del anterior es una novela que s√≠ sali√≥ bien, en la que describe la progresi√≥n de alguien del √°rea de IT que obligadamente se convierte en l√≠der del √°rea. Describe como es que las √°reas de IT se convierten de cuellos de botella en partes que agregan valor a la empresa.</p>

<p>El libro da los fundamentos de DevOps, y cu√°les son los principios que todos los equipos de desarrollo de software deber√≠an seguir para producir software m√°s efectivamente.</p>

<p>Aunque est√° enfocado en la operaci√≥n y la entrega del software, a final de cuentas, es donde todos queremos que nuestro software llegue, as√≠ que todos los desarrolladores de software se pueden beneficiar de los principios que presenta.</p>

<p>Se ha convertido en un cl√°sico, y con justa raz√≥n. Lo puedes comprar aqu√≠: <a href="https://amzn.to/3WWWMQ1" target="_blank" rel="noopener">The Phoenix Project</a>.</p>

<h2 id="libros-de-historia-de-la-inform√°tica">Libros de historia de la inform√°tica</h2>

<p>En esta secci√≥n recomendaremos algunos libros que creemos que te pueden ayudar a conocer m√°s la historia de tu campo y que por lo tanto te ayudar√°n a <em>aprender de lo que ya se ha hecho</em>. Esto te ayudar√° a no cometer los mismos errores y m√°s mejor, <strong>‚Äúpararte en hombros de gigantes‚Äù</strong> para poder ver m√°s lejos.</p>

<p>Afortunadamente, de estos tenemos tanto libros en ingl√©s como en espa√±ol.</p>

<h3 id="historia-de-los-lenguajes-de-programaci√≥n-a√±os-1940-1959--manuel-rubio">Historia de los lenguajes de programaci√≥n: A√±os 1940-1959 | Manuel Rubio</h3>

<p><a href="https://altenwald.com/book/histlangprog" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686489306/Screen_Shot_2023-06-11_at_7.14.50_g1d4lh.png" alt="Portada de Historia de los lenguajes de programaci√≥n" class="align-center" /></a></p>

<p>Aqu√≠, <a href="https://altenwald.com/">Manuel Rubio</a> explica el nacimiento de las lenguajes de programaci√≥n y c√≥mo esto va de la mano con la historia de la computaci√≥n. Me gusta mucho de este libro que te da una visi√≥n m√°s amplia que la centra en US que normalmente nos dan en la escuela y en la mayor√≠a de los libros de computaci√≥n.</p>

<p>Manuel hizo una investigaci√≥n muy amplia, cuestiona algunas cosas impl√≠citamente (<em>¬øde verdad fue Ada Lovelace la primera programadora?</em>) y te da una visi√≥n m√°s amplia de lo que significa la computaci√≥n.</p>

<p>Me gusta mucho que resalta algunas cosas que nos siguen sucediendo hoy:</p>

<ul>
  <li>Nos cuesta naturalmente despegarnos del trabajo</li>
  <li>El campo siempre se ha resistido a las innovaciones</li>
  <li>Siempre creemos que lo que viene despu√©s de lo que ya sabemos tiene menos valor</li>
</ul>

<p>En el blog hicimos ya un <a href="/2022/06/11/resumen-historia-de-los-lenguajes-de-programacion.html" target="_blank" rel="noopener">resumen de este libro</a> y tambi√©n hicimos un <a href="https://youtu.be/JDDEOi1jwDA">resumen en video</a> pero sinceramente te recomiendo leerlo completo.</p>

<p>Lo puedes comprar aqu√≠: <a href="https://altenwald.com/book/histlangprog" target="_blank" rel="noopener">Historia de los lenguajes de programaci√≥n</a>. Si <em>necesitas</em> un descuento para comprarlo, no dudes en contactarme o contactar a Manuel, que es muy accesible y una gran persona.</p>

<h3 id="mentes-geniales--camilo-chac√≥n-sartori">Mentes Geniales | Camilo Chac√≥n Sartori</h3>

<p><a href="https://www.amazon.com.mx/Mentes-geniales-ingenier%C3%ADa-software-ingenieros/dp/6077074797" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686488396/978607538877_xfcfmk.jpg" alt="Portada de Mentes Geniales" class="align-center" /></a></p>

<p><a href="https://camilochs.github.io/web/">Camilo Chac√≥n Sartori</a> es un gran desarrollador de software, pronto Doctor en Ciencias de la computaci√≥n y escritor. Ha escrito varios libros de programaci√≥n o temas relacionados y en realidad es un escritor (y lector, ¬øse puede ser buen escritor sin leer mucho?) muy prol√≠fico.</p>

<p>En este libro, habla de 12 personas que han contribuido de diferentes formas al desarrollo de la computaci√≥n y se les ha reconocido con el <strong>Premio Turing</strong>. Aunque no es un libro hist√≥rico en todo el sentido de la palabra, adem√°s de que no sigue una cronolog√≠a, s√≠ habla de importantes eventos hist√≥ricos de la computaci√≥n y desarrollo.</p>

<p>Lo recomiendo porque no s√≥lamente te habla de los logros de las personas que menciona, analiza su entorno, te cuenta sobre su personalidad y extrae lecciones. Adem√°s, te deja las fuentes y referencias por si quieres leer m√°s de ellos.</p>

<p>Algunos de los personajes que a mi me impactaron:</p>

<ul>
  <li><strong>Manuel Blum</strong> - El creador de CAPTCHA</li>
  <li><strong>Michael Stonebraker</strong> - El creador de PostgreSQL</li>
  <li><strong>Barbara Liskov</strong> - Una gran proponente de los tipos abstractos de datos</li>
  <li><strong>Leslie Lamport</strong> - Un gran matem√°tico que ha contribuido a la computaci√≥n con cosas como el algoritmo de Paxos y TLA+</li>
  <li><strong>Richard Manning Karp</strong> - Un matem√°tico que ha contribuido a la computaci√≥n con cosas como el algoritmo de Karp-Rabin y el an√°lisis de complejidad de algoritmos</li>
</ul>

<p>Sin duda te llevar√°s muchas buenas lecciones y aprendizajes sobre el desarrollo de la computaci√≥n de este libro. Lo puedes comprar aqu√≠: <a href="https://amzn.to/43J2jfG" target="_blank" rel="noopener">Mentes Geniales</a>.</p>

<h3 id="dealers-of-lightning-xerox-parc-and-the-dawn-of-the-computer-ag--michael-a-hiltzik">Dealers of Lightning: Xerox PARC and the Dawn of the Computer Ag | Michael A. Hiltzik</h3>

<p><a href="https://www.goodreads.com/book/show/1101290.Dealers_of_Lightning" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686549204/61pJVqUUoJL._AC_UF1000_1000_QL80__gevadr.jpg" alt="Portada de Dealers of Lightning" class="align-center" /></a></p>

<p>En los a√±os 70 y 80‚Äôs, la compa√±√≠a <strong>Xerox</strong> (s√≠, la de las impresoras), consigui√≥ un equipo de personas muy h√°biles con la tecnolog√≠a. Eran conocidos como el <strong>PARC</strong> (Palo Alto Research Center) y fueron los creadores de muchas de las tecnolog√≠as que hoy usamos, como:</p>

<ul>
  <li>La primera computadora personal</li>
  <li>La interfaz gr√°fica</li>
  <li>La impresora l√°ser</li>
</ul>

<p>Todas estas tecnolog√≠as cambiaron el mundo, ayudando a crear la tecnolog√≠a que hoy en d√≠a nos da trabajo y ha moldeado todas las industrias y la vida en general.</p>

<p>Este libro est√° basado en entrevistas con las personas que vieron de cerca estas creaciones y que muestran c√≥mo es que Xerox nunca vio el potencial de las creaciones de este equipo de ingenieros. Si quieres aprender sobre la historia de la tecnolog√≠a que tenemos hoy, ver c√≥mo se forman equipos de alt√≠simo rendimiento y aumentar tus posibilidades de crear algo que sea digno de menci√≥n, este libro es un gran recurso.</p>

<p>Puedes comprarlo aqu√≠: <a href="https://amzn.to/3Cs5QTm" target="_blank" rel="noopener">Dealers of Lightning</a>.</p>

<h3 id="la-catedral-de-turing--george-dyson">La Catedral de Turing | George Dyson</h3>

<p><a href="https://books.google.com.mx/books/about/La_catedral_de_Turing.html?id=QvjeBQAAQBAJ&amp;redir_esc=y" target="_blank" rel="noopener"><img src="" alt="Portada de La Catedral de Turing" class="align-center" /></a></p>

<p>En este libro se narra el comienzo de la computaci√≥n despu√©s de la segunda guerra mundial y de todos los actores que tuvieron un impacto en el desarrollo de la computaci√≥n moderna.</p>

<p>Es una cr√≥nica muy completa, junto con la explicaci√≥n de muchos conceptos de la computaci√≥n. El autor, hijo del f√≠sico <a href="https://www.profisica.cl/index.php/component/content/article/115-biografias/216-freeman-dyson?Itemid=542">Freeman Dyson</a>, tuvo acceso a muchos de los actores de la historia y a sus documentos, lo que le permiti√≥ hacer una libro que revela muchos detalles.</p>

<p>Sin duda es algo que muchos dedicados a esta √°rea del conocimiento queremos leer. Lo puedes comprar aqu√≠: <a href="https://amzn.to/3NoQKV6" target="_blank" rel="noopener">La Catedral de Turing</a>.</p>

<h2 id="otros-temas-relacionados">Otros temas relacionados</h2>

<p>Finalmente, como √∫ltima parte de este art√≠culo y de la serie de libros recomendados. Quiero poner algunas recomendaciones sobre temas y habilidades alternas a la programaci√≥n que te ayudar√°n tanto como programador como a desarrollar tu carrera.</p>

<p>Algunos de estos temas o libros pensar√°s que no tienen nada que ver, pero te puedo asegurar que son habilidades y temas de soporte necesarios que te van a ayudar a resaltar.</p>

<h3 id="how-to-solve-it--george-polya">How to solve it | George Polya</h3>

<p><a href="https://math.hawaii.edu/home/pdf/putnam/PolyaHowToSolveIt.pdf" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686666135/71GFUNCh7hL._AC_UF1000_1000_QL80__q5xtrk.jpg" alt="Portada de How to solve it" class="align-center" /></a></p>

<p>George Polya fue un matem√°tico del Siglo XX que contribuy√≥ en el √°rea de heur√≠stica y resoluci√≥n de problemas. Fue un gran profesor al mismo tiempo que un gran investigador. Este libro es una combinaci√≥n de ambas facetas de √©l: le preocupaba que las matem√°ticas se ense√±aran bien al mismo tiempo que √©l era muy bueno haciendo matem√°ticas.</p>

<p>En este escrito, Polya establece los pasos a seguir para resolver problemas matem√°ticos, pero que por extensi√≥n tambi√©n nos sirve a los desarrolladores para aprender a establecer un m√©todo para resolver los problemas que encontramos d√≠a a d√≠a en nuestro trabajo.</p>

<p>Los cuatro pasos que propone son:</p>

<ul>
  <li>Plantear y entender correctamente el problema</li>
  <li>Idear un plan para resolverlo (aqu√≠ da algunas t√©cnicas comunes)</li>
  <li>Ejecutar el plan</li>
  <li>Revisar el resultado, el proceso y los aprendizajes</li>
</ul>

<p>Cuando lo le√≠, not√© inmediatamente que era un libro que se deber√≠a dar en todas las escuelas relacionadas con la ingenier√≠a o la computaci√≥n, ya que nos da claridad, o por lo menos una idea de c√≥mo empezar a resolver algo.</p>

<p>Lo puedes comprar aqu√≠: <a href="https://amzn.to/43YlSQC" target="_blank" rel="noopener">How to solve it</a>, pero tambi√©n lo puedes leer gratis: <a href="https://cienciaymatematicas.files.wordpress.com/2012/09/como-resolver.pdf">C√≥mo plantear y resolver problemas</a>.</p>

<h3 id="enf√≥cate--cal-newport">Enf√≥cate | Cal Newport</h3>

<p><a href="https://www.amazon.com.mx/Enf%C3%B3cate-estrategias-eficacia-trabajo-creativo/dp/607527998X" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686669189/71p-QmjVoWL._AC_UF1000_1000_QL80__ymtjyl.jpg" alt="Portada de Enf√≥cate" class="align-center" /></a></p>

<p>La atenci√≥n es uno de los bienes m√°s preciados que tenemos los seres humanos, ya que a nuestra mente consciente s√≥lo entra aquello a lo que la dirigimos o <em>enfocamos</em>. Pero cuando m√°s beneficios da es cuando la enfocamos en una sola cosa por un periodo prolongado. Es como si nuestra mente fuera acelerando y tomando impulso para resolver un problema.</p>

<p>Esa es la tesis principal de ‚ÄúEnf√≥cate‚Äù, un profesor de ciencias de la computaci√≥n, muy interesado en temas como el logro acad√©mico, la productividad intelectual y el rendimiento a pesar de los obst√°culos modernos.</p>

<p>En este libro, presenta un caso muy s√≥lido para convencerte de apartar tiempo ininterrumpido para lograr tus tareas m√°s dif√≠ciles. Adem√°s, relata c√≥mo √©l lo logra y te da algunos consejos para que t√∫ lo puedas hacer.</p>

<p>Creo que este libro es especialmente relevante para los desarrolladores de software por el entorno en el que trabajamos y porque muchos de los problemas que enfrentamos rebasan nuestra capacidad o conocimiento actual, por lo que necesitamos toda la ayuda posible para poder resolverlos.</p>

<p>Puedes comprarlo aqu√≠: <a href="https://amzn.to/45YWNqJ" target="_blank" rel="noopener">Enf√≥cate</a>.</p>

<h3 id="accelerate--nicole-forsgren">Accelerate | Nicole Forsgren</h3>

<p><a href="https://www.oreilly.com/library/view/accelerate/9781457191435/9" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686808509/41OoXs3W3nL._AC_UF1000_1000_QL80__knm3bn.jpg" alt="Portada de Accelerate" class="align-center" /></a></p>

<p><strong>¬øQu√© es lo que distingue a un equipo de alto rendimiento en la entrega de software de uno de bajo rendimiento?</strong> La medida m√°s b√°sica es el tiempo que toma un cambio en ser liberado o en llegar a producci√≥n. En este libro se habla de 1) c√≥mo medir esto y 2) los factores que llevan a un equipo a mejorar esas m√©tricas.</p>

<p>En realidad el libro es el resultado de un estudio de muchos equipos de desarrollo de software, en el que descubrieron varias cosas acerca de los equipos de alto rendimiento, entre ellas:</p>

<ul>
  <li>Las pr√°cticas t√©cnicas que tienen</li>
  <li>El tipo de liderazgo que los gu√≠a</li>
  <li>Qu√© tipo de arquitecturas siguen</li>
  <li>Qu√© pr√°cticas de administraci√≥n de recursos humanos siguen</li>
  <li>C√≥mo hacen todo el trabajo sostenible</li>
</ul>

<p>Adem√°s el libro habla de la forma en la que se realiz√≥ el estudio. Sin duda, es un libro muy valioso para los desarrolladores de software que quieren mejorar su rendimiento y el de sus equipos. Puedes comprarlo aqu√≠: <a href="https://amzn.to/3JaPTEP" target="_blank" rel="noopener">Accelerate</a>.</p>

<h3 id="data-and-reality--william-kent">Data and Reality | William Kent</h3>

<p><a href="https://www.bkent.net/Doc/darxrp.htm" target="_blank" rel="noopener"><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1686837219/41351CTT93L._AC_UF1000_1000_QL80__qgzcwb.jpg" alt="Portada de Data and Reality" class="align-center" /></a></p>

<p>Creo que como programadores, gran cantidad del tiempo lo dedicamos a procesar datos, o a crear representaciones datos de procesos externos a la computaci√≥n. Esto es el <strong>modelado de datos</strong>, y es de lo que este libro habla, pero de manera bastante especial.</p>

<p><strong>William Kent</strong> hace un an√°lisis profundo de las cosas a las que estamos acostumbrados: modelos, datos, registros, relaciones, atributos, entidades. Primero, <em>intenta</em> definirlas y despu√©s aplicarlas al modelado de datos, explorando las implicaciones de definici√≥n. Es un libro que te va a hacer pensar bastante, relacionado con la epistemolog√≠a, la ontolog√≠a y en nuestra percepci√≥n de la realidad.</p>

<p>Aunque el libro te deja con m√°s dudas que respuestas, deja algo totalmente claro: no existe una forma <em>correcta</em> de modelar el mundo, s√≥lo <strong>representaciones m√°s convenientes</strong> para un caso u otro, ya que todas son arbitrarias.</p>

<p>Yo le√≠ la <a href="https://amzn.to/42FOOMs">tercera edici√≥n</a>, que es la que √∫nica que est√° en producci√≥n actualmente. Esta tiene comentarios de otro modelador de datos muy experimentado, pero que seg√∫n <a href="https://buttondown.email/hillelwayne/archive/data-and-reality-2nd-edition/">Hillel Wayne</a> cambi√≥ completamente el libro.Hillel recomienda leer la segunda edici√≥n, que aunque ya no est√° en impresi√≥n, lo puedes encontrar en <a href="https://buttondown.email/hillelwayne/archive/data-and-reality-2nd-edition/" target="_blank" rel="noopener">PDF</a>. Yo tengo pendiente leer la segunda edici√≥n, pero tengo altas expectativas ya que incluso la tercera me dej√≥ grandes ense√±anzas.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>Para avanzar en tu carrera no basta con aprender s√≥lo habilidades t√©cnicas, tambi√©n hacen falta algunas meta-habilidades, habilidades paralelas y conocimiento de la historia de tu profesi√≥n.</p>

<p>Tener estos conocimientos te puede hacer destacar de los dem√°s profesionales, y son especialmente √∫tiles si quieres lograr un puesto de liderazgo. As√≠ que sigue prepar√°ndote, recuerda que un libro bien editado es de las mejores inversiones que puedes hacer.</p>]]></content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="libros" /><category term="desarrollo-de-carrera" /><category term="career" /><category term="historia" /><summary type="html"><![CDATA[Hablemos de los libros que te pueden ayudar a desarrollar tu carrera como desarrollador de software, escritos por personas con experiencia en el tema.]]></summary></entry></feed>