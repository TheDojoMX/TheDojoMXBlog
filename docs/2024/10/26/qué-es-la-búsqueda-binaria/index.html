<!doctype html><html lang=es dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>¿Qué es la búsqueda binaria? | The Dojo MX Blog</title>
<link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><meta property="og:title" content="¿Qué es la búsqueda binaria?"><meta property="og:description" content="Hablemos de un algoritmo sencillo que incluso utilizamos en la vida real pero que es"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thedojo.mx/2024/10/26/qu%C3%A9-es-la-b%C3%BAsqueda-binaria/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="¿Qué es la búsqueda binaria?"><meta name=twitter:description content="Hablemos de un algoritmo sencillo que incluso utilizamos en la vida real pero que es"><link rel=stylesheet href=/css/extended.min.771dff75f9f3290205d2bfcbeda2ed15a5984c0414d431dfec3423ae5e37bb90.css integrity="sha256-dx3/dfnzKQIF0r/L7aLtFaWYTAQU1DHf7DQjrl43u5A=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js integrity="sha256-zIrplS2/tzGv+vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://blog.thedojo.mx/ style=color:inherit>The Dojo MX Blog</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>¿Qué es la búsqueda binaria?</h1><time class=dim datetime=2024-10-26T00:00:00+00:00>October 26, 2024</time><div class=term-container><div class=tag><a href=https://blog.thedojo.mx/tags/algoritmos/>#algoritmos</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/b%C3%BAsqueda/>#búsqueda</a></div></ol></div><section class=page-section><p>Uno de los algoritmos más fáciles de entender, que incluso sin preparación
aplicamos en la vida real y que se enseña en las primeras clases de programación
es la <strong>búsqueda binaria</strong>. Vamos a hablar de este algoritmo y su relación
profunda con las ciencias de la computación y la información en general.</p><h2 id=búsqueda-binaria-en-la-vida-real>Búsqueda binaria en la vida real</h2><p>¿Alguna ves has jugado &ldquo;Adivina Quién&rdquo;? Es un juego de mesa en el
que cada jugador tiene un tablero con un conjunto de personajes con
características físicas distintas, como el color de pelo, diferentes
accesorios, y otros rasgos distintivos. Cada jugador escoge secretamente
un personaje y el otro lo tiene que adivinar, haciendo preguntas que
le permitan ir eliminando a los personajes que el otro jugador no ha elegido.
¿Cuál es la mejor estrategia para adivinar con la menor cantidad de
preguntas? Podrías pensar que es por cosas muy distintivas, por ejemplo,
si hay dos personajes con sombrero, y preguntas si tiene sombrero, puede
parecer una buena estrategia, pero no lo es.</p><p>En este caso, suponiendo que tenemos 40 personajes y solo dos tienen sombrero y
suponiendo que tienes 40 personajes, sólo 5% de las veces te ayudará reducir
significativamente el número de personajes, por lo que la mayoría de las veces
será una pregunta extra si la haces inicialmente. Lo mejor es empezar por las
características que dividan el conjunto de personajes en dos grupos más o menos
iguales. Por ejemplo, si hay 40 personajes y 20 tienen el pelo largo y 20 el corto,
la pregunta si el personaje tiene el pelo largo, te dejará con 20 personajes.
La siguiente pregunta debería ser algo similar.</p><p>Esto es exactamente lo que hace la búsqueda binaria, ir partiendo el conjunto
de elementos en dos grupos más o menos iguales e ir eliminando la mitad en cada
paso.</p><h2 id=búsqueda-binaria-en-la-computación>Búsqueda binaria en la computación</h2><p>El algoritmo de búsqueda binaria se aplica para encontrar un valor en una
colección <em>ordenada</em> de elementos. Esto es para tener una forma sencilla de
eliminar la mitad del espacio de búsqueda en cada paso. Y puedes pensar justamente
que la necesidad de tener que ordenar los elementos es precisamente una de sus
des</p><h2 id=implementación-en-pseudocódigo>Implementación en pseudocódigo</h2><p>Aquí puedes ver una implementación de la búsqueda binaria en pseudocódigo:</p><pre tabindex=0><code>búsqueda_binaria(arreglo, elemento_buscado):
    inicio = 0
    fin = longitud(arreglo) - 1
    mientras inicio &lt;= fin:
        medio = (inicio + fin) // 2  # división entera

        si arreglo[medio] == elemento_buscado:
            retornar medio
        sino si arreglo[medio] &lt; elemento_buscado:
            inicio = medio + 1
        sino:
            fin = medio - 1
    retornar -1  # Elemento no encontrado
</code></pre><p>En pocas palabras, nombramos dos índices, <code>inicio</code> y <code>fin</code>, que van a ser
los que nos dicen en qué parte vamos a buscar. Después, calculamos el centro
de la lista, sumando el inicio y el fin y dividiendo entre dos. Otra forma de
calcularlo sería restando el inicio y el fin, dividiendo entre dos y sumándole
el inicio. Estas dos formas son equivalentes.</p><p>Ahora, comparamos el elemento buscado con el elemento en el centro. Si es igual,
hemos encontrado el elemento y terminamos. Si es menor, tenemos que agarrar
la parte de la lista que está a la derecha, es decir, los elementos mayores.
Para esto, el inicio es un elemento a la derecha del medio (<code>inicio = medio + 1</code>)
y el fin se queda igual. Si el elemento buscado es mayor, tenemos que agarrar
la parte de lista que está a la izquierda, y ahora el que cambia es el fin.</p><p>De esta manera, en cada paso nuestro espacio de búsqueda se reduce a la mitad.</p><p>Si llegamos a un punto en el que el inicio es mayor que el fin, entonces no
encontramos el elemento y retornamos -1 (el -1 es una forma de que el
programa nos diga que no encontramos el elemento, muy usada en programación).</p><h2 id=complejidad>Complejidad</h2><p>Con un arreglo pequeño pensarás que la búsqueda binaria es más lenta una búsqueda
aleatoria o secuencial y así es, pero recuerda que los algoritmos eficientes
se notan cuando el tamaño de los datos crece.</p><p>Al ir cortando sucesivamente a la mitad el espacio de búsqueda, la complejidad
de la búsqueda binaria crece en forma logarítmica.</p><p>Expliquemos un poco eso. Un logaritmo es la función que nos ayuda a encontrar
el exponente al que hay que elevar un número para obtener otro. En la búsqueda
binaria, el número que queremos &ldquo;obtener&rdquo; (en verdad, es recorrer) es el número
de elementos en el arreglo que vamos a buscar.</p><p>Suponiendo que en cada paso hacemos más o menos 5 operaciones, por ejemplo,
para buscar en un arreglo de 1000 elementos y tomando en cuenta lo que hemos
visto de cómo se va reduciendo el espacio de búsqueda, tendríamos la siguiente
sucesión:</p><p>Elementos por buscar: 1000</p><p>Operaciones totales: 5</p><hr><p>Elementos por buscar: 500</p><p>Operaciones totales: 10</p><hr><p>Elementos por buscar: 250</p><p>Operaciones totales: 15</p><hr><p>Elementos por buscar: 125</p><p>Operaciones totales: 20</p><hr><p>Elementos por buscar: 62</p><p>Operaciones totales: 25</p><hr><p>Elementos por buscar: 31</p><p>Operaciones totales: 30</p><hr><p>Elementos por buscar: 15</p><p>Operaciones totales: 35</p><hr><p>Elementos por buscar: 7</p><p>Operaciones totales: 40</p><hr><p>Elementos por buscar: 3</p><p>Operaciones totales: 45</p><hr><p>Elementos por buscar: 1</p><p>Operaciones totales: 50</p><hr><p>Observa cómo es que el número de operaciones no creció al mismo ritmo que el número de
elementos. El número de operaciones creció sumó sólo 5 operaciones cada que duplicamos
el número de elementos. Aquí es donde está el logaritmo, como estamos duplicando o
multiplicando por dos, la base de nuestro logaritmo es el 2. ¿Cuánto &ldquo;pasos&rdquo; vamos a
tener que hacer? Cuantas veces tengamos que duplicar el número de elementos para llegar
al número total de elementos del arreglo en el peor de los casos. Esto es el logaritmo
base 2.</p><p>Así que la complejidad de la búsqueda binaria es $$O(\log n)$$. Donde $$n$$ es el
número de elementos en el arreglo.</p><h2 id=implementaciones>Implementaciones</h2><p>Vamos a ver dos implementaciones en Python, una iterativa y otra recursiva.</p><p>Empezamos con la iterativa:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary_search</span>(arreglo, elemento_buscado):
</span></span><span style=display:flex><span>    inicio <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    fin <span style=color:#f92672>=</span> len(arreglo) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> inicio <span style=color:#f92672>&lt;=</span> fin:
</span></span><span style=display:flex><span>        medio <span style=color:#f92672>=</span> (inicio <span style=color:#f92672>+</span> fin) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> arreglo[medio] <span style=color:#f92672>==</span> elemento_buscado:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> medio
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> arreglo[medio] <span style=color:#f92672>&lt;</span> elemento_buscado:
</span></span><span style=display:flex><span>            inicio <span style=color:#f92672>=</span> medio <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            fin <span style=color:#f92672>=</span> medio <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Y la versión recursiva:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary_search</span>(arreglo, elemento_buscado, inicio<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, fin<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> fin <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        fin <span style=color:#f92672>=</span> len(arreglo) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> inicio <span style=color:#f92672>&gt;</span> fin:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    medio <span style=color:#f92672>=</span> (inicio <span style=color:#f92672>+</span> fin) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> arreglo[medio] <span style=color:#f92672>==</span> elemento_buscado:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> medio
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> arreglo[medio] <span style=color:#f92672>&lt;</span> elemento_buscado:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> binary_search(arreglo, elemento_buscado, medio <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, fin)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> binary_search(arreglo, elemento_buscado, inicio, medio <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>Debido a la sintaxis de Python, la versión recursiva es un poco más verbosa,
por el manejo que tienes que hacer de los parámetros por defecto, pero si no
fuera por eso, en general me gusta más la versión recursiva.</p><p>Finalmente, si quieres hacer un programa que funcione con esta forma de búsqueda,
tienes que asegurarte de que las inserciones en el arreglo sean ordenadas, una forma
sencilla es usar un algoritmo parecido para encontrar el lugar adecuado para insertarlo.</p><h2 id=uso-en-el-mundo-real>Uso en el mundo real</h2><p>Lo que vimos en la sección anterior es para que entiendas cómo funciona, pero
lenguajes como Python, Ruby y otros, probablemente ya tengan implementaciones de
este algoritmo muy común. Por ejemplo, en Python tenemos el módulo <code>bisect</code> que
permite hacer lo mismo con muchas menos líneas. Ejemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> bisect
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>lista <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>]
</span></span><span style=display:flex><span>elemento <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>indice <span style=color:#f92672>=</span> bisect<span style=color:#f92672>.</span>bisect_left(lista, elemento) <span style=color:#75715e># en realidad nos dice el valor más pequeño que es mayor o igual al elemento buscado</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># si el índice es más grande que el número de elementos, no está en la lista</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> indice <span style=color:#f92672>!=</span> len(lista) <span style=color:#f92672>and</span> lista[indice] <span style=color:#f92672>==</span> elemento: 
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;El elemento </span><span style=color:#e6db74>{</span>elemento<span style=color:#e6db74>}</span><span style=color:#e6db74> está en el índice </span><span style=color:#e6db74>{</span>indice<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;El elemento </span><span style=color:#e6db74>{</span>elemento<span style=color:#e6db74>}</span><span style=color:#e6db74> no está en la lista&#34;</span>)
</span></span></code></pre></div><p>Puedes ver más detalles del módulo <code>bisect</code> en la <a href=https://docs.python.org/3/library/bisect.html>documentación oficial</a>.</p><h2 id=conclusión>Conclusión</h2><p>La búsqueda binaria es uno de los algoritmos que todos los desarrolladores deberíamos conocer.
Espero que este artículo te haya ayudado a entender cómo funciona y su importancia.</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025 Héctor Patricio</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>1344 words</span>
<span>7 - 10 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#búsqueda-binaria-en-la-vida-real>Búsqueda binaria en la vida real</a></li><li><a href=#búsqueda-binaria-en-la-computación>Búsqueda binaria en la computación</a></li><li><a href=#implementación-en-pseudocódigo>Implementación en pseudocódigo</a></li><li><a href=#complejidad>Complejidad</a></li><li><a href=#implementaciones>Implementaciones</a></li><li><a href=#uso-en-el-mundo-real>Uso en el mundo real</a></li><li><a href=#conclusión>Conclusión</a></li></ul></nav></aside></div></div></body></html>