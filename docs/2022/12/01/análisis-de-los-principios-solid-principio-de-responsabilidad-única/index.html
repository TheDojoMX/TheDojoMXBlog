<!doctype html><html lang=es dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Análisis de los principios SOLID: Principio de Responsabilidad Única | The Dojo MX Blog</title>
<link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><meta property="og:title" content="Análisis de los principios SOLID: Principio de Responsabilidad Única"><meta property="og:description" content="¿Son útiles los principios SOLID? En esta serie empezaremos una exploración para ver si podemos aplicarlos mejor o si vale la pena seguirlos."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thedojo.mx/2022/12/01/an%C3%A1lisis-de-los-principios-solid-principio-de-responsabilidad-%C3%BAnica/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Análisis de los principios SOLID: Principio de Responsabilidad Única"><meta name=twitter:description content="¿Son útiles los principios SOLID? En esta serie empezaremos una exploración para ver si podemos aplicarlos mejor o si vale la pena seguirlos."><link rel=stylesheet href=/css/extended.min.771dff75f9f3290205d2bfcbeda2ed15a5984c0414d431dfec3423ae5e37bb90.css integrity="sha256-dx3/dfnzKQIF0r/L7aLtFaWYTAQU1DHf7DQjrl43u5A=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js integrity="sha256-zIrplS2/tzGv+vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://blog.thedojo.mx/ style=color:inherit>The Dojo MX Blog</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Análisis de los principios SOLID: Principio de Responsabilidad Única</h1><time class=dim datetime=2022-12-01T00:00:00+00:00>December 1, 2022</time><div class=term-container><div class=tag><a href=https://blog.thedojo.mx/tags/solid/>#solid</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/principios/>#principios</a></div></ol></div><section class=page-section><p>En esta serie de artículos vamos a hablar sobre los cinco <strong>principios SOLID</strong>. Se dice que todo programador que quiera crear código mantenible y <em>&ldquo;limpio&rdquo;</em> debe conocer y usar. La estructura de los artículos llevará la siguiente forma:</p><ul><li>Explicación del principio</li><li>Ejemplos y contraejemplos para pensar</li><li>Críticas y alternativas</li></ul><p>Esta serie de artículos surge debido a que <strong>aunque son poco entendidos por la mayoría de los programadores</strong>, estos principios se toman como <em>verdades universales</em> que hay que seguir. Si queremos desarrollar buen software, no podemos ir por allí solamente aceptando lo que <em>la mayoría</em> dice que está bien sin entenderlo a fondo y cuestionarlo.</p><p>Así que esta serie estará enfocada más bien en el lado débil de los principios SOLID y ver si tenemos mejores alternativas, o por lo menos, ver cuando podemos usarlos y cuando no.</p><p>Empecemos diseccionando el primer principio de los aclamados SOLID: el principio de Responsabilidad Única. Como verás a lo largo de los artículos, estos principios casi siempre se aplican con ejemplos de programación orientada a objetos, por lo que los verás explicados con <em>&ldquo;clases&rdquo;</em> y <em>&ldquo;objetos&rdquo;</em>.</p><h2 id=el-principio-de-responsabilidad-única>El principio de Responsabilidad Única</h2><p>Este principio se puede enunciar como:</p><blockquote><p>&ldquo;Una clase debe tener una única razón para ser modificada&rdquo; según en libro <em>Rober Martin</em>.</p></blockquote><p>Otros lo enuncian como:</p><blockquote><p>Una clase debe hacer sólo una cosa y hacerla bien.</p></blockquote><p>Esto es un resumen del principio que nos puede servir para ayudarnos a pensar sobre las <em>responsabilidades</em> que nuestro código tiene, específicamente una clase. Pero, ¿qué es una <em>responsabilidad</em>? Aquí es donde empiezan a entrar los problemas al definir este principio y a tomar pasos prácticos para aplicarlo. Pensemos en algunos ejemplos:</p><ul><li><p>Una clase que se encarga de transformar un archivo de un formato en otro debería encargarse sólo de esta transformación. ¿En dónde empieza y dónde acaba la <em>responsabilidad</em> de esta clase? ¿Tiene que encargarse de leer y guardar el archivo? ¿Debe existir una clase para guardar el archivo y otra para leerlo?</p></li><li><p>Una clase que se encarga de la comunicación con la API, transformando las peticiones del programa interno en peticiones HTTP y transformando las respuestas de la API en objetos y tipos de datos internos. ¿Dónde acaba su <em>responsabilidad</em>?¿Es la encargada de verificar la condición de la red? ¿Se encarga de verificar que los datos sean correctos, o es responsabilidad de otra clase?</p></li></ul><p>Como puedes ver, el principio, aunque suena simple, deja muchas cosas sin resolver y vagas, por lo que pocos encuentran un manera clara de aplicarlo. A mi me parece que tiene aplicaciones, pero solamente si acotamos más su alcance y definimos algunos límites, incluso cambiando el enfoque del consejo.</p><h2 id=el-problema>El problema</h2><p>El gran problema con este consejo es que la definición de lo que una <strong>responsabilidad</strong> significa es completamente arbitraria. Todo dependerá de quién esté dividiendo el problema más grande en <em>responsabilidades</em>. Además, esta división puede tener diferentes niveles de granularidad, por lo que una sola <em>responsabilidad</em> a cierto nivel puede significar varias <em>responsabilidades</em> en un nivel más bajo.</p><h2 id=transformando-el-principio>Transformando el principio</h2><p>¿Cuál es la <em>esencia</em> del principio? Para mi el corazón de este consejo tiene que ver con controlar la <strong>información</strong> que una clase maneja. También tiene que ver con el <strong>cambio</strong>. Finalmente el consejo tiene que ver con la cantidad de información que podemos mantener en nuestra mente en un tiempo específico. Si una pieza de código hace demasiadas cosas, será difícil de entender y por lo tanto propensa a errores y omisiones.</p><p>La primera cosa de la que vamos a hablar es de la <strong>información</strong>. La idea de que se encapsule una responsabilidad en un una clase es que si la información que tenemos sobre un problema cambia, se propague por la menor cantidad de código posible en nuestra base, rediciendo el impacto y la posibilidad de crear problemas.</p><p>Entonces, lo primero que tenemos que pensar es si el nivel de granularidad del que se está hablando (clases) es el correcto. Para mi, no se puede establecer un nivel de granularidad tan fijo, sino que dependerá del programador que decida dónde <strong>encapsular o esconder</strong> la información que esta responsabilidad maneja. Puede que sea un módulo, paquete, clase o función. Hay problemas grandes y pequeños.</p><p>Para aplicar esto, piensa:</p><ul><li>¿Qué procedimientos, información y datos va a manejar esta pieza de código? Si no tienes claro esto, puede que te falte pensar un poco más en problema, e incluso dividirlo mejor.</li><li>¿Cómo puedo aislar la información que esta pieza de código maneja, de tal forma que si cambiar, no afecte a todo lo que está fuera de ella?</li><li>¿De dónde viene y a dónde va la información que esta pieza de código transforma?</li><li>¿Cómo puedo definir <em>exactamente</em> qué hace esta pieza de código? Esta definición junto con la justificación de la decisión debería estar bien documentada.</li></ul><h2 id=técnicas-para-concretar-el-principio>Técnicas para concretar el principio</h2><ul><li><p>Divide en problemas (responsabilidades) bien definidas tu problema principal. No hay una forma correcta de hacerlo, estas divisiones siempre serán arbitrarias, así que trata de documentar estas decisiones lo mejor posible. Estas decisiones deben ser fáciles de entender en la medida de lo posible.</p></li><li><p>Define exactamente que hará cada pieza de código que tenga una interfaz. Un módulo, una clase y una función tienen una interfaz, una parte que permite a otras piezas de código usar su funcionalidad interna. La función de esta interfaz es <em>esconder</em> los detalles de implementación permitiendo el uso de la funcionalidad encapsulada. También esto debe estar bien documentado en el lugar adecuado. Documenta lo que hace, no cómo lo hace.</p></li></ul><p>Estos dos puntos anteriores los puedes aplicar recursivamente a nivel cada vez más bajo, hasta que consideres que el problema es lo suficientemente pequeño como para resolverlo directamente.</p><p>El último consejo tiene varias partes, por lo que trataremos en un subtítulo aparte.</p><h2 id=evita-las-fugas-de-información>Evita las fugas de información</h2><p>Aunque tengamos completamente claro lo que una clase, módulo o función hace, nuestros detalles de implementación pueden dejar escapar información que no es conveniente que esté fuera de ella.</p><p>Piensa por ejemplo en la clase que se comunica con la API. ¿Qué pasaría si pasaras directamente los errores que la API da hacia las demás partes del código? Si esta parte cambia en el futuro, afectarás a todas estas partes que consumen esos errores.</p><p>Puedes seguir estos consejos para evitar fugas de información:</p><ul><li><p>Define estructuras de datos para comunicar información entre clases, módulos y funciones que sean uniformes a todos. Si alguien necesita un formato diferente, sólo lo transformará dentro de sus límites, siempre encargándose de devolver y recibir la información en el formato correcto.</p></li><li><p>Evita las dependencias temporales. Siempre que tienes que llamar las mismas funciones, clases o módulos en el mismo orden quiere decir que tienes una dependencia temporal. La información se está escapando en el orden de las llamadas. Piensa si estas piezas de código en realidad debieron ser una sola pieza.</p></li><li><p>Evita usar la misma abstracción a diferentes niveles. Imagínate que estás haciendo una aplicación para editar texto. Tienes una clase central que se encarga de mantener el estado del texto. Esta clase tiene la interfaz básica para realizar todas las transformaciones necesarias básicas, pero no le puedes exponer esto al usuario. El usuario necesita comandos como Copiar, Pegar y Cortar. Sería una mala idea usar estas mismas abstracciones en tu clase central, porque encadenaría completamente tu interfaz con tu centro y viceversa. Por eso, la clase que maneja el código debe tener abstracciones más básicas, adecuadas para crear funcionalidades como Copiar, Pegar, Cortar, u otras, si se necesitara.</p></li></ul><p>Todos estos consejos se tratan de mejor manera en el libro &ldquo;A Philosophy of Software Design&rdquo; de John Ousterhout, pero también me gustaría hacer eco de un consejo de Dan North: <strong>Busca crear código simple.</strong></p><p>Esta fue la crítica y aplicación del principio de Responsabilidad Única. En el siguiente artículo veremos el principio de Abierto/Cerrado (Open/Closed Principle).</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025 Héctor Patricio</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>1302 words</span>
<span>7 - 9 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#el-principio-de-responsabilidad-única>El principio de Responsabilidad Única</a></li><li><a href=#el-problema>El problema</a></li><li><a href=#transformando-el-principio>Transformando el principio</a></li><li><a href=#técnicas-para-concretar-el-principio>Técnicas para concretar el principio</a></li><li><a href=#evita-las-fugas-de-información>Evita las fugas de información</a></li></ul></nav><h3>Related</h3><ul><li><a href=/2019/03/19/principios-de-dise%C3%B1o-de-software/>Principios de Diseño de Software</a></li></ul></aside></div></div></body></html>