{
  "text": "Hola, ¿cómo están? Soy Héctor Patricio, me da mucho gusto estar con ustedes aquí de nuevo y me da mucho gusto que haya tanta gente presente en el Python Fest que organizó Código Facilito. Python es uno de mis lenguajes favoritos y creo que es una gran iniciativa para que mucha gente más se introduzca a él y el ecosistema siga creciendo. Yo voy a dar una plática que habla acerca de los secretos de Python o cosas que a mí me hubiera gustado saber antes de empezar a programar en Python. Una de las cosas más interesantes de Python es su biblioteca estándar, es decir, todos aquellos paquetes que vienen ya con el lenguaje cuando ustedes lo instalan sin que tengan que traer paquetes de terceros o programar ustedes mismos las funcionalidades. Esto me, digamos que me interesa especialmente porque muchas personas aprenden los lenguajes como yo le digo a lo salvaje, aprenden al vuelo, es decir, tienes un proyecto que hacer o de repente se te ocurre hacer un proyecto en cierto lenguaje y en vez de ponerte a estudiarlo lo que haces es lanzarte directamente y empezar a programar en él después de haber visto la sintaxis mínima, la instalación y el tooling mínimo. Y eso está muy bien, la verdad es que es una forma muy buena de aprender porque inmediatamente empiezas a crear cosas interesantes pero esta forma de aprender también tiene sus desventajas y a mí me ha pasado muchas veces cuando vas aprendiendo o vas aprendiendo al vuelo y vas haciendo cosas útiles muchas veces pasa que tienes hoyos en tu conocimiento, es decir, hay cosas que no sabías que existían o hay cosas que incluso parecen básicas y no las sabías porque justamente tú te saltaste a hacer cosas inmediatamente avanzadas y a veces mucho más que aquellos que estudian del lenguaje de principio. Entonces quiero que quede claro que no estoy hablando de mal de ninguna de las dos formas de aprender, estudiar un lenguaje por adelantado y después aplicarlo o aventarte al ruedo desde el principio. Cualquiera de las dos formas está bien. Lo único que tiene es que cada una tiene ventajas y desventajas. Entonces, esto que les voy a hablar hoy son cosas que a mí me hubiera gustado saber desde el principio, desde que empecé a programar en Python, porque es una de las fortalezas más grandes que Python tiene. Entonces, vamos a empezar a hablar acerca de los... Les decía que el inicio de la plática era secretos en general de Python, pero decidí centrarme específicamente en los secretos de la biblioteca estándar de Python. Estas cosas son normalmente cosas que los programadores hacemos y que nos vendría muy bien tenerlo en nuestro lenguaje. Y como ustedes saben, los lenguajes con diferentes grados de madurez, normalmente a veces les falta funcionalidades que uno tiene que programar. Por ejemplo, cuando yo programo en Go, extraño muchas cosas que Python ya tiene hechas prefabricadas y que normalmente incluso tengo bibliotecas por ahí que yo he hecho, que ando cargando de proyecto en proyecto porque no están en la biblioteca estándar. Y así me pasa con varios lenguajes. Con Python no sucede esto porque Python tiene una filosofía bastante diferente respecto a este apartado de lenguaje. Entonces, ¿de qué vamos a hablar? Vamos a hablar de ocho paquetes o de ocho partes de la biblioteca estándar de Python que tienen bastante utilidad para ti como programador. Primeramente vamos a hablar de IterTools. IterTools ahorita lo vamos a dejar simplemente como álgebra de iteradores. Un iterador es cualquier cosa sobre la que puedas hacer un ciclo o un loop. Puedes agarrarlo e iterar sobre él, justamente por eso se llama IterTools. También hay una biblioteca que se llama, bueno, un paquete que se llama Functools. Estas son utilidades para hacer programación funcional y te ayudan a hacer optimizaciones increíbles para tu código, para que quede limpio y también para que quede... más eficiente de lo que tú lo harías si te dedicaras a programarlo manualmente o de la forma imperativa. La siguiente parte es vamos a hablar de dos cosas importantes las colecciones, las colecciones son, como ustedes saben, la base de la programación, muchas veces las colecciones las menospreciamos pero hay lenguajes que se dedican completamente a procesar colecciones de datos, por ejemplo, Lisp su nombre original es Lisp Processing entonces las colecciones son una parte muy importante de los lenguajes de programación y Python te da un módulo que te ayuda a trabajar con colecciones de manera mucho más sencilla de lo que se haría en cualquier otro lenguaje y luego tenemos otra parte importante que es el manejo de recursos manejo de recursos y en general envolvimiento de cosas este paquete es muy interesante porque te permite envolver código para hacer cosas antes y después de él, por eso se llama ContextLib y te permite hacer cosas que no harías en otros lenguajes de manera tan sencilla la última parte va a tratar acerca de primeramente, bueno, la penúltima parte, perdón, va a tratar acerca de dos cosas cómo manejar datos en general los cuando programamos en un lenguaje con su principal característica de orientación a objetos muchas veces tenemos que hacer mucho código que le llamamos Boilerplate, es decir código que es repetitivo y que soporta la estructura de todo lo demás más interesante que sigamos a hacer Python tiene una cosa que se llama Dataclasses que te ayuda a eliminar todo ese Boilerplate porque se dieron cuenta justamente de que lo repetimos vez tras vez Python te ayuda a manejarlo de manera sencilla y por otro lado para manejar datos justamente ya sabemos que en datos digamos, o si ustedes han escuchado de Python seguramente han escuchado de sus bibliotecas para manejo de números famosas como NumPy o como para manejo de datos como Pandas. Pero Python en sí mismo ya trae una biblioteca o un paquete de estadísticas que si ustedes no están haciendo muchos cálculos, no tienen que instalar Pandas, no tienen que instalar NumPy. Con Statistics es suficiente para hacer cosas sencillas. Y ahora sí, la última parte, vamos a hablar de, primeramente, funcionalidades para hacer o trabajar con colecciones y bueno, con consecuencias y con cadenas de texto de manera digamos que más inteligente y vamos a hablar también de la metaprogramación que es una característica que pocos conocen de Python. Python tiene un paquete de metaprogramación bastante interesante que te permite hacer cosas que, de otra forma, serían bastante difíciles. Entonces, ahora sí, empecemos. Vamos a empezar hablando, primeramente, de EtherTools. Cuando uno está programando, hay una multitud de problemas que consisten en sacar todas las combinaciones posibles de una colección de elementos. Tienes tu dominio, por ejemplo, o sea, le llevamos dominio a tu entrada de datos. Piénsenlo, por ejemplo, en la generación de contraseñas. En la generación de contraseñas, básicamente, para saber qué tan fuerte es tu contraseña, tienes que saber cuántas contraseñas son posibles con tu conjunto de datos iniciales o con tu conjunto de caracteres iniciales. Ese y un montón de problemas se basan directamente en sacar las combinaciones en el sentido matemático de un conjunto de elementos. Entonces, si ustedes han intentado hacer lead code o problemas justamente de algoritmia, muchos de estos problemas se basan en esto, en sacar todas las combinaciones posibles de un conjunto de elementos. Ya más matemáticamente, este conjunto de combinaciones posibles lo podríamos llamar todo el conjunto de los subconjuntos de... de un conjunto mayor. Entonces, este problema, para quienes ya lo sepan, es un problema bastante difícil de resolver. Y tú lo podrías intentar resolver en tu práctica, digamos, para mejorar tu forma de hacer código o de tu capacidad de lógica. Pero la realidad es que en el día a día, no tienes tiempo ni siquiera de hacerlo justamente porque tienes deadlines y tienes cosas que entregar. Pues, justamente, Python te entrega esto ya en un paquete y muchas más utilidades para hacerlo de manera eficiente y con poquito código. Como les dije, este paquete está en, bueno, todas estas funciones están en el paquete IterTools. Y podríamos pensarlo así como álgebra de iteradores. No solamente te da herramientas para trabajar con iteradores, sino que además te da forma de componerlo. Es decir, de crear, digamos, cadenas de este tipo de soluciones. Entonces, ahorita solamente quiero recordarles por qué es importante o es crucial que ustedes trabajen con combinatoria de manera eficiente. Quienes se hayan enfrentado a estos problemas que les decía Ya lo pueden estar pensando en, bueno, de problemas de algoritmo en general, no necesariamente de litcode. Ya lo pueden estar teniendo claro en su cabeza que es, primeramente, cuando quieres sacar todo el subconjunto de un conjunto más grande, este número crece exponencialmente. Este número es muy, muy grande. Y, de hecho, ese es el chiste de todos esos problemas de algoritmo. ¿Cómo le vas a hacer para manejar ese crecimiento? ¿Cómo le vas a hacer para eliminar las posibles soluciones de este problema? Entonces, esta es la primera cosa que pasa cuando empiezas a hacer combinatorias, sobre todo con iteradores. La segunda cosa que pasa es que te acabas tu memoria porque tener tantos elementos hace que manejar la memoria es imposible. Es cierto que ahorita tenemos máquinas muy poderosas y tenemos máquinas con mucha memoria y eso nos ha llevado a no preocuparnos tanto por cómo utilizamos la memoria en nuestros sistemas. Pero eso también ha llevado a que el software cada vez sea peor en general. Entonces, si quieres ser un programador que resalte entre todos aquellos que hacen cosas que no les importa el rendimiento de sus sistemas, el manejo de memoria es una cosa que tiene que ser parte de tu toolkit, parte de tus habilidades más básicas. Justamente en la combinatoria pasa esto, que te acabas tu memoria porque estás llenando de elementos generados esta memoria. Entonces, ¿cómo te ayuda IterTools? Te ayuda de dos formas. Primeramente, por default sus herramientas son de evaluación perezosa o de evaluación retardada. Esto quiere decir que haz de cuenta que sus herramientas no generan los datos que te dicen, sino simplemente te dicen que ya los tienen disponibles. Y como normalmente no vas a ocupar todos los elementos de golpe, te los van generando uno a uno solamente cuando se necesitan o cuando los obligas, como por ejemplo con una conversión de datos como list. Pero la evaluación retardada o perezosa te ayuda justamente a no acabarte tu memoria ni tampoco acabarte tu procesamiento, digamos. No es que se acabe, pero digamos de ocuparlo todo de golpe. Y luego, esto que les decía justamente, que las herramientas de IterTools aparte se pueden componer entre ellas. Aquí lo llevamos de manera chistosa. Composability, no sé cómo decirlo directamente en español, pero justamente te permite crear soluciones un poquito más complejas que te pueden ayudar a hacer mejor código. Bueno, ahora una de las cosas más interesantes de EtherTools es que te permite trabajar con colecciones infinitas. Esto, ustedes como bien saben y como lo acabamos de mencionar, no es posible de manera cruda o de manera dura en los sistemas porque tu memoria tiene un límite, tu procesamiento tiene un límite. Entonces, ¿cómo le hace EtherTools para tratar con enfoques o con cosas infinitas? Pues justamente aplica las técnicas de las que hablamos hace ratito. Por ejemplo, la evaluación perezosa es esta parte que dijimos aquí de generar bajo demanda. O también, en vez de procesarlo todo de golpe, los iteradores se van procesando solamente cuando obligas al programa o cuando realmente se necesita ya algo. También muchas de sus herramientas mantienen memoria constante y así de esa manera te ayuda a crear mejor código. Y pues justamente esto te ayuda a que tu programa pueda escalar, digamos que de manera infinita, entre comillas, como saben, todo tiene límites. Pero finalmente te ayuda a crecer de manera mucho más rápido. Es decir, por ejemplo, imagínense intentar hacer la combinatoria de un conjunto de un millón de elementos. Este, por ejemplo, podría ser un caso que te ayude a resolverlo de manera sencilla. En esta presentación que van a tener disponible en línea, hay un montón de ejemplos de código que les permiten ver qué es lo que hacen las herramientas. Entonces, por ejemplo, esto de aquí, Editor Tools, te permite sacar. las permutaciones de los elementos de un conjunto de manera sencilla sin que tú tengas que programar nada y en todas las secciones van a ver ejemplos de este estilo por ejemplo aquí hay un producto punto de los elementos que existen igual si lo ejecutamos van a ver el ejemplo producto punto de dos conjuntos justamente entonces hacen la combinación de los conjuntos que ustedes quieran entonces intertools otra vez como les dije es una cosa amplia no lo vamos a alcanzar a ocurrir ahorita que vamos a hablar de otras siete bibliotecas pero es una de las cosas más útiles que pueden encontrar en la biblioteca de python vamos a pasar a la siguiente la siguiente biblioteca de la que vamos a hablar tiene mucho que ver con la programación funcional y la primera una de las primeras cosas para la que te ayuda es para hacer cosas interesantes como memorización ahorita vamos a hablar de ella entonces la pregunta para ustedes es cuántas veces calculan lo mismo sin darse cuenta esto pasa en muchos problemas en problemas sobre todo que se pueden convertir en recursivos o en problemas iterativos en los que hacen cosas o el cálculo de la misma cosa muchas veces para solucionar ese tipo de cosas hay dos hay muchas muchas técnicas una de ellas la programación dinámica que se basa principalmente en lo que conocemos como memorización ahorita vamos a hablar un poquito de eso pero esta biblioteca tiene muchas más funciones de las que de las que estoy mencionando ahorita entonces una de las de las funciones más inmediatas de la de la biblioteca functools es precisamente hacer lo que se llama un lr ucache entonces functools es una herramienta para hacer programación bueno un paquete para hacer programación funcional y les ayuda a hacer optimizaciones automáticas, principalmente su función tiene que ver con darles código elegante de manera que esté completamente automatizado por detrás de la manera en la que se hacen las cosas y que probablemente si ustedes lo programaran, claro que lo van a poder hacer igual de bien, pero con mucho tiempo de dedicación. Entonces Python les va a ahorrar un montón de tiempo en ese sentido. ¿Qué pasa cuando no le ponemos atención a la redundancia computacional? Pues justamente la complejidad ciclomática le decimos o la complejidad de tu sistema puede crecer mucho y entonces va a ser un problemón para todos. Si buscamos una forma de resolverlo podemos buscar una cosa que se llama el principio de Bellman. El principio de Bellman te ayuda a encontrar problemas o te dice más bien que tienes que utilizar problemas con substructura óptima. Otra de las formas para atacar justamente la complejidad o más bien la repetición es esto que les acabo de mencionar, el memorization. ¿Por qué lo ponemos aquí como intercambio de memoria por tiempo de CPU? Pues justamente porque en vez de volver a calcular un resultado lo guardas en una tabla o en cualquier lugar en el que lo puedas traer luego rápido y entonces estás usando más memoria pero en general menos CPU. Y bueno la programación funcional tiene un principio que se llama transparencia referencial. La transparencia referencial quiere decir que cambies el llamado de una función por su valor y este cambio no debería tener ningún efecto en tu programa. Entonces la programación funcional sobre todo a través de herramientas como los lenguajes funcionales modernos o herramientas como functools te permiten hacer este tipo de cosas. Vamos a ver aquí un ejemplo, algunos ejemplos de las cosas a las que te ayuda tener FungTools. Entonces, FungTools te permite tratar las funciones como si fueran datos. Esta es una de las cosas más interesantes. Entonces, por ejemplo, hay una función que ahorita vamos a ver para hacer aplicación parcial. La aplicación parcial es, en vez de llamar una función inmediatamente con todos sus argumentos, la llamas con los que tienes disponibles y posteriormente la vas a usar, vas a completarla con lo que tengas. La biblioteca FungTools también te permite hacer composición de funciones, te permite crear envoltorios de funciones o funciones que reciban funciones y que devuelvan funciones de manera mucho más sencilla porque Python lo permite de por sí. Y te permite hacer reutilización de funciones de manera mucho más sencilla justamente como con aplicación parcial que es una de las técnicas para hacer reutilización de funciones. Este es el ejemplo que les decía acerca del recálculo. Uno de los problemas más comunes que tenemos cuando queremos hacer algo recursivo o algo iterativo que hace muchas cosas repetidas es el cálculo de Fibonacci. El cálculo de Fibonacci justamente aquí va a calcular, digamos que por dos ramas, exactamente los mismos números hasta abajo, pero esto lo va a hacer un montón de veces. Entonces FungTools mediante la función LRU Cache te permite hacer esto de manera automática, cosa que como les digo es problema de algoritmo que ustedes tendrán que programar a mano en un montón de tiempo. No lo vamos a correr ahorita para ahorrarnos un poquito de tiempo pero ustedes lo van a tener disponible para correrlo y para copiar el código si ustedes lo requieren. La aplicación parcial es otra técnica de programación funcional que les decía que te puede ayudar primeramente a crear mejor código. con una estructura más simple de entender para quienes lo lean. Y que muchas veces es la única forma que tenemos de hacer algo. Esta función, por ejemplo, calcular precio, recibe tres argumentos, digamos, que necesarios y un argumento opcional, que es el del envío. Y la aplicación parcial lo que te permite es mandarle lo que tengas en el momento justamente. Entonces, Partial te está diciendo que va a calcular el precio con datos, digamos, que fijos para México. Entonces, aquí está para México, para Argentina o con envío gratis. Y ahora tienes tres funciones que no tuviste que reescribir y que no tuviste que parametrizar de otra forma, más que con la aplicación parcial. Y después puedes usar estas funciones sin tener que mandarle todos los argumentos cada vez. Esto es algo mucho más elegante que andarle mandando los argumentos todas las veces o constantes o cosas similares. Esto es, digamos, técnicas de programación funcional bastante buenas. Y, bueno, tiene otras funcionalidades. Como les decía, no las vamos a alcanzar a ver aquí. Tiene una forma de crear más o menos algo parecido a los decoradores, que se llama wraps, con algunas diferencias entre ellos, pero te permite hacer cosas interesantes. Muy bien. El siguiente módulo del que vamos a hablar tiene que ver con las colecciones. Entonces, esto me ha pasado muchas veces hasta que descubrí este módulo, la colección que se llama, bueno, el paquete que se llama collections. Estas cosas, les digo, se repiten vez tras vez en las redes de programación hasta que alguien te dice que ya existe algo que lo hace por ti en tres patadas, como decimos aquí en México. Entonces, este módulo se llama collections y tiene. tiene un montón de colecciones especializadas para hacer cosas que se repiten vez tras vez en la programación. Entonces, por ejemplo, primeramente, nosotros muchas veces nos dedicamos a hacer cosas como por ejemplo especializar diccionarios, listas y tuplas. Y no siempre es así. Entonces, esto es lo que te ayuda el módulo de collections. Luego, te ayuda a reducir código repetitivo, te da eficiencia porque lo optimizaron al máximo posible para que tú no tengas que pelearte con eso. Y finalmente, al ser menos código, normalmente es más legible. Obviamente, a veces tienes que explicar un poquito más sobre por qué usaste eso, pero al final de cuentas, te permite hacer código más legible. Entonces, eso es lo que les decía que pasa vez tras vez. Imagínense que quieren guardar algo en un diccionario y normalmente, o en algunos lenguajes, si intentas guardar algo en una llave que no existe o actualizar algo en una llave que no existe, tu programa va a tronar. En Python eso lo harías con, para evitar eso, tendrías que hacerlo con un get. Tendrías que primero hacer un get, como lo estamos viendo. No se ve aquí, pero para no fallar, cuando traigas una llave, haces un get y después actualizas lo que tienes que hacer. Y si no, pues te planchas el valor. Este es como el código sin la función, o más bien sin el módulo collections. Y esto es con el código con el collections. Entonces, aquí están haciendo dos cosas. Primeramente, esto nos pasa muchas veces. Tenemos que hacer la parte de verificar si está la llave y si sí guardarlo. Y después imagínate justamente que te piden contar el número de repeticiones de algo. El módulo counter lo hace directamente por ti. Más bien, la clase counter lo hace directamente por ti. por ti y te da muchas otras funcionalidades bastante útiles para este tipo de situaciones. Entonces, primeramente, te está ahorrando un montón de trabajo. Bueno, aquí hay un ejemplo un poquito más grande sobre Counter. Igual, ustedes lo pueden ejecutar cuando vean esta presentación en sus máquinas. Y otra clase que me gusta mucho, bueno, esta no es una clase, digamos que es una función constructora que te da un tipo de dato que les prometo es súper útil. Entonces, imagínense justamente que el caso que les decía hace rato, ustedes están haciendo, por ejemplo, un contador, tienen que contar el número de veces que una palabra se repite en cierto texto. Entonces, en vez de verificar cada vez si la palabra ya está en el diccionario como una llave, el default dic te dice, no te preocupes, si no está, yo lo inserto con lo que tú me digas. Entonces, vean lo que está haciendo aquí. El default dic, estamos creando una lista, más bien un diccionario que si no está la llave, automáticamente va a crear una lista vacía. Este es el constructor, digamos, de tu tipo de dato. Este es otro constructor, pero por medio de set. Y tú le puedes mandar una función personalizada a final de cuentas. Entonces, el default dic es otra de las herramientas más famosas y comunes del módulo collections. Y bueno, hay un montón de herramientas más, como por ejemplo, name tuple, deque, bueno, deque. Deque es una lista enlazada con dos finales, es decir, puedes acceder a ella eficientemente desde el final o desde el principio y sirve para implementar otras estructuras de datos interesantes. Y finalmente está chainmap aquí como ejemplo. Entonces, el módulo collections te da un montón de cosas interesantes que puedes utilizar. Todavía nos quedan varios módulos que ver, así es que continuemos. El siguiente módulo del que vamos a hablar tiene que ver con el manejo de contextos. El manejo de contextos tiene mucho que verlo con lo que pasa cuando abres un archivo, por ejemplo. Tienes que preocuparte por abrirlo y luego por cerrarlo para no dejar por ahí espacios de memoria ocupados o cosas sucias, digamos, sin limpiar. A todo esto, bueno, y este patrón de manejo de cosas, le llamamos en Python justamente manejo de contextos. La pregunta para ti es, ¿cuántas veces te ha pasado que abres un archivo y olvides cerrarlo o liberar cualquier otro recurso? ¿Qué pasaría si Python te permitiera garantizar una limpieza automática? Esto, muchos lenguajes modernos ya lo traen integrados, pero justamente lenguajes de la generación de Python no lo traían tan integrado. Pero aunque lo traigan integrado en el lenguaje directamente, Python te permite ser bastante más flexible con eso y te permite hacer tus propios manejadores de contexto mediante el paquete context-lib. Bueno, ¿por qué es importante el protocolo de manejo de contextos? Primeramente, te permite seguir este patrón, el patrón de que cuando adquieres un recurso, lo inicializas, pero también lo tienes que hacer algo por limpiarlo. Los protocolos, el manejo de protocolos, el protocolo de manejo de contextos te ayuda a liberar recursos sin que te importe cómo terminó explícitamente la ejecución. Es muy parecido a cuando pones un final y en el try es más o menos lo mismo. Y te permite, por ejemplo, hacer excepciones de manera segura y otras cosas. Entonces, todo este protocolo de manejo de contextos mediante los context managers, te lo puedes imaginar justamente como algo que envuelve la ejecución de alguna cosa que tú quieras asegurarte de que código se ejecuta antes y después de esta ejecución. Entonces, una de las primeras cosas que es para los que se usa como ya dijimos, es para el manejo de recursos, para manejar archivos, para manejar streams, para manejar conexiones de red, para manejar en concurrencia, para manejar semáforos y logs, conexiones a base de datos u otras cosas. También se puede utilizar para cosas un poquito más creativas, como para medir el tiempo de algo que corre. Puede ser un envoltorio que corre código antes y corre código después. Y para manejar estados temporales. ¿Qué beneficios te da si lo usas correctamente? Pues justamente te ayuda a evitar los memory leaks, es decir, espacios de memoria que se queden ocupados porque no liberaste algún recurso. Te ayuda a tener código de más fácil comprensión, más robusto y con una mejor legibilidad. Y esto te lleva a tener menos bugs y mantenimiento simple. Esta es la ventaja de los context managers. No es algo que estemos tan acostumbrados a hacer, pero en Python se puede hacer de manera muy sencilla. Entonces, aquí en el slide que vas a tener, vas a ver varios ejemplos de context managers que vienen en la librería ContextLib. Y uno de ellos, por ejemplo, es el context manager suppress, que lo que hace es suprimir excepciones justamente para que tu programa no truene, sino simplemente cacharlas y eliminarlas o hacer algo con ellas. Entonces, este es un ejemplo que tenemos del context manager, pero también te permite crear tu propio context manager. Hay un decorador de Python que se llama el context manager que viene justamente de ContextLib y que te ayuda a crear tus propios manejadores de contexto que son muy útiles y que te pueden ayudar a crear tu propio, digamos que tu propio conjunto de manejadores semánticos de todo lo que necesites. En este ejemplo tenemos un cronómetro que te ayuda a contar el tiempo que pasó en cualquier ejecución. Entonces, lo puedes usar como un context manager. Bueno, puedes crear tu context manager de manera arbitraria. Y, bueno, finalmente tenemos otra utilidad que es muy interesante, que es el Exit Stack. El Exit Stack lo que te ayuda es a anidar un montón de context managers y el Exit Stack te ayuda a salirte de todos ellos sin que tengas que preocupar de todo lo que abras, o de todos los context managers que abras. Otra vez, esta librería de ContextLib tiene muchas más cosas interesantes de las que te puedes servir. Vamos a pasar a la siguiente que es, bueno, la pregunta para ti antes de decirte el nombre de la biblioteca es ¿cuántas líneas de código tienes que escribir para crear una clase que almacena datos? Una de las cosas que menos me gustaba a mí de Java, cuando hacía Java hace muchísimo tiempo, es que tenía que hacer mucho código de boilerplate. Y justamente eso te puede seguir pasando en casi cualquier otro lenguaje o en todo objeto, es que tienes que meter un montón de cosas que siempre son las mismas. Por ejemplo, siempre tienes que poner una función de representación, una función de string, que eso me pasaba antes cuando usaba este tipo de cosas en Python. Pero Python te ayuda justamente mediante otro módulo que son los dataclases, te ayuda a crear clases de datos, bueno, clases que manejen datos y evitar el código repetitivo. Entonces, si vas a crear una clase que su función principal sea almacenar datos o como representar un tipo de dato, los dataclases de Python son perfectos para esto. Entonces, ya hablamos de qué es el código boilerplate, es todo aquel código que repites porque tiene que estar justamente, ¿verdad? A veces, no sé si les ha pasado, si han programado en Python o en otros lenguajes que este método, por ejemplo, el método de representación, que es cómo se va a imprimir tu objeto cuando cuando se usa en una cadena, lo tienes que agregar, porque si no, cuando hagas un log, por ejemplo, te va a tronar o va a salir algo ilegible. O, por ejemplo, cómo se va a comportar tu objeto cuando hagas una comparación. Entonces, a veces tienes que hacer eso siempre igual y eso es el código de Boilerplate. Las data classes te ayudan a evitar eso. ¿Por qué queremos evitar al máximo el código de Boilerplate? Pues justamente porque te ayuda, bueno, más bien el código Boilerplate te da o es propenso a errores. También cuesta más trabajo mantenerlo, pero cuando lo evitas, pues entonces tienes la tarea más fácil. Y, finalmente, el código Boilerplate esconde el código que realmente te importa, que es lo que diferencia tu programa. Entonces, mientras más lo puedas evitar, justamente mejor. Entonces, los Boilerplates, más bien las data clases, llevan a evitar el Boilerplate. Quiero que vean esta comparación de esta clase. Esta es una clase de persona que, justamente, que lo único que quiere es guardar los datos básicos de una persona y que, de todos modos, tenemos que escribir las clases de, bueno, más bien los métodos de siempre que son los que les decía, el método de inicialización, el método de representación, método de comparación y un método de hash que tenemos aquí. Los data clases te dan todo eso. Y, justamente, nada más con importar el módulo data clases y usarlo, ya tienes todos esos métodos, digamos que ya prefabricados de manera default. Y todavía puedes customizarlo un poquito como, por ejemplo, con hooks como el Postinit o cosas similares. Y, entonces, tú ya nada más te preocupas por agregar tus datos tal como lo harías con una clase, bueno, con un lenguaje mucho más sencillo sin tener que meter un montón de boilerplate. Los data classes también te ayudan a generar datos dinámicos. Justamente a veces se requiere cuando haces algo en tu inicializador, que por ejemplo inicializa una nueva lista, podrías hacerlo mediante el campo field y te va a facilitar mucho la creación de tipos de datos o de clases que su principal objetivo sea almacenar y transportar datos. Entonces te voy a dejar aquí tres ejemplos de cómo los puedes usar para que los veas en la presentación ya en línea. Muy bien, la siguiente pregunta que tenemos para ti es, o que tengo para ti es, y nos pasa muy común en Python, me pasa a mí de hecho, ¿cuántas librerías tienes que instalar solamente para calcular una media, una división estándar o hacer cualquier otro cálculo estadístico sencillo? Les digo que a mí me ha pasado y que incluso cuando es la costumbre, inmediatamente instalas NumPy y Pandas o Polars o el que tengas, que esas bibliotecas son muy poderosas, esos paquetes son muy poderosos, pero tienen su uso justamente cuando estás haciendo un cálculo sencillo para que le metas dependencias extra a tu proyecto que solamente te van a complicar la vida en el futuro si no estás utilizando todo su poder. Entonces Python tiene una biblioteca que se llama Statistics, que te ayuda a hacer estadística descriptiva sin que tengas que instalar nada, justamente porque es el chiste de la biblioteca estándar. Entonces ya sabemos que la estadística nos puede ayudar para muchas cosas, para hacer análisis exploratorio, para hacer prototipado rápido y especialmente la estadística en general nos puede ayudar para hacer algoritmos precisos justamente, que no solamente hagan cálculos de juguete, sino que sean numéricamente estables. es decir, que puedas confiar en su precisión. Y te puede ayudar a casos específicos de tu problema. Entonces, la biblioteca de statistics ya tiene algoritmos robustos que te pueden ayudar a todos estos casos. Como, por ejemplo, para calcular velocidades promedio, dependiendo de tu caso de uso, calcular tasas de crecimiento, valores centrales y la variabilidad en general. Entonces, tienes todo un toolkit de estadísticas sin tener que instalar, como te dije, ni NumPy ni nada parecido en tu proyecto. Aquí hay algunos ejemplos que te pueden servir para que veas cómo o qué es lo que tiene la biblioteca de statistics de Python. Y como en los otros casos, también te recomiendo que le has hecho un ojito para que tú veas qué es todo lo que se puede hacer. Este caso, o este tercer caso específicamente, es muy interesante porque no solamente utiliza statistics, sino que lo combina con otra biblioteca de la que ya hablamos, otro paquete del que ya hablamos, que es el paquete Collections, mediante la clase Counter. Entonces, te recomiendo que tú los veas. Finalmente, o casi finalmente, vamos a hablar de la biblioteca DiffLeaf. La biblioteca DiffLeaf te puede servir para hacer comparaciones más inteligentes entre colecciones, o más bien secuencias y cadenas. Entonces, muchas veces nos ha pasado eso. Y yo creo que ustedes lo han visto en... Si usan git moderno en la terminal, les ha pasado que escriben un comando de manera incorrecta y git les dice el comando que más se acerca a lo que ustedes querían. Obviamente no lo ejecuta porque puede que se equivoque y entonces podría meterlos en problemas. Pero la funcionalidad es útil. Entonces, ustedes, yo creo que a veces les han pedido un quisiste decir, ¿no? Hay varias maneras de lograr este quisiste decir, pero hay métodos matemáticos para lograr encontrarse. similitud de cadenas. Justamente eso es lo que Python es probable mediante la biblioteca DiffLib. Les da un conjunto de herramientas para hacer comparaciones entre secuencias de texto y otro tipo de secuencias. Entonces, ¿qué algoritmos incluye Python aquí? Utiliza el algoritmo de Radcliffe, que te da una medida de similitud bastante robusta. Te da el Language Common Subsequence, que también es un problema de LeetCode, por si alguien lo ha intentado. Aquí lo tienes implementado de manera eficiente y te puede ayudar a crear programas que sean tolerantes a errores. Y a hacer otros programas más interesantes, como por ejemplo, análisis de cambios. Los casos de uso más comunes para esto, pues ya los hemos mencionado un poquito, que es el autocompletado inteligente, corrección de comandos o de cosas que el usuario haya escrito mal, detección de cadenas duplicadas, búsquedas más inteligentes mediante búsquedas. En inglés se llaman FOSI, en español le llamaríamos como búsquedas no exactas de cosas. Algunos sistemas de recomendación o control de versiones de cosas, justamente mediante la comparación o la detección de cambios. Aquí también te puse otros tres ejemplos que muestran algunas de las cosas que DiffLib te puede dar. Por ejemplo, encontrar matches no exactos, sino cercanos. Te puede ayudar también a encontrar diferencias entre cadenas mediante Unified Diff. Y te puede ayudar a cosas más avanzadas, como por ejemplo, combinándolo con otras herramientas, te puede ayudar a hacer un sistema, por ejemplo, de búsqueda por similitud. Entonces, esta biblioteca de Python o este paquete de biblioteca estándar, es algo que sin duda te puede servir para hacer. programas más avanzados. Y puede que en esta nueva generación de programadores o en esta nueva época, tú vayas a escribir poquito de esto directamente, gracias a los LLMs y cosas similares. Pero tener el nombre de la cosa y saber cómo funciona, te puede ayudar justamente a que tus asistentes te ayuden mejor. Bueno, la última biblioteca de la que vamos a hablar, el último paquete del que vamos a hablar, es que espero que les haya pasado este problema en el mundo real, porque es un problema muy interesante. Y es, ¿cuántas veces han necesitado saber exactamente qué es lo que una función o una clase o un tipo de dato tiene en tiempo de ejecución? Y esto es cuando se pueden modificar estos elementos en tiempo de ejecución. Es muy interesante. A mí me tocó una vez hacer un sistema que guardar en una base de datos común mediante Django, guardara una base de datos, digamos que, extremamente dinámica. Entonces, lo que teníamos que hacer es analizar la base de datos dinámica, construir los tipos de datos en Python, construir las clases, los objetos, mediante justamente reflexión y luego usarlos esos para trabajar con tu programa. Cuando se encuentran cosas extremadamente dinámicas en ejecución, es cuando este tipo de funciones les sirven bastante. Entonces, ¿qué pasaría si Python te puede ayudar a eso? Pues, justamente tenemos el módulo o el paquete Inspect que te puede ayudar a hacer una introspección profunda de todo tipo de código que encuentres en Python. Esta es una funcionalidad avanzada de la que no vamos a hablar tan a profundidad, también porque ya no estamos quedando sin tiempo, pero a esto se le conoce como metaprogramación. Justamente la metaprogramación son varias cosas. Primeramente, la metaprogramación requiere la capacidad de examinar el código y de modificarse a sí mismo. Justamente. Y básicamente eso es lo que hace el módulo Inspect. La metaprogramación te puede ayudar a hacer cosas muy interesantes, como por ejemplo, cosas que trabajen con código. Te puede ayudar a también hacer un debugging avanzado de código que no es tuyo o al que no tienes acceso. Te puede ayudar a hacer cosas que se adapten en el tiempo de ejecución basado en datos que los usuarios te den o en datos que encuentres en algún lado. Y finalmente te ayuda a generar algunas cosas de manera automática como entre ellas la documentación. Entonces, la reflexión y la introspección te pueden ayudar a tener un conjunto de herramientas disponibles para crear código primeramente más poderoso justamente que no se hubiera podido resolver de otra forma. De hecho, algunos odian la reflexión y odian la introspección en general porque es algo complejo de hacer. Justamente estás trabajando con el mismo código. El mismo código está modificando a sí mismo. Pero te permite, cuando llegas a ese punto de necesidad, te permite hacer cosas que no se podrían hacer con ninguna otra cosa. Entonces, ¿en qué creen que está basado justamente las herramientas que usan diariamente de análisis de código como los IDs y los seguidores? Pues justamente están basados en este tipo de cosas. Están basados en herramientas que pueden leer el código y que se analizan a sí mismas. Entonces, es una capacidad muy interesante. Aquí de la misma manera les puse tres ejemplos que les pueden ayudar a entender qué es el módulo Inspect que básicamente les ayuda a descomponer en tiempo de ejecución cualquier tipo de dato y cualquier función que ustedes requieran observar. en su programa para poder hacer algo con ella. Ya les di un caso de uso. Imagínense justamente que están leyendo datos dinámicos de algún lado y quieren construir clases o construir tipos de datos o funciones que se adapten a esas clases. Una forma de hacerlo es mediante la introspección justamente. Y trabajando con algo un poquito más avanzado, que es el árbol de sintaxis abstracta de Python. Entonces, es un módulo muy interesante que requiere su tiempo dominar y requiere su tiempo entender siquiera, pero les puede ayudar bastante en casos difíciles. Pasamos a la conclusión. La conclusión de que quiero que se lleven de esto es que la biblioteca estándar de Python tiene cosas que en otros lenguajes ustedes tendrían que programar o que tendrían que depender de otro que no es el equipo core del lenguaje y que finalmente eso los pone en algún tipo de riesgo. Python, mediante su, bueno, mediante la filosofía de traer las baterías incluidas, les ayuda a acelerar el desarrollo significativamente, pero también les puede ayudar a crear mejor código y cosas que ustedes tardarían mucho más en crear. Entonces, como próximos pasos, les recomiendo que ustedes le echen un ojito a esta y a otras bibliotecas de la biblioteca estándar, bueno, otros módulos o paquetes de la biblioteca estándar de Python y puedan beneficiarse de todo lo que hay ahí. Me faltaron muchos que yo uso en el día a día. Por ejemplo, el paquete de criptografía es una joya. El paquete de manejo de tiempos también es bastante bueno. En vez de depender de terceros, ya lo trae integrado Python en su biblioteca estándar y todo lo que ustedes pueden hacer mediante su biblioteca estándar es bastante interesante. Entonces, muchas gracias a todos por la atención y si tienen alguna pregunta, estaré por aquí en el Twitter o en el Slack o en el Discord del festival. Gracias a todos.",
  "language": "es",
  "duration": 2711.168,
  "words": [],
  "segments": []
}