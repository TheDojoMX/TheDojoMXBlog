<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="es" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>El arte genérico: una historia de la metaprogramación en C++ - The Dojo MX Blog</title>
<meta name="description" content="La metaprogramación en C++ ha recorrido un camino tan complejo como fascinante, hasta convertirse en una herramienta clave para el desarrollo de software genérico y de alto rendimiento">


  <meta name="author" content="Francisco Zavala">
  
  <meta property="article:author" content="Francisco Zavala">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="es">
<meta property="og:site_name" content="The Dojo MX Blog">
<meta property="og:title" content="El arte genérico: una historia de la metaprogramación en C++">
<meta property="og:url" content="https://blog.thedojo.mx/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++.html">


  <meta property="og:description" content="La metaprogramación en C++ ha recorrido un camino tan complejo como fascinante, hasta convertirse en una herramienta clave para el desarrollo de software genérico y de alto rendimiento">



  <meta property="og:image" content="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_1440/v1745040911/mitchell-luo-KM9rx_KSmWk-unsplash_lgmdht.jpg">





  <meta property="article:published_time" content="2025-04-17T00:00:00-06:00">






<link rel="canonical" href="https://blog.thedojo.mx/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "https://blog.thedojo.mx/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="The Dojo MX Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    
<!-- favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/images/favicons/site.webmanifest">
<link rel="mask-icon" href="/assets/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/images/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<!-- end favicon -->
<!-- for mathjax support -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNSYMJDY5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZNSYMJDY5S');
</script>

<!-- Hotjar Tracking Code for blog.thedojo.mx -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1217463,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9860440966400421"
     crossorigin="anonymous"></script>

<script src="/assets/js/sharect.min.js"></script>
<!-- Fathom - beautiful, simple website analytics -->
   <script src="https://cdn.usefathom.com/script.js" data-site="NGGHUUZH" defer></script>
<!-- / Fathom -->
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "url": "https://blog.thedojo.mx/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++.html",
      "name": "El arte genérico: una historia de la metaprogramación en C++",
      "headline": "El arte genérico: una historia de la metaprogramación en C++",
      "keywords": "c++,metaprogramación",
      "description": "La metaprogramación en C++ ha recorrido un camino tan complejo como fascinante, hasta convertirse en una herramienta clave para el desarrollo de software genérico y de alto rendimiento",
      "articleBody": "Hablar de metaprogramación en C++ suele generar cierto rechazo, y no sin razón: dominar el lenguaje ya representa un reto considerable, y sumarle la complejidad de los teamplates puede parecer excesivo. A diferencia de otros lenguajes con mecanismos más flexibles o integrados, C++ exige un conocimiento profundo no solo del lenguaje, sino también del compilador y su comportamiento. Comprender cómo interactúan las plantillas, como se resuelven los tipos, como se gestionan las sobrecargas o se aplican las optimizaciones es esencial para escribir código genérico eficaz, lo que convierte esta práctica en un desafío tanto técnico como mental.\n\nPero el desafío que implica la Metaprogramación no es exclusivo de C++; otros lenguajes también han buscado formas de extender sus propias capacidades, enfrentándose a problemas similares desde enfoques muy distintos.\n\nA lo largo de la historia de la informática, diversos lenguajes han explorado la metaprogramación desde ángulos muy distintos. LISP fue pionero absoluto en este campo, abordando el código como si fuera datos y utilizando macros para modificar y extender el propio lenguaje desde dentro. Esa fusión entre programa y datos sentó las bases de lo que hoy conocemos como metaprogramación.\n\nPor otro lado, Ada introdujo desde etapas tempranas mecanismos más estructurados, como los generics, que ofrecían una forma de reutilización de código orientada a la seguridad y el tipado fuerte. Por ejemplo, al definir un paquete genérico para pilas:\n\n\ngeneric\n   type Elemento is private;\npackage Pilas is\n   procedure Push (P : in out Pilas; E : in Elemento);\n   function Pop (P : in out Pilas) return Elemento;\nprivate\n   type Pilas is array (Natural range &lt;&gt;) of Elemento;\nend Pilas;\npackage Pilas_Enteros is new Pilas (Elemento =&gt; Integer);\n\n\n\nMientras Ada se centra en la metaprogramación estática, otros lenguajes exploraron la reflexión y los meta‑objetos para ganar flexibilidad en tiempo de ejecución. Java, por ejemplo, utiliza Annotation Processors para generar código antes de compilar, C# aprovecha Roslyn para inspeccionar y modificar su árbol de sintaxis, D ofrece CTFE y mixins, y Rust incorpora procedural macros que derivan implementaciones de rasgos automáticamente.\n\nUno de los primeros antecedentes directos de la metaprogramación en C++ lo encontramos en C, particularmente en el uso creativo de su preprocesador. Más allá de las clásicas macros con funciones, surgieron técnicas como los X-macros, que permitían generar múltiples fragmentos de código reutilizando una lista común de componentes. Esta técnica consistía en definir un conjunto de macros en un archivo de cabecera que podía incluirse varias veces, redefiniendo la macro principal en cada inclusión para producir diferentes versiones del código.\n\n// xmacro.h\n#define COMPONENTS \\\n    X(int, age)     \\\n    X(char*, name)  \\\n    X(double, salary)\n\n\n#include &lt;stdio.h&gt;\n#include \"mac.h\"\n\n// 1. Definir la estructura usando las X-macros\n#define X(type, name) type name;\ntypedef struct {\n    COMPONENTS\n} Employee;\n#undef X\n\n// 2. Declarar funciones específicas para imprimir cada campo\nvoid print_age(int age) {\n    printf(\"age: %d\\n\", age);\n}\n\nvoid print_name(char* name) {\n    printf(\"name: %s\\n\", name);\n}\n\nvoid print_salary(double salary) {\n    printf(\"salary: %.2f\\n\", salary);\n}\n\n// 3. Usar X-macros para llamar automáticamente a las funciones de impresión\n#define X(type, name) print_##name(e.name);\nvoid print_employee(Employee e) {\n    COMPONENTS\n}\n#undef X\n\nint main() {\n    Employee emp = {30, \"John Doe\", 55000.5};\n    print_employee(emp);\n    return 0;\n}\n\n\nAunque limitada y propensa a errores, esta estrategia fue una solución creativa a la falta de mecanismos más robustos, y se ha usado en tareas como la serialización de estructuras o la generación repetitiva de código.\n\nLa evolución hacia C++ introdujo un enfoque más robusto y expresivo para la generación de código: en lugar de depender de las macros del preprocesador — propensas a errores y difíciles de depurar — , el lenguaje apostó por mecanismos estáticos como los templates. Esta decisión, formalizada en el estándar C++98, marcó un hito importante en la historia del lenguaje. Originalmente concebidos por Bjarne Stroustrup a principios de los años 90, los templates surgieron como una extensión natural de la idea de reutilización de código sin sacrificar eficiencia. Esta elección estaba alineada con la filosofía de C++: ofrecer un control fino sobre el rendimiento y el uso eficiente de los recursos.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\n// Definición de la clase Persona\nstruct Persona {\n    std::string nombre;\n    int edad;\n\n    // Sobrecarga del operador &gt;\n    bool operator&gt;(const Persona&amp; otra) const {\n        return edad &gt; otra.edad;\n    }\n};\n\n// Plantilla max para comparar dos objetos de cualquier tipo\ntemplate &lt;typename T&gt;\nT max(T a, T b) {\n    return (a &gt; b) ? a : b;\n}\n\nint main() {\n    \n    std::cout &lt;&lt; max(5, 10) &lt;&lt; std::endl; // Comparar enteros\n    std::cout &lt;&lt; max(5.5, 2.3) &lt;&lt; std::endl; // Comparar flotantes\n    std::cout &lt;&lt; max('a', 'b') &lt;&lt; std::endl; // Comparar caracteres\n    std::cout &lt;&lt; max(\"Hola\", \"Mundo\") &lt;&lt; std::endl; // Comparar cadenas de caracteres\n\n    // Crear objetos Persona\n    Persona p1{\"Ana\", 30};\n    Persona p2{\"Luis\", 25};\n\n    // Usar la plantilla max con objetos Persona\n    Persona mayor = max(p1, p2);\n    std::cout &lt;&lt; \"La persona mayor es: \" &lt;&lt; mayor.nombre &lt;&lt; \" con \" &lt;&lt; mayor.edad &lt;&lt; \" años.\";\n\n\n    return 0;\n}\n\n\n\nUn ejemplo sobresaliente del poder de la metaprogramación en C++ es la Standard Template Library (STL). Diseñada hace más de dos décadas, esta biblioteca demostró que es posible construir algoritmos y estructuras de datos altamente reutilizables, seguros y eficientes sin sacrificar rendimiento. Su arquitectura, basada completamente en templates, permite que muchas decisiones se tomen en tiempo de compilación, lo que facilita optimizaciones que en otros lenguajes se delegan al tiempo de ejecución. Gracias a este enfoque, los programadores pueden trabajar con listas, vectores, mapas y muchos otros contenedores de forma abstracta, sin comprometer el control sobre el rendimiento.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\n// Clase personalizada\nstruct Persona {\n    std::string nombre;\n    int edad;\n\n    // Sobrecarga del operador &gt; (requisito para usar con maximo&lt;T&gt;)\n    bool operator&gt;(const Persona&amp; otra) const {\n        return edad &gt; otra.edad;\n    }\n\n    // Para usar en búsquedas\n    bool esMayorDeEdad() const {\n        return edad &gt;= 18;\n    }\n};\n\n// Template genérico como ejemplo de metaprogramación\ntemplate &lt;typename T&gt;\nT maximo(const T&amp; a, const T&amp; b) {\n    return (a &gt; b) ? a : b;\n}\n\n// Función para imprimir un vector genérico (puede usarse con cualquier tipo imprimible)\ntemplate &lt;typename T&gt;\nvoid imprimirVector(const std::vector&lt;T&gt;&amp; vec, const std::string&amp; titulo) {\n    std::cout &lt;&lt; titulo &lt;&lt; \":\\n\";\n    for (const auto&amp; elem : vec) {\n        std::cout &lt;&lt; \"- \" &lt;&lt; elem.nombre &lt;&lt; \" (\" &lt;&lt; elem.edad &lt;&lt; \" años)\\n\";\n    }\n}\n\nint main() {\n    Persona p1{\"Ana\", 30};\n    Persona p2{\"Luis\", 25};\n    Persona p3{\"Carlos\", 40};\n    Persona p4{\"Elena\", 35};\n\n    // Uso del template maximo\n    Persona mayor = maximo(p1, p2);\n    std::cout &lt;&lt; \"Entre \" &lt;&lt; p1.nombre &lt;&lt; \" y \" &lt;&lt; p2.nombre\n              &lt;&lt; \", el mayor es: \" &lt;&lt; mayor.nombre &lt;&lt; \" con \" &lt;&lt; mayor.edad &lt;&lt; \" años.\\n\\n\";\n\n    // STL: vector y sort con lambda\n    std::vector&lt;Persona&gt; personas = {p1, p2, p3, p4};\n    std::sort(personas.begin(), personas.end(), [](const Persona&amp; a, const Persona&amp; b) {\n        return a.edad &lt; b.edad;\n    });\n    imprimirVector(personas, \"Personas ordenadas por edad\");\n\n    // Uso de std::find_if para buscar al primer mayor de edad\n    auto it = std::find_if(personas.begin(), personas.end(), [](const Persona&amp; p) {\n        return p.esMayorDeEdad();\n    });\n    if (it != personas.end()) {\n        std::cout &lt;&lt; \"\\nPrimera persona mayor de edad: \" &lt;&lt; it-&gt;nombre &lt;&lt; \"\\n\";\n    }\n\n    // Uso de std::map con string -&gt; Persona\n    std::map&lt;std::string, Persona&gt; directorio;\n    for (const auto&amp; persona : personas) {\n        directorio[persona.nombre] = persona;\n    }\n\n    std::cout &lt;&lt; \"\\nDirectorio (map de nombre -&gt; edad):\\n\";\n    for (const auto&amp; [nombre, persona] : directorio) {\n        std::cout &lt;&lt; nombre &lt;&lt; \" tiene \" &lt;&lt; persona.edad &lt;&lt; \" años\\n\";\n    }\n\n    return 0;\n}\n\n\n\nLa STL no solo consolidó el papel de la metaprogramación en el ecosistema de C++, sino que también mostró cómo podía usarse para diseñar software genérico, modular y de alto rendimiento.\n\nDurante mucho tiempo, trabajar con metaprogramación en C++ fue una tarea ardua: los mensajes de error crípticos, la dificultad de depuración y la complejidad sintáctica desalentaban incluso a programadores experimentados. A pesar de la gran utilidad de los templates, las actualizaciones significativas fueron pausadas durante un largo periodo, desde el estándar de 1998 hasta la llegada de C++11 en 2011.\n\nSin embargo, el lenguaje comenzó a evolucionar de manera más progresiva, incorporando características como auto, decltype, constexpr y variadic templates, que facilitaban la escritura de código genérico más expresivo. Posteriormente, C++14 y C++17 siguieron refinando estas ideas, mientras que C++20 marcó un punto de inflexión con la inclusión de concepts, que aportaron una forma formal y clara de expresar los requisitos de los tipos en las plantillas.\n\nLa introducción de concepts en C++20 representó un paso crucial en esta evolución. Inspirados en gran medida por las ideas de Alexander Stepanov, cocreador de la STL, los concepts permiten especificar de forma clara y expresiva qué requisitos debe cumplir un tipo para ser utilizado en una plantilla. Esta abstracción permite escribir código genérico más legible y seguro, con validaciones en tiempo de compilación que antes requerían técnicas mucho más complejas o indirectas. Gracias a herramientas como concepts, la metaprogramación en C++ ha dejado de ser un arte oscuro para convertirse en una práctica más accesible, robusta y expresiva.\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;concepts&gt;\n\n// Concepto que exige un método miembro `area()` que devuelva un número (real o entero)\ntemplate &lt;typename T&gt;\nconcept TieneArea = requires(T a) {\n    { a.area() } -&gt; std::convertible_to&lt;double&gt;;\n};\n\n// Función que suma el área de todas las figuras que cumplen con el concepto TieneArea\ntemplate &lt;TieneArea T&gt;\ndouble area_total(const std::vector&lt;T&gt;&amp; figuras) {\n    double total = 0;\n    for (const auto&amp; figura : figuras) {\n        total += figura.area();  // Se garantiza que existe\n    }\n    return total;\n}\n\n// Clases que implementan el método `area()`\nstruct Rectangulo {\n    double ancho, alto;\n    double area() const { return ancho * alto; }\n};\n\nstruct Circulo {\n    double radio;\n    double area() const { return 3.14159 * radio * radio; }\n};\n\n// Clase que NO implementa `area()` y no cumple el concepto\nstruct Punto {\n    double x, y;\n};\n\nint main() {\n    std::vector&lt;Rectangulo&gt; rectangulos = {\n        {4.0, 5.0}, {2.0, 3.0}\n    };\n\n    std::vector&lt;Circulo&gt; circulos = {\n        {1.0}, {2.5}\n    };\n\n    std::cout &lt;&lt; \"Área total de rectángulos: \" &lt;&lt; area_total(rectangulos) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Área total de círculos: \" &lt;&lt; area_total(circulos) &lt;&lt; \"\\n\";\n\n    // std::vector&lt;Punto&gt; puntos = { {1.0, 2.0}, {3.0, 4.0} };\n    // area_total(puntos);  // Error de compilación: Punto no tiene `area()`\n\n    return 0;\n}\n\n\n\nAdemás, de cara a C++26, se contempla la incorporación de mecanismos de reflexión estática, una capacidad largamente esperada que permitiría inspeccionar y manipular tipos y estructuras del programa durante la compilación. Esta funcionalidad ampliaría aún más el poder de la metaprogramación en C++, facilitando tareas como la generación automática de código, la serialización de objetos o la validación estructural sin recurrir a macros o técnicas intrusivas.\n\nLa metaprogramación en C++ ha evolucionado de forma notable: desde los ingeniosos — aunque limitados — usos del preprocesador, hasta un presente donde los templates, concepts y la futura incorporación de reflexión estática conforman un ecosistema cada vez más potente, seguro y expresivo. Lejos de ser una técnica reservada a expertos, hoy se consolida como una herramienta estratégica para escribir código genérico, reutilizable y eficiente. Comprender esta evolución no solo permite valorar mejor el diseño del lenguaje, sino también adoptar una perspectiva más madura sobre cómo abstraemos y optimizamos nuestros programas. En última instancia, Metaprogramación en C++ es ampliar los límites de lo que podemos construir con precisión, elegancia y control.\n",
      "datePublished": "2025-04-17 00:00:00 -0600",
      "dateModified": "2025-04-17 00:00:00 -0600",
      "author": {
        "@type": "Person",
        "name": "Francisco Zavala",
        "givenName": "Francisco Zavala",
        "email": null
      },
      "publisher": {
        "@type": "Organization",
        "name": "The Dojo MX Blog",
        "url": "https://blog.thedojo.mx",
        "logo": {
          "@type": "ImageObject",
          "width": 32,
          "height": 32,
          "url": "https://blog.thedojo.mx/icon/favicon.ico"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.thedojo.mx/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++.html"
      },
      "image": {
        "@type": "ImageObject",
        "width": 1200,
        "height": 400,
        "url": "https://res.cloudinary.com/hectorip/image/upload/c_scale,w_1440/v1745040911/mitchell-luo-KM9rx_KSmWk-unsplash_lgmdht.jpg"
      }
    }
</script>



  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Saltar a navegación principal</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Saltar a contenido</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Saltar a pie</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="https://res.cloudinary.com/hectorip/image/upload/v1554098427/TheDojo/the-dojo-transparent.png" alt="The Dojo MX Blog"></a>
        
        <a class="site-title" href="/">
          The Dojo MX Blog
          
        </a>
        <ul class="visible-links">
<li class="masthead__menu-item">
              <a href="/latest">Todos los posts</a>
            </li>
<li class="masthead__menu-item">
              <a href="/about">Acerca de</a>
            </li>
<li class="masthead__menu-item">
              <a href="https://thedojo.mx">Cursos</a>
            </li>
</ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Alternar búsqueda</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Alternar menú</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
  







<div class="page__hero--overlay" style=" background-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('https://res.cloudinary.com/hectorip/image/upload/c_scale,w_1440/v1745040911/mitchell-luo-KM9rx_KSmWk-unsplash_lgmdht.jpg');">
  
    <div class="wrapper">
      <h1 id="page-title" class="page__title" itemprop="headline">
        
          El arte genérico: una historia de la metaprogramación en C++

        
      </h1>
      
        <p class="page__lead">La metaprogramación en C++ ha recorrido un camino tan complejo como fascinante, hasta convertirse en una herramienta clave para el desarrollo de software genérico y de alto rendimiento
</p>
      
      

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
        1880 palabras | 15 minutos de lectura
        
      </span>
    
  </p>

      
      
    </div>
  
  
</div>







<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="https://res.cloudinary.com/hectorip/image/upload/v1745287989/fzavala_tvao22.jpg" alt="Francisco Zavala" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Francisco Zavala</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Ingeniero de software apasionado de los algoritmos y las matemáticas aplicadas.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Seguir</button>
    <ul class="author__urls social-icons">
      

      

      
        <li>
          <a href="https://github.com/Nobody-1321" itemprop="url">
            <i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">Sitio web</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="El arte genérico: una historia de la metaprogramación en C++">
    <meta itemprop="description" content="La metaprogramación en C++ ha recorrido un camino tan complejo como fascinante, hasta convertirse en una herramienta clave para el desarrollo de software genérico y de alto rendimiento">
    <meta itemprop="datePublished" content="2025-04-17T00:00:00-06:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content e-content" itemprop="text">
        
        <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>

        </div>
        <p>Hablar de metaprogramación en C++ suele generar cierto rechazo, y no sin razón: dominar el lenguaje ya representa un reto considerable, y sumarle la complejidad de los teamplates puede parecer excesivo. A diferencia de otros lenguajes con mecanismos más flexibles o integrados, C++ exige un conocimiento profundo no solo del lenguaje, sino también del compilador y su comportamiento. Comprender cómo interactúan las plantillas, como se resuelven los tipos, como se gestionan las sobrecargas o se aplican las optimizaciones es esencial para escribir código genérico eficaz, lo que convierte esta práctica en un desafío tanto técnico como mental.</p>

<p>Pero el desafío que implica la Metaprogramación no es exclusivo de C++; otros lenguajes también han buscado formas de extender sus propias capacidades, enfrentándose a problemas similares desde enfoques muy distintos.</p>

<p>A lo largo de la historia de la informática, diversos lenguajes han explorado la metaprogramación desde ángulos muy distintos. LISP fue pionero absoluto en este campo, abordando el código como si fuera datos y utilizando macros para modificar y extender el propio lenguaje desde dentro. Esa fusión entre programa y datos sentó las bases de lo que hoy conocemos como metaprogramación.</p>

<p>Por otro lado, Ada introdujo desde etapas tempranas mecanismos más estructurados, como los generics, que ofrecían una forma de reutilización de código orientada a la seguridad y el tipado fuerte. Por ejemplo, al definir un paquete genérico para pilas:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">generic</span>
   <span class="n">type</span> <span class="n">Elemento</span> <span class="n">is</span> <span class="k">private</span><span class="p">;</span>
<span class="n">package</span> <span class="n">Pilas</span> <span class="n">is</span>
   <span class="n">procedure</span> <span class="n">Push</span> <span class="p">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">in</span> <span class="n">out</span> <span class="n">Pilas</span><span class="p">;</span> <span class="n">E</span> <span class="o">:</span> <span class="n">in</span> <span class="n">Elemento</span><span class="p">);</span>
   <span class="n">function</span> <span class="n">Pop</span> <span class="p">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">in</span> <span class="n">out</span> <span class="n">Pilas</span><span class="p">)</span> <span class="k">return</span> <span class="n">Elemento</span><span class="p">;</span>
<span class="k">private</span>
   <span class="n">type</span> <span class="n">Pilas</span> <span class="n">is</span> <span class="n">array</span> <span class="p">(</span><span class="n">Natural</span> <span class="n">range</span> <span class="o">&lt;&gt;</span><span class="p">)</span> <span class="n">of</span> <span class="n">Elemento</span><span class="p">;</span>
<span class="n">end</span> <span class="n">Pilas</span><span class="p">;</span>
<span class="n">package</span> <span class="n">Pilas_Enteros</span> <span class="n">is</span> <span class="k">new</span> <span class="nf">Pilas</span> <span class="p">(</span><span class="n">Elemento</span> <span class="o">=&gt;</span> <span class="n">Integer</span><span class="p">);</span>

</code></pre></div></div>

<p>Mientras Ada se centra en la metaprogramación estática, otros lenguajes exploraron la reflexión y los meta‑objetos para ganar flexibilidad en tiempo de ejecución. Java, por ejemplo, utiliza Annotation Processors para generar código antes de compilar, C# aprovecha Roslyn para inspeccionar y modificar su árbol de sintaxis, D ofrece CTFE y mixins, y Rust incorpora procedural macros que derivan implementaciones de rasgos automáticamente.</p>

<p>Uno de los primeros antecedentes directos de la metaprogramación en C++ lo encontramos en C, particularmente en el uso creativo de su preprocesador. Más allá de las clásicas macros con funciones, surgieron técnicas como los X-macros, que permitían generar múltiples fragmentos de código reutilizando una lista común de componentes. Esta técnica consistía en definir un conjunto de macros en un archivo de cabecera que podía incluirse varias veces, redefiniendo la macro principal en cada inclusión para producir diferentes versiones del código.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// xmacro.h</span>
<span class="cp">#define COMPONENTS \
    X(int, age)     \
    X(char*, name)  \
    X(double, salary)
</span></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"mac.h"</span><span class="cp">
</span>
<span class="c1">// 1. Definir la estructura usando las X-macros</span>
<span class="cp">#define X(type, name) type name;
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">COMPONENTS</span>
<span class="p">}</span> <span class="n">Employee</span><span class="p">;</span>
<span class="cp">#undef X
</span>
<span class="c1">// 2. Declarar funciones específicas para imprimir cada campo</span>
<span class="kt">void</span> <span class="nf">print_age</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"age: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_name</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"name: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_salary</span><span class="p">(</span><span class="kt">double</span> <span class="n">salary</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"salary: %.2f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">salary</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 3. Usar X-macros para llamar automáticamente a las funciones de impresión</span>
<span class="cp">#define X(type, name) print_##name(e.name);
</span><span class="kt">void</span> <span class="nf">print_employee</span><span class="p">(</span><span class="n">Employee</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">COMPONENTS</span>
<span class="p">}</span>
<span class="cp">#undef X
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Employee</span> <span class="n">emp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="s">"John Doe"</span><span class="p">,</span> <span class="mi">55000</span><span class="p">.</span><span class="mi">5</span><span class="p">};</span>
    <span class="n">print_employee</span><span class="p">(</span><span class="n">emp</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Aunque limitada y propensa a errores, esta estrategia fue una solución creativa a la falta de mecanismos más robustos, y se ha usado en tareas como la serialización de estructuras o la generación repetitiva de código.</p>

<p>La evolución hacia C++ introdujo un enfoque más robusto y expresivo para la generación de código: en lugar de depender de las macros del preprocesador — propensas a errores y difíciles de depurar — , el lenguaje apostó por mecanismos estáticos como los templates. Esta decisión, formalizada en el estándar C++98, marcó un hito importante en la historia del lenguaje. Originalmente concebidos por Bjarne Stroustrup a principios de los años 90, los templates surgieron como una extensión natural de la idea de reutilización de código sin sacrificar eficiencia. Esta elección estaba alineada con la filosofía de C++: ofrecer un control fino sobre el rendimiento y el uso eficiente de los recursos.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="c1">// Definición de la clase Persona</span>
<span class="k">struct</span> <span class="nc">Persona</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nombre</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">edad</span><span class="p">;</span>

    <span class="c1">// Sobrecarga del operador &gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">otra</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">edad</span> <span class="o">&gt;</span> <span class="n">otra</span><span class="p">.</span><span class="n">edad</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Plantilla max para comparar dos objetos de cualquier tipo</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">max</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Comparar enteros</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="mf">5.5</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Comparar flotantes</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Comparar caracteres</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="s">"Hola"</span><span class="p">,</span> <span class="s">"Mundo"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Comparar cadenas de caracteres</span>

    <span class="c1">// Crear objetos Persona</span>
    <span class="n">Persona</span> <span class="n">p1</span><span class="p">{</span><span class="s">"Ana"</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
    <span class="n">Persona</span> <span class="n">p2</span><span class="p">{</span><span class="s">"Luis"</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>

    <span class="c1">// Usar la plantilla max con objetos Persona</span>
    <span class="n">Persona</span> <span class="n">mayor</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"La persona mayor es: "</span> <span class="o">&lt;&lt;</span> <span class="n">mayor</span><span class="p">.</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" con "</span> <span class="o">&lt;&lt;</span> <span class="n">mayor</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;&lt;</span> <span class="s">" años."</span><span class="p">;</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Un ejemplo sobresaliente del poder de la metaprogramación en C++ es la Standard Template Library (STL). Diseñada hace más de dos décadas, esta biblioteca demostró que es posible construir algoritmos y estructuras de datos altamente reutilizables, seguros y eficientes sin sacrificar rendimiento. Su arquitectura, basada completamente en templates, permite que muchas decisiones se tomen en tiempo de compilación, lo que facilita optimizaciones que en otros lenguajes se delegan al tiempo de ejecución. Gracias a este enfoque, los programadores pueden trabajar con listas, vectores, mapas y muchos otros contenedores de forma abstracta, sin comprometer el control sobre el rendimiento.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="c1">// Clase personalizada</span>
<span class="k">struct</span> <span class="nc">Persona</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nombre</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">edad</span><span class="p">;</span>

    <span class="c1">// Sobrecarga del operador &gt; (requisito para usar con maximo&lt;T&gt;)</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">otra</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">edad</span> <span class="o">&gt;</span> <span class="n">otra</span><span class="p">.</span><span class="n">edad</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Para usar en búsquedas</span>
    <span class="kt">bool</span> <span class="n">esMayorDeEdad</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">edad</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Template genérico como ejemplo de metaprogramación</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">maximo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Función para imprimir un vector genérico (puede usarse con cualquier tipo imprimible)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">imprimirVector</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">titulo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">titulo</span> <span class="o">&lt;&lt;</span> <span class="s">":</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- "</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" ("</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;&lt;</span> <span class="s">" años)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Persona</span> <span class="n">p1</span><span class="p">{</span><span class="s">"Ana"</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
    <span class="n">Persona</span> <span class="n">p2</span><span class="p">{</span><span class="s">"Luis"</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>
    <span class="n">Persona</span> <span class="n">p3</span><span class="p">{</span><span class="s">"Carlos"</span><span class="p">,</span> <span class="mi">40</span><span class="p">};</span>
    <span class="n">Persona</span> <span class="n">p4</span><span class="p">{</span><span class="s">"Elena"</span><span class="p">,</span> <span class="mi">35</span><span class="p">};</span>

    <span class="c1">// Uso del template maximo</span>
    <span class="n">Persona</span> <span class="n">mayor</span> <span class="o">=</span> <span class="n">maximo</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Entre "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" y "</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">nombre</span>
              <span class="o">&lt;&lt;</span> <span class="s">", el mayor es: "</span> <span class="o">&lt;&lt;</span> <span class="n">mayor</span><span class="p">.</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" con "</span> <span class="o">&lt;&lt;</span> <span class="n">mayor</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;&lt;</span> <span class="s">" años.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// STL: vector y sort con lambda</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Persona</span><span class="o">&gt;</span> <span class="n">personas</span> <span class="o">=</span> <span class="p">{</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">personas</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">personas</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">edad</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="n">imprimirVector</span><span class="p">(</span><span class="n">personas</span><span class="p">,</span> <span class="s">"Personas ordenadas por edad"</span><span class="p">);</span>

    <span class="c1">// Uso de std::find_if para buscar al primer mayor de edad</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">personas</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">personas</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Persona</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">esMayorDeEdad</span><span class="p">();</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">personas</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Primera persona mayor de edad: "</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Uso de std::map con string -&gt; Persona</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Persona</span><span class="o">&gt;</span> <span class="n">directorio</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">persona</span> <span class="o">:</span> <span class="n">personas</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">directorio</span><span class="p">[</span><span class="n">persona</span><span class="p">.</span><span class="n">nombre</span><span class="p">]</span> <span class="o">=</span> <span class="n">persona</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Directorio (map de nombre -&gt; edad):</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">nombre</span><span class="p">,</span> <span class="n">persona</span><span class="p">]</span> <span class="o">:</span> <span class="n">directorio</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" tiene "</span> <span class="o">&lt;&lt;</span> <span class="n">persona</span><span class="p">.</span><span class="n">edad</span> <span class="o">&lt;&lt;</span> <span class="s">" años</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>La STL no solo consolidó el papel de la metaprogramación en el ecosistema de C++, sino que también mostró cómo podía usarse para diseñar software genérico, modular y de alto rendimiento.</p>

<p>Durante mucho tiempo, trabajar con metaprogramación en C++ fue una tarea ardua: los mensajes de error crípticos, la dificultad de depuración y la complejidad sintáctica desalentaban incluso a programadores experimentados. A pesar de la gran utilidad de los templates, las actualizaciones significativas fueron pausadas durante un largo periodo, desde el estándar de 1998 hasta la llegada de C++11 en 2011.</p>

<p>Sin embargo, el lenguaje comenzó a evolucionar de manera más progresiva, incorporando características como auto, decltype, constexpr y variadic templates, que facilitaban la escritura de código genérico más expresivo. Posteriormente, C++14 y C++17 siguieron refinando estas ideas, mientras que C++20 marcó un punto de inflexión con la inclusión de concepts, que aportaron una forma formal y clara de expresar los requisitos de los tipos en las plantillas.</p>

<p>La introducción de concepts en C++20 representó un paso crucial en esta evolución. Inspirados en gran medida por las ideas de Alexander Stepanov, cocreador de la STL, los concepts permiten especificar de forma clara y expresiva qué requisitos debe cumplir un tipo para ser utilizado en una plantilla. Esta abstracción permite escribir código genérico más legible y seguro, con validaciones en tiempo de compilación que antes requerían técnicas mucho más complejas o indirectas. Gracias a herramientas como concepts, la metaprogramación en C++ ha dejado de ser un arte oscuro para convertirse en una práctica más accesible, robusta y expresiva.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
</span>
<span class="c1">// Concepto que exige un método miembro `area()` que devuelva un número (real o entero)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">TieneArea</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">area</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Función que suma el área de todas las figuras que cumplen con el concepto TieneArea</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">TieneArea</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="kt">double</span> <span class="nf">area_total</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">figuras</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">figura</span> <span class="o">:</span> <span class="n">figuras</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">figura</span><span class="p">.</span><span class="n">area</span><span class="p">();</span>  <span class="c1">// Se garantiza que existe</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Clases que implementan el método `area()`</span>
<span class="k">struct</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">ancho</span><span class="p">,</span> <span class="n">alto</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">area</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ancho</span> <span class="o">*</span> <span class="n">alto</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Circulo</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">radio</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">area</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">3.14159</span> <span class="o">*</span> <span class="n">radio</span> <span class="o">*</span> <span class="n">radio</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Clase que NO implementa `area()` y no cumple el concepto</span>
<span class="k">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Rectangulo</span><span class="o">&gt;</span> <span class="n">rectangulos</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">},</span> <span class="p">{</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Circulo</span><span class="o">&gt;</span> <span class="n">circulos</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mf">1.0</span><span class="p">},</span> <span class="p">{</span><span class="mf">2.5</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Área total de rectángulos: "</span> <span class="o">&lt;&lt;</span> <span class="n">area_total</span><span class="p">(</span><span class="n">rectangulos</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Área total de círculos: "</span> <span class="o">&lt;&lt;</span> <span class="n">area_total</span><span class="p">(</span><span class="n">circulos</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// std::vector&lt;Punto&gt; puntos = { {1.0, 2.0}, {3.0, 4.0} };</span>
    <span class="c1">// area_total(puntos);  // Error de compilación: Punto no tiene `area()`</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Además, de cara a C++26, se contempla la incorporación de mecanismos de reflexión estática, una capacidad largamente esperada que permitiría inspeccionar y manipular tipos y estructuras del programa durante la compilación. Esta funcionalidad ampliaría aún más el poder de la metaprogramación en C++, facilitando tareas como la generación automática de código, la serialización de objetos o la validación estructural sin recurrir a macros o técnicas intrusivas.</p>

<p>La metaprogramación en C++ ha evolucionado de forma notable: desde los ingeniosos — aunque limitados — usos del preprocesador, hasta un presente donde los templates, concepts y la futura incorporación de reflexión estática conforman un ecosistema cada vez más potente, seguro y expresivo. Lejos de ser una técnica reservada a expertos, hoy se consolida como una herramienta estratégica para escribir código genérico, reutilizable y eficiente. Comprender esta evolución no solo permite valorar mejor el diseño del lenguaje, sino también adoptar una perspectiva más madura sobre cómo abstraemos y optimizamos nuestros programas. En última instancia, Metaprogramación en C++ es ampliar los límites de lo que podemos construir con precisión, elegancia y control.</p>

       <div style="border: 1px solid gray; border-radius: 4px; margin: 20px; padding: 5px;">
          Visita nuestro canal de YouTube para encontrar temas similares en video:<a href="https://youtube.com/thedojomx"> The Dojo MX en YouTube </a>
        </div>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Etiquetas: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#c" class="page__taxonomy-item" rel="tag">c++</a><span class="sep">, </span>
    
      <a href="/tags/#metaprogramaci%C3%B3n" class="page__taxonomy-item" rel="tag">metaprogramación</a>
    
    </span>
  </p>




        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Actualizado:</strong> <time datetime="2025-04-17T00:00:00-06:00">April 17, 2025</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Compartir</h4>
  

  <a href="https://twitter.com/intent/tweet?text=El+arte+gen%C3%A9rico%3A+una+historia+de+la+metaprogramaci%C3%B3n+en+C%2B%2B%20https%3A%2F%2Fblog.thedojo.mx%2F2025%2F04%2F17%2Fel-arte-generico-una-historia-de-la-metaprogramacion-en-C%2B%2B.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Compartir Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fblog.thedojo.mx%2F2025%2F04%2F17%2Fel-arte-generico-una-historia-de-la-metaprogramacion-en-C%2B%2B.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Compartir Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fblog.thedojo.mx%2F2025%2F04%2F17%2Fel-arte-generico-una-historia-de-la-metaprogramacion-en-C%2B%2B.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Compartir LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/2025/02/23/resena-del-libro-deep-learning-de-mit-essential-knowledge-series.html" class="pagination--pager" title="Reseña del libro ‘Deep Learning’ de MIT Press Essential Knowledge Series
">Anterior</a>
    
    
      <a href="/2025/05/10/bases-de-datos-para-llm-s.html" class="pagination--pager" title="Bases de datos para LLM’s
">Siguiente</a>
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">Comentar</h4>
      <section id="disqus_thread"></section>
    
</div>

    
  </article>

  
  
    <div class="page__related">
      <h2 class="page__related-title">Podrías ver también</h2>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1747718313/mariola-grobelska-EJBwRJZMOCQ-unsplash_rugsm8.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/2025/08/19/zig-un-lenguaje-que-quiere-reemplazar-al-poderoso-c.html" rel="permalink">Zig: un lenguaje que quiere reemplazar al poderoso C
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




6 minutos de lectura



| <i class="far fa-calendar" aria-hidden="true"></i> 19-08-2025
</p>
    
    <p class="archive__item-excerpt" itemprop="description">Zig es un lenguaje prometedor que quiere reemplazar a C y competir con Rust por ser el nuevo lenguaje de sistemas. Hablemos de sus promesas y características.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_440/v1739597131/ryan-klaus-Xa0BLOXVxrQ-unsplash_necdjp.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/2025/05/16/que-son-los-agentes-inteligentes.html" rel="permalink">¿Qué son los agentes inteligentes?
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




7 minutos de lectura



| <i class="far fa-calendar" aria-hidden="true"></i> 16-05-2025
</p>
    
    <p class="archive__item-excerpt" itemprop="description">La palabra ‘agente’ anda por todos lados desde la salida de los LLM’s. Hablemos de lo que son y cómo te pueden ayudar a desarrollar sistemas más complejos.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_440/v1740059354/ricardo-frantz-nEd9E9V8Qx0-unsplash_wnklhe.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/2025/05/15/debes-leer-thinking-in-systems.html" rel="permalink">Debes leer ‘Thinking in Systems’
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




10 minutos de lectura



| <i class="far fa-calendar" aria-hidden="true"></i> 15-05-2025
</p>
    
    <p class="archive__item-excerpt" itemprop="description">El pensamiento de sistemas es una de las habilidades más importantes para los desarrolladores de software. Hablemos de un libro que te ayuda a cultivarlo.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_400/v1742691554/chen-zy-ccr9dAWi0hw-unsplash_omykun.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/2025/05/10/bases-de-datos-para-llm-s.html" rel="permalink">Bases de datos para LLM’s
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




13 minutos de lectura



| <i class="far fa-calendar" aria-hidden="true"></i> 10-05-2025
</p>
    
    <p class="archive__item-excerpt" itemprop="description">Los LLM’s nos permiten crear softeware que no creíamos posible hasta hacer poco. Pero necesitan que les demos información de manera especial. ¿Qué tipo de ba...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap">
<form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Términos de búsqueda...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Términos de búsqueda...">
  </form>
  <div id="results" class="results"></div>
</div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        
<script>
    var sharect = new Sharect();
    sharect.config({
      twitter: true,
      twitterUsername: '@thedojomx',
      backgroundColor: '#4b0082',
      iconColor: '#fff'
    }).init();
</script>
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Seguir:</strong></li>
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">© 2025 The Dojo MX Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <script>
    var disqus_config = function () {
      this.page.url = "https://blog.thedojo.mx/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++.html";  /* Replace PAGE_URL with your page's canonical URL variable */
      this.page.identifier = "/2025/04/17/el-arte-generico-una-historia-de-la-metaprogramacion-en-C++"; /* Replace PAGE_IDENTIFIER with your page's unique identifier variable */
    };
    (function() { /* DON'T EDIT BELOW THIS LINE */
      var d = document, s = d.createElement('script');
      s.src = 'https://the-dojo-mx-blog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>


  





  </body>
</html>
