<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Complejidad on The Dojo MX Blog</title><link>https://blog.thedojo.mx/tags/complejidad/</link><description>Recent content in Complejidad on The Dojo MX Blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 15 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.thedojo.mx/tags/complejidad/index.xml" rel="self" type="application/rss+xml"/><item><title>Debes leer 'Thinking in Systems'</title><link>https://blog.thedojo.mx/2025/05/15/debes-leer-thinking-in-systems/</link><pubDate>Thu, 15 May 2025 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2025/05/15/debes-leer-thinking-in-systems/</guid><description>El libro &amp;ldquo;Thinking in Systems&amp;rdquo; de Donella Hager Meadows es un libro muy importante para cualquier desarrollador de software. ¿Por qué? Los desarrolladores nos dedicamos a hacer sistemas, y este es justo el tema principal del libro, escrito por una experta en sistemas complejos.
Veamos por qué puede ser una buena lectura para ti y por que te recomiendo leerlo lo antes posible.
A cerca de Thinking in Systems Thinking in systems es un libro un poco antiguo, publicado hace casi 17 años, en 2008, después del fallecimiento de su autora.</description></item><item><title>A Philosophy of Software Design: Ocultar información</title><link>https://blog.thedojo.mx/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/</guid><description>La idea básica es que cada módulo debería encapsular algunas piezas de conocimiento, que representen decisiones de diseño. - John Ousterhout
En el artículo anterior vimos por qué es bueno que los módulos sean profundos, es decir, oculten detalles de implementación y funcionalidades detrás de una interfaz lo más sencilla posible. En este y los siguientes artículos vamos a ver maneras prácticas de lograr esto, basado en ejemplos de &amp;ldquo;A Philosophy of Software Design&amp;rdquo;.</description></item><item><title>A Philosophy of Software Design: Los módulos deben ser profundos</title><link>https://blog.thedojo.mx/2020/03/02/a-philosophy-of-software-design-los-m%C3%B3dulos-deben-ser-profundos/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/03/02/a-philosophy-of-software-design-los-m%C3%B3dulos-deben-ser-profundos/</guid><description>Para reducir la complejidad de los programas es importante tener técnicas definidas. La primera que vamos a analizar es la organización y separación de código a alto nivel, es decir separación en módulos.
Por qué es importante la separación Antes de empezar a hablar de cómo deberíamos diseñar nuestros módulos hablemos de por qué es importante la separación.
La mejor forma de resolver un problema complejo es mediante la descomposición del problema en problemas más sencillos.</description></item><item><title>A Philosophy of Software Design: Tres formas de identificar la complejidad</title><link>https://blog.thedojo.mx/2020/02/26/a-philosophy-of-software-design-tres-formas-de-identificar-la-complejidad/</link><pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/02/26/a-philosophy-of-software-design-tres-formas-de-identificar-la-complejidad/</guid><description>&amp;ldquo;Controlar la complejidad es la esencia de la programación&amp;rdquo; - Brian W. Kernighan
Muchas mentes brillantes dedicadas al desarrollo de software han estado de acuerdo en que el principal problema al crear y mantener programas es el manejo de la complejidad.
Podemos decir que algo complejo es aquello que está compuesto por muchas piezas relacionadas entre ellas. Ousterhout lo define de manera práctica como todo aquello que hace que el software sea difícil de entender, escribir o mantener.</description></item><item><title>A Philosophy of Software Design: Desarrollo Táctico vs Estratégico</title><link>https://blog.thedojo.mx/2020/02/11/a-philosophy-of-software-design-desarrollo-t%C3%A1ctico-vs-estrat%C3%A9gico/</link><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/02/11/a-philosophy-of-software-design-desarrollo-t%C3%A1ctico-vs-estrat%C3%A9gico/</guid><description>Cuando desarrollas software tienes dos actitudes para escoger: desarrollas de forma rápida y sucia (desarrollo táctico) o de forma ordenada, planeada y pensando en el futuro. Cada uno de estos tipos de desarrollo o filosofías de desarrollo tiene ventajas y desventajas. Pero veamos a más detalle de qué trata cada uno.
Desarrollo táctico Está caracterizado por la alta velocidad inicial con la que empiezas a desarrollar y crear las funciones de tu programa.</description></item></channel></rss>