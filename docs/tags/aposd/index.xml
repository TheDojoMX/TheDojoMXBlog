<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aposd on The Dojo MX Blog</title><link>https://blog.thedojo.mx/tags/aposd/</link><description>Recent content in Aposd on The Dojo MX Blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Fri, 07 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.thedojo.mx/tags/aposd/index.xml" rel="self" type="application/rss+xml"/><item><title>Cuando separar el código</title><link>https://blog.thedojo.mx/2023/04/07/cuando-separar-el-c%C3%B3digo/</link><pubDate>Fri, 07 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2023/04/07/cuando-separar-el-c%C3%B3digo/</guid><description>Hay quienes afirman que mientras más pequeñas sean tus clases o funciones, mejor. Hasta llegan a poner un límite de la líneas que pueden ir en un método o función. Esto crea código súper fragmentado que llega a ser complejo por el simple hecho de tener muchos elementos individuales que luego se tienen que unir mediante más código. Además, trazar la causa de algo a través de un código similar es casi imposible o, por lo menos, te puede tomar mucho tiempo.</description></item><item><title>¿Deberías comentar tu código?</title><link>https://blog.thedojo.mx/2020/12/30/deber%C3%ADas-comentar-tu-c%C3%B3digo/</link><pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/12/30/deber%C3%ADas-comentar-tu-c%C3%B3digo/</guid><description>Cuando hablamos de los comentarios en el código, hay dos escuelas. La primera dice que debes usar los comentarios para clarificar lo que quisiste expresar con tu código, mientras que la segunda dice que deberías evitarlos al máximo y que comentar tu código es un mal necesario que sólo denota tu falta de habilidad para no hacer código lo suficientemente claro.
¿A cuál de los dos consejos deberías hacerle caso? En este artículo explicaremos por qué creemos que deberías ver los comentarios como una herramienta necesaria, valiosa y muy útil, y cómo usarlos para no caer en el extremo que ha llevado a algunas personas a tener una mala actitud hacia ellos.</description></item><item><title>A Philosophy of Software Design: Crea módulos de propósito general</title><link>https://blog.thedojo.mx/2020/04/02/a-philosophy-of-software-design-crea-m%C3%B3dulos-de-prop%C3%B3sito-general/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/04/02/a-philosophy-of-software-design-crea-m%C3%B3dulos-de-prop%C3%B3sito-general/</guid><description>Una burla común hacia los programadores es que todo lo queremos hacer demasiado general. Nos piden una funcionalidad y en ese momento empezamos a pensar en todos los casos en los que podría ser usado en el universo.
Hay muchos consejos en contra de escribir código que abarque muchos casos. En este artículo vamos a hablar de las ventajas y desventajas de módulos de propósito general, es decir, vamos a hablar en contra de la sabiduría popular.</description></item><item><title>A Philosophy of Software Design: Recomendaciones de diseño modular</title><link>https://blog.thedojo.mx/2020/03/18/a-philosophy-of-software-design-recomendaciones-de-dise%C3%B1o-modular/</link><pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/03/18/a-philosophy-of-software-design-recomendaciones-de-dise%C3%B1o-modular/</guid><description>En los artículos anteriores hemos estado hablando de cómo evitar la complejidad mediante ocultar información.
En este daremos algunas recomendaciones más y hablaremos de cómo no llevar este principio al extremo.
Hablemos primero de consejos que te ayudarán a mantener oculta la información que debe de estarlo.
Exponer lo menos posible estructuras de datos Un error común cuando creamos un módulo es exponer las estructuras de datos internas hacia otros módulos.</description></item><item><title>A Philosophy of Software Design: Descomposición Temporal</title><link>https://blog.thedojo.mx/2020/03/16/a-philosophy-of-software-design-descomposici%C3%B3n-temporal/</link><pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/03/16/a-philosophy-of-software-design-descomposici%C3%B3n-temporal/</guid><description>En el artículo pasado hablamos de una forma de evitar una fuga de información, que consiste en encapsular una decisión de diseño en un módulo.
Otra forma de dejar escapar información no relevante para los usuarios de una pieza de software es mediante obligarlos a usarla siempre de la misma forma, con el mismo orden de operaciones reglas de operación implícita. Esto se llama descomposición temporal. Hablemos más de ella.</description></item><item><title>A Philosophy of Software Design: Ocultar información</title><link>https://blog.thedojo.mx/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/</guid><description>La idea básica es que cada módulo debería encapsular algunas piezas de conocimiento, que representen decisiones de diseño. - John Ousterhout
En el artículo anterior vimos por qué es bueno que los módulos sean profundos, es decir, oculten detalles de implementación y funcionalidades detrás de una interfaz lo más sencilla posible. En este y los siguientes artículos vamos a ver maneras prácticas de lograr esto, basado en ejemplos de &amp;ldquo;A Philosophy of Software Design&amp;rdquo;.</description></item><item><title>A Philosophy of Software Design: Desarrollo Táctico vs Estratégico</title><link>https://blog.thedojo.mx/2020/02/11/a-philosophy-of-software-design-desarrollo-t%C3%A1ctico-vs-estrat%C3%A9gico/</link><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/02/11/a-philosophy-of-software-design-desarrollo-t%C3%A1ctico-vs-estrat%C3%A9gico/</guid><description>Cuando desarrollas software tienes dos actitudes para escoger: desarrollas de forma rápida y sucia (desarrollo táctico) o de forma ordenada, planeada y pensando en el futuro. Cada uno de estos tipos de desarrollo o filosofías de desarrollo tiene ventajas y desventajas. Pero veamos a más detalle de qué trata cada uno.
Desarrollo táctico Está caracterizado por la alta velocidad inicial con la que empiezas a desarrollar y crear las funciones de tu programa.</description></item></channel></rss>