<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Diseño-De-Software on The Dojo MX Blog</title>
    <link>http://localhost:1313/tags/dise%C3%B1o-de-software/</link>
    <description>Recent content in Diseño-De-Software on The Dojo MX Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <copyright>© 2026 </copyright>
    <lastBuildDate>Sat, 19 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/dise%C3%B1o-de-software/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Los diferentes grados de diseño de software</title>
      <link>http://localhost:1313/2024/10/19/los-diferentes-grados-de-dise%C3%B1o-de-software/</link>
      <pubDate>Sat, 19 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2024/10/19/los-diferentes-grados-de-dise%C3%B1o-de-software/</guid>
      <description>&lt;p&gt;Hay una confusión enorme sobre el diseño de software. Cuando se habla de arquitectura, se empieza
a hablar de patrones de diseño, infraestructura, y otras cosas con las que no nos conviene
meternos en ese nivel.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Cuando separar el código</title>
      <link>http://localhost:1313/2023/04/07/cuando-separar-el-c%C3%B3digo/</link>
      <pubDate>Fri, 07 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2023/04/07/cuando-separar-el-c%C3%B3digo/</guid>
      <description>&lt;p&gt;Hay quienes afirman que mientras más pequeñas sean tus clases o funciones, mejor. Hasta llegan a poner un límite de la líneas que pueden ir en un método o función. Esto crea código súper fragmentado que llega a ser complejo por el simple hecho de tener muchos elementos individuales que luego se tienen que unir mediante más código. Además, trazar la causa de algo a través de un código similar es casi imposible o, por lo menos, te puede tomar mucho tiempo.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>¿Qué es una API?</title>
      <link>http://localhost:1313/2023/03/18/qu%C3%A9-es-una-api/</link>
      <pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2023/03/18/qu%C3%A9-es-una-api/</guid>
      <description>&lt;p&gt;A veces limitamos el uso de la palabra &lt;strong&gt;API&lt;/strong&gt; a un programa que nos regresa información mediante una conexión web, generalmente en un formato que una máquina puede procesar. Pero muchas otras veces se usa de manera más amplia. En este artículo hablaremos de otras acepciones y qué tiene que ver con la buena programación.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Orígenes de la deuda técnica</title>
      <link>http://localhost:1313/2020/10/19/or%C3%ADgenes-de-la-deuda-t%C3%A9cnica/</link>
      <pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2020/10/19/or%C3%ADgenes-de-la-deuda-t%C3%A9cnica/</guid>
      <description>&lt;p&gt;Tuvimos una plática con &lt;a
  href=&#34;https://twitter.com/sagmmd&#34;
    target=&#34;_blank&#34;
  &gt;Sagrario Meneses&lt;/a&gt; sobre la &lt;strong&gt;deuda técnica&lt;/strong&gt; y cómo podemos atacarla. En este artículo te presentamos un pequeño resumen de lo que es y algunas sugerencias sobre su manejo.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>A Philosophy of Software Design: Ocultar información</title>
      <link>http://localhost:1313/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;La idea básica es que cada módulo debería encapsular algunas piezas de conocimiento, que representen decisiones de diseño. - &lt;strong&gt;John Ousterhout&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;En &lt;a
  href=&#34;https://blog.thedojo.mx/2020/03/02/a-philosophy-of-software-design-los-modulos-deben-ser-profundos.html&#34;
    target=&#34;_blank&#34;
  &gt;el artículo anterior&lt;/a&gt; vimos por qué es bueno que los módulos sean profundos, es decir, oculten detalles de implementación y funcionalidades detrás de una interfaz lo más sencilla posible. En este y los siguientes artículos vamos a ver maneras prácticas de lograr esto, basado en ejemplos de &lt;a
  href=&#34;https://amzn.to/2H92nwA&#34;
    target=&#34;_blank&#34;
  &gt;&amp;ldquo;A Philosophy of Software Design&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>A Philosophy of Software Design: Tres formas de identificar la complejidad</title>
      <link>http://localhost:1313/2020/02/26/a-philosophy-of-software-design-tres-formas-de-identificar-la-complejidad/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2020/02/26/a-philosophy-of-software-design-tres-formas-de-identificar-la-complejidad/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Controlar la complejidad es la esencia de la programación&amp;rdquo; - Brian W. Kernighan&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Muchas mentes brillantes dedicadas al desarrollo de software han estado de acuerdo en que el principal problema al crear y mantener programas es el manejo de la complejidad.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Principios de Diseño de Software</title>
      <link>http://localhost:1313/2019/03/19/principios-de-dise%C3%B1o-de-software/</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2019/03/19/principios-de-dise%C3%B1o-de-software/</guid>
      <description>&lt;p&gt;En este artículo hablaremos primero de la importancia de aprender &lt;strong&gt;principios&lt;/strong&gt;: qué son, qué ventajas tienen y cómo aplicarlos.&lt;/p&gt;
&lt;p&gt;Hallarás una explicación básica de cada principio y su importancia, pero cada principio tendrá un post extenso explicando sus aplicaciones, forma de implementarlo y ejemplos prácticos, un sólo artículo no es suficiente para explicarlos cuando se podría escribir un libro sobre cada principio.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Aplicando los grados de diseño de software: guía práctica</title>
      <link>http://localhost:1313/1/01/01/aplicando-los-grados-de-dise%C3%B1o-de-software-gu%C3%ADa-pr%C3%A1ctica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/1/01/01/aplicando-los-grados-de-dise%C3%B1o-de-software-gu%C3%ADa-pr%C3%A1ctica/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Este artículo es una continuación práctica del post &lt;a
  href=&#34;http://localhost:1313/2024/10/19/los-diferentes-grados-de-diseno-de-software.html&#34;&gt;“Los diferentes grados de diseño de software”&lt;/a&gt;. Aquí bajamos las ideas a artefactos, decisiones, ejemplos y checklists aplicables.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 class=&#34;relative group&#34;&gt;Introducción
    &lt;div id=&#34;introducción&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none&#34;&gt;
        &lt;a class=&#34;text-primary-300 dark:text-neutral-700 !no-underline&#34; href=&#34;#introducci%c3%b3n&#34; aria-label=&#34;Ancla&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;
    
&lt;/h2&gt;
&lt;p&gt;En el artículo pasado, presentamos una taxonomía de los grados de diseño de software,
entendiendo como &amp;ldquo;grado&amp;rdquo; qué tan lejos estamos de la implementación en código. En este
artículo presentamos una forma de practicar cada uno de esos niveles.&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
