<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dise√±o-De-Software on The Dojo MX Blog</title><link>https://blog.thedojo.mx/tags/dise%C3%B1o-de-software/</link><description>Recent content in Dise√±o-De-Software on The Dojo MX Blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sat, 19 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.thedojo.mx/tags/dise%C3%B1o-de-software/index.xml" rel="self" type="application/rss+xml"/><item><title>Los diferentes grados de dise√±o de software</title><link>https://blog.thedojo.mx/2024/10/19/los-diferentes-grados-de-dise%C3%B1o-de-software/</link><pubDate>Sat, 19 Oct 2024 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2024/10/19/los-diferentes-grados-de-dise%C3%B1o-de-software/</guid><description>Hay una confusi√≥n enorme sobre el dise√±o de software. Cuando se habla de arquitectura, se empieza a hablar de patrones de dise√±o, infraestructura, y otras cosas con las que no nos conviene meternos en ese nivel.
Es por eso que en este art√≠culo vamos a proponer una taxonom√≠a para los diferentes grados de dise√±o de software. Pero antes hablemos de por qu√© te conviene hacer una distinci√≥n clara.
Por qu√© te conviene distinguir los grados de dise√±o de software Lo primero que debemos entender es que hacer software implica dise√±ar software.</description></item><item><title>Los diferentes grados de dise√±o de software</title><link>https://blog.thedojo.mx/2024/10/19/los-diferentes-grados-de-dise%C3%B1o-de-software/</link><pubDate>Sat, 19 Oct 2024 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2024/10/19/los-diferentes-grados-de-dise%C3%B1o-de-software/</guid><description>Hay una confusi√≥n enorme sobre el dise√±o de software. Cuando se habla de arquitectura, se empieza a hablar de patrones de dise√±o, infraestructura, y otras cosas con las que no nos conviene meternos en ese nivel.
Es por eso que en este art√≠culo vamos a proponer una taxonom√≠a para los diferentes grados de dise√±o de software. Pero antes hablemos de por qu√© te conviene hacer una distinci√≥n clara.
Tambi√©n presentaremos una serie de recursos que puedes usar m√°s para aprender de cada uno de estos niveles de abstracci√≥n en el dise√±o de software.</description></item><item><title>Cuando separar el c√≥digo</title><link>https://blog.thedojo.mx/2023/04/07/cuando-separar-el-c%C3%B3digo/</link><pubDate>Fri, 07 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2023/04/07/cuando-separar-el-c%C3%B3digo/</guid><description>Hay quienes afirman que mientras m√°s peque√±as sean tus clases o funciones, mejor. Hasta llegan a poner un l√≠mite de la l√≠neas que pueden ir en un m√©todo o funci√≥n. Esto crea c√≥digo s√∫per fragmentado que llega a ser complejo por el simple hecho de tener muchos elementos individuales que luego se tienen que unir mediante m√°s c√≥digo. Adem√°s, trazar la causa de algo a trav√©s de un c√≥digo similar es casi imposible o, por lo menos, te puede tomar mucho tiempo.</description></item><item><title>¬øQu√© es una API?</title><link>https://blog.thedojo.mx/2023/03/18/qu%C3%A9-es-una-api/</link><pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2023/03/18/qu%C3%A9-es-una-api/</guid><description>A veces limitamos el uso de la palabra API a un programa que nos regresa informaci√≥n mediante una conexi√≥n web, generalmente en un formato que una m√°quina puede procesar. Pero muchas otras veces se usa de manera m√°s amplia. En este art√≠culo hablaremos de otras acepciones y qu√© tiene que ver con la buena programaci√≥n.
Application Programming Interface La realidad es que el inicialismo &amp;ldquo;API&amp;rdquo; es casi auto-explicativo: Interfaz de Programaci√≥n de Aplicaci√≥n.</description></item><item><title>Or√≠genes de la deuda t√©cnica</title><link>https://blog.thedojo.mx/2020/10/19/or%C3%ADgenes-de-la-deuda-t%C3%A9cnica/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/10/19/or%C3%ADgenes-de-la-deuda-t%C3%A9cnica/</guid><description>Tuvimos una pl√°tica con Sagrario Meneses sobre la deuda t√©cnica y c√≥mo podemos atacarla. En este art√≠culo te presentamos un peque√±o resumen de lo que es y algunas sugerencias sobre su manejo.
¬øQu√© es la deuda t√©cnica? La definici√≥n corta de deuda t√©cnica es: todo aquello que hace que el software sea m√°s dif√≠cil de producir y desarrollar.
La deuda t√©cnica es invisible para los miembros no directamente relacionados con el desarrollo del proyecto; para los que participan en ellos no siempre es f√°cil de ver.</description></item><item><title>A Philosophy of Software Design: Ocultar informaci√≥n</title><link>https://blog.thedojo.mx/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/03/07/a-philosophy-of-software-design-ocultar-informaci%C3%B3n/</guid><description>La idea b√°sica es que cada m√≥dulo deber√≠a encapsular algunas piezas de conocimiento, que representen decisiones de dise√±o. - John Ousterhout
En el art√≠culo anterior vimos por qu√© es bueno que los m√≥dulos sean profundos, es decir, oculten detalles de implementaci√≥n y funcionalidades detr√°s de una interfaz lo m√°s sencilla posible. En este y los siguientes art√≠culos vamos a ver maneras pr√°cticas de lograr esto, basado en ejemplos de &amp;ldquo;A Philosophy of Software Design&amp;rdquo;.</description></item><item><title>A Philosophy of Software Design: Tres formas de identificar la complejidad</title><link>https://blog.thedojo.mx/2020/02/26/a-philosophy-of-software-design-tres-formas-de-identificar-la-complejidad/</link><pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2020/02/26/a-philosophy-of-software-design-tres-formas-de-identificar-la-complejidad/</guid><description>&amp;ldquo;Controlar la complejidad es la esencia de la programaci√≥n&amp;rdquo; - Brian W. Kernighan
Muchas mentes brillantes dedicadas al desarrollo de software han estado de acuerdo en que el principal problema al crear y mantener programas es el manejo de la complejidad.
Podemos decir que algo complejo es aquello que est√° compuesto por muchas piezas relacionadas entre ellas. Ousterhout lo define de manera pr√°ctica como todo aquello que hace que el software sea dif√≠cil de entender, escribir o mantener.</description></item><item><title>Principios de Dise√±o de Software</title><link>https://blog.thedojo.mx/2019/03/19/principios-de-dise%C3%B1o-de-software/</link><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><guid>https://blog.thedojo.mx/2019/03/19/principios-de-dise%C3%B1o-de-software/</guid><description>En este art√≠culo hablaremos primero de la importancia de aprender principios: qu√© son, qu√© ventajas tienen y c√≥mo aplicarlos.
Hallar√°s una explicaci√≥n b√°sica de cada principio y su importancia, pero cada principio tendr√° un post extenso explicando sus aplicaciones, forma de implementarlo y ejemplos pr√°cticos, un s√≥lo art√≠culo no es suficiente para explicarlos cuando se podr√≠a escribir un libro sobre cada principio.
Ponle atenci√≥n a los primeros dos üòâ. Pero antes hablemos de lo que es un principio en general.</description></item></channel></rss>