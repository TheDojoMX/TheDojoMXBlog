<!doctype html><html lang=es dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>A Philosophy of Software Design: Los módulos deben ser profundos | The Dojo MX Blog</title>
<link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><meta property="og:title" content="A Philosophy of Software Design: Los módulos deben ser profundos"><meta property="og:description" content="Veamos algunos lineamientos para el diseño de funciones/clases/módulos que ayudarán a reducir la complejidad de tus sistemas de software."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thedojo.mx/2020/03/02/a-philosophy-of-software-design-los-m%C3%B3dulos-deben-ser-profundos/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-02T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A Philosophy of Software Design: Los módulos deben ser profundos"><meta name=twitter:description content="Veamos algunos lineamientos para el diseño de funciones/clases/módulos que ayudarán a reducir la complejidad de tus sistemas de software."><link rel=stylesheet href=/css/extended.min.771dff75f9f3290205d2bfcbeda2ed15a5984c0414d431dfec3423ae5e37bb90.css integrity="sha256-dx3/dfnzKQIF0r/L7aLtFaWYTAQU1DHf7DQjrl43u5A=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js integrity="sha256-zIrplS2/tzGv+vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://blog.thedojo.mx/ style=color:inherit>The Dojo MX Blog</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>A Philosophy of Software Design: Los módulos deben ser profundos</h1><time class=dim datetime=2020-03-02T00:00:00+00:00>March 2, 2020</time><div class=term-container><div class=tag><a href=https://blog.thedojo.mx/tags/m%C3%B3dulo/>#módulo</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/posd/>#PoSD</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/ousterhout/>#ousterhout</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/complejidad/>#complejidad</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/funci%C3%B3n/>#función</a></div></ol></div><section class=page-section><p>Para reducir la complejidad de los programas es importante tener técnicas definidas. La primera que vamos a analizar es la organización y separación de código a alto nivel, es decir separación en módulos.</p><h2 id=por-qué-es-importante-la-separación>Por qué es importante la separación</h2><p>Antes de empezar a hablar de cómo deberíamos diseñar nuestros módulos hablemos de por qué es importante la separación.</p><p>La mejor forma de resolver un problema complejo es mediante <em>la descomposición</em> del problema en problemas más sencillos. Estos problemas se resuelven individualmente, idealmente de de manera independiente en un módulo por separado para cada uno. De esta manera podemos hacer software más mantenible y fácil de entender. Incluso se puede dividir mejor el trabajo.</p><p>La división del problema permite además <strong>ocultar</strong> información no relevante para el problema en cuestión.</p><p>Esta división del trabajo es diferente dependiendo del paradigma del lenguaje de programación que usemos, así que veamos a qué nos referimos con un <strong>módulo</strong>.</p><h2 id=qué-es-un-módulo>¿Qué es un módulo?</h2><p>Una definición fácil y amplia de &ldquo;módulo&rdquo; dada por <a href=https://amzn.to/2H92nwA>&ldquo;A Philosophy of Software Design&rdquo;</a> es: <em>todo aquello que agrupe código, proveyendo separación de funcionalidad</em>, es decir que agrupe comportamiento en detrás de una <em>interfaz</em>.</p><p>Un módulo puede ser una función, una clase, un paquete o cosas similares dependiendo del lenguaje de programación. Un módulo incluso puede ser una API HTTP u otro programa.</p><p>Como resumen: <strong>un módulo permite hacer <em>algo</em> mediante una interfaz.</strong></p><p>Ahora bien, ¿qué es la interfaz de un módulo?</p><h2 id=interfaces>Interfaces</h2><p>Ya hemos hablado sobre <a href="https://www.youtube.com/watch?v=n8MxyHG0j3Q&amp;t">lo que es una interfaz</a>, pero para resumir: es el punto en donde un sistema, en este caso específico, un módulo, se encuentra con otro (otro módulo o código que lo usa).</p><p>Un módulo tiene una interfaz que permite a otras partes del sistema usarlo. Usaremos el caso más sencillo, una función. La interfaz de una función es su firma: su nombre, los parámetros que recibe y lo que devuelve.</p><p>Veamos un ejemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>archivo <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;my_file.md&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#75715e># Devuelve un apuntador a un archivo abierto</span>
</span></span></code></pre></div><p>La interfaz de la función es su nombre <code>open</code> (nos permite identificarla y comunica información sobre lo que hace), el nombre del archivo como primer parámetro y el modo de operación en el segundo.</p><p>Dependiendo de la forma de agrupar la interfaz de los módulos varía, pero recuerda esto: <strong>la interfaz es la parte visible del módulo hacia otros módulos</strong>.</p><h2 id=diseño-de-módulos>Diseño de módulos</h2><p>Aquí entramos en lo importante: los módulos deberían ser lo más profundos posible.</p><p>¿A qué nos referimos con un módulo profundo? Puedes imaginarte un módulo como un rectángulo en el que su interfaz es el largo de la base y su funcionalidad es la altura. Un módulo profundo es aquel que tiene una altura elevada comparada con el largo de la base.</p><p>Observa la siguiente imagen:</p><p><img src=https://res.cloudinary.com/hectorip/image/upload/c_scale,w_500/v1630554161/Ilustracio%CC%81n_sin_ti%CC%81tulo_zchwj3.png alt="Módulos profundos vs superficiales"></p><p>Un módulo profundo tiene una <strong>interfaz sencilla</strong> o fácil de usar para la mayoría de los casos de uso y provee de mucha funcionalidad, hace mucho por ti.</p><p>Un módulo superficial tiene una interfaz compleja o difícil de usar y provee poca funcionalidad.</p><p>Esto no es absoluto: la relación entre la complejidad de la interfaz es relativa a la funcionalidad que provee, por ejemplo, si un módulo hace muchas cosas por ti, puede que requiera muchos datos. La relación interfaz/funcionalidad debe ser razonable para considerar que el módulo es profundo.</p><p>Abrir archivos en la mayoría de los lenguajes es un ejemplo de una función profunda: con una interfaz muy pequeña (el nombre y el modo), la función se encarga de todos los detalles de implementación de apertura y creación del archivo. No te debes de preocupar por cosas como el sistema de archivos, el guardado físico en el disco, por verificar si hay memoria, etc.</p><p>En el caso contrario, los <em>getters</em> y <em>setters</em> que se acostumbra usar en algunos lenguajes de programación (Java) son ejemplo de funciones poco profundas, generalmente no hacen algo más que devolver el valor de la propiedad.</p><p>Ejemplo: Piensa en un aparato electrónico. En una televisión, sus control remoto te permiten acceder a las funcionalidades de encender el panel de iluminación, captar la señal del canal, decodificarlo y saltar entre diferentes canales, todo sin preocuparte tú por los detalles. Sólo la usas y ya. Mientras más detalles de implementación oculte es más fácil de usar.</p><h2 id=ventajas-de-los-módulos-profundos>Ventajas de los módulos profundos</h2><p>Encontrar un equilibrio entre la cantidad de código que metes en un módulo y la interfaz que expone tiene varias ventajas:</p><ul><li>El código se puede re-usar en otras partes del sistema</li><li>Evitas la acumulación de interfaces, es decir, tener demasiadas interfaces (funciones, clases o módulos) que tienes que aprender a usar y que hacen poco por ti</li><li>La expansión de cambios (tener que tocar muchos lados del sistema para hacer un cambio relativamente pequeño)</li></ul><p>Finalmente, recuerda que una de las funciones que proveen los módulos es <em>ocultar</em> la complejidad. ¿Cuántas veces has visto lo que hacen las funciones prefabricadas de tu lenguaje de programación? Es probable que ninguna. Los módulos profundos te permiten ocultar mayor cantidad de información, hace más fácil trabajar con ellos y simplifica el sistema en general.</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025 Héctor Patricio</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>842 words</span>
<span>5 - 6 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#por-qué-es-importante-la-separación>Por qué es importante la separación</a></li><li><a href=#qué-es-un-módulo>¿Qué es un módulo?</a></li><li><a href=#interfaces>Interfaces</a></li><li><a href=#diseño-de-módulos>Diseño de módulos</a></li><li><a href=#ventajas-de-los-módulos-profundos>Ventajas de los módulos profundos</a></li></ul></nav><h3>Related</h3><ul><li><a href=/2020/02/26/a-philosophy-of-software-design-tres-formas-de-identificar-la-complejidad/>A Philosophy of Software Design: Tres formas de identificar la complejidad</a></li><li><a href=/2020/02/11/a-philosophy-of-software-design-desarrollo-t%C3%A1ctico-vs-estrat%C3%A9gico/>A Philosophy of Software Design: Desarrollo Táctico vs Estratégico</a></li></ul></aside></div></div></body></html>