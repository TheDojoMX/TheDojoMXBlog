<!doctype html><html lang=es dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>A Philosophy of Software Design: Organiza bien los sistemas en capas | The Dojo MX Blog</title>
<link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><meta property="og:title" content="A Philosophy of Software Design: Organiza bien los sistemas en capas"><meta property="og:description" content="Resuelve problemas de organización de código mediante un sistema en capas."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thedojo.mx/2020/09/01/a-philosophy-of-software-design-organiza-bien-los-sistemas-en-capas/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A Philosophy of Software Design: Organiza bien los sistemas en capas"><meta name=twitter:description content="Resuelve problemas de organización de código mediante un sistema en capas."><link rel=stylesheet href=/css/extended.min.771dff75f9f3290205d2bfcbeda2ed15a5984c0414d431dfec3423ae5e37bb90.css integrity="sha256-dx3/dfnzKQIF0r/L7aLtFaWYTAQU1DHf7DQjrl43u5A=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js integrity="sha256-zIrplS2/tzGv+vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://blog.thedojo.mx/ style=color:inherit>The Dojo MX Blog</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>A Philosophy of Software Design: Organiza bien los sistemas en capas</h1><time class=dim datetime=2020-09-01T00:00:00+00:00>September 1, 2020</time><div class=term-container><div class=tag><a href=https://blog.thedojo.mx/tags/comments/>#comments:</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/true/>#true</a></div></ol></div><section class=page-section><p>Hemos escuchado muchísimo acerca de los sistemas en capas como <em>Modelo-Vista-Controlador</em>, Modelo-Vista-Template, Modelo-Vista-*, <em>MV-lo-que-sea</em> etc. y eso es porque la mayoría de los sistemas actuales se organiza así: <strong>en capas</strong>. Además, nuestros módulos se dividen naturalmente en capas con diferentes funciones (como código que usa a otro).</p><p>Hablemos de por qué es efectiva esta forma de organización (o patrón de arquitectura)
de código, de sus características y cómo podemos aprovecharla para sacar el máximo provecho.</p><h2 id=características-de-los-sistemas-en-capas>Características de los sistemas en capas</h2><p>Sabemos que la mejor forma de organización de un proyecto es <strong>descomponerlo</strong> en partes independientes que <strong>oculten</strong> información de otras.</p><p>La comunicación entre las diferentes partes se da por medio de una <strong>interfaz</strong>. Esta interfaz, es la <strong>API</strong> del componente, ya que será usada de manera automática por otra parte del programa.</p><p>En un sistema en capas el conjunto de elementos pertenecientes a una capa sólo se puede comunicar con la capa superior y con la capa inferior.</p><p>Si un sistema tiene 10 capas, cada componente puede comunicarse máximo con 2 capas.
En los sistemas más comunes, como el de 3 capas (MVC, MVT, MV*), sólamente la capa intermedia (el controlador, por ejemplo) puede comunicarse con dos capas, mientras que las otras sólo se comunican con la intermedia.</p><p><a href=https://amzn.to/2GdeHi5>John Ousterhout</a> usa la división en capas para explicar cómo se organiza el software con respecto al usuario final: la capa de &ldquo;hasta arriba&rdquo; es la que interactúa directamente con el usuario y la de &ldquo;hasta abajo&rdquo; es la más alejada del usuario, generalmente el núcleo de tu sistema.</p><p>Hablemos ahora de las mejores prácticas según <a href=https://amzn.to/2GdeHi5>A Philosphy of Software Design</a>.</p><h2 id=diferente-capa-diferente-abstracción>Diferente capa, diferente abstracción</h2><p>El concepto que debes tener más claro para descomponer tu software en capas es que cada capa debe tener sus propias abstracciones. Ousterhout da el ejemplo de un sistema de archivos:</p><ol><li>La capa que interactúa con el mundo exterior o la más alta, tiene la abstracción de un archivo</li><li>La siguiente capa tiene la abstracción de bloques de memoria y caché</li><li>La siguiente capa maneja directamente los bloques en el disco</li></ol><p>Esta abstracción es efectiva porque cada capa trabaja con abstracciones diferentes y no repiten ninguna entre ellas.</p><p>Esta es la idea básica que debes checar en tus diseños, si notas que una abstracción no cambia de una capa a otra, algo está saliendo mal. ¿Cómo puedes identificarlas?</p><h3 id=funciones-de-paso>Funciones de paso</h3><p>Estos son funciones que no hacen nada mas que mandar llamar una función de la siguiente capa, normalmente para cumplir con la limitante de comunicación entre capas.</p><p>Esto indica que no hay una división clara de responsabilidad entre clases o módulos. Para resolver este problema tienes que asegurarte de que la interfaz y la funcionalidad de este punto de tu sistema estén en el mismo módulo.</p><p>Evitar este tipo de métodos te evitará complicar la interfaz sin añadir ninguna funcionalidad.</p><h3 id=variables-pasadas>Variables pasadas</h3><p>Similar al caso anterior, si tienes una variable que recibes en la llamada de tu módulo y no haces nada con ella mas que pasarla a una capa inferior, estás mezclando las abstracciones entre capas.</p><p>A veces son necesarias, pero el manejarlas crea complejidad. Dependiendo del paradigma y el lenguaje de programación deberías buscar una solución adecuada.</p><p>Por ejemplo, en lenguajes orientados a objetos podrías guardar todos lo valores a los que necesitas constante acceso desde diferentes lugares un una variable de &ldquo;contexto&rdquo; y que generalmente está almacenada en un lugar en el que todas tus funciones puedan acceder. Algunos frameworks usan su variable de <code>settings</code> para poner información necesaria ahí.</p><p>Los siguientes dos consejos tratan más los diferentes niveles de código que capas del sistema.</p><h3 id=evita-lo-más-que-puedas-los-decoradores>Evita lo más que puedas los decoradores</h3><p>Ousterhout habla en contra del patrón decorador. Este patrón consiste en envolver clases, objetos o funciones con otros, con el fin de extender la funcionalidad. Los decoradores intentan mantener una interfaz muy similar o exactamente igual al elemento original.</p><p>Un ejemplo es la clase de Java <code>BufferedInputStream</code> es un decorador de <code>InputStream</code>, añadiéndole el buffering.</p><p>Los decoradores pueden crear un montón de funciones y variables de pasada y agregar un montón de código de soporte sin de verdad agregar tanta funcionalidad como código.</p><p><strong>APoSD</strong> (el libro) sugiere crear entidades separadas cuando sea posible y evitar el sobreuso de este patrón, a menos que de verdad tenga sentido, por ejemplo: cuando tienes un módulo muy profundo que con un decorador vas a poder reutilizar todo con muy poco código de soporte.</p><h3 id=abstracciones-diferentes-entre-la-interfaz-y-la-implementación>Abstracciones diferentes entre la interfaz y la implementación</h3><p>Tu código debería de exponer en su interfaz la abstracción más conveniente para los usuarios de tu módulo, sin importar las abstracciones más convenientes para manejar los datos internamente.</p><p>Por este principio, es muy normal que las abstracciones de la interfaz no sean las mismas interfaces que tu implementación usa.</p><p>Un ejemplo: imagina que estás escribiendo un componente que te permite editar texto. <strong>¿Cuál es la unidad básica con la que el usuario de tu módulo interactuará?</strong></p><p>Puede ser un carácter, una línea, un párrafo. Ya que tu la visualización del texto es en líneas, lo más conveniente para la implementación es una abstracción que represente una línea de texto.</p><p>Pero para el usuario de la clase que maneja texto lo más conveniente es una interfaz que use carácteres porque es más fácil de usar, se quita la responsabilidad de manejar las líneas.</p><p>Entonces tu clase queda así: internamente representa el texto como un conjunto de líneas, pero las interfaces lo usan como si fuera un conjunto de caractéres en los que puedes insertar y borrar sin preocuparte por la organización en líneas.</p><h2 id=conclusión>Conclusión</h2><p>La separación en capas permitirá que tu código esté mejor organizado y que sea más fácil de entender. Tener cuidado con la forma en que las capas se organizan, cómo se dividen responsabilidades y las interfaces que cada capa expone hará mucho más mantenible y entendible tu base de código.</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025 Héctor Patricio</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>982 words</span>
<span>5 - 7 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#características-de-los-sistemas-en-capas>Características de los sistemas en capas</a></li><li><a href=#diferente-capa-diferente-abstracción>Diferente capa, diferente abstracción</a><ul><li><a href=#funciones-de-paso>Funciones de paso</a></li><li><a href=#variables-pasadas>Variables pasadas</a></li><li><a href=#evita-lo-más-que-puedas-los-decoradores>Evita lo más que puedas los decoradores</a></li><li><a href=#abstracciones-diferentes-entre-la-interfaz-y-la-implementación>Abstracciones diferentes entre la interfaz y la implementación</a></li></ul></li><li><a href=#conclusión>Conclusión</a></li></ul></nav><h3>Related</h3><ul><li><a href=/2019/03/03/la-forma-f%C3%A1cil-de-colaborar-en-the-dojo-mx-blog/>La forma fácil de colaborar en The Dojo MX Blog</a></li></ul></aside></div></div></body></html>