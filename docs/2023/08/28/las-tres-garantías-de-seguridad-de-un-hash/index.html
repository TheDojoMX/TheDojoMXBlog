<!doctype html><html lang=es dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Las tres garantías de seguridad de un hash | The Dojo MX Blog</title>
<link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><meta property="og:title" content="Las tres garantías de seguridad de un hash"><meta property="og:description" content="Veamos más profundamente las garantías de seguridad que debe cumplir un hash para ser considerado seguro. Por fin entenderemos lo que es una colisión y qué significa para nosotros."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thedojo.mx/2023/08/28/las-tres-garant%C3%ADas-de-seguridad-de-un-hash/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-28T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-28T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Las tres garantías de seguridad de un hash"><meta name=twitter:description content="Veamos más profundamente las garantías de seguridad que debe cumplir un hash para ser considerado seguro. Por fin entenderemos lo que es una colisión y qué significa para nosotros."><link rel=stylesheet href=/css/extended.min.771dff75f9f3290205d2bfcbeda2ed15a5984c0414d431dfec3423ae5e37bb90.css integrity="sha256-dx3/dfnzKQIF0r/L7aLtFaWYTAQU1DHf7DQjrl43u5A=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js integrity="sha256-zIrplS2/tzGv+vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://blog.thedojo.mx/ style=color:inherit>The Dojo MX Blog</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Las tres garantías de seguridad de un hash</h1><time class=dim datetime=2023-08-28T00:00:00+00:00>August 28, 2023</time><div class=term-container><div class=tag><a href=https://blog.thedojo.mx/tags/hash/>#hash</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/criptograf%C3%ADa/>#criptografía</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/md5/>#md5</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/sha-256/>#sha-256</a></div></ol></div><section class=page-section><p>En este artículo profundizaremos sobre las garantías de seguridad mínimas que una función hash debe cumplir para ser criptográficamente segura. En un artículo anterior: <a href=/2021/12/02/algoritmos-criptograficos-que-es-un-hash.html>¿Qué es un hash?</a> ya hablamos más detalladamente de la definición y de los algoritmos que puedes usar aún hoy de manera segura.</p><p>Empecemos por una pequeña definición de lo que es una función hash en la criptografía.</p><h2 id=qué-es-un-hash>¿Qué es un hash?</h2><p>Un hash es una función que te devuelve un valor de tamaño fijo independientemente del tamaño de la entrada, esto implica una compresión de datos. Las funciones hash que son usadas en criptografía, tienen la característica de entregar valores completamente <em>impredecibles</em>, tanto para un humano como para una computadora. Es decir que no hay manera de saber qué valor va a entregar una función hash para un valor dado si no le has pasado ese valor antes.</p><p>Lo anterior no quiere decir que las funciones hash devuelvan algo diferente cada vez que las ejecutas, sino que para un valor dado, siempre devuelven el mismo resultado, y aquí es donde radica su utilidad.</p><p>Un hash perfecto se comportaría como un generador de valores aleatorios, pero debido a lo que hemos dicho anteriormente, deben ser <strong>deterministas</strong> al mismo tiempo que <strong>impredecibles</strong>.</p><p>Para medir la seguridad de una función hash, se usan tres pruebas, que se conocen como las garantía de seguridad de un hash.</p><p>Estas garantías son:</p><ol><li>Resistencia a la primera preimagen</li><li>Resistencia a la segunda preimagen</li><li>Resistencia a la colisión</li></ol><p>Cada una de estas garantías se refiere a un tipo de ataque que se puede hacer a una función hash. Vamos a explicarlas pero antes aclaremos algunos términos.</p><h2 id=imagen-y-preimagen>Imagen y preimagen</h2><p>En matemáticas, una función es una relación entre dos conjuntos de valores, uno de entrada y uno de salida. En la mayoría la de las funciones matemáticas comunes, cada valor de entrada tiene un único valor de salida.</p><p>Tomemos como ejemplo: $$f(x) = x + 1$$, esta función toma un valor $$x$$ y le suma $$1$$, por lo que cada valor de $$x$$ tiene un único valor de salida, porque sabemos que un número cualquiera tiene solamente un sucesor.</p><p>Pero no todas las funciones se comportan así, por ejemplo: $$f(x) = x^2$$. En esta función el valor 4 puede ser generado por dos valores de entrada diferentes: $$2$$ y $$-2$$.</p><p>Cuando vemos una función así no es común que nos definan el conjunto de entrada, así que asumimos que el conjunto de entrada o <strong>dominio</strong> es el conjunto de los números reales, y el conjunto de salida o <strong>codominio</strong> es el conjunto de los números reales.</p><p>Pensemos en el dominio y codominio como conjuntos amplios en los que los valores de entrada y salida <em>podrían estar</em>. La <strong>imagen</strong> de una función es el conjunto de valores que <em>están</em> en el codominio, es decir, los valores que la función <em>puede</em> devuelve. La <strong>preimagen</strong> es el conjunto de valores que <em>pueden</em> ser entrada de la función.</p><p>En términos prácticos para nosotros los programadores, la imagen es casi equivalente al codominio, y la preimagen es el dominio.</p><p>Esta imagen sacada de Wikipedia lo ilustra un poco mejor:</p><p><img src=https://res.cloudinary.com/hectorip/image/upload/c_scale,w_600/v1693144037/Codomain2_kzda4n.svg alt="Imagen vs Codomino">{: .align-center}</p><p>La imagen es el área amarilla, mientras que Y es el codominio, y X es el dominio. Lo último que nos hace falta saber es que aunque imagen y preimagen son los conjuntos de entradas y salidas del algoritmo, también nos podemos referir así a un valor individual de este conjunto.</p><p>Apliquemos los aprendido al ejemplo de la función $$f(x) = x^2$$. El dominio es el conjunto de los números reales, y el codominio también es el conjunto de los números reales. La imagen es el conjunto de los <strong>números reales positivos que tengan una raíz cuadrada</strong>, y la preimagen es el conjunto de los números reales. Un ejemplo concreto: para el valor <code>4</code> considerado como resultado de la función o <strong>imagen</strong>, tendría <em>dos</em> preimágenes: $$2$$ y $$-2$$.</p><p>Ahora sí, hablemos de la primera garantía de seguridad de un hash.</p><h2 id=resistencia-a-la-primera-preimagen>Resistencia a la primera preimagen</h2><p>Aquí debes poner atención a los valores <em>que se dan</em> para hacer la prueba de seguridad. Presta atención a cuando se dice &ldquo;dado un valor&rdquo;, estos son la valores que suponemos que ya se conocen.</p><p>En la primera garantía es: <strong>Dada</strong> una <em>imagen</em> es computacionalmente inviable encontrar una <em>preimagen</em> que la genere.</p><p>En palabras de programadores: Dado un hash, es computacionalmente inviable encontrar un valor que al ser pasado a la función hash, genere ese hash.</p><p>¿Por qué decimos <strong>un</strong> valor que genere ese hash y no <strong>el</strong> valor que genere ese hash? Porque para un valor de salida, puede haber más de un valor de entrada que lo genere. Especialmente para los hashes, su conjunto de valores posibles es infinito: todas las combinaciones de bits posibles de cualquier tamaño.</p><p>¿Cuál es el tamaño del conjunto de posibles salida? Eso depende del hash usado y su número de bits. Por ejemplo, el SHA-256 genera hashes de 256 bits, por lo que su conjunto de posibles valores es $$2^{256}$$, que es un número muy grande, pero no infinito, por lo que es posible que dos valores generen el mismo hash. Cada uno de esos valores sería <em>una preimagen</em> de un hash dado.</p><p>Entonces ya tenemos todo el escenario: nos han dado un hash y tenemos que encontrar uno de los infinitos valores que pueden producir ese hash, una preimagen.</p><p>Pues bien, para un hash criptográficamente seguro esta operación debe de ser imposible de realizar de manera más eficiente que usando fuerza bruta, es decir, probando todos los valores posibles hasta encontrar uno que genere el hash dado.</p><p>Para que un hash sea considerado seguro, hallar una preimagen por fuerza bruta debería tomar $$2^{n}$$ operaciones, donde $$n$$ es el número de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, toma $$2^{256}$$ operaciones, que es un número muy grande, computacionalmente inviable.</p><p>Por ejemplo, imagina que puedes hacer 1 millón de operaciones por segundo, aproximadamente $$2^{19}$$. Encontrar una primera preimagen para el SHA-256 te tomaría $$2^{256} / 2^{19}$$, es decir $$2^{247}$$ segundos, mientras que lo que se calcula que ha durado el universo son $$2^{38}$$ segundos.</p><p>Pongamos un ejemplo en Python. Supongamos que la función <code>hash</code> es un hash seguro, y que la función <code>mensaje_aleatorio</code> devuelve un mensaje diferente cada vez. Pon atención en lo que recibe la función <code>primera_preimagen</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>primera_preimagen</span>(h):
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> mensaje_aleatorio()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> hash(m) <span style=color:#f92672>!=</span> h:
</span></span><span style=display:flex><span>        m <span style=color:#f92672>=</span> mensaje_aleatorio()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> m
</span></span></code></pre></div><p>Este debería ser el mejor ataque que se pueda hacer sobre un hash seguro.</p><h2 id=resistencia-a-la-segunda-preimagen>Resistencia a la segunda preimagen</h2><p>Esta garantía de seguridad es muy parecida a la primera, pero lo que se recibe aquí es una <em>preimagen</em> y se debe encontrar otra preimagen que genere el mismo hash.</p><p>La garantía de seguridad debería ser la misma: encontrar una segunda preimagen debería ser computacionalmente inviable, es decir, que tomaría $$2^{n}$$ operaciones, donde $$n$$ es el número de bits del hash.</p><p>Pongamos un ejemplo en Python. Observa que usamos la función <code>primera_preimagen</code> que definimos antes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>segunda_preimagen</span>(m):
</span></span><span style=display:flex><span>    h <span style=color:#f92672>=</span> hash(m)
</span></span><span style=display:flex><span>    m2 <span style=color:#f92672>=</span> primera_preimagen(h)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> m2
</span></span></code></pre></div><p>Este ataque no implica más que hashear el mensaje y encontrar una primera preimagen de ese hash. Si el hash es resistente a la primera preimagen, entonces también lo será a la segunda.</p><p>Parece que esta garantía no tiene mucho sentido, pero vayamos a la tercera y la más conocida.</p><h2 id=resistencia-a-colisiones>Resistencia a colisiones</h2><p>Una colisión es cuando dos valores diferentes generan el mismo hash. Ya mencionamos que, al tener un conjunto infinito de valores de entrada y tener un conjunto muy grande (<em>pero limitado</em>) de valores de salida, es inevitable que suceda esto, de hecho, en este caso, un conjunto infinito de valores de entrada generan el mismo hash.</p><p>Pero hagamos un caso concreto. Imagina que tu hash recibirá cadenas de bits de 512 bits, y generará un hash de 256 bits. Esto significa que el conjunto de posibles valores de entrada es $$2^{512}$$ y el de posibles valores de salida es $$2^{256}$$. A cada valor de salida le corresponden $$2^{512}/2^{256} = 2^{512-256}$$ valores de entrada, es decir, que para cada valor de salida hay $$2^{256}$$ valores de entrada que generan el mismo hash.</p><p>Bueno, pues la tercera garantía de seguridad indica que <strong>debe ser computacionalmente inviable encontrar una colisión</strong>. En este caso no se nos da nada, ni una imagen (hash), ni una preimagen (valor de entrada). Se puede escoger cualquier valor de entrada para encontrar una colisión.</p><p>Aquí entra la segunda garantía de seguridad, si la función hash es resistente a la segunda preimagen, es resistente a colisiones. En Python, el mejor algoritmo para encontrar una colisión debería ser el siguiente para un hash seguro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encontrar_colision</span>():
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> mensaje_aleatorio()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> encontrar_segunda_preimagen(m)
</span></span></code></pre></div><p>La garantía de seguridad que debe de cumplir un hash seguro es que encontrar una colisión debería tomar $$2^{n/2}$$ operaciones, donde $$n$$ es el número de bits del hash. Por ejemplo, para el SHA-256, que tiene 256 bits, tomaría $$2^{128}$$ operaciones, que sigue siendo un número muy grande, computacionalmente inviable.</p><p>¿Por qué $$2^{n/2}$$? Porque es más fácil encontrar <em>un par</em> de valores que generen el mismo hash sin tener restricciones, que encontrar <em>un valor</em> que genere un hash dado.</p><p>Si haces $$N$$ hashes, puedes tener ~$$N^2$$ oportunidades para encontrar una colisión por que puedes comparar cada hash con todos los demás. Esto es lo que se conoce como la paradoja del cumpleaños.</p><h2 id=cómo-se-vuelve-inseguro-un-hash>Cómo se vuelve inseguro un hash</h2><p>Un hash seguro se comporta de manera completamente impredecible con respecto a su valor de entrada. Los hashes inseguros empiezan a dar muestras de regularidad en sus salidas o tienen salidas demasiado pequeñas.</p><p>De esta manera, es posible encontrar métodos estadísticos para analizar las salidas y así encontrar patrones que permitan encontrar colisiones o preimágenes más fácilmente.</p><p>Pero en realidad, tiene mucho que ver con su construcción y las formas en las que puedes truquear los valores que le das para reducir el número de pasos que se necesitan para encontrar una preimagen o una colisión.</p><h2 id=conclusión>Conclusión</h2><p>En este artículo vimos las tres garantías de seguridad que debe cumplir una función hash para ser criptográficamente segura. Te sirven para entender claramente de lo que se habla cuando se han encontrado colisiones en un hash, y poder evaluar la gravedad de la situación.</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025 Héctor Patricio</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>1709 words</span>
<span>9 - 12 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#qué-es-un-hash>¿Qué es un hash?</a></li><li><a href=#imagen-y-preimagen>Imagen y preimagen</a></li><li><a href=#resistencia-a-la-primera-preimagen>Resistencia a la primera preimagen</a></li><li><a href=#resistencia-a-la-segunda-preimagen>Resistencia a la segunda preimagen</a></li><li><a href=#resistencia-a-colisiones>Resistencia a colisiones</a></li><li><a href=#cómo-se-vuelve-inseguro-un-hash>Cómo se vuelve inseguro un hash</a></li><li><a href=#conclusión>Conclusión</a></li></ul></nav><h3>Related</h3><ul><li><a href=/2021/12/03/algoritmos-criptogr%C3%A1ficos-hashes-seguros-para-alamcenar-passwords/>Algoritmos criptográficos: hashes seguros para alamcenar passwords</a></li><li><a href=/2021/12/02/algoritmos-criptogr%C3%A1ficos-qu%C3%A9-es-un-hash/>Algoritmos criptográficos: ¿Qué es un Hash?</a></li><li><a href=/2023/02/03/problemas-dif%C3%ADciles-de-la-computaci%C3%B3n-y-su-relaci%C3%B3n-con-la-criptograf%C3%ADa-problemas-np/>Problemas difíciles de la computación y su relación con la criptografía: Problemas NP</a></li><li><a href=/2022/10/12/crea-hashes-resistentes-a-balas-con-keccak-sha-3/>Crea hashes resistentes a balas con Keccak (SHA-3)</a></li><li><a href=/2021/12/25/matem%C3%A1ticas-para-criptograf%C3%ADa/>Matemáticas para criptografía</a></li></ul></aside></div></div></body></html>