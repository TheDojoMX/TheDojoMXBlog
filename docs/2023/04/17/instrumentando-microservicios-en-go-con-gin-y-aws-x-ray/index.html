<!doctype html><html lang=es dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Instrumentando microservicios en Go con Gin y AWS X-Ray | The Dojo MX Blog</title>
<link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><meta property="og:title" content="Instrumentando microservicios en Go con Gin y AWS X-Ray"><meta property="og:description" content="Descubre cómo mejorar la observabilidad de tus microservicios en Go con X-Ray."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thedojo.mx/2023/04/17/instrumentando-microservicios-en-go-con-gin-y-aws-x-ray/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-17T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Instrumentando microservicios en Go con Gin y AWS X-Ray"><meta name=twitter:description content="Descubre cómo mejorar la observabilidad de tus microservicios en Go con X-Ray."><link rel=stylesheet href=/css/extended.min.771dff75f9f3290205d2bfcbeda2ed15a5984c0414d431dfec3423ae5e37bb90.css integrity="sha256-dx3/dfnzKQIF0r/L7aLtFaWYTAQU1DHf7DQjrl43u5A=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js integrity="sha256-zIrplS2/tzGv+vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://blog.thedojo.mx/ style=color:inherit>The Dojo MX Blog</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Instrumentando microservicios en Go con Gin y AWS X-Ray</h1><time class=dim datetime=2023-04-17T00:00:00+00:00>April 17, 2023</time><div class=term-container><div class=tag><a href=https://blog.thedojo.mx/tags/programaci%C3%B3n/>#programación</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/instrumentaci%C3%B3n/>#instrumentación</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/microservicios/>#microservicios</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/aws/>#AWS</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/go/>#Go</a></div></ol></div><section class=page-section><p>En una arquitectura de microservicios, las operaciones muchas veces abarcan múltiples servicios y recursos tales como gateways, microservicios, balanceadores de carga, bases de datos entre otros. La naturaleza distribuida de los microservicios es lo que hace invaluable la instrumentazión de software.</p><p>Si nuestro código provee información de traceo para requests, y logs, podemos decir que está instrumentado y que podemos observar cómo se está desempeñando nuestro sistema.</p><p>La instrumentación de servicios es especialmente útil para identificar y resolver problemas de rendimiento y errores. Los datos recolectados pueden ser usados para planear la capacidad de nuestros servicios al ayudarnos a entender el tráfico y patrones de uso en nuestras aplicaciones.</p><p>Existen varias soluciones para instrumentar nuestros servicios, como <a href=https://opentelemetry.io/>OpenTelemetry</a>, <a href=https://zipkin.io/>Zipkin</a> y <a href=https://www.datadoghq.com/>datadog</a>. AWS también ofrece una <a href=https://aws-otel.github.io/>Distribución de OpenTelemetry</a> para poder usar OpenTelemetry como backend de obserbabilidad mientras usas X-Ray o cualquier otra solución de terceros para recibir datos de telemetría y proveer procesamiento, agregación y visualización de éstos.</p><p>En este post, les voy a contar sobre mi experiencia al instrumentar un microservicio en Go usando Gin y AWS X-Ray.</p><h2 id=gin>Gin</h2><p>Gin es un framework para el lenguaje de programación Go para crear aplicaciones web, se destaca por ser ligero y tener un alto rendimiento, diseñado para facilitar la creación de aplicaciones web escalables de una manera rápida.</p><p>Ofrece una API minimalista, un router robusto, soporte para middleware y características de seguridad integradas, lo que lo convierte en una opción ideal para construir microservicios y otras aplicaciones web de alto rendimiento.</p><p>Si bien Gin puede tener una curva de aprendizaje empinada y características limitadas integradas, su simplicidad y capacidad de extensión lo convierten en una opción popular para los desarrolladores que priorizan el rendimiento y la escalabilidad.</p><p><strong>Crear un servicio de Gin desde cero está fuera del alcance de esta publicación</strong>, pero puedes leer más sobre Gin en la <a href=(https://gin-gonic.com/docs/)>página oficial de su documentación</a>.</p><h2 id=aws-x-ray>AWS X-Ray</h2><p>AWS X-Ray es un servicio de AWS que recolecta datos sobre los requests servidos por tu aplicación y provee herramientas para ver, filtrar y obtener información sobre esos datos para identificar problemas y oportunidades de optimización.</p><p>Algunos puntos a favor de X-Ray sobre otras herramientas similares son:</p><ul><li>Facilidad de integración con otros servicios de AWS.</li><li>No hay infraestructura extra qué mantener (el daemon de X-Ray está incluído en las plataformas AWS Elastic Beanstalk y AWS Lambda).</li><li>Puede funcionar sólo como visualizador (usando OpenTelemetry como tracer).</li><li>Para servicios soportados, el SDK de X-Ray puede enviar y rastrear automáticamente los &ldquo;ID de request&rdquo; entre los servicios.</li><li>Es administrado por AWS.</li><li>Los primeros 100k rastreos del mes son gratis.</li><li>El primer millón de rastreos obtenidos o escaneados cada mes es gratis.</li></ul><p>Sin embargo algunos puntos en contra son:</p><ul><li>AWS X-Ray sólo puede ser usado con aplicaciones corriendo en Amazon EC2, Amazon EC2 containser service, AWS Lambda, y AWS Elastic Beanstalk.</li><li>Después de agotar los rastreos gratuitos del mes, cada rastreo indexado y consultado tiene un costo.</li><li>Soporte limitado de lenguajes: Mientras que el SDK de X-Ray tiene soporte para varios lenguajes de programación, no soporta todos los lenguajes o plataformas, lo cual puede limitar su utilidad en algunos casos.</li><li>Vendor lock-in: El uso de X-Ray puede llevar a la dependencia exclusiva de AWS, ya que es un servicio propietario disponible sólo en la plataforma de AWS. Esto puede limitar su capacidad para cambiar a otros proveedores de nube o herramientas en el futuro.</li></ul><p>Si, después de leer algunos de los pros y contras, aún estás inclinado a usar X-Ray, entonces puedes seguir leyendo.</p><h3 id=requerimientos>Requerimientos</h3><p>Para ver la información de rastreo en AWS X-Ray, necesitas una cuenta de AWS y una aplicación corriendo en la infraestructura de AWS o que esté integrada con los servicios de AWS. Además, necesitarás:</p><ul><li>Una instancia del X-Ray daemon, que se puede ejecutar como un binario o como un contenedor de Docker. Puedes encontrar instrucciones detalladas sobre cómo ejecutar y configurar el daemon <a href=https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon-local.html>aquí</a>. Para éste artículo, estaré usando el binario para OS X.</li><li>Tu aplicación debe de tener los permisos necesarios para interactuar con AWS X-Ray y otros servicios que use.</li></ul><h4 id=iam-role>IAM Role</h4><p>Para permitir que tu aplicación mande información sobre tus requests a X-Ray, tienes que proveerle al daemon de X-Ray un rol. Para crear un rol, vamos a entrar a nuestra consola web de AWS y de allí navegamos a la página principal de IAM y allí encontraremos el botón &ldquo;Create Role&rdquo; (o &ldquo;Crear Rol&rdquo; si tienes configurado tu panel de AWS en español).</p><p><img src=https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/create-role.png alt="Crear nuevo rol"></p><p>En el asistente, selecciona &ldquo;AWS Account&rdquo; para Trusted Entity y da click en &ldquo;Next&rdquo;/&ldquo;Siguiente&rdquo;. En la siguiente pantalla, busca por la política de permisos llamada &ldquo;AWSXRayDaemonWriteAccess&rdquo;. Da click en &ldquo;Next&rdquo;/&ldquo;Siguiente&rdquo; para continuar..</p><p><img src=https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/name-review-create.png alt="Nombra, Revisa y Crea"></p><p>Agrega un nombre y descripción para el rol, y después da click en &ldquo;Create Role&rdquo;. Ésto te llevará a la lista de roles. Busca el rol que acabas de crear para ver y copiar su ARN.</p><p><img src=https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/role-details.png alt="Detalles del rol"></p><h3 id=x-ray-daemon>X-Ray Daemon</h3><p>Ahora que ya tenemos el rol para el daemon, vamos a configurarlo.</p><p>Para mi proyecto de prueba, solo tuve que cambiar algunos valores de la configuración, como el nivel del logger, especificar el modo local a verdadero, y agregar el ARN del rol que creamos y la región de AWS en la que estamos operando nuestros servicios.</p><p>Aquí está la configuración que usé:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># Send segments to AWS X-Ray service in a specific region</span>
</span></span><span style=display:flex><span><span style=color:#f92672>Region</span>: <span style=color:#e6db74>&#34;us-west-2&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>Socket</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># Change the address and port on which the daemon listens for UDP packets containing segment documents.</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>UDPAddress</span>: <span style=color:#e6db74>&#34;127.0.0.1:2000&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Change the address and port on which the daemon listens for HTTP requests to proxy to AWS X-Ray.</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>TCPAddress</span>: <span style=color:#e6db74>&#34;127.0.0.1:2000&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>Logging</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># Change the log level, from most verbose to least: dev, debug, info, warn, error, prod (default).</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>LogLevel</span>: <span style=color:#e6db74>&#34;dev&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Turn on local mode to skip EC2 instance metadata check.</span>
</span></span><span style=display:flex><span><span style=color:#f92672>LocalMode</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Assume an IAM role to upload segments to a different account.</span>
</span></span><span style=display:flex><span><span style=color:#f92672>RoleARN</span>: <span style=color:#e6db74>&#34;arn:aws:iam::269174633178:role/X-Ray_Daemon_role&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Daemon configuration file format version.</span>
</span></span><span style=display:flex><span><span style=color:#f92672>Version</span>: <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>En <a href=https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon-configuration.html>la guía del desarrollador de AWS X-Ray</a> puedes aprender más sobre otros valores que puedes configurar.</p><h3 id=instrumentando-tu-microservicio-en-go>Instrumentando tu microservicio en Go</h3><p>Ahora que ya tenemos el X-Ray daemon configurado y corriendo, podemos proceder a instrumentar nuestro servicio.</p><p>AWS recomienda empezar agregando rastreo para requests entrantes envolviendo los controladores de servicio con <code>xray.Handler</code>. Pero, como estamos usando Gin, el enfoque que implementaremos es ligeramente diferente.</p><p>Mientras buscaba recursos sobre cómo instrumentar una aplicación con Gin, me encontré con éste <a href=https://raw.githubusercontent.com/oroshnivskyy/go-gin-aws-x-ray>middleware</a>, el cual está basado en la función <a href=https://raw.githubusercontent.com/aws/aws-xray-sdk-go/1e154184282bb3b0166cb1b154f2b4abed0b1e6f/xray/handler.go#L99><code>xray.Handler</code></a>.</p><p>Éste middleware hace el mismo trabajo que <code>xray.Handler</code>, abrirá y cerrará un segmento para cada request recibido. También se encargará de manejar el header para IDs de rastreo (<code>"x-amzn-trace-id"</code>), que es un header que contiene un identificador que será generado para cada petición nueva y que será propagado a travéz de todos nuestros microservicios.</p><p>Así que vamos a agregar el middleware a las rutas que queremos intrumentar:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// as part of my gin routes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>v1</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/auth/roles&#34;</span>, <span style=color:#a6e22e>xraymid</span>.<span style=color:#a6e22e>Middleware</span>(<span style=color:#a6e22e>xray</span>.<span style=color:#a6e22e>NewFixedSegmentNamer</span>(<span style=color:#e6db74>&#34;GetRoles&#34;</span>)), <span style=color:#a6e22e>controller</span>.<span style=color:#a6e22e>GetRoles</span>)
</span></span></code></pre></div><p>Aquí estamos agregando el middleware de X-Ray (con el alias <code>xraymid</code>) a una ruta del grupo <code>v1</code>. El valor que estamos pasando como argumento a <code>NewFixedSegmentNamer</code> debe de ser un nombre descriptivo para tu ruta. Éste será el nombre para el grupo principal de rastreo para éste endpoint.</p><p>¡Bien! ¡Ahora veamos si funciona! Inicia tu servicio y verifica que el daemon esté corriendo.</p><p>Después de hacer un request, podemos ver en los logs del daemon algo como:</p><pre tabindex=0><code>2023-03-21T13:10:47-06:00 [Debug] Received request on HTTP Proxy server : /GetSamplingRules
2023-03-21T13:10:48-06:00 [Debug] processor: sending partial batch
2023-03-21T13:10:48-06:00 [Debug] processor: segment batch size: 1. capacity: 50
2023-03-21T13:10:48-06:00 [Info] Successfully sent batch of 1 segments (0.109 seconds)
2023-03-21T13:10:49-06:00 [Debug] Send 1 telemetry record(s)
</code></pre><p>¡Parece que está funcionando! Vamos a ver qué dice la consola de AWS.</p><p>En tu consola web de AWS, ve a CloudWatch y en el panel lateral busca la opción para X-Ray, y da click en la opción &ldquo;traces&rdquo;.</p><p>Si todo salió bien, deberías estar viendo el número de rastreos recibidos recientemente, y una tabla con la información de esos rastreos.</p><p><img src=https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/cloudwatch-xray-traces.png alt="Cloudwatch -> X-Ray -> Traces"></p><p>En la tabla de registros, da click en alguno. Aparecerá la vista de rastreo/seguimiento, donde puedes ver la información registrada.</p><p><img src=https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/simple-trace-info.png alt="Información de rastreo"></p><p>Aquí podemos ver los datos de seguimiento. Hasta el momento sólo estamos creando un segmento y cerrándolo para cada llamada, por lo que no tenemos mucha otra información, pero podemos ver el código de estado de respuesta, el tiempo que tomó para que se atendiera la solicitud y, por supuesto, el mapa de seguimiento, que por ahora incluye sólo el cliente y el servicio.</p><h4 id=creando-sub-segmentos>Creando sub segmentos</h4><p>Ahora que tenemos nuestra configuración básica de instrumentación, ¿qué más podemos rastrear?</p><p>Hasta el momento, solo estamos rastreando una solicitud y algunos de sus metadatos. Pero, ¿qué pasa si queremos ser más detallados?</p><p>Digamos que tenemos un proceso intensivo que se ejecuta como parte de la solicitud; podemos agregar un subsegmento para monitorearlo.</p><p>En algún lugar de mi servicio, se ejecuta el siguiente código cuando llamo al endpoint <code>auth/roles</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// dentro de alguna función
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>roles</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>Role</span>, len(<span style=color:#a6e22e>rolesList</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>roleItem</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rolesList</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>role</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>buildRole</span>(<span style=color:#a6e22e>roleItem</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>RoleList</span>{}, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>roles</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>role</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Aquí podemos envolver el bucle <code>for</code> en un subsegmento para ver cuánto tiempo del request tarda en ejecutar éste proceso.</p><p>Para crear el subsegmento, envolvemos el ciclo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>xray</span>.<span style=color:#a6e22e>Capture</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;BuildRolesDetail&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx1</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>roleItem</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rolesList</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>role</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>buildRole</span>(<span style=color:#a6e22e>roleItem</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>roles</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>role</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>xray</span>.<span style=color:#a6e22e>AddMetadata</span>(<span style=color:#a6e22e>ctx1</span>, <span style=color:#e6db74>&#34;No. roles built&#34;</span>, len(<span style=color:#a6e22e>roles</span>)); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>nepErrors</span>.<span style=color:#a6e22e>InternalServerError</span>.<span style=color:#a6e22e>WithDetail</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Vamos a correr nuestro servicio y llamemos de nuevo nuestro endpoint instrumentado.</p><p>Éste es el nuevo registro en AWS CloudWatch -> Traces:</p><p><img src=https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/trace-with-sub-segment.png alt="Rastreo con subsegmentos"></p><p>Ahora podemos ver que la petición tomó <strong>215ms</strong>, y de esos, el ciclo <code>BuildRolesDetail</code> tomó <strong>205ms</strong>.</p><p>¿Ya estás pensando en las posibilidades? ¡Deberías! puedes usar <code>xray.AddMetadata</code> para agregar cualquier dato que te sea de utilidad. Únicamente toma en cuenta que el Daemon de X-Ray sólo envía a AWS <a href=https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html>hasta 64KB de metadata por segmento</a>.</p><h3 id=instrumentando-clientes-de-aws-con-x-ray>Instrumentando clientes de AWS con X-Ray</h3><p>Instrumentar clientes de AWS usando el SDK-V1 es bastante sencillo, puedes seguir la <a href=https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-go-awssdkclients.html>guía oficial</a> para hacerlo.</p><p>No hay mucha documentación sobre cómo instrumentar clientes de AWS usando el AWS SDK-v2, pero la configuración es bastante sencilla.</p><p>En algún lugar en el código de tu servicio, estás inicializando tu(s) cliente(s) de AWS. Para instrumentarlos, necesitas proveer a tus clientes con un cliente HTTP de X-Ray y pasar el contexto del request para cada llamada.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>cfg</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>LoadDefaultConfig</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create an HTTP client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>httpClient</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Set the HTTP client as the AWS configuration&#39;s HTTP client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>HTTPClient</span> = <span style=color:#a6e22e>httpClient</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create an X-Ray client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>xrayClient</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>xray</span>.<span style=color:#a6e22e>Client</span>(<span style=color:#a6e22e>httpClient</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dynamoClient</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dynamodb</span>.<span style=color:#a6e22e>NewFromConfig</span>(<span style=color:#a6e22e>cfg</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>options</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>dynamodb</span>.<span style=color:#a6e22e>Options</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Wrap the http.Client with an xray.Client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>options</span>.<span style=color:#a6e22e>HTTPClient</span> = <span style=color:#a6e22e>xrayClient</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Aquí, estoy agregando el cliente HTTP de X-Ray al cliente de AWS DynamoDB.</p><p>Una vez hecho esto, llamemos de nuevo a nuestro endpoint instrumentado.</p><p><img src=https://raw.githubusercontent.com/makkoman/blogposts/main/x-ray/images/instrumenting-ddb-client.png alt="Instrumentando el cliente de DynamoDB"></p><p>Yo estoy corriendo DynamoDB localmente, pero ya puedes ver qué tanto tiempo toma cada llamada a DynamoDB. También podemos ver que el mapa de rastreo ha sido acualizado para mostrar mi instancia local de DynamoDB.</p><h2 id=conclusión>Conclusión</h2><p>Instrumentar un servicio con X-Ray es relativamente sencillo, pero puede complicarse muy rápido dependiendo de las cosas que queremos monitorear. Debido a esto, el esfuerzo para agregar trazabilidad a su servicio puede variar de caso en caso.</p><p>Otra cosa a considerar es el límite de 64KB por segmento. Puede que no sea suficiente si deseas rastrear muchos subsegmentos o agregar más metadatos. Existen formas de evitar esto, pero están fuera del alcance de esta publicación.</p><p>En conclusión, implementar X-Ray en un microservicio en Go es un proceso sencillo que puede beneficiar enormemente la observabilidad y las capacidades de resolución de problemas de tu aplicación. El proceso de integración es relativamente fácil, y el SDK de X-Ray proporciona una serie de características útiles que facilitan la trazabilidad de las solicitudes y la identificación de cuellos de botella. Sin embargo, es importante tener en cuenta que X-Ray tiene algunas desventajas, como el costo asociado con su uso y las limitaciones de sus capacidades de muestreo.</p><p>No obstante, con una consideración cuidadosa y una implementación adecuada, X-Ray puede ser una herramienta invaluable para la depuración y optimización de tu arquitectura de microservicios. Así que no dudes en probarlo y ver cómo puede mejorar el rendimiento y la confiabilidad de tus microservicios en Go.</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025 Héctor Patricio</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2080 words</span>
<span>14 - 17 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#gin>Gin</a></li><li><a href=#aws-x-ray>AWS X-Ray</a><ul><li><a href=#requerimientos>Requerimientos</a></li><li><a href=#x-ray-daemon>X-Ray Daemon</a></li><li><a href=#instrumentando-tu-microservicio-en-go>Instrumentando tu microservicio en Go</a></li><li><a href=#instrumentando-clientes-de-aws-con-x-ray>Instrumentando clientes de AWS con X-Ray</a></li></ul></li><li><a href=#conclusión>Conclusión</a></li></ul></nav><h3>Related</h3><ul><li><a href=/2023/02/27/code-review-la-practica-milenaria-que-seguimos-haciendo-mal./>Code Review: La practica Milenaria que seguimos haciendo mal.</a></li><li><a href=/2021/06/14/fuentes-no-convencionales-de-aprendizaje/>Fuentes no convencionales de aprendizaje</a></li><li><a href=/2020/09/10/no-hagas-hagas-devops-por-convivir/>No hagas hagas DevOps por convivir</a></li><li><a href=/2020/05/16/cursos-certificados-gratuitos/>Cursos certificados gratuitos</a></li><li><a href=/2019/02/23/patrones-de-dise%C3%B1o-qu%C3%A9-son-y-cu%C3%A1ndo-usarlos/>Patrones de diseño: qué son y cuándo usarlos</a></li></ul></aside></div></div></body></html>