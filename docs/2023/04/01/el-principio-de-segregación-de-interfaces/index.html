<!doctype html><html lang=es dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>El principio de segregación de Interfaces | The Dojo MX Blog</title>
<link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><meta property="og:title" content="El principio de segregación de Interfaces"><meta property="og:description" content="Analicemos el cuarto principio de SOLID: El principio de segregación de interfaces, y veamos qué tanto vale la pena tenerlo en cuenta en nuetros desarrollos."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thedojo.mx/2023/04/01/el-principio-de-segregaci%C3%B3n-de-interfaces/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="El principio de segregación de Interfaces"><meta name=twitter:description content="Analicemos el cuarto principio de SOLID: El principio de segregación de interfaces, y veamos qué tanto vale la pena tenerlo en cuenta en nuetros desarrollos."><link rel=stylesheet href=/css/extended.min.771dff75f9f3290205d2bfcbeda2ed15a5984c0414d431dfec3423ae5e37bb90.css integrity="sha256-dx3/dfnzKQIF0r/L7aLtFaWYTAQU1DHf7DQjrl43u5A=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js integrity="sha256-zIrplS2/tzGv+vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://blog.thedojo.mx/ style=color:inherit>The Dojo MX Blog</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>El principio de segregación de Interfaces</h1><time class=dim datetime=2023-04-01T00:00:00+00:00>April 1, 2023</time><div class=term-container><div class=tag><a href=https://blog.thedojo.mx/tags/solid/>#solid</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/principios-solid/>#principios-solid</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/isp/>#isp</a></div></ol></div><section class=page-section><p>Continuemos con el estudio de los principios SOLID. En esta ocasión hablaremos del cuarto principio: El principio de segregación de interfaces.</p><p>Recuerda que el objetivo de estos artículos <strong>no es explicártelos como si fueran una religión que estás mal si no sigues</strong>, sino analizarlos bajo una luz crítica y decidir si de verdad son útiles o podemos usar otro principio.</p><p>Analicemos primero el enunciado, junto con algunos ejemplos y veamos si nos conviene aplicarlo directamente o no.</p><h2 id=el-principio-de-segregación-de-interfaces>El principio de segregación de interfaces</h2><p>La frase que define el principio es:</p><blockquote><p>Los clientes no deberían ser forzados a depender de interfaces que no usan.</p></blockquote><p>Creo que el nombre y este enunciado lo hace sonar demasiado complicado para lo que es: se trata de pensar bien tus interfaces para que no sean lo más sencillo que se pueda. <em>&ldquo;Los clientes&rdquo;</em> son todas las partes del código que usan <strong>una interfaz</strong>.</p><p>Al hacer tus interfaces lo más sencillas que puedas, evitarás que los clientes tengan que implementar métodos que no usan, y que no deberían tener que implementar.</p><p>Pongamos un ejemplo de la vida real:</p><p>¿Te ha tocado llenar un formulario que te pregunta cosas que no te aplican? Por ejemplo un formulario que te pregunta por los datos de tus hijos independientemente si no tienes o no. Sin duda es molesto y una pérdida de tiempo. Aquí, te están forzando a cumplir con una interfaz que no usas.</p><p>Lo mismo exactamente puede pasar con el software. Si una interfaz, por ejemplo, al usar un método con muchos parámetros obligatorios que no siempre se ocupan, o una clase con métodos que corresponden a otros usos.</p><p>Esto se puede dar cuando tienes una clase o una función que implementa algo que puede ser ocupado en diversos lugares (estos son sus <em>clientes</em>). Imagina que los diferentes lugares tienen ligeras variaciones, por las que hay que modificar la interfaz para que se pueda usar en cada uno de ellos. Hacer esto te llevaría a crear una interfaz complicada de usar y además frágil.</p><p>Es por esto que John Ousterhout da varios consejos relacionados:</p><ol><li>Mientras más simple la interfaz, mejor.</li><li>Son mejores los módulos de propósito <strong>general</strong>, que después puedan ser especializados o combinados para crear interfaces específicas, para cada caso.</li><li>Crear las interfaces pensando en el caso más común.</li></ol><p>Sin embargo, este último consejo de Ousterhout puede ir en contra de este principio, pero aquí preferimos la practicidad sobre la pureza. Más adelante daremos un ejemplo.</p><h2 id=ejemplos-de-aplicación>Ejemplos de aplicación</h2><p>Empecemos con un ejemplo que nos pude ayudar a entender el problema y la solución mediante un conjunto de clases.</p><p>Usemos un ejemplo común este blog: una plataforma para enviar mensajes a diferentes canales, como Telegram, WhatsApp, Messenger, Instagram. Una forma de representar la interfaz de un mensaje sería la siguiente:</p><p><img src=https://res.cloudinary.com/hectorip/image/upload/c_scale,w_350/v1680394988/clase_texto_ylaj7m.png alt="Clase única">{: .align-center}</p><p>Aunque podríamos nombrar algunos de estos argumentos como opcionales (lo cuál evitaría que en estricto sentido los clientes estén forzados a usarlos), la interfaz sigue siendo confusa e impráctica. Por ejemplo, si quieres mandar algo por SMS, no tienes la opción de mandar tarjetas multimedia.</p><p>Una mejor solución sería crear un interfaz base, con especializaciones para cada caso. Por ejemplo:</p><p><img src=https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1680398494/Screen_Shot_2023-04-01_at_19.21.23_m7wuws.png alt="Composición de clases">{: .align-center}</p><p>Esta forma no sigue la herencia (un mensaje con tarjetas es un mensaje de texto), sino la composición (un mensaje con tarjetas tiene un mensaje de texto). Esto nos permite tener una interfaz más sencilla y fácil de usar, que puede ser especializada por cada caso.</p><h2 id=llevándolo-al-extremo>Llevándolo al extremo</h2><p>Si llevamos este consejo al extremo, podemos quedar con una cantidad tan grande de interfaces y tan especializadas que el código quedaría más difícil de entender y mantener. Imagínate el infierno que sería navegar por ese código. <strong>Recuerda que las interfaces son simplemente la parte accesible de una funcionalidad</strong>. Ousterhout dice que a veces, la complejidad viene de la cantidad de cosas con las que tenemos que tratar.</p><p>Además, separar el código a veces conlleva código extra: el que se usa para seleccionar qué interfaz o código usar.</p><p>Así que la pregunta básica es: ¿cuándo debo separar o romper código que hace algo en partes más pequeñas? Pensar que este principio es la guía más fuerte es un error, el análisis debe ir mucho más al fondo, no sólo pensar en las interfaces y si alguien está &ldquo;obligado&rdquo; a implementar o lidiar con cosas que no usa.</p><p>Por ejemplo, ¿qué pasa si el 90% de las veces que vayas a usar un módulo como una función vas a usarla en la versión más complejas? ¿Valdrá la pena separarla en dos funciones? Yo creo que vale más la pena que los lugares donde no la usas completa, se trate de manera especial.</p><p>Para un análisis más profundo, escribiré un artículo basado en el capítulo &ldquo;Better Together o Better Apart?&rdquo; de <a href=https://web.stanford.edu/~ouster/cgi-bin/book.php>A Philosophy of Software Design</a> de John Ousterhout.</p><h2 id=conclusión>Conclusión</h2><p>Aunque es una buena idea que las interfaces sean demasiado complejas para no forzar al código que las usa a implementar cosas que no le corresponden, llevarlo al extremo podría hacer que tu base de código sea más compleja de lo que empezó.</p><p>Este principio de diseño no debería ser la única fuente de decisión para saber si deber <em>segregar</em> o como diríamos más cotidianamente <em>separar</em> una interfaz. Recuerda que al separar la interfaz estás separando la implementación y la lógica de tu programa, por lo que debes pensarlo muy bien antes de hacerlo.</p><p>Finalmente, es muy poco probable que te pase algo similar si piensas en hacer interfaces que sean lo más sencillo posible.</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025 Héctor Patricio</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>920 words</span>
<span>5 - 6 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#el-principio-de-segregación-de-interfaces>El principio de segregación de interfaces</a></li><li><a href=#ejemplos-de-aplicación>Ejemplos de aplicación</a></li><li><a href=#llevándolo-al-extremo>Llevándolo al extremo</a></li><li><a href=#conclusión>Conclusión</a></li></ul></nav><h3>Related</h3><ul><li><a href=/2023/03/06/el-principio-de-sustituci%C3%B3n-de-liskov/>El principio de sustitución de Liskov</a></li><li><a href=/2022/12/03/el-principio-abierto/cerrado-open/closed/>El principio Abierto/Cerrado (Open/Closed)</a></li><li><a href=/2022/12/01/an%C3%A1lisis-de-los-principios-solid-principio-de-responsabilidad-%C3%BAnica/>Análisis de los principios SOLID: Principio de Responsabilidad Única</a></li><li><a href=/2019/03/19/principios-de-dise%C3%B1o-de-software/>Principios de Diseño de Software</a></li></ul></aside></div></div></body></html>