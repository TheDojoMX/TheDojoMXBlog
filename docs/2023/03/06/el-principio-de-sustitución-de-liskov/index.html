<!doctype html><html lang=es dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>El principio de sustitución de Liskov | The Dojo MX Blog</title>
<link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><meta property="og:title" content="El principio de sustitución de Liskov"><meta property="og:description" content="El principio de sustitución de Liskov es uno de las reglas de comportamiento más famosas entre los desarrolladores. Hablemos de lo que significa."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thedojo.mx/2023/03/06/el-principio-de-sustituci%C3%B3n-de-liskov/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="El principio de sustitución de Liskov"><meta name=twitter:description content="El principio de sustitución de Liskov es uno de las reglas de comportamiento más famosas entre los desarrolladores. Hablemos de lo que significa."><link rel=stylesheet href=/css/extended.min.771dff75f9f3290205d2bfcbeda2ed15a5984c0414d431dfec3423ae5e37bb90.css integrity="sha256-dx3/dfnzKQIF0r/L7aLtFaWYTAQU1DHf7DQjrl43u5A=" crossorigin=anonymous><link rel=stylesheet href=/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H+ZeT/jBpieRZ8=" crossorigin=anonymous><link rel=stylesheet href=/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css integrity="sha256-WesaBZ+M1VjmQ3Xt4+aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin=anonymous><script src=/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js integrity="sha256-zIrplS2/tzGv+vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin=anonymous></script><script defer src=/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js integrity="sha256-ZFlLEl97eL30+oMWlVkiu+uxzWuu8/FmVL/KIDCfGPg="></script><script defer src=/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js integrity="sha256-HZgPhN8R8+t8jF8X9UHUmgYRYI3xed10+n8GIl61as4="></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel=stylesheet></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://blog.thedojo.mx/ style=color:inherit>The Dojo MX Blog</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div><div class=nav-item><a>Acerca de</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/><span itemprop=name>Home</span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://blog.thedojo.mx/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>El principio de sustitución de Liskov</h1><time class=dim datetime=2023-03-06T00:00:00+00:00>March 6, 2023</time><div class=term-container><div class=tag><a href=https://blog.thedojo.mx/tags/lsp/>#lsp</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/liskov/>#liskov</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/solid/>#solid</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/principios/>#principios</a></div><div class=tag><a href=https://blog.thedojo.mx/tags/solid-principles/>#solid-principles</a></div></ol></div><section class=page-section><p>El tercer principio enunciado en los principios <strong>SOLID</strong> es el principio de sustitución de Liskov. ¿Qué significa este principio? Y más importante, ¿vale la pena seguirlo? Pero antes de hablar del principio, hablemos de <strong>Barbara Liskov</strong>, la persona que lo inspiró y que estableció los conceptos principales.</p><h2 id=un-poco-de-historia-barbara-liskov>Un poco de historia: Barbara Liskov</h2><p>Barbara Liskov es una matemática muy reconocida en las ciencias de la computación por los grandes aportes que ha hecho. Es conocida por su trabajo en el diseño de lenguajes de programación y la teoría de tipos. En 1994 junto con Jeannette Wing publicó el artículo del que Robert Martin se sacó lo que el llamó &ldquo;el principio de sustitución de Liskov&rdquo; o &ldquo;LSP&rdquo; (Liskov Substitution Principle). Ya ves que los <em>inicialismos</em> le dan un aire de importancia a lo que escribes.</p><p>En su libro, <a href=https://www.marcombo.com/mentes-geniales-la-vida-y-obra-de-12-grandes-informaticos-9788426733573/>&ldquo;Mentes Geniales. La vida y obra de 12 grandes informáticos&rdquo;</a>, Camilo Chacón nos da una semblanza de las contribuciones de Barbara a las ciencias de la computación. Sus principales aportaciones, resumidas son:</p><ul><li>Lenguajes de programación que aplican ideas de polimorfismo, modularidad, abstracción de datos y manejo de excepciones</li><li>Sistemas distribuidos (inventó Paxos antes que Leslie Lamport)</li><li>Abstracción de datos y tipos de datos abstractos</li></ul><p>Si quieres saber más de ella en poco tiempo, te recomiendo mucho su capítulo en ese libro, es muy interesante, además de que obtiene lecciones muy valiosas de su vida. Ahora sí hablemos de lo que más gente conoce de ella.</p><h2 id=el-principio-de-sustitución-de-liskov>El principio de sustitución de Liskov</h2><p>El artículo en el que lo definió se llama <a href=/assets/pdfs/subtyping.pdf>&ldquo;A Behavioral Notion of Subtyping&rdquo;</a>. Tiene notación matemática que cuesta un poco leer si no tienes nociones de lenguaje matemático formal, pero resumiremos las ideas básicas aquí.</p><p>El espíritu del LSP está basado en las ideas de <strong>subtipado</strong> que Liskov describió en este artículo. Estas ideas tienen <em>muy poco</em> que ver en realidad con herencia en los lenguajes de programación orientados a objetos y mucho más con la <strong>abstracción</strong> y restricciones que hay que tener en cuenta para considerar que un tipo es un subtipo de otro.
Es cierto que Liskov usó las jerarquías de clases para ilustrar sus ideas, pero el principio de su trabajo tiene que ver mucho más con el comportamiento externo de un tipo de datos que con la forma en la que se encapsula este comportamiento.</p><p>Pero vayamos a la parte más profunda de la teoría para entender si lo que Liskov propone tiene sentido.</p><h3 id=qué-es-un-tipo>¿Qué es un tipo?</h3><p>Un tipo es la definición de lo que un valor almacenado tiene, puede hacer o las operaciones que se pueden hacer sobre él.</p><p>Pongamos un ejemplo. En JavaScript el tipo <code>Number</code> define un valor que representa un número de cualquier tipo. Este tipo de dato define las operaciones que podemos hacer sobre los valores con este tipo, por ejemplo:</p><ul><li>Podemos usar el operador <code>+</code> para sumar dos datos de este tipo</li><li>Podemos usar el operador <code>-</code> para restar dos datos de este tipo</li><li>Las operaciones (excepto las comparativas) entre el tipo de dato <code>Number</code> siempre devuelven un valor de este tipo</li></ul><p>También definen la <em>interfaz</em> de este tipo de datos, es decir, la forma en la que podemos interactuar con ellos. Normalmente, en lenguajes orientados a objetos, esta interfaz está compuesta por los métodos públicos que se pueden llamar sobre este tipo de dato.</p><p>Por ejemplo en JavaScript, el tipo <code>Number</code> tiene definido el método <code>toString</code> que nos devuelve este valor como una cadena de texto.</p><p>Pero Bárbara Liskov expandió esto, proponiendo lo que llamamos <strong>Abstract Data Type</strong> o <strong>Tipo de Dato Abstracto</strong> (les llamaremos <strong>ADT</strong>). Un tipo abstracto de dato es una <strong>definición de un tipo de dato</strong>.</p><p>Este tipo de dato no tiene una implementación concreta, sino que define la interfaz que debe tener cualquier implementación de este tipo de dato, siendo responsabilidad del programador implementar esta interfaz.</p><p>Ejemplos de ADT&rsquo;s son por ejemplo las Colas (Queues), Listas (Lists), Pilas (Stacks), etc. El ADT define que interfaz debe tener cualquier implementación de este, y cada lenguaje o programador puede implementarlo como le convenga.</p><p>Ahora, ¿qué es un subtipo?</p><h3 id=qué-es-un-subtipo>¿Qué es un subtipo?</h3><p>Un subtipo es una derivación de un tipo. Esta derivación puede ser una variación, una generalización o una especialización de este tipo. Normalmente se usan para hacer <strong>especializaciones</strong>.</p><p>Y aquí es donde empezamos a entrar en el terreno del LSP. Una de las restricciones más importantes que Liskov propone es que si un tipo de dato tiene definido un método X, entonces cualquier subtipo de este tipo (que en relación con este se llama &ldquo;supertipo&rdquo;) también debe tener este método definido.</p><p>Para hacerlo más generalizable podemos cambiar &ldquo;método&rdquo; por cualquier elemento visible en la interfaz de este tipo de dato.</p><p>Así, nos podremos usar que estas clases sean intercambiables entre ellas, sin siquiera tener que hacer consciente a la parte del programa que la usa de qué clase se está usando, mientras sea una clase derivada de la clase base.</p><p>Un ejemplo de la vida real puede ser con un cámara. Todos tenemos en la mente las funciones básicas de una cámara electrónica:</p><ul><li>Podemos encenderla y apagarla</li><li>Puede tomar fotos (disparador)</li><li>Puede mostrarnos las fotos</li><li>Podemos descargar las fotos</li><li>Podemos borrar las fotos</li></ul><p>Mientras la cámara cumpla con esas características (su interfaz) no tendremos problema para usarla, independientemente de la marca o modelo de la cámara. Los subtipos del tipo de dato abstracto <code>Cámara</code> podría ser entonces:</p><ul><li><code>Cámara DSLR</code></li><li><code>Cámara Compacta</code></li><li><code>Cámara Mirrorless</code></li><li><code>Cámara de teléfono móvil</code></li></ul><p>En realidad en la programación, esta interfaz es un poco más estricta: los métodos deben de llamarse igual y tener la misma firma (parámetros y tipo de retorno). Es como si la cámara tuviera los botones en el mismo lugar y se usaran de la misma forma.</p><p>Y esto es básicamente el principio de sustitución de Liskov, la capacidad de usar clases derivadas de una clase principal sin ningún cambio en el código que rodea. ¿Crees que es útil?</p><h2 id=crítica-sobre-el-lsp>Crítica sobre el LSP</h2><p>Tal como lo describimos aquí (mal llamado, para mi) principio de sustitución de Liskov parece una muy buena idea, ya que permitirá que crees nuevos comportamientos en partes específicas de tu código sin en tener que afectar a muchas partes de tu código.</p><p>Lo que no estuvo tan bien, <em>históricamente</em>, es que este principio siempre ha sido explicado y relacionado con la HERENCIA de clases, en lugar de poner énfasis en la abstracción de tipos de datos. Esto ha hecho que muchos desarrolladores piensen que esta práctica sólo aplica a la programación orientada a objetos y no al paradigma funcional, por ejemplo.</p><p>De hecho, el principio como es enunciado en <a href=/assets/pdfs/DesignPrinciplesAndPatterns.pdf>Design Principles and Patterns</a> dice:</p><blockquote><p>Subclasses should be substitutable for their base classes.</p></blockquote><hr><blockquote><p>Las subclases deben ser sustituibles por sus clases base.</p></blockquote><p>También, como se menciona en el artículo en el que se presenta originalmente este principio dice:</p><blockquote><p>FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT</p></blockquote><hr><blockquote><p>Funciones que usen punteros o referencias a clases base deben ser capaces de usar objetos de clases derivadas sin saberlo</p></blockquote><p>Como puedes ver, el consejo es que está directamente relacionado con la herencia de clases y jerarquías de objetos. Incluso llega a hablar de punteros y referencias a clases base, es decir, a la clase padre.</p><p>De hecho, esto tiene cierta justificación, porque Barbara Liskov siempre habla de objetos. Lo que Liskov nunca hace es hablar de <em>Clases</em> y jerarquías de clases. Ella habla de tipos de datos abstractos, que son una abstracción de los objetos, por lo que esta idea se extiende a <strong>cualquier artefacto computacional que se encargue de encapsular un comportamiento</strong>.</p><p>¿Qué es encapsular? Es <strong>ocultar la implementación</strong> y exponer sólo lo necesario para que el resto del programa pueda usarlo. Esto es lo que hace una clase, un módulo, una función, etc.</p><p>¿Qué te recuerda esto? Lo mismo de lo que hemos hablado en los principios anteriores: <strong>abstracción</strong>. Esconder lo más que se pueda la información, <em>Information Hiding</em>, como le llamaría John Ousterhout.</p><p>Lo que es más, seguir esta idea de que diferentes tipos de datos puedan ser intercambiables hace que selecciones mejor los elementos que van a componer tu interfaz (en este caso le llamaríamos <strong>API</strong>).</p><p>Para mí, las ideas de Liskov son un aplicación particular de la idea de ocultar la mayor cantidad de información posible dentro de interfaces lo mejor diseñadas posible, tal como se explica en el libro <a href=https://web.stanford.edu/~ouster/cgi-bin/book.php>A Philosophy of Software Design de John Ousterhout</a>.</p><h3 id=conclusión>Conclusión</h3><p>La ideas sobre <strong>subtipos</strong> y la forma de usarlos lo mejor posible que Bárbara Liskov y Jeannette Wing propusieron son muy útiles para crear mejor código, sobre todo mejor separación y ocultado de la implementación.</p><p>Esto lo vamos a repetir hasta el cansancio: <strong>ocultar información</strong> te ayudará a hacer que tus programas sea más fáciles de entender y de mantener.</p><p>Como lección, podemos decir que seguir las guías de Liskov para el subtipado es una forma de aplicar este principio de diseño aún más amplio, digamos que en realidad la especificación de cómo deben comportarse los subtipos es más como una <em>regla</em> de diseño que un <em>principio</em> de diseño.</p><p>Entender el verdadero significado de lo que Liskov propone, te ayudará a ver que no sólo se aplica a la programación orientada a objetos, tal como se enunciaba en SOLID originalmente, sino a muchas otras situaciones.</p></section></main><footer id=main-footer><div class=footer><a href=#>Scroll to Top</a><div class=footer-copyright><div class=dim>© 2025 Héctor Patricio</div><div>Made with ❤️ and powered by <a href=https://github.com/math-queiroz/rusty-typewriter target=_blank>Rusty Typewriter</a> theme for <a href=https://gohugo.io/ target=_blank>Hugo</a></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>1565 words</span>
<span>9 - 11 minutes read</span></div><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#un-poco-de-historia-barbara-liskov>Un poco de historia: Barbara Liskov</a></li><li><a href=#el-principio-de-sustitución-de-liskov>El principio de sustitución de Liskov</a><ul><li><a href=#qué-es-un-tipo>¿Qué es un tipo?</a></li><li><a href=#qué-es-un-subtipo>¿Qué es un subtipo?</a></li></ul></li><li><a href=#crítica-sobre-el-lsp>Crítica sobre el LSP</a><ul><li><a href=#conclusión>Conclusión</a></li></ul></li></ul></nav><h3>Related</h3><ul><li><a href=/2022/12/01/an%C3%A1lisis-de-los-principios-solid-principio-de-responsabilidad-%C3%BAnica/>Análisis de los principios SOLID: Principio de Responsabilidad Única</a></li><li><a href=/2023/02/17/la-importancia-de-entender-los-principios-de-la-computaci%C3%B3n/>La importancia de entender los principios de la computación</a></li><li><a href=/2022/12/03/el-principio-abierto/cerrado-open/closed/>El principio Abierto/Cerrado (Open/Closed)</a></li><li><a href=/2019/03/19/principios-de-dise%C3%B1o-de-software/>Principios de Diseño de Software</a></li></ul></aside></div></div></body></html>