Y lo interesante es que cuando termina esa evolución, nos queda un algoritmo que es distinto al original, pero que a su vez mejora el estado del arte del original. Por ejemplo, la multiplicación de matrices. Lo hace más rápido que el original. Cosas así, ¿no? Aunque el paper también muestra ejemplos prácticos que se aplicaron dentro de Google para acelerar distintos tipos de procesos. Entonces, lo interesante y lo novedoso de esto es que ellos aplican este sistema a código más grande, más complejo, mayores cantidades de base de datos y también lo aplican a problemas reales propios de Google, ¿no? Entonces, no es simplemente que te mejore un pequeño aspecto logístico de un algoritmo, sino que es capaz de hacer una mejora incremental basada en un proceso evolutivo, basada en agentes que siguen principios evolutivos y que llega a un resultado mucho más satisfactorio, ¿no? Sí, está interesante. La parte que acabas de mencionar de las 3 operaciones, me quedé con la duda de si la operación de cruces siempre es necesaria, ¿no? O sea, yo entendía justamente, ¿eh? Sí, generalmente, sí. Bueno, obviamente estos algoritmos tienen distintos tipos de parámetros de configuración donde tú puedes hacer que un operador sea más preferente que otro, ¿no? Pero, generalmente, la cruza sí es necesaria para evitar ciertos sesgos.